#pragma once

//------------------------------------------------------------------------------
// STM32H743: STM32H743
//------------------------------------------------------------------------------

#include <stdint.h>

//------------------------------------------------------------------------------
// Peripheral AC: Access control
//------------------------------------------------------------------------------

//---  Register ITCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
  #define AC_ITCMCR (* ((volatile uint32_t *) (0xE000EF90 + 0)))

  // Field EN: EN
    const uint32_t AC_ITCMCR_EN = 1U << 0 ;

  // Field RMW: RMW
    const uint32_t AC_ITCMCR_RMW = 1U << 1 ;

  // Field RETEN: RETEN
    const uint32_t AC_ITCMCR_RETEN = 1U << 2 ;

  // Field SZ: SZ
    inline uint32_t AC_ITCMCR_SZ (const uint32_t inValue) {return (inValue & 0xFU) << 3 ; }

//------------------------------------------------------------------------------

//---  Register DTCMCR: Instruction and Data Tightly-Coupled Memory Control Registers
  #define AC_DTCMCR (* ((volatile uint32_t *) (0xE000EF90 + 4)))

  // Field EN: EN
    const uint32_t AC_DTCMCR_EN = 1U << 0 ;

  // Field RMW: RMW
    const uint32_t AC_DTCMCR_RMW = 1U << 1 ;

  // Field RETEN: RETEN
    const uint32_t AC_DTCMCR_RETEN = 1U << 2 ;

  // Field SZ: SZ
    inline uint32_t AC_DTCMCR_SZ (const uint32_t inValue) {return (inValue & 0xFU) << 3 ; }

//------------------------------------------------------------------------------

//---  Register AHBPCR: AHBP Control register
  #define AC_AHBPCR (* ((volatile uint32_t *) (0xE000EF90 + 8)))

  // Field EN: EN
    const uint32_t AC_AHBPCR_EN = 1U << 0 ;

  // Field SZ: SZ
    inline uint32_t AC_AHBPCR_SZ (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

//------------------------------------------------------------------------------

//---  Register CACR: Auxiliary Cache Control register
  #define AC_CACR (* ((volatile uint32_t *) (0xE000EF90 + 12)))

  // Field SIWT: SIWT
    const uint32_t AC_CACR_SIWT = 1U << 0 ;

  // Field ECCEN: ECCEN
    const uint32_t AC_CACR_ECCEN = 1U << 1 ;

  // Field FORCEWT: FORCEWT
    const uint32_t AC_CACR_FORCEWT = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register AHBSCR: AHB Slave Control register
  #define AC_AHBSCR (* ((volatile uint32_t *) (0xE000EF90 + 16)))

  // Field CTL: CTL
    inline uint32_t AC_AHBSCR_CTL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field TPRI: TPRI
    inline uint32_t AC_AHBSCR_TPRI (const uint32_t inValue) {return (inValue & 0x1FFU) << 2 ; }

  // Field INITCOUNT: INITCOUNT
    inline uint32_t AC_AHBSCR_INITCOUNT (const uint32_t inValue) {return (inValue & 0x1FU) << 11 ; }

//------------------------------------------------------------------------------

//---  Register ABFSR: Auxiliary Bus Fault Status register
  #define AC_ABFSR (* ((volatile uint32_t *) (0xE000EF90 + 24)))

  // Field ITCM: ITCM
    const uint32_t AC_ABFSR_ITCM = 1U << 0 ;

  // Field DTCM: DTCM
    const uint32_t AC_ABFSR_DTCM = 1U << 1 ;

  // Field AHBP: AHBP
    const uint32_t AC_ABFSR_AHBP = 1U << 2 ;

  // Field AXIM: AXIM
    const uint32_t AC_ABFSR_AXIM = 1U << 3 ;

  // Field EPPB: EPPB
    const uint32_t AC_ABFSR_EPPB = 1U << 4 ;

  // Field AXIMTYPE: AXIMTYPE
    inline uint32_t AC_ABFSR_AXIMTYPE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

//------------------------------------------------------------------------------
// Peripheral ADC1
//------------------------------------------------------------------------------

//---  Register ISR: ADC interrupt and status register
  #define ADC1_ISR (* ((volatile uint32_t *) (0x40022000 + 0)))

  // Field JQOVF: ADC group injected contexts queue overflow flag
    const uint32_t ADC1_ISR_JQOVF = 1U << 10 ;

  // Field AWD3: ADC analog watchdog 3 flag
    const uint32_t ADC1_ISR_AWD3 = 1U << 9 ;

  // Field AWD2: ADC analog watchdog 2 flag
    const uint32_t ADC1_ISR_AWD2 = 1U << 8 ;

  // Field AWD1: ADC analog watchdog 1 flag
    const uint32_t ADC1_ISR_AWD1 = 1U << 7 ;

  // Field JEOS: ADC group injected end of sequence conversions flag
    const uint32_t ADC1_ISR_JEOS = 1U << 6 ;

  // Field JEOC: ADC group injected end of unitary conversion flag
    const uint32_t ADC1_ISR_JEOC = 1U << 5 ;

  // Field OVR: ADC group regular overrun flag
    const uint32_t ADC1_ISR_OVR = 1U << 4 ;

  // Field EOS: ADC group regular end of sequence conversions flag
    const uint32_t ADC1_ISR_EOS = 1U << 3 ;

  // Field EOC: ADC group regular end of unitary conversion flag
    const uint32_t ADC1_ISR_EOC = 1U << 2 ;

  // Field EOSMP: ADC group regular end of sampling flag
    const uint32_t ADC1_ISR_EOSMP = 1U << 1 ;

  // Field ADRDY: ADC ready flag
    const uint32_t ADC1_ISR_ADRDY = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: ADC interrupt enable register
  #define ADC1_IER (* ((volatile uint32_t *) (0x40022000 + 4)))

  // Field JQOVFIE: ADC group injected contexts queue overflow interrupt
    const uint32_t ADC1_IER_JQOVFIE = 1U << 10 ;

  // Field AWD3IE: ADC analog watchdog 3 interrupt
    const uint32_t ADC1_IER_AWD3IE = 1U << 9 ;

  // Field AWD2IE: ADC analog watchdog 2 interrupt
    const uint32_t ADC1_IER_AWD2IE = 1U << 8 ;

  // Field AWD1IE: ADC analog watchdog 1 interrupt
    const uint32_t ADC1_IER_AWD1IE = 1U << 7 ;

  // Field JEOSIE: ADC group injected end of sequence conversions interrupt
    const uint32_t ADC1_IER_JEOSIE = 1U << 6 ;

  // Field JEOCIE: ADC group injected end of unitary conversion interrupt
    const uint32_t ADC1_IER_JEOCIE = 1U << 5 ;

  // Field OVRIE: ADC group regular overrun interrupt
    const uint32_t ADC1_IER_OVRIE = 1U << 4 ;

  // Field EOSIE: ADC group regular end of sequence conversions interrupt
    const uint32_t ADC1_IER_EOSIE = 1U << 3 ;

  // Field EOCIE: ADC group regular end of unitary conversion interrupt
    const uint32_t ADC1_IER_EOCIE = 1U << 2 ;

  // Field EOSMPIE: ADC group regular end of sampling interrupt
    const uint32_t ADC1_IER_EOSMPIE = 1U << 1 ;

  // Field ADRDYIE: ADC ready interrupt
    const uint32_t ADC1_IER_ADRDYIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: ADC control register
  #define ADC1_CR (* ((volatile uint32_t *) (0x40022000 + 8)))

  // Field ADCAL: ADC calibration
    const uint32_t ADC1_CR_ADCAL = 1U << 31 ;

  // Field ADCALDIF: ADC differential mode for calibration
    const uint32_t ADC1_CR_ADCALDIF = 1U << 30 ;

  // Field DEEPPWD: ADC deep power down enable
    const uint32_t ADC1_CR_DEEPPWD = 1U << 29 ;

  // Field ADVREGEN: ADC voltage regulator enable
    const uint32_t ADC1_CR_ADVREGEN = 1U << 28 ;

  // Field LINCALRDYW6: Linearity calibration ready Word 6
    const uint32_t ADC1_CR_LINCALRDYW6 = 1U << 27 ;

  // Field LINCALRDYW5: Linearity calibration ready Word 5
    const uint32_t ADC1_CR_LINCALRDYW5 = 1U << 26 ;

  // Field LINCALRDYW4: Linearity calibration ready Word 4
    const uint32_t ADC1_CR_LINCALRDYW4 = 1U << 25 ;

  // Field LINCALRDYW3: Linearity calibration ready Word 3
    const uint32_t ADC1_CR_LINCALRDYW3 = 1U << 24 ;

  // Field LINCALRDYW2: Linearity calibration ready Word 2
    const uint32_t ADC1_CR_LINCALRDYW2 = 1U << 23 ;

  // Field LINCALRDYW1: Linearity calibration ready Word 1
    const uint32_t ADC1_CR_LINCALRDYW1 = 1U << 22 ;

  // Field ADCALLIN: Linearity calibration
    const uint32_t ADC1_CR_ADCALLIN = 1U << 16 ;

  // Field BOOST: Boost mode control
    const uint32_t ADC1_CR_BOOST = 1U << 8 ;

  // Field JADSTP: ADC group injected conversion stop
    const uint32_t ADC1_CR_JADSTP = 1U << 5 ;

  // Field ADSTP: ADC group regular conversion stop
    const uint32_t ADC1_CR_ADSTP = 1U << 4 ;

  // Field JADSTART: ADC group injected conversion start
    const uint32_t ADC1_CR_JADSTART = 1U << 3 ;

  // Field ADSTART: ADC group regular conversion start
    const uint32_t ADC1_CR_ADSTART = 1U << 2 ;

  // Field ADDIS: ADC disable
    const uint32_t ADC1_CR_ADDIS = 1U << 1 ;

  // Field ADEN: ADC enable
    const uint32_t ADC1_CR_ADEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: ADC configuration register 1
  #define ADC1_CFGR (* ((volatile uint32_t *) (0x40022000 + 12)))

  // Field JQDIS: ADC group injected contexts queue disable
    const uint32_t ADC1_CFGR_JQDIS = 1U << 31 ;

  // Field AWDCH1CH: ADC analog watchdog 1 monitored channel selection
    inline uint32_t ADC1_CFGR_AWDCH1CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field JAUTO: ADC group injected automatic trigger mode
    const uint32_t ADC1_CFGR_JAUTO = 1U << 25 ;

  // Field JAWD1EN: ADC analog watchdog 1 enable on scope ADC group injected
    const uint32_t ADC1_CFGR_JAWD1EN = 1U << 24 ;

  // Field AWD1EN: ADC analog watchdog 1 enable on scope ADC group regular
    const uint32_t ADC1_CFGR_AWD1EN = 1U << 23 ;

  // Field AWD1SGL: ADC analog watchdog 1 monitoring a single channel or all channels
    const uint32_t ADC1_CFGR_AWD1SGL = 1U << 22 ;

  // Field JQM: ADC group injected contexts queue mode
    const uint32_t ADC1_CFGR_JQM = 1U << 21 ;

  // Field JDISCEN: ADC group injected sequencer discontinuous mode
    const uint32_t ADC1_CFGR_JDISCEN = 1U << 20 ;

  // Field DISCNUM: ADC group regular sequencer discontinuous number of ranks
    inline uint32_t ADC1_CFGR_DISCNUM (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DISCEN: ADC group regular sequencer discontinuous mode
    const uint32_t ADC1_CFGR_DISCEN = 1U << 16 ;

  // Field AUTDLY: ADC low power auto wait
    const uint32_t ADC1_CFGR_AUTDLY = 1U << 14 ;

  // Field CONT: ADC group regular continuous conversion mode
    const uint32_t ADC1_CFGR_CONT = 1U << 13 ;

  // Field OVRMOD: ADC group regular overrun configuration
    const uint32_t ADC1_CFGR_OVRMOD = 1U << 12 ;

  // Field EXTEN: ADC group regular external trigger polarity
    inline uint32_t ADC1_CFGR_EXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field EXTSEL: ADC group regular external trigger source
    inline uint32_t ADC1_CFGR_EXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field RES: ADC data resolution
    inline uint32_t ADC1_CFGR_RES (const uint32_t inValue) {return (inValue & 0x7U) << 2 ; }

  // Field DMNGT: ADC DMA transfer enable
    inline uint32_t ADC1_CFGR_DMNGT (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: ADC configuration register 2
  #define ADC1_CFGR2 (* ((volatile uint32_t *) (0x40022000 + 16)))

  // Field ROVSE: ADC oversampler enable on scope ADC group regular
    const uint32_t ADC1_CFGR2_ROVSE = 1U << 0 ;

  // Field JOVSE: ADC oversampler enable on scope ADC group injected
    const uint32_t ADC1_CFGR2_JOVSE = 1U << 1 ;

  // Field OVSS: ADC oversampling shift
    inline uint32_t ADC1_CFGR2_OVSS (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field TROVS: ADC oversampling discontinuous mode (triggered mode) for ADC group regular
    const uint32_t ADC1_CFGR2_TROVS = 1U << 9 ;

  // Field ROVSM: Regular Oversampling mode
    const uint32_t ADC1_CFGR2_ROVSM = 1U << 10 ;

  // Field RSHIFT1: Right-shift data after Offset 1 correction
    const uint32_t ADC1_CFGR2_RSHIFT1 = 1U << 11 ;

  // Field RSHIFT2: Right-shift data after Offset 2 correction
    const uint32_t ADC1_CFGR2_RSHIFT2 = 1U << 12 ;

  // Field RSHIFT3: Right-shift data after Offset 3 correction
    const uint32_t ADC1_CFGR2_RSHIFT3 = 1U << 13 ;

  // Field RSHIFT4: Right-shift data after Offset 4 correction
    const uint32_t ADC1_CFGR2_RSHIFT4 = 1U << 14 ;

  // Field OSR: Oversampling ratio
    inline uint32_t ADC1_CFGR2_OSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field LSHIFT: Left shift factor
    inline uint32_t ADC1_CFGR2_LSHIFT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register SMPR1: ADC sampling time register 1
  #define ADC1_SMPR1 (* ((volatile uint32_t *) (0x40022000 + 20)))

  // Field SMP9: ADC channel 9 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP9 (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

  // Field SMP8: ADC channel 8 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP8 (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SMP7: ADC channel 7 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP7 (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SMP6: ADC channel 6 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP6 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field SMP5: ADC channel 5 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP5 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field SMP4: ADC channel 4 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP4 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SMP3: ADC channel 3 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP3 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field SMP2: ADC channel 2 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP2 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SMP1: ADC channel 1 sampling time selection
    inline uint32_t ADC1_SMPR1_SMP1 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

//------------------------------------------------------------------------------

//---  Register SMPR2: ADC sampling time register 2
  #define ADC1_SMPR2 (* ((volatile uint32_t *) (0x40022000 + 24)))

  // Field SMP19: ADC channel 18 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP19 (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

  // Field SMP18: ADC channel 18 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP18 (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SMP17: ADC channel 17 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP17 (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SMP16: ADC channel 16 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP16 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field SMP15: ADC channel 15 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP15 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field SMP14: ADC channel 14 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP14 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SMP13: ADC channel 13 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP13 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field SMP12: ADC channel 12 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP12 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SMP11: ADC channel 11 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP11 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field SMP10: ADC channel 10 sampling time selection
    inline uint32_t ADC1_SMPR2_SMP10 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR1: ADC analog watchdog 1 threshold register
  #define ADC1_LTR1 (* ((volatile uint32_t *) (0x40022000 + 32)))

  // Field LTR1: ADC analog watchdog 1 threshold low
    inline uint32_t ADC1_LTR1_LTR1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LHTR1: ADC analog watchdog 2 threshold register
  #define ADC1_LHTR1 (* ((volatile uint32_t *) (0x40022000 + 36)))

  // Field LHTR1: ADC analog watchdog 2 threshold low
    inline uint32_t ADC1_LHTR1_LHTR1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR1: ADC group regular sequencer ranks register 1
  #define ADC1_SQR1 (* ((volatile uint32_t *) (0x40022000 + 48)))

  // Field SQ4: ADC group regular sequencer rank 4
    inline uint32_t ADC1_SQR1_SQ4 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ3: ADC group regular sequencer rank 3
    inline uint32_t ADC1_SQR1_SQ3 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ2: ADC group regular sequencer rank 2
    inline uint32_t ADC1_SQR1_SQ2 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ1: ADC group regular sequencer rank 1
    inline uint32_t ADC1_SQR1_SQ1 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field L3: L3
    inline uint32_t ADC1_SQR1_L3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR2: ADC group regular sequencer ranks register 2
  #define ADC1_SQR2 (* ((volatile uint32_t *) (0x40022000 + 52)))

  // Field SQ9: ADC group regular sequencer rank 9
    inline uint32_t ADC1_SQR2_SQ9 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ8: ADC group regular sequencer rank 8
    inline uint32_t ADC1_SQR2_SQ8 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ7: ADC group regular sequencer rank 7
    inline uint32_t ADC1_SQR2_SQ7 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ6: ADC group regular sequencer rank 6
    inline uint32_t ADC1_SQR2_SQ6 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ5: ADC group regular sequencer rank 5
    inline uint32_t ADC1_SQR2_SQ5 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR3: ADC group regular sequencer ranks register 3
  #define ADC1_SQR3 (* ((volatile uint32_t *) (0x40022000 + 56)))

  // Field SQ14: ADC group regular sequencer rank 14
    inline uint32_t ADC1_SQR3_SQ14 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ13: ADC group regular sequencer rank 13
    inline uint32_t ADC1_SQR3_SQ13 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ12: ADC group regular sequencer rank 12
    inline uint32_t ADC1_SQR3_SQ12 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ11: ADC group regular sequencer rank 11
    inline uint32_t ADC1_SQR3_SQ11 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ10: ADC group regular sequencer rank 10
    inline uint32_t ADC1_SQR3_SQ10 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR4: ADC group regular sequencer ranks register 4
  #define ADC1_SQR4 (* ((volatile uint32_t *) (0x40022000 + 60)))

  // Field SQ16: ADC group regular sequencer rank 16
    inline uint32_t ADC1_SQR4_SQ16 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ15: ADC group regular sequencer rank 15
    inline uint32_t ADC1_SQR4_SQ15 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR: ADC group regular conversion data register
  #define ADC1_DR (* ((const volatile uint32_t *) (0x40022000 + 64)))

  // Field RDATA: ADC group regular conversion data
    inline uint32_t ADC1_DR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JSQR: ADC group injected sequencer register
  #define ADC1_JSQR (* ((volatile uint32_t *) (0x40022000 + 76)))

  // Field JSQ4: ADC group injected sequencer rank 4
    inline uint32_t ADC1_JSQR_JSQ4 (const uint32_t inValue) {return (inValue & 0x1FU) << 27 ; }

  // Field JSQ3: ADC group injected sequencer rank 3
    inline uint32_t ADC1_JSQR_JSQ3 (const uint32_t inValue) {return (inValue & 0x1FU) << 21 ; }

  // Field JSQ2: ADC group injected sequencer rank 2
    inline uint32_t ADC1_JSQR_JSQ2 (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field JSQ1: ADC group injected sequencer rank 1
    inline uint32_t ADC1_JSQR_JSQ1 (const uint32_t inValue) {return (inValue & 0x1FU) << 9 ; }

  // Field JEXTEN: ADC group injected external trigger polarity
    inline uint32_t ADC1_JSQR_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 7 ; }

  // Field JEXTSEL: ADC group injected external trigger source
    inline uint32_t ADC1_JSQR_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 2 ; }

  // Field JL: ADC group injected sequencer scan length
    inline uint32_t ADC1_JSQR_JL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR1: ADC offset number 1 register
  #define ADC1_OFR1 (* ((volatile uint32_t *) (0x40022000 + 96)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC1_OFR1_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC1_OFR1_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC1_OFR1_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR2: ADC offset number 2 register
  #define ADC1_OFR2 (* ((volatile uint32_t *) (0x40022000 + 100)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC1_OFR2_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC1_OFR2_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC1_OFR2_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR3: ADC offset number 3 register
  #define ADC1_OFR3 (* ((volatile uint32_t *) (0x40022000 + 104)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC1_OFR3_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC1_OFR3_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC1_OFR3_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR4: ADC offset number 4 register
  #define ADC1_OFR4 (* ((volatile uint32_t *) (0x40022000 + 108)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC1_OFR4_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC1_OFR4_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC1_OFR4_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR1: ADC group injected sequencer rank 1 register
  #define ADC1_JDR1 (* ((const volatile uint32_t *) (0x40022000 + 128)))

  // Field JDATA1: ADC group injected sequencer rank 1 conversion data
    inline uint32_t ADC1_JDR1_JDATA1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR2: ADC group injected sequencer rank 2 register
  #define ADC1_JDR2 (* ((const volatile uint32_t *) (0x40022000 + 132)))

  // Field JDATA2: ADC group injected sequencer rank 2 conversion data
    inline uint32_t ADC1_JDR2_JDATA2 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR3: ADC group injected sequencer rank 3 register
  #define ADC1_JDR3 (* ((const volatile uint32_t *) (0x40022000 + 136)))

  // Field JDATA3: ADC group injected sequencer rank 3 conversion data
    inline uint32_t ADC1_JDR3_JDATA3 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR4: ADC group injected sequencer rank 4 register
  #define ADC1_JDR4 (* ((const volatile uint32_t *) (0x40022000 + 140)))

  // Field JDATA4: ADC group injected sequencer rank 4 conversion data
    inline uint32_t ADC1_JDR4_JDATA4 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWD2CR: ADC analog watchdog 2 configuration register
  #define ADC1_AWD2CR (* ((volatile uint32_t *) (0x40022000 + 160)))

  // Field AWD2CH: ADC analog watchdog 2 monitored channel selection
    inline uint32_t ADC1_AWD2CR_AWD2CH (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWD3CR: ADC analog watchdog 3 configuration register
  #define ADC1_AWD3CR (* ((volatile uint32_t *) (0x40022000 + 164)))

  // Field AWD3CH: ADC analog watchdog 3 monitored channel selection
    inline uint32_t ADC1_AWD3CR_AWD3CH (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 1 ; }

//------------------------------------------------------------------------------

//---  Register DIFSEL: ADC channel differential or single-ended mode selection register
  #define ADC1_DIFSEL (* ((volatile uint32_t *) (0x40022000 + 192)))

  // Field DIFSEL: ADC channel differential or single-ended mode for channel
    inline uint32_t ADC1_DIFSEL_DIFSEL (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALFACT: ADC calibration factors register
  #define ADC1_CALFACT (* ((volatile uint32_t *) (0x40022000 + 196)))

  // Field CALFACT_D: ADC calibration factor in differential mode
    inline uint32_t ADC1_CALFACT_CALFACT_D (const uint32_t inValue) {return (inValue & 0x7FFU) << 16 ; }

  // Field CALFACT_S: ADC calibration factor in single-ended mode
    inline uint32_t ADC1_CALFACT_CALFACT_S (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PCSEL: ADC pre channel selection register
  #define ADC1_PCSEL (* ((volatile uint32_t *) (0x40022000 + 28)))

  // Field PCSEL: Channel x (VINP[i]) pre selection
    inline uint32_t ADC1_PCSEL_PCSEL (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR2: ADC watchdog lower threshold register 2
  #define ADC1_LTR2 (* ((volatile uint32_t *) (0x40022000 + 176)))

  // Field LTR2: Analog watchdog 2 lower threshold
    inline uint32_t ADC1_LTR2_LTR2 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register HTR2: ADC watchdog higher threshold register 2
  #define ADC1_HTR2 (* ((volatile uint32_t *) (0x40022000 + 180)))

  // Field HTR2: Analog watchdog 2 higher threshold
    inline uint32_t ADC1_HTR2_HTR2 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR3: ADC watchdog lower threshold register 3
  #define ADC1_LTR3 (* ((volatile uint32_t *) (0x40022000 + 184)))

  // Field LTR3: Analog watchdog 3 lower threshold
    inline uint32_t ADC1_LTR3_LTR3 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register HTR3: ADC watchdog higher threshold register 3
  #define ADC1_HTR3 (* ((volatile uint32_t *) (0x40022000 + 188)))

  // Field HTR3: Analog watchdog 3 higher threshold
    inline uint32_t ADC1_HTR3_HTR3 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALFACT2: ADC Calibration Factor register 2
  #define ADC1_CALFACT2 (* ((volatile uint32_t *) (0x40022000 + 200)))

  // Field LINCALFACT: Linearity Calibration Factor
    inline uint32_t ADC1_CALFACT2_LINCALFACT (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral ADC12_Common
//------------------------------------------------------------------------------

//---  Register CSR: ADC Common status register
  #define ADC12_Common_CSR (* ((const volatile uint32_t *) (0x40022300 + 0)))

  // Field ADRDY_MST: Master ADC ready
    const uint32_t ADC12_Common_CSR_ADRDY_MST = 1U << 0 ;

  // Field EOSMP_MST: End of Sampling phase flag of the master ADC
    const uint32_t ADC12_Common_CSR_EOSMP_MST = 1U << 1 ;

  // Field EOC_MST: End of regular conversion of the master ADC
    const uint32_t ADC12_Common_CSR_EOC_MST = 1U << 2 ;

  // Field EOS_MST: End of regular sequence flag of the master ADC
    const uint32_t ADC12_Common_CSR_EOS_MST = 1U << 3 ;

  // Field OVR_MST: Overrun flag of the master ADC
    const uint32_t ADC12_Common_CSR_OVR_MST = 1U << 4 ;

  // Field JEOC_MST: End of injected conversion flag of the master ADC
    const uint32_t ADC12_Common_CSR_JEOC_MST = 1U << 5 ;

  // Field JEOS_MST: End of injected sequence flag of the master ADC
    const uint32_t ADC12_Common_CSR_JEOS_MST = 1U << 6 ;

  // Field AWD1_MST: Analog watchdog 1 flag of the master ADC
    const uint32_t ADC12_Common_CSR_AWD1_MST = 1U << 7 ;

  // Field AWD2_MST: Analog watchdog 2 flag of the master ADC
    const uint32_t ADC12_Common_CSR_AWD2_MST = 1U << 8 ;

  // Field AWD3_MST: Analog watchdog 3 flag of the master ADC
    const uint32_t ADC12_Common_CSR_AWD3_MST = 1U << 9 ;

  // Field JQOVF_MST: Injected Context Queue Overflow flag of the master ADC
    const uint32_t ADC12_Common_CSR_JQOVF_MST = 1U << 10 ;

  // Field ADRDY_SLV: Slave ADC ready
    const uint32_t ADC12_Common_CSR_ADRDY_SLV = 1U << 16 ;

  // Field EOSMP_SLV: End of Sampling phase flag of the slave ADC
    const uint32_t ADC12_Common_CSR_EOSMP_SLV = 1U << 17 ;

  // Field EOC_SLV: End of regular conversion of the slave ADC
    const uint32_t ADC12_Common_CSR_EOC_SLV = 1U << 18 ;

  // Field EOS_SLV: End of regular sequence flag of the slave ADC
    const uint32_t ADC12_Common_CSR_EOS_SLV = 1U << 19 ;

  // Field OVR_SLV: Overrun flag of the slave ADC
    const uint32_t ADC12_Common_CSR_OVR_SLV = 1U << 20 ;

  // Field JEOC_SLV: End of injected conversion flag of the slave ADC
    const uint32_t ADC12_Common_CSR_JEOC_SLV = 1U << 21 ;

  // Field JEOS_SLV: End of injected sequence flag of the slave ADC
    const uint32_t ADC12_Common_CSR_JEOS_SLV = 1U << 22 ;

  // Field AWD1_SLV: Analog watchdog 1 flag of the slave ADC
    const uint32_t ADC12_Common_CSR_AWD1_SLV = 1U << 23 ;

  // Field AWD2_SLV: Analog watchdog 2 flag of the slave ADC
    const uint32_t ADC12_Common_CSR_AWD2_SLV = 1U << 24 ;

  // Field AWD3_SLV: Analog watchdog 3 flag of the slave ADC
    const uint32_t ADC12_Common_CSR_AWD3_SLV = 1U << 25 ;

  // Field JQOVF_SLV: Injected Context Queue Overflow flag of the slave ADC
    const uint32_t ADC12_Common_CSR_JQOVF_SLV = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register CCR: ADC common control register
  #define ADC12_Common_CCR (* ((volatile uint32_t *) (0x40022300 + 8)))

  // Field DUAL: Dual ADC mode selection
    inline uint32_t ADC12_Common_CCR_DUAL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field DELAY: Delay between 2 sampling phases
    inline uint32_t ADC12_Common_CCR_DELAY (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field DAMDF: Dual ADC Mode Data Format
    inline uint32_t ADC12_Common_CCR_DAMDF (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKMODE: ADC clock mode
    inline uint32_t ADC12_Common_CCR_CKMODE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PRESC: ADC prescaler
    inline uint32_t ADC12_Common_CCR_PRESC (const uint32_t inValue) {return (inValue & 0xFU) << 18 ; }

  // Field VREFEN: VREFINT enable
    const uint32_t ADC12_Common_CCR_VREFEN = 1U << 22 ;

  // Field VSENSEEN: Temperature sensor enable
    const uint32_t ADC12_Common_CCR_VSENSEEN = 1U << 23 ;

  // Field VBATEN: VBAT enable
    const uint32_t ADC12_Common_CCR_VBATEN = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CDR: ADC common regular data register for dual and triple modes
  #define ADC12_Common_CDR (* ((const volatile uint32_t *) (0x40022300 + 12)))

  // Field RDATA_SLV: Regular data of the slave ADC
    inline uint32_t ADC12_Common_CDR_RDATA_SLV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RDATA_MST: Regular data of the master ADC
    inline uint32_t ADC12_Common_CDR_RDATA_MST (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CDR2: ADC x common regular data register for 32-bit dual mode
  #define ADC12_Common_CDR2 (* ((const volatile uint32_t *) (0x40022300 + 16)))

  // Field RDATA_ALT: Regular data of the master/slave alternated ADCs
    inline uint32_t ADC12_Common_CDR2_RDATA_ALT (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral ADC2
//------------------------------------------------------------------------------

//---  Register ISR: ADC interrupt and status register
  #define ADC2_ISR (* ((volatile uint32_t *) (0x40022100 + 0)))

  // Field JQOVF: ADC group injected contexts queue overflow flag
    const uint32_t ADC2_ISR_JQOVF = 1U << 10 ;

  // Field AWD3: ADC analog watchdog 3 flag
    const uint32_t ADC2_ISR_AWD3 = 1U << 9 ;

  // Field AWD2: ADC analog watchdog 2 flag
    const uint32_t ADC2_ISR_AWD2 = 1U << 8 ;

  // Field AWD1: ADC analog watchdog 1 flag
    const uint32_t ADC2_ISR_AWD1 = 1U << 7 ;

  // Field JEOS: ADC group injected end of sequence conversions flag
    const uint32_t ADC2_ISR_JEOS = 1U << 6 ;

  // Field JEOC: ADC group injected end of unitary conversion flag
    const uint32_t ADC2_ISR_JEOC = 1U << 5 ;

  // Field OVR: ADC group regular overrun flag
    const uint32_t ADC2_ISR_OVR = 1U << 4 ;

  // Field EOS: ADC group regular end of sequence conversions flag
    const uint32_t ADC2_ISR_EOS = 1U << 3 ;

  // Field EOC: ADC group regular end of unitary conversion flag
    const uint32_t ADC2_ISR_EOC = 1U << 2 ;

  // Field EOSMP: ADC group regular end of sampling flag
    const uint32_t ADC2_ISR_EOSMP = 1U << 1 ;

  // Field ADRDY: ADC ready flag
    const uint32_t ADC2_ISR_ADRDY = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: ADC interrupt enable register
  #define ADC2_IER (* ((volatile uint32_t *) (0x40022100 + 4)))

  // Field JQOVFIE: ADC group injected contexts queue overflow interrupt
    const uint32_t ADC2_IER_JQOVFIE = 1U << 10 ;

  // Field AWD3IE: ADC analog watchdog 3 interrupt
    const uint32_t ADC2_IER_AWD3IE = 1U << 9 ;

  // Field AWD2IE: ADC analog watchdog 2 interrupt
    const uint32_t ADC2_IER_AWD2IE = 1U << 8 ;

  // Field AWD1IE: ADC analog watchdog 1 interrupt
    const uint32_t ADC2_IER_AWD1IE = 1U << 7 ;

  // Field JEOSIE: ADC group injected end of sequence conversions interrupt
    const uint32_t ADC2_IER_JEOSIE = 1U << 6 ;

  // Field JEOCIE: ADC group injected end of unitary conversion interrupt
    const uint32_t ADC2_IER_JEOCIE = 1U << 5 ;

  // Field OVRIE: ADC group regular overrun interrupt
    const uint32_t ADC2_IER_OVRIE = 1U << 4 ;

  // Field EOSIE: ADC group regular end of sequence conversions interrupt
    const uint32_t ADC2_IER_EOSIE = 1U << 3 ;

  // Field EOCIE: ADC group regular end of unitary conversion interrupt
    const uint32_t ADC2_IER_EOCIE = 1U << 2 ;

  // Field EOSMPIE: ADC group regular end of sampling interrupt
    const uint32_t ADC2_IER_EOSMPIE = 1U << 1 ;

  // Field ADRDYIE: ADC ready interrupt
    const uint32_t ADC2_IER_ADRDYIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: ADC control register
  #define ADC2_CR (* ((volatile uint32_t *) (0x40022100 + 8)))

  // Field ADCAL: ADC calibration
    const uint32_t ADC2_CR_ADCAL = 1U << 31 ;

  // Field ADCALDIF: ADC differential mode for calibration
    const uint32_t ADC2_CR_ADCALDIF = 1U << 30 ;

  // Field DEEPPWD: ADC deep power down enable
    const uint32_t ADC2_CR_DEEPPWD = 1U << 29 ;

  // Field ADVREGEN: ADC voltage regulator enable
    const uint32_t ADC2_CR_ADVREGEN = 1U << 28 ;

  // Field LINCALRDYW6: Linearity calibration ready Word 6
    const uint32_t ADC2_CR_LINCALRDYW6 = 1U << 27 ;

  // Field LINCALRDYW5: Linearity calibration ready Word 5
    const uint32_t ADC2_CR_LINCALRDYW5 = 1U << 26 ;

  // Field LINCALRDYW4: Linearity calibration ready Word 4
    const uint32_t ADC2_CR_LINCALRDYW4 = 1U << 25 ;

  // Field LINCALRDYW3: Linearity calibration ready Word 3
    const uint32_t ADC2_CR_LINCALRDYW3 = 1U << 24 ;

  // Field LINCALRDYW2: Linearity calibration ready Word 2
    const uint32_t ADC2_CR_LINCALRDYW2 = 1U << 23 ;

  // Field LINCALRDYW1: Linearity calibration ready Word 1
    const uint32_t ADC2_CR_LINCALRDYW1 = 1U << 22 ;

  // Field ADCALLIN: Linearity calibration
    const uint32_t ADC2_CR_ADCALLIN = 1U << 16 ;

  // Field BOOST: Boost mode control
    const uint32_t ADC2_CR_BOOST = 1U << 8 ;

  // Field JADSTP: ADC group injected conversion stop
    const uint32_t ADC2_CR_JADSTP = 1U << 5 ;

  // Field ADSTP: ADC group regular conversion stop
    const uint32_t ADC2_CR_ADSTP = 1U << 4 ;

  // Field JADSTART: ADC group injected conversion start
    const uint32_t ADC2_CR_JADSTART = 1U << 3 ;

  // Field ADSTART: ADC group regular conversion start
    const uint32_t ADC2_CR_ADSTART = 1U << 2 ;

  // Field ADDIS: ADC disable
    const uint32_t ADC2_CR_ADDIS = 1U << 1 ;

  // Field ADEN: ADC enable
    const uint32_t ADC2_CR_ADEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: ADC configuration register 1
  #define ADC2_CFGR (* ((volatile uint32_t *) (0x40022100 + 12)))

  // Field JQDIS: ADC group injected contexts queue disable
    const uint32_t ADC2_CFGR_JQDIS = 1U << 31 ;

  // Field AWDCH1CH: ADC analog watchdog 1 monitored channel selection
    inline uint32_t ADC2_CFGR_AWDCH1CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field JAUTO: ADC group injected automatic trigger mode
    const uint32_t ADC2_CFGR_JAUTO = 1U << 25 ;

  // Field JAWD1EN: ADC analog watchdog 1 enable on scope ADC group injected
    const uint32_t ADC2_CFGR_JAWD1EN = 1U << 24 ;

  // Field AWD1EN: ADC analog watchdog 1 enable on scope ADC group regular
    const uint32_t ADC2_CFGR_AWD1EN = 1U << 23 ;

  // Field AWD1SGL: ADC analog watchdog 1 monitoring a single channel or all channels
    const uint32_t ADC2_CFGR_AWD1SGL = 1U << 22 ;

  // Field JQM: ADC group injected contexts queue mode
    const uint32_t ADC2_CFGR_JQM = 1U << 21 ;

  // Field JDISCEN: ADC group injected sequencer discontinuous mode
    const uint32_t ADC2_CFGR_JDISCEN = 1U << 20 ;

  // Field DISCNUM: ADC group regular sequencer discontinuous number of ranks
    inline uint32_t ADC2_CFGR_DISCNUM (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DISCEN: ADC group regular sequencer discontinuous mode
    const uint32_t ADC2_CFGR_DISCEN = 1U << 16 ;

  // Field AUTDLY: ADC low power auto wait
    const uint32_t ADC2_CFGR_AUTDLY = 1U << 14 ;

  // Field CONT: ADC group regular continuous conversion mode
    const uint32_t ADC2_CFGR_CONT = 1U << 13 ;

  // Field OVRMOD: ADC group regular overrun configuration
    const uint32_t ADC2_CFGR_OVRMOD = 1U << 12 ;

  // Field EXTEN: ADC group regular external trigger polarity
    inline uint32_t ADC2_CFGR_EXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field EXTSEL: ADC group regular external trigger source
    inline uint32_t ADC2_CFGR_EXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field RES: ADC data resolution
    inline uint32_t ADC2_CFGR_RES (const uint32_t inValue) {return (inValue & 0x7U) << 2 ; }

  // Field DMNGT: ADC DMA transfer enable
    inline uint32_t ADC2_CFGR_DMNGT (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: ADC configuration register 2
  #define ADC2_CFGR2 (* ((volatile uint32_t *) (0x40022100 + 16)))

  // Field ROVSE: ADC oversampler enable on scope ADC group regular
    const uint32_t ADC2_CFGR2_ROVSE = 1U << 0 ;

  // Field JOVSE: ADC oversampler enable on scope ADC group injected
    const uint32_t ADC2_CFGR2_JOVSE = 1U << 1 ;

  // Field OVSS: ADC oversampling shift
    inline uint32_t ADC2_CFGR2_OVSS (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field TROVS: ADC oversampling discontinuous mode (triggered mode) for ADC group regular
    const uint32_t ADC2_CFGR2_TROVS = 1U << 9 ;

  // Field ROVSM: Regular Oversampling mode
    const uint32_t ADC2_CFGR2_ROVSM = 1U << 10 ;

  // Field RSHIFT1: Right-shift data after Offset 1 correction
    const uint32_t ADC2_CFGR2_RSHIFT1 = 1U << 11 ;

  // Field RSHIFT2: Right-shift data after Offset 2 correction
    const uint32_t ADC2_CFGR2_RSHIFT2 = 1U << 12 ;

  // Field RSHIFT3: Right-shift data after Offset 3 correction
    const uint32_t ADC2_CFGR2_RSHIFT3 = 1U << 13 ;

  // Field RSHIFT4: Right-shift data after Offset 4 correction
    const uint32_t ADC2_CFGR2_RSHIFT4 = 1U << 14 ;

  // Field OSR: Oversampling ratio
    inline uint32_t ADC2_CFGR2_OSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field LSHIFT: Left shift factor
    inline uint32_t ADC2_CFGR2_LSHIFT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register SMPR1: ADC sampling time register 1
  #define ADC2_SMPR1 (* ((volatile uint32_t *) (0x40022100 + 20)))

  // Field SMP9: ADC channel 9 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP9 (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

  // Field SMP8: ADC channel 8 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP8 (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SMP7: ADC channel 7 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP7 (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SMP6: ADC channel 6 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP6 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field SMP5: ADC channel 5 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP5 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field SMP4: ADC channel 4 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP4 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SMP3: ADC channel 3 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP3 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field SMP2: ADC channel 2 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP2 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SMP1: ADC channel 1 sampling time selection
    inline uint32_t ADC2_SMPR1_SMP1 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

//------------------------------------------------------------------------------

//---  Register SMPR2: ADC sampling time register 2
  #define ADC2_SMPR2 (* ((volatile uint32_t *) (0x40022100 + 24)))

  // Field SMP19: ADC channel 18 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP19 (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

  // Field SMP18: ADC channel 18 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP18 (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SMP17: ADC channel 17 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP17 (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SMP16: ADC channel 16 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP16 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field SMP15: ADC channel 15 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP15 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field SMP14: ADC channel 14 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP14 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SMP13: ADC channel 13 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP13 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field SMP12: ADC channel 12 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP12 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SMP11: ADC channel 11 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP11 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field SMP10: ADC channel 10 sampling time selection
    inline uint32_t ADC2_SMPR2_SMP10 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR1: ADC analog watchdog 1 threshold register
  #define ADC2_LTR1 (* ((volatile uint32_t *) (0x40022100 + 32)))

  // Field LTR1: ADC analog watchdog 1 threshold low
    inline uint32_t ADC2_LTR1_LTR1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LHTR1: ADC analog watchdog 2 threshold register
  #define ADC2_LHTR1 (* ((volatile uint32_t *) (0x40022100 + 36)))

  // Field LHTR1: ADC analog watchdog 2 threshold low
    inline uint32_t ADC2_LHTR1_LHTR1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR1: ADC group regular sequencer ranks register 1
  #define ADC2_SQR1 (* ((volatile uint32_t *) (0x40022100 + 48)))

  // Field SQ4: ADC group regular sequencer rank 4
    inline uint32_t ADC2_SQR1_SQ4 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ3: ADC group regular sequencer rank 3
    inline uint32_t ADC2_SQR1_SQ3 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ2: ADC group regular sequencer rank 2
    inline uint32_t ADC2_SQR1_SQ2 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ1: ADC group regular sequencer rank 1
    inline uint32_t ADC2_SQR1_SQ1 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field L3: L3
    inline uint32_t ADC2_SQR1_L3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR2: ADC group regular sequencer ranks register 2
  #define ADC2_SQR2 (* ((volatile uint32_t *) (0x40022100 + 52)))

  // Field SQ9: ADC group regular sequencer rank 9
    inline uint32_t ADC2_SQR2_SQ9 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ8: ADC group regular sequencer rank 8
    inline uint32_t ADC2_SQR2_SQ8 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ7: ADC group regular sequencer rank 7
    inline uint32_t ADC2_SQR2_SQ7 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ6: ADC group regular sequencer rank 6
    inline uint32_t ADC2_SQR2_SQ6 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ5: ADC group regular sequencer rank 5
    inline uint32_t ADC2_SQR2_SQ5 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR3: ADC group regular sequencer ranks register 3
  #define ADC2_SQR3 (* ((volatile uint32_t *) (0x40022100 + 56)))

  // Field SQ14: ADC group regular sequencer rank 14
    inline uint32_t ADC2_SQR3_SQ14 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ13: ADC group regular sequencer rank 13
    inline uint32_t ADC2_SQR3_SQ13 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ12: ADC group regular sequencer rank 12
    inline uint32_t ADC2_SQR3_SQ12 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ11: ADC group regular sequencer rank 11
    inline uint32_t ADC2_SQR3_SQ11 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ10: ADC group regular sequencer rank 10
    inline uint32_t ADC2_SQR3_SQ10 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR4: ADC group regular sequencer ranks register 4
  #define ADC2_SQR4 (* ((volatile uint32_t *) (0x40022100 + 60)))

  // Field SQ16: ADC group regular sequencer rank 16
    inline uint32_t ADC2_SQR4_SQ16 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ15: ADC group regular sequencer rank 15
    inline uint32_t ADC2_SQR4_SQ15 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR: ADC group regular conversion data register
  #define ADC2_DR (* ((const volatile uint32_t *) (0x40022100 + 64)))

  // Field RDATA: ADC group regular conversion data
    inline uint32_t ADC2_DR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JSQR: ADC group injected sequencer register
  #define ADC2_JSQR (* ((volatile uint32_t *) (0x40022100 + 76)))

  // Field JSQ4: ADC group injected sequencer rank 4
    inline uint32_t ADC2_JSQR_JSQ4 (const uint32_t inValue) {return (inValue & 0x1FU) << 27 ; }

  // Field JSQ3: ADC group injected sequencer rank 3
    inline uint32_t ADC2_JSQR_JSQ3 (const uint32_t inValue) {return (inValue & 0x1FU) << 21 ; }

  // Field JSQ2: ADC group injected sequencer rank 2
    inline uint32_t ADC2_JSQR_JSQ2 (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field JSQ1: ADC group injected sequencer rank 1
    inline uint32_t ADC2_JSQR_JSQ1 (const uint32_t inValue) {return (inValue & 0x1FU) << 9 ; }

  // Field JEXTEN: ADC group injected external trigger polarity
    inline uint32_t ADC2_JSQR_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 7 ; }

  // Field JEXTSEL: ADC group injected external trigger source
    inline uint32_t ADC2_JSQR_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 2 ; }

  // Field JL: ADC group injected sequencer scan length
    inline uint32_t ADC2_JSQR_JL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR1: ADC offset number 1 register
  #define ADC2_OFR1 (* ((volatile uint32_t *) (0x40022100 + 96)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC2_OFR1_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC2_OFR1_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC2_OFR1_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR2: ADC offset number 2 register
  #define ADC2_OFR2 (* ((volatile uint32_t *) (0x40022100 + 100)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC2_OFR2_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC2_OFR2_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC2_OFR2_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR3: ADC offset number 3 register
  #define ADC2_OFR3 (* ((volatile uint32_t *) (0x40022100 + 104)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC2_OFR3_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC2_OFR3_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC2_OFR3_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR4: ADC offset number 4 register
  #define ADC2_OFR4 (* ((volatile uint32_t *) (0x40022100 + 108)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC2_OFR4_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC2_OFR4_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC2_OFR4_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR1: ADC group injected sequencer rank 1 register
  #define ADC2_JDR1 (* ((const volatile uint32_t *) (0x40022100 + 128)))

  // Field JDATA1: ADC group injected sequencer rank 1 conversion data
    inline uint32_t ADC2_JDR1_JDATA1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR2: ADC group injected sequencer rank 2 register
  #define ADC2_JDR2 (* ((const volatile uint32_t *) (0x40022100 + 132)))

  // Field JDATA2: ADC group injected sequencer rank 2 conversion data
    inline uint32_t ADC2_JDR2_JDATA2 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR3: ADC group injected sequencer rank 3 register
  #define ADC2_JDR3 (* ((const volatile uint32_t *) (0x40022100 + 136)))

  // Field JDATA3: ADC group injected sequencer rank 3 conversion data
    inline uint32_t ADC2_JDR3_JDATA3 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR4: ADC group injected sequencer rank 4 register
  #define ADC2_JDR4 (* ((const volatile uint32_t *) (0x40022100 + 140)))

  // Field JDATA4: ADC group injected sequencer rank 4 conversion data
    inline uint32_t ADC2_JDR4_JDATA4 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWD2CR: ADC analog watchdog 2 configuration register
  #define ADC2_AWD2CR (* ((volatile uint32_t *) (0x40022100 + 160)))

  // Field AWD2CH: ADC analog watchdog 2 monitored channel selection
    inline uint32_t ADC2_AWD2CR_AWD2CH (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWD3CR: ADC analog watchdog 3 configuration register
  #define ADC2_AWD3CR (* ((volatile uint32_t *) (0x40022100 + 164)))

  // Field AWD3CH: ADC analog watchdog 3 monitored channel selection
    inline uint32_t ADC2_AWD3CR_AWD3CH (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 1 ; }

//------------------------------------------------------------------------------

//---  Register DIFSEL: ADC channel differential or single-ended mode selection register
  #define ADC2_DIFSEL (* ((volatile uint32_t *) (0x40022100 + 192)))

  // Field DIFSEL: ADC channel differential or single-ended mode for channel
    inline uint32_t ADC2_DIFSEL_DIFSEL (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALFACT: ADC calibration factors register
  #define ADC2_CALFACT (* ((volatile uint32_t *) (0x40022100 + 196)))

  // Field CALFACT_D: ADC calibration factor in differential mode
    inline uint32_t ADC2_CALFACT_CALFACT_D (const uint32_t inValue) {return (inValue & 0x7FFU) << 16 ; }

  // Field CALFACT_S: ADC calibration factor in single-ended mode
    inline uint32_t ADC2_CALFACT_CALFACT_S (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PCSEL: ADC pre channel selection register
  #define ADC2_PCSEL (* ((volatile uint32_t *) (0x40022100 + 28)))

  // Field PCSEL: Channel x (VINP[i]) pre selection
    inline uint32_t ADC2_PCSEL_PCSEL (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR2: ADC watchdog lower threshold register 2
  #define ADC2_LTR2 (* ((volatile uint32_t *) (0x40022100 + 176)))

  // Field LTR2: Analog watchdog 2 lower threshold
    inline uint32_t ADC2_LTR2_LTR2 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register HTR2: ADC watchdog higher threshold register 2
  #define ADC2_HTR2 (* ((volatile uint32_t *) (0x40022100 + 180)))

  // Field HTR2: Analog watchdog 2 higher threshold
    inline uint32_t ADC2_HTR2_HTR2 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR3: ADC watchdog lower threshold register 3
  #define ADC2_LTR3 (* ((volatile uint32_t *) (0x40022100 + 184)))

  // Field LTR3: Analog watchdog 3 lower threshold
    inline uint32_t ADC2_LTR3_LTR3 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register HTR3: ADC watchdog higher threshold register 3
  #define ADC2_HTR3 (* ((volatile uint32_t *) (0x40022100 + 188)))

  // Field HTR3: Analog watchdog 3 higher threshold
    inline uint32_t ADC2_HTR3_HTR3 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALFACT2: ADC Calibration Factor register 2
  #define ADC2_CALFACT2 (* ((volatile uint32_t *) (0x40022100 + 200)))

  // Field LINCALFACT: Linearity Calibration Factor
    inline uint32_t ADC2_CALFACT2_LINCALFACT (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral ADC3: Analog to Digital Converter
//------------------------------------------------------------------------------

//---  Register ISR: ADC interrupt and status register
  #define ADC3_ISR (* ((volatile uint32_t *) (0x58026000 + 0)))

  // Field JQOVF: ADC group injected contexts queue overflow flag
    const uint32_t ADC3_ISR_JQOVF = 1U << 10 ;

  // Field AWD3: ADC analog watchdog 3 flag
    const uint32_t ADC3_ISR_AWD3 = 1U << 9 ;

  // Field AWD2: ADC analog watchdog 2 flag
    const uint32_t ADC3_ISR_AWD2 = 1U << 8 ;

  // Field AWD1: ADC analog watchdog 1 flag
    const uint32_t ADC3_ISR_AWD1 = 1U << 7 ;

  // Field JEOS: ADC group injected end of sequence conversions flag
    const uint32_t ADC3_ISR_JEOS = 1U << 6 ;

  // Field JEOC: ADC group injected end of unitary conversion flag
    const uint32_t ADC3_ISR_JEOC = 1U << 5 ;

  // Field OVR: ADC group regular overrun flag
    const uint32_t ADC3_ISR_OVR = 1U << 4 ;

  // Field EOS: ADC group regular end of sequence conversions flag
    const uint32_t ADC3_ISR_EOS = 1U << 3 ;

  // Field EOC: ADC group regular end of unitary conversion flag
    const uint32_t ADC3_ISR_EOC = 1U << 2 ;

  // Field EOSMP: ADC group regular end of sampling flag
    const uint32_t ADC3_ISR_EOSMP = 1U << 1 ;

  // Field ADRDY: ADC ready flag
    const uint32_t ADC3_ISR_ADRDY = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: ADC interrupt enable register
  #define ADC3_IER (* ((volatile uint32_t *) (0x58026000 + 4)))

  // Field JQOVFIE: ADC group injected contexts queue overflow interrupt
    const uint32_t ADC3_IER_JQOVFIE = 1U << 10 ;

  // Field AWD3IE: ADC analog watchdog 3 interrupt
    const uint32_t ADC3_IER_AWD3IE = 1U << 9 ;

  // Field AWD2IE: ADC analog watchdog 2 interrupt
    const uint32_t ADC3_IER_AWD2IE = 1U << 8 ;

  // Field AWD1IE: ADC analog watchdog 1 interrupt
    const uint32_t ADC3_IER_AWD1IE = 1U << 7 ;

  // Field JEOSIE: ADC group injected end of sequence conversions interrupt
    const uint32_t ADC3_IER_JEOSIE = 1U << 6 ;

  // Field JEOCIE: ADC group injected end of unitary conversion interrupt
    const uint32_t ADC3_IER_JEOCIE = 1U << 5 ;

  // Field OVRIE: ADC group regular overrun interrupt
    const uint32_t ADC3_IER_OVRIE = 1U << 4 ;

  // Field EOSIE: ADC group regular end of sequence conversions interrupt
    const uint32_t ADC3_IER_EOSIE = 1U << 3 ;

  // Field EOCIE: ADC group regular end of unitary conversion interrupt
    const uint32_t ADC3_IER_EOCIE = 1U << 2 ;

  // Field EOSMPIE: ADC group regular end of sampling interrupt
    const uint32_t ADC3_IER_EOSMPIE = 1U << 1 ;

  // Field ADRDYIE: ADC ready interrupt
    const uint32_t ADC3_IER_ADRDYIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: ADC control register
  #define ADC3_CR (* ((volatile uint32_t *) (0x58026000 + 8)))

  // Field ADCAL: ADC calibration
    const uint32_t ADC3_CR_ADCAL = 1U << 31 ;

  // Field ADCALDIF: ADC differential mode for calibration
    const uint32_t ADC3_CR_ADCALDIF = 1U << 30 ;

  // Field DEEPPWD: ADC deep power down enable
    const uint32_t ADC3_CR_DEEPPWD = 1U << 29 ;

  // Field ADVREGEN: ADC voltage regulator enable
    const uint32_t ADC3_CR_ADVREGEN = 1U << 28 ;

  // Field LINCALRDYW6: Linearity calibration ready Word 6
    const uint32_t ADC3_CR_LINCALRDYW6 = 1U << 27 ;

  // Field LINCALRDYW5: Linearity calibration ready Word 5
    const uint32_t ADC3_CR_LINCALRDYW5 = 1U << 26 ;

  // Field LINCALRDYW4: Linearity calibration ready Word 4
    const uint32_t ADC3_CR_LINCALRDYW4 = 1U << 25 ;

  // Field LINCALRDYW3: Linearity calibration ready Word 3
    const uint32_t ADC3_CR_LINCALRDYW3 = 1U << 24 ;

  // Field LINCALRDYW2: Linearity calibration ready Word 2
    const uint32_t ADC3_CR_LINCALRDYW2 = 1U << 23 ;

  // Field LINCALRDYW1: Linearity calibration ready Word 1
    const uint32_t ADC3_CR_LINCALRDYW1 = 1U << 22 ;

  // Field ADCALLIN: Linearity calibration
    const uint32_t ADC3_CR_ADCALLIN = 1U << 16 ;

  // Field BOOST: Boost mode control
    const uint32_t ADC3_CR_BOOST = 1U << 8 ;

  // Field JADSTP: ADC group injected conversion stop
    const uint32_t ADC3_CR_JADSTP = 1U << 5 ;

  // Field ADSTP: ADC group regular conversion stop
    const uint32_t ADC3_CR_ADSTP = 1U << 4 ;

  // Field JADSTART: ADC group injected conversion start
    const uint32_t ADC3_CR_JADSTART = 1U << 3 ;

  // Field ADSTART: ADC group regular conversion start
    const uint32_t ADC3_CR_ADSTART = 1U << 2 ;

  // Field ADDIS: ADC disable
    const uint32_t ADC3_CR_ADDIS = 1U << 1 ;

  // Field ADEN: ADC enable
    const uint32_t ADC3_CR_ADEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: ADC configuration register 1
  #define ADC3_CFGR (* ((volatile uint32_t *) (0x58026000 + 12)))

  // Field JQDIS: ADC group injected contexts queue disable
    const uint32_t ADC3_CFGR_JQDIS = 1U << 31 ;

  // Field AWDCH1CH: ADC analog watchdog 1 monitored channel selection
    inline uint32_t ADC3_CFGR_AWDCH1CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field JAUTO: ADC group injected automatic trigger mode
    const uint32_t ADC3_CFGR_JAUTO = 1U << 25 ;

  // Field JAWD1EN: ADC analog watchdog 1 enable on scope ADC group injected
    const uint32_t ADC3_CFGR_JAWD1EN = 1U << 24 ;

  // Field AWD1EN: ADC analog watchdog 1 enable on scope ADC group regular
    const uint32_t ADC3_CFGR_AWD1EN = 1U << 23 ;

  // Field AWD1SGL: ADC analog watchdog 1 monitoring a single channel or all channels
    const uint32_t ADC3_CFGR_AWD1SGL = 1U << 22 ;

  // Field JQM: ADC group injected contexts queue mode
    const uint32_t ADC3_CFGR_JQM = 1U << 21 ;

  // Field JDISCEN: ADC group injected sequencer discontinuous mode
    const uint32_t ADC3_CFGR_JDISCEN = 1U << 20 ;

  // Field DISCNUM: ADC group regular sequencer discontinuous number of ranks
    inline uint32_t ADC3_CFGR_DISCNUM (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DISCEN: ADC group regular sequencer discontinuous mode
    const uint32_t ADC3_CFGR_DISCEN = 1U << 16 ;

  // Field AUTDLY: ADC low power auto wait
    const uint32_t ADC3_CFGR_AUTDLY = 1U << 14 ;

  // Field CONT: ADC group regular continuous conversion mode
    const uint32_t ADC3_CFGR_CONT = 1U << 13 ;

  // Field OVRMOD: ADC group regular overrun configuration
    const uint32_t ADC3_CFGR_OVRMOD = 1U << 12 ;

  // Field EXTEN: ADC group regular external trigger polarity
    inline uint32_t ADC3_CFGR_EXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field EXTSEL: ADC group regular external trigger source
    inline uint32_t ADC3_CFGR_EXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 5 ; }

  // Field RES: ADC data resolution
    inline uint32_t ADC3_CFGR_RES (const uint32_t inValue) {return (inValue & 0x7U) << 2 ; }

  // Field DMNGT: ADC DMA transfer enable
    inline uint32_t ADC3_CFGR_DMNGT (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: ADC configuration register 2
  #define ADC3_CFGR2 (* ((volatile uint32_t *) (0x58026000 + 16)))

  // Field ROVSE: ADC oversampler enable on scope ADC group regular
    const uint32_t ADC3_CFGR2_ROVSE = 1U << 0 ;

  // Field JOVSE: ADC oversampler enable on scope ADC group injected
    const uint32_t ADC3_CFGR2_JOVSE = 1U << 1 ;

  // Field OVSS: ADC oversampling shift
    inline uint32_t ADC3_CFGR2_OVSS (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field TROVS: ADC oversampling discontinuous mode (triggered mode) for ADC group regular
    const uint32_t ADC3_CFGR2_TROVS = 1U << 9 ;

  // Field ROVSM: Regular Oversampling mode
    const uint32_t ADC3_CFGR2_ROVSM = 1U << 10 ;

  // Field RSHIFT1: Right-shift data after Offset 1 correction
    const uint32_t ADC3_CFGR2_RSHIFT1 = 1U << 11 ;

  // Field RSHIFT2: Right-shift data after Offset 2 correction
    const uint32_t ADC3_CFGR2_RSHIFT2 = 1U << 12 ;

  // Field RSHIFT3: Right-shift data after Offset 3 correction
    const uint32_t ADC3_CFGR2_RSHIFT3 = 1U << 13 ;

  // Field RSHIFT4: Right-shift data after Offset 4 correction
    const uint32_t ADC3_CFGR2_RSHIFT4 = 1U << 14 ;

  // Field OSR: Oversampling ratio
    inline uint32_t ADC3_CFGR2_OSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field LSHIFT: Left shift factor
    inline uint32_t ADC3_CFGR2_LSHIFT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register SMPR1: ADC sampling time register 1
  #define ADC3_SMPR1 (* ((volatile uint32_t *) (0x58026000 + 20)))

  // Field SMP9: ADC channel 9 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP9 (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

  // Field SMP8: ADC channel 8 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP8 (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SMP7: ADC channel 7 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP7 (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SMP6: ADC channel 6 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP6 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field SMP5: ADC channel 5 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP5 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field SMP4: ADC channel 4 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP4 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SMP3: ADC channel 3 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP3 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field SMP2: ADC channel 2 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP2 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SMP1: ADC channel 1 sampling time selection
    inline uint32_t ADC3_SMPR1_SMP1 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

//------------------------------------------------------------------------------

//---  Register SMPR2: ADC sampling time register 2
  #define ADC3_SMPR2 (* ((volatile uint32_t *) (0x58026000 + 24)))

  // Field SMP19: ADC channel 18 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP19 (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

  // Field SMP18: ADC channel 18 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP18 (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SMP17: ADC channel 17 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP17 (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SMP16: ADC channel 16 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP16 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field SMP15: ADC channel 15 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP15 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field SMP14: ADC channel 14 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP14 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SMP13: ADC channel 13 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP13 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field SMP12: ADC channel 12 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP12 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SMP11: ADC channel 11 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP11 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field SMP10: ADC channel 10 sampling time selection
    inline uint32_t ADC3_SMPR2_SMP10 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR1: ADC analog watchdog 1 threshold register
  #define ADC3_LTR1 (* ((volatile uint32_t *) (0x58026000 + 32)))

  // Field LTR1: ADC analog watchdog 1 threshold low
    inline uint32_t ADC3_LTR1_LTR1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LHTR1: ADC analog watchdog 2 threshold register
  #define ADC3_LHTR1 (* ((volatile uint32_t *) (0x58026000 + 36)))

  // Field LHTR1: ADC analog watchdog 2 threshold low
    inline uint32_t ADC3_LHTR1_LHTR1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR1: ADC group regular sequencer ranks register 1
  #define ADC3_SQR1 (* ((volatile uint32_t *) (0x58026000 + 48)))

  // Field SQ4: ADC group regular sequencer rank 4
    inline uint32_t ADC3_SQR1_SQ4 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ3: ADC group regular sequencer rank 3
    inline uint32_t ADC3_SQR1_SQ3 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ2: ADC group regular sequencer rank 2
    inline uint32_t ADC3_SQR1_SQ2 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ1: ADC group regular sequencer rank 1
    inline uint32_t ADC3_SQR1_SQ1 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field L3: L3
    inline uint32_t ADC3_SQR1_L3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR2: ADC group regular sequencer ranks register 2
  #define ADC3_SQR2 (* ((volatile uint32_t *) (0x58026000 + 52)))

  // Field SQ9: ADC group regular sequencer rank 9
    inline uint32_t ADC3_SQR2_SQ9 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ8: ADC group regular sequencer rank 8
    inline uint32_t ADC3_SQR2_SQ8 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ7: ADC group regular sequencer rank 7
    inline uint32_t ADC3_SQR2_SQ7 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ6: ADC group regular sequencer rank 6
    inline uint32_t ADC3_SQR2_SQ6 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ5: ADC group regular sequencer rank 5
    inline uint32_t ADC3_SQR2_SQ5 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR3: ADC group regular sequencer ranks register 3
  #define ADC3_SQR3 (* ((volatile uint32_t *) (0x58026000 + 56)))

  // Field SQ14: ADC group regular sequencer rank 14
    inline uint32_t ADC3_SQR3_SQ14 (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field SQ13: ADC group regular sequencer rank 13
    inline uint32_t ADC3_SQR3_SQ13 (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field SQ12: ADC group regular sequencer rank 12
    inline uint32_t ADC3_SQR3_SQ12 (const uint32_t inValue) {return (inValue & 0x1FU) << 12 ; }

  // Field SQ11: ADC group regular sequencer rank 11
    inline uint32_t ADC3_SQR3_SQ11 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ10: ADC group regular sequencer rank 10
    inline uint32_t ADC3_SQR3_SQ10 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SQR4: ADC group regular sequencer ranks register 4
  #define ADC3_SQR4 (* ((volatile uint32_t *) (0x58026000 + 60)))

  // Field SQ16: ADC group regular sequencer rank 16
    inline uint32_t ADC3_SQR4_SQ16 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field SQ15: ADC group regular sequencer rank 15
    inline uint32_t ADC3_SQR4_SQ15 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR: ADC group regular conversion data register
  #define ADC3_DR (* ((const volatile uint32_t *) (0x58026000 + 64)))

  // Field RDATA: ADC group regular conversion data
    inline uint32_t ADC3_DR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JSQR: ADC group injected sequencer register
  #define ADC3_JSQR (* ((volatile uint32_t *) (0x58026000 + 76)))

  // Field JSQ4: ADC group injected sequencer rank 4
    inline uint32_t ADC3_JSQR_JSQ4 (const uint32_t inValue) {return (inValue & 0x1FU) << 27 ; }

  // Field JSQ3: ADC group injected sequencer rank 3
    inline uint32_t ADC3_JSQR_JSQ3 (const uint32_t inValue) {return (inValue & 0x1FU) << 21 ; }

  // Field JSQ2: ADC group injected sequencer rank 2
    inline uint32_t ADC3_JSQR_JSQ2 (const uint32_t inValue) {return (inValue & 0x1FU) << 15 ; }

  // Field JSQ1: ADC group injected sequencer rank 1
    inline uint32_t ADC3_JSQR_JSQ1 (const uint32_t inValue) {return (inValue & 0x1FU) << 9 ; }

  // Field JEXTEN: ADC group injected external trigger polarity
    inline uint32_t ADC3_JSQR_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 7 ; }

  // Field JEXTSEL: ADC group injected external trigger source
    inline uint32_t ADC3_JSQR_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 2 ; }

  // Field JL: ADC group injected sequencer scan length
    inline uint32_t ADC3_JSQR_JL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR1: ADC offset number 1 register
  #define ADC3_OFR1 (* ((volatile uint32_t *) (0x58026000 + 96)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC3_OFR1_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC3_OFR1_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC3_OFR1_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR2: ADC offset number 2 register
  #define ADC3_OFR2 (* ((volatile uint32_t *) (0x58026000 + 100)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC3_OFR2_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC3_OFR2_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC3_OFR2_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR3: ADC offset number 3 register
  #define ADC3_OFR3 (* ((volatile uint32_t *) (0x58026000 + 104)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC3_OFR3_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC3_OFR3_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC3_OFR3_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OFR4: ADC offset number 4 register
  #define ADC3_OFR4 (* ((volatile uint32_t *) (0x58026000 + 108)))

  // Field SSATE: ADC offset number 1 enable
    const uint32_t ADC3_OFR4_SSATE = 1U << 31 ;

  // Field OFFSET1_CH: ADC offset number 1 channel selection
    inline uint32_t ADC3_OFR4_OFFSET1_CH (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

  // Field OFFSET1: ADC offset number 1 offset level
    inline uint32_t ADC3_OFR4_OFFSET1 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR1: ADC group injected sequencer rank 1 register
  #define ADC3_JDR1 (* ((const volatile uint32_t *) (0x58026000 + 128)))

  // Field JDATA1: ADC group injected sequencer rank 1 conversion data
    inline uint32_t ADC3_JDR1_JDATA1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR2: ADC group injected sequencer rank 2 register
  #define ADC3_JDR2 (* ((const volatile uint32_t *) (0x58026000 + 132)))

  // Field JDATA2: ADC group injected sequencer rank 2 conversion data
    inline uint32_t ADC3_JDR2_JDATA2 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR3: ADC group injected sequencer rank 3 register
  #define ADC3_JDR3 (* ((const volatile uint32_t *) (0x58026000 + 136)))

  // Field JDATA3: ADC group injected sequencer rank 3 conversion data
    inline uint32_t ADC3_JDR3_JDATA3 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register JDR4: ADC group injected sequencer rank 4 register
  #define ADC3_JDR4 (* ((const volatile uint32_t *) (0x58026000 + 140)))

  // Field JDATA4: ADC group injected sequencer rank 4 conversion data
    inline uint32_t ADC3_JDR4_JDATA4 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWD2CR: ADC analog watchdog 2 configuration register
  #define ADC3_AWD2CR (* ((volatile uint32_t *) (0x58026000 + 160)))

  // Field AWD2CH: ADC analog watchdog 2 monitored channel selection
    inline uint32_t ADC3_AWD2CR_AWD2CH (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWD3CR: ADC analog watchdog 3 configuration register
  #define ADC3_AWD3CR (* ((volatile uint32_t *) (0x58026000 + 164)))

  // Field AWD3CH: ADC analog watchdog 3 monitored channel selection
    inline uint32_t ADC3_AWD3CR_AWD3CH (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 1 ; }

//------------------------------------------------------------------------------

//---  Register DIFSEL: ADC channel differential or single-ended mode selection register
  #define ADC3_DIFSEL (* ((volatile uint32_t *) (0x58026000 + 192)))

  // Field DIFSEL: ADC channel differential or single-ended mode for channel
    inline uint32_t ADC3_DIFSEL_DIFSEL (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALFACT: ADC calibration factors register
  #define ADC3_CALFACT (* ((volatile uint32_t *) (0x58026000 + 196)))

  // Field CALFACT_D: ADC calibration factor in differential mode
    inline uint32_t ADC3_CALFACT_CALFACT_D (const uint32_t inValue) {return (inValue & 0x7FFU) << 16 ; }

  // Field CALFACT_S: ADC calibration factor in single-ended mode
    inline uint32_t ADC3_CALFACT_CALFACT_S (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PCSEL: ADC pre channel selection register
  #define ADC3_PCSEL (* ((volatile uint32_t *) (0x58026000 + 28)))

  // Field PCSEL: Channel x (VINP[i]) pre selection
    inline uint32_t ADC3_PCSEL_PCSEL (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR2: ADC watchdog lower threshold register 2
  #define ADC3_LTR2 (* ((volatile uint32_t *) (0x58026000 + 176)))

  // Field LTR2: Analog watchdog 2 lower threshold
    inline uint32_t ADC3_LTR2_LTR2 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register HTR2: ADC watchdog higher threshold register 2
  #define ADC3_HTR2 (* ((volatile uint32_t *) (0x58026000 + 180)))

  // Field HTR2: Analog watchdog 2 higher threshold
    inline uint32_t ADC3_HTR2_HTR2 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LTR3: ADC watchdog lower threshold register 3
  #define ADC3_LTR3 (* ((volatile uint32_t *) (0x58026000 + 184)))

  // Field LTR3: Analog watchdog 3 lower threshold
    inline uint32_t ADC3_LTR3_LTR3 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register HTR3: ADC watchdog higher threshold register 3
  #define ADC3_HTR3 (* ((volatile uint32_t *) (0x58026000 + 188)))

  // Field HTR3: Analog watchdog 3 higher threshold
    inline uint32_t ADC3_HTR3_HTR3 (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALFACT2: ADC Calibration Factor register 2
  #define ADC3_CALFACT2 (* ((volatile uint32_t *) (0x58026000 + 200)))

  // Field LINCALFACT: Linearity Calibration Factor
    inline uint32_t ADC3_CALFACT2_LINCALFACT (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral ADC3_Common: Analog-to-Digital Converter
//------------------------------------------------------------------------------

//---  Register CSR: ADC Common status register
  #define ADC3_Common_CSR (* ((const volatile uint32_t *) (0x58026300 + 0)))

  // Field ADRDY_MST: Master ADC ready
    const uint32_t ADC3_Common_CSR_ADRDY_MST = 1U << 0 ;

  // Field EOSMP_MST: End of Sampling phase flag of the master ADC
    const uint32_t ADC3_Common_CSR_EOSMP_MST = 1U << 1 ;

  // Field EOC_MST: End of regular conversion of the master ADC
    const uint32_t ADC3_Common_CSR_EOC_MST = 1U << 2 ;

  // Field EOS_MST: End of regular sequence flag of the master ADC
    const uint32_t ADC3_Common_CSR_EOS_MST = 1U << 3 ;

  // Field OVR_MST: Overrun flag of the master ADC
    const uint32_t ADC3_Common_CSR_OVR_MST = 1U << 4 ;

  // Field JEOC_MST: End of injected conversion flag of the master ADC
    const uint32_t ADC3_Common_CSR_JEOC_MST = 1U << 5 ;

  // Field JEOS_MST: End of injected sequence flag of the master ADC
    const uint32_t ADC3_Common_CSR_JEOS_MST = 1U << 6 ;

  // Field AWD1_MST: Analog watchdog 1 flag of the master ADC
    const uint32_t ADC3_Common_CSR_AWD1_MST = 1U << 7 ;

  // Field AWD2_MST: Analog watchdog 2 flag of the master ADC
    const uint32_t ADC3_Common_CSR_AWD2_MST = 1U << 8 ;

  // Field AWD3_MST: Analog watchdog 3 flag of the master ADC
    const uint32_t ADC3_Common_CSR_AWD3_MST = 1U << 9 ;

  // Field JQOVF_MST: Injected Context Queue Overflow flag of the master ADC
    const uint32_t ADC3_Common_CSR_JQOVF_MST = 1U << 10 ;

  // Field ADRDY_SLV: Slave ADC ready
    const uint32_t ADC3_Common_CSR_ADRDY_SLV = 1U << 16 ;

  // Field EOSMP_SLV: End of Sampling phase flag of the slave ADC
    const uint32_t ADC3_Common_CSR_EOSMP_SLV = 1U << 17 ;

  // Field EOC_SLV: End of regular conversion of the slave ADC
    const uint32_t ADC3_Common_CSR_EOC_SLV = 1U << 18 ;

  // Field EOS_SLV: End of regular sequence flag of the slave ADC
    const uint32_t ADC3_Common_CSR_EOS_SLV = 1U << 19 ;

  // Field OVR_SLV: Overrun flag of the slave ADC
    const uint32_t ADC3_Common_CSR_OVR_SLV = 1U << 20 ;

  // Field JEOC_SLV: End of injected conversion flag of the slave ADC
    const uint32_t ADC3_Common_CSR_JEOC_SLV = 1U << 21 ;

  // Field JEOS_SLV: End of injected sequence flag of the slave ADC
    const uint32_t ADC3_Common_CSR_JEOS_SLV = 1U << 22 ;

  // Field AWD1_SLV: Analog watchdog 1 flag of the slave ADC
    const uint32_t ADC3_Common_CSR_AWD1_SLV = 1U << 23 ;

  // Field AWD2_SLV: Analog watchdog 2 flag of the slave ADC
    const uint32_t ADC3_Common_CSR_AWD2_SLV = 1U << 24 ;

  // Field AWD3_SLV: Analog watchdog 3 flag of the slave ADC
    const uint32_t ADC3_Common_CSR_AWD3_SLV = 1U << 25 ;

  // Field JQOVF_SLV: Injected Context Queue Overflow flag of the slave ADC
    const uint32_t ADC3_Common_CSR_JQOVF_SLV = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register CCR: ADC common control register
  #define ADC3_Common_CCR (* ((volatile uint32_t *) (0x58026300 + 8)))

  // Field DUAL: Dual ADC mode selection
    inline uint32_t ADC3_Common_CCR_DUAL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field DELAY: Delay between 2 sampling phases
    inline uint32_t ADC3_Common_CCR_DELAY (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field DAMDF: Dual ADC Mode Data Format
    inline uint32_t ADC3_Common_CCR_DAMDF (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKMODE: ADC clock mode
    inline uint32_t ADC3_Common_CCR_CKMODE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PRESC: ADC prescaler
    inline uint32_t ADC3_Common_CCR_PRESC (const uint32_t inValue) {return (inValue & 0xFU) << 18 ; }

  // Field VREFEN: VREFINT enable
    const uint32_t ADC3_Common_CCR_VREFEN = 1U << 22 ;

  // Field VSENSEEN: Temperature sensor enable
    const uint32_t ADC3_Common_CCR_VSENSEEN = 1U << 23 ;

  // Field VBATEN: VBAT enable
    const uint32_t ADC3_Common_CCR_VBATEN = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CDR: ADC common regular data register for dual and triple modes
  #define ADC3_Common_CDR (* ((const volatile uint32_t *) (0x58026300 + 12)))

  // Field RDATA_SLV: Regular data of the slave ADC
    inline uint32_t ADC3_Common_CDR_RDATA_SLV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RDATA_MST: Regular data of the master ADC
    inline uint32_t ADC3_Common_CDR_RDATA_MST (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CDR2: ADC x common regular data register for 32-bit dual mode
  #define ADC3_Common_CDR2 (* ((const volatile uint32_t *) (0x58026300 + 16)))

  // Field RDATA_ALT: Regular data of the master/slave alternated ADCs
    inline uint32_t ADC3_Common_CDR2_RDATA_ALT (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral AXI: AXI interconnect registers
//------------------------------------------------------------------------------

//---  Register AXI_PERIPH_ID_4: AXI interconnect - peripheral ID4 register
  #define AXI_AXI_PERIPH_ID_4 (* ((const volatile uint32_t *) (0x51000000 + 8144)))

  // Field JEP106CON: JEP106 continuation code
    inline uint32_t AXI_AXI_PERIPH_ID_4_JEP106CON (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field KCOUNT4: Register file size
    inline uint32_t AXI_AXI_PERIPH_ID_4_KCOUNT4 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register AXI_PERIPH_ID_0: AXI interconnect - peripheral ID0 register
  #define AXI_AXI_PERIPH_ID_0 (* ((const volatile uint32_t *) (0x51000000 + 8160)))

  // Field PARTNUM: Peripheral part number bits 0 to 7
    inline uint32_t AXI_AXI_PERIPH_ID_0_PARTNUM (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_PERIPH_ID_1: AXI interconnect - peripheral ID1 register
  #define AXI_AXI_PERIPH_ID_1 (* ((const volatile uint32_t *) (0x51000000 + 8164)))

  // Field PARTNUM: Peripheral part number bits 8 to 11
    inline uint32_t AXI_AXI_PERIPH_ID_1_PARTNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field JEP106I: JEP106 identity bits 0 to 3
    inline uint32_t AXI_AXI_PERIPH_ID_1_JEP106I (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register AXI_PERIPH_ID_2: AXI interconnect - peripheral ID2 register
  #define AXI_AXI_PERIPH_ID_2 (* ((const volatile uint32_t *) (0x51000000 + 8168)))

  // Field JEP106ID: JEP106 Identity bits 4 to 6
    inline uint32_t AXI_AXI_PERIPH_ID_2_JEP106ID (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field JEDEC: JEP106 code flag
    const uint32_t AXI_AXI_PERIPH_ID_2_JEDEC = 1U << 3 ;

  // Field REVISION: Peripheral revision number
    inline uint32_t AXI_AXI_PERIPH_ID_2_REVISION (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register AXI_PERIPH_ID_3: AXI interconnect - peripheral ID3 register
  #define AXI_AXI_PERIPH_ID_3 (* ((const volatile uint32_t *) (0x51000000 + 8172)))

  // Field CUST_MOD_NUM: Customer modification
    inline uint32_t AXI_AXI_PERIPH_ID_3_CUST_MOD_NUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field REV_AND: Customer version
    inline uint32_t AXI_AXI_PERIPH_ID_3_REV_AND (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register AXI_COMP_ID_0: AXI interconnect - component ID0 register
  #define AXI_AXI_COMP_ID_0 (* ((const volatile uint32_t *) (0x51000000 + 8176)))

  // Field PREAMBLE: Preamble bits 0 to 7
    inline uint32_t AXI_AXI_COMP_ID_0_PREAMBLE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_COMP_ID_1: AXI interconnect - component ID1 register
  #define AXI_AXI_COMP_ID_1 (* ((const volatile uint32_t *) (0x51000000 + 8180)))

  // Field PREAMBLE: Preamble bits 8 to 11
    inline uint32_t AXI_AXI_COMP_ID_1_PREAMBLE (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field CLASS: Component class
    inline uint32_t AXI_AXI_COMP_ID_1_CLASS (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register AXI_COMP_ID_2: AXI interconnect - component ID2 register
  #define AXI_AXI_COMP_ID_2 (* ((const volatile uint32_t *) (0x51000000 + 8184)))

  // Field PREAMBLE: Preamble bits 12 to 19
    inline uint32_t AXI_AXI_COMP_ID_2_PREAMBLE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_COMP_ID_3: AXI interconnect - component ID3 register
  #define AXI_AXI_COMP_ID_3 (* ((const volatile uint32_t *) (0x51000000 + 8188)))

  // Field PREAMBLE: Preamble bits 20 to 27
    inline uint32_t AXI_AXI_COMP_ID_3_PREAMBLE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_TARG1_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG1_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 8200)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG1_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG1_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG2_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG2_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 12296)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG2_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG2_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG3_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG3_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 16392)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG3_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG3_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG4_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG4_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 20488)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG4_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG4_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG5_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG5_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 24584)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG5_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG5_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG6_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG6_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 28680)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG6_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG6_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG7_FN_MOD_ISS_BM: AXI interconnect - TARG x bus matrix issuing functionality register
  #define AXI_AXI_TARG7_FN_MOD_ISS_BM (* ((volatile uint32_t *) (0x51000000 + 32780)))

  // Field READ_ISS_OVERRIDE: READ_ISS_OVERRIDE
    const uint32_t AXI_AXI_TARG7_FN_MOD_ISS_BM_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Switch matrix write issuing override for target
    const uint32_t AXI_AXI_TARG7_FN_MOD_ISS_BM_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG1_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
  #define AXI_AXI_TARG1_FN_MOD2 (* ((volatile uint32_t *) (0x51000000 + 8228)))

  // Field BYPASS_MERGE: Disable packing of beats to match the output data width
    const uint32_t AXI_AXI_TARG1_FN_MOD2_BYPASS_MERGE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG2_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
  #define AXI_AXI_TARG2_FN_MOD2 (* ((volatile uint32_t *) (0x51000000 + 12324)))

  // Field BYPASS_MERGE: Disable packing of beats to match the output data width
    const uint32_t AXI_AXI_TARG2_FN_MOD2_BYPASS_MERGE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG7_FN_MOD2: AXI interconnect - TARG x bus matrix functionality 2 register
  #define AXI_AXI_TARG7_FN_MOD2 (* ((volatile uint32_t *) (0x51000000 + 32804)))

  // Field BYPASS_MERGE: Disable packing of beats to match the output data width
    const uint32_t AXI_AXI_TARG7_FN_MOD2_BYPASS_MERGE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG1_FN_MOD_LB: AXI interconnect - TARG x long burst functionality modification
  #define AXI_AXI_TARG1_FN_MOD_LB (* ((volatile uint32_t *) (0x51000000 + 8236)))

  // Field FN_MOD_LB: Controls burst breaking of long bursts
    const uint32_t AXI_AXI_TARG1_FN_MOD_LB_FN_MOD_LB = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG2_FN_MOD_LB: AXI interconnect - TARG x long burst functionality modification
  #define AXI_AXI_TARG2_FN_MOD_LB (* ((volatile uint32_t *) (0x51000000 + 12332)))

  // Field FN_MOD_LB: Controls burst breaking of long bursts
    const uint32_t AXI_AXI_TARG2_FN_MOD_LB_FN_MOD_LB = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG1_FN_MOD: AXI interconnect - TARG x long burst functionality modification
  #define AXI_AXI_TARG1_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 8456)))

  // Field READ_ISS_OVERRIDE: Override AMIB read issuing capability
    const uint32_t AXI_AXI_TARG1_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override AMIB write issuing capability
    const uint32_t AXI_AXI_TARG1_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG2_FN_MOD: AXI interconnect - TARG x long burst functionality modification
  #define AXI_AXI_TARG2_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 12552)))

  // Field READ_ISS_OVERRIDE: Override AMIB read issuing capability
    const uint32_t AXI_AXI_TARG2_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override AMIB write issuing capability
    const uint32_t AXI_AXI_TARG2_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_TARG7_FN_MOD: AXI interconnect - TARG x long burst functionality modification
  #define AXI_AXI_TARG7_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 33032)))

  // Field READ_ISS_OVERRIDE: Override AMIB read issuing capability
    const uint32_t AXI_AXI_TARG7_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override AMIB write issuing capability
    const uint32_t AXI_AXI_TARG7_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI1_FN_MOD2: AXI interconnect - INI x functionality modification 2 register
  #define AXI_AXI_INI1_FN_MOD2 (* ((volatile uint32_t *) (0x51000000 + 270372)))

  // Field BYPASS_MERGE: Disables alteration of transactions by the up-sizer unless required by the protocol
    const uint32_t AXI_AXI_INI1_FN_MOD2_BYPASS_MERGE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI3_FN_MOD2: AXI interconnect - INI x functionality modification 2 register
  #define AXI_AXI_INI3_FN_MOD2 (* ((volatile uint32_t *) (0x51000000 + 278564)))

  // Field BYPASS_MERGE: Disables alteration of transactions by the up-sizer unless required by the protocol
    const uint32_t AXI_AXI_INI3_FN_MOD2_BYPASS_MERGE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI1_FN_MOD_AHB: AXI interconnect - INI x AHB functionality modification register
  #define AXI_AXI_INI1_FN_MOD_AHB (* ((volatile uint32_t *) (0x51000000 + 270376)))

  // Field RD_INC_OVERRIDE: Converts all AHB-Lite write transactions to a series of single beat AXI
    const uint32_t AXI_AXI_INI1_FN_MOD_AHB_RD_INC_OVERRIDE = 1U << 0 ;

  // Field WR_INC_OVERRIDE: Converts all AHB-Lite read transactions to a series of single beat AXI
    const uint32_t AXI_AXI_INI1_FN_MOD_AHB_WR_INC_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI3_FN_MOD_AHB: AXI interconnect - INI x AHB functionality modification register
  #define AXI_AXI_INI3_FN_MOD_AHB (* ((volatile uint32_t *) (0x51000000 + 278568)))

  // Field RD_INC_OVERRIDE: Converts all AHB-Lite write transactions to a series of single beat AXI
    const uint32_t AXI_AXI_INI3_FN_MOD_AHB_RD_INC_OVERRIDE = 1U << 0 ;

  // Field WR_INC_OVERRIDE: Converts all AHB-Lite read transactions to a series of single beat AXI
    const uint32_t AXI_AXI_INI3_FN_MOD_AHB_WR_INC_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI1_READ_QOS: AXI interconnect - INI x read QoS register
  #define AXI_AXI_INI1_READ_QOS (* ((volatile uint32_t *) (0x51000000 + 270592)))

  // Field AR_QOS: Read channel QoS setting
    inline uint32_t AXI_AXI_INI1_READ_QOS_AR_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI2_READ_QOS: AXI interconnect - INI x read QoS register
  #define AXI_AXI_INI2_READ_QOS (* ((volatile uint32_t *) (0x51000000 + 274688)))

  // Field AR_QOS: Read channel QoS setting
    inline uint32_t AXI_AXI_INI2_READ_QOS_AR_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI3_READ_QOS: AXI interconnect - INI x read QoS register
  #define AXI_AXI_INI3_READ_QOS (* ((volatile uint32_t *) (0x51000000 + 278784)))

  // Field AR_QOS: Read channel QoS setting
    inline uint32_t AXI_AXI_INI3_READ_QOS_AR_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI4_READ_QOS: AXI interconnect - INI x read QoS register
  #define AXI_AXI_INI4_READ_QOS (* ((volatile uint32_t *) (0x51000000 + 282880)))

  // Field AR_QOS: Read channel QoS setting
    inline uint32_t AXI_AXI_INI4_READ_QOS_AR_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI5_READ_QOS: AXI interconnect - INI x read QoS register
  #define AXI_AXI_INI5_READ_QOS (* ((volatile uint32_t *) (0x51000000 + 286976)))

  // Field AR_QOS: Read channel QoS setting
    inline uint32_t AXI_AXI_INI5_READ_QOS_AR_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI6_READ_QOS: AXI interconnect - INI x read QoS register
  #define AXI_AXI_INI6_READ_QOS (* ((volatile uint32_t *) (0x51000000 + 291072)))

  // Field AR_QOS: Read channel QoS setting
    inline uint32_t AXI_AXI_INI6_READ_QOS_AR_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI1_WRITE_QOS: AXI interconnect - INI x write QoS register
  #define AXI_AXI_INI1_WRITE_QOS (* ((volatile uint32_t *) (0x51000000 + 270596)))

  // Field AW_QOS: Write channel QoS setting
    inline uint32_t AXI_AXI_INI1_WRITE_QOS_AW_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI2_WRITE_QOS: AXI interconnect - INI x write QoS register
  #define AXI_AXI_INI2_WRITE_QOS (* ((volatile uint32_t *) (0x51000000 + 274692)))

  // Field AW_QOS: Write channel QoS setting
    inline uint32_t AXI_AXI_INI2_WRITE_QOS_AW_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI3_WRITE_QOS: AXI interconnect - INI x write QoS register
  #define AXI_AXI_INI3_WRITE_QOS (* ((volatile uint32_t *) (0x51000000 + 278788)))

  // Field AW_QOS: Write channel QoS setting
    inline uint32_t AXI_AXI_INI3_WRITE_QOS_AW_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI4_WRITE_QOS: AXI interconnect - INI x write QoS register
  #define AXI_AXI_INI4_WRITE_QOS (* ((volatile uint32_t *) (0x51000000 + 282884)))

  // Field AW_QOS: Write channel QoS setting
    inline uint32_t AXI_AXI_INI4_WRITE_QOS_AW_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI5_WRITE_QOS: AXI interconnect - INI x write QoS register
  #define AXI_AXI_INI5_WRITE_QOS (* ((volatile uint32_t *) (0x51000000 + 286980)))

  // Field AW_QOS: Write channel QoS setting
    inline uint32_t AXI_AXI_INI5_WRITE_QOS_AW_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI6_WRITE_QOS: AXI interconnect - INI x write QoS register
  #define AXI_AXI_INI6_WRITE_QOS (* ((volatile uint32_t *) (0x51000000 + 291076)))

  // Field AW_QOS: Write channel QoS setting
    inline uint32_t AXI_AXI_INI6_WRITE_QOS_AW_QOS (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AXI_INI1_FN_MOD: AXI interconnect - INI x issuing functionality modification register
  #define AXI_AXI_INI1_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 270600)))

  // Field READ_ISS_OVERRIDE: Override ASIB read issuing capability
    const uint32_t AXI_AXI_INI1_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override ASIB write issuing capability
    const uint32_t AXI_AXI_INI1_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI2_FN_MOD: AXI interconnect - INI x issuing functionality modification register
  #define AXI_AXI_INI2_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 274696)))

  // Field READ_ISS_OVERRIDE: Override ASIB read issuing capability
    const uint32_t AXI_AXI_INI2_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override ASIB write issuing capability
    const uint32_t AXI_AXI_INI2_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI3_FN_MOD: AXI interconnect - INI x issuing functionality modification register
  #define AXI_AXI_INI3_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 278792)))

  // Field READ_ISS_OVERRIDE: Override ASIB read issuing capability
    const uint32_t AXI_AXI_INI3_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override ASIB write issuing capability
    const uint32_t AXI_AXI_INI3_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI4_FN_MOD: AXI interconnect - INI x issuing functionality modification register
  #define AXI_AXI_INI4_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 282888)))

  // Field READ_ISS_OVERRIDE: Override ASIB read issuing capability
    const uint32_t AXI_AXI_INI4_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override ASIB write issuing capability
    const uint32_t AXI_AXI_INI4_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI5_FN_MOD: AXI interconnect - INI x issuing functionality modification register
  #define AXI_AXI_INI5_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 286984)))

  // Field READ_ISS_OVERRIDE: Override ASIB read issuing capability
    const uint32_t AXI_AXI_INI5_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override ASIB write issuing capability
    const uint32_t AXI_AXI_INI5_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AXI_INI6_FN_MOD: AXI interconnect - INI x issuing functionality modification register
  #define AXI_AXI_INI6_FN_MOD (* ((volatile uint32_t *) (0x51000000 + 291080)))

  // Field READ_ISS_OVERRIDE: Override ASIB read issuing capability
    const uint32_t AXI_AXI_INI6_FN_MOD_READ_ISS_OVERRIDE = 1U << 0 ;

  // Field WRITE_ISS_OVERRIDE: Override ASIB write issuing capability
    const uint32_t AXI_AXI_INI6_FN_MOD_WRITE_ISS_OVERRIDE = 1U << 1 ;

//------------------------------------------------------------------------------
// Peripheral BDMA: BDMA
//------------------------------------------------------------------------------

//---  Register ISR: DMA interrupt status register
  #define BDMA_ISR (* ((const volatile uint32_t *) (0x58025400 + 0)))

  // Field GIF1: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF1 = 1U << 0 ;

  // Field TCIF1: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF1 = 1U << 1 ;

  // Field HTIF1: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF1 = 1U << 2 ;

  // Field TEIF1: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF1 = 1U << 3 ;

  // Field GIF2: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF2 = 1U << 4 ;

  // Field TCIF2: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF2 = 1U << 5 ;

  // Field HTIF2: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF2 = 1U << 6 ;

  // Field TEIF2: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF2 = 1U << 7 ;

  // Field GIF3: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF3 = 1U << 8 ;

  // Field TCIF3: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF3 = 1U << 9 ;

  // Field HTIF3: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF3 = 1U << 10 ;

  // Field TEIF3: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF3 = 1U << 11 ;

  // Field GIF4: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF4 = 1U << 12 ;

  // Field TCIF4: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF4 = 1U << 13 ;

  // Field HTIF4: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF4 = 1U << 14 ;

  // Field TEIF4: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF4 = 1U << 15 ;

  // Field GIF5: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF5 = 1U << 16 ;

  // Field TCIF5: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF5 = 1U << 17 ;

  // Field HTIF5: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF5 = 1U << 18 ;

  // Field TEIF5: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF5 = 1U << 19 ;

  // Field GIF6: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF6 = 1U << 20 ;

  // Field TCIF6: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF6 = 1U << 21 ;

  // Field HTIF6: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF6 = 1U << 22 ;

  // Field TEIF6: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF6 = 1U << 23 ;

  // Field GIF7: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF7 = 1U << 24 ;

  // Field TCIF7: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF7 = 1U << 25 ;

  // Field HTIF7: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF7 = 1U << 26 ;

  // Field TEIF7: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF7 = 1U << 27 ;

  // Field GIF8: Channel x global interrupt flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_GIF8 = 1U << 28 ;

  // Field TCIF8: Channel x transfer complete flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TCIF8 = 1U << 29 ;

  // Field HTIF8: Channel x half transfer flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_HTIF8 = 1U << 30 ;

  // Field TEIF8: Channel x transfer error flag (x = 1..8) This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCR register.
    const uint32_t BDMA_ISR_TEIF8 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register IFCR: DMA interrupt flag clear register
  #define BDMA_IFCR (* ((volatile uint32_t *) (0x58025400 + 4)))

  // Field CGIF1: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF1 = 1U << 0 ;

  // Field CTCIF1: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF1 = 1U << 1 ;

  // Field CHTIF1: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF1 = 1U << 2 ;

  // Field CTEIF1: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF1 = 1U << 3 ;

  // Field CGIF2: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF2 = 1U << 4 ;

  // Field CTCIF2: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF2 = 1U << 5 ;

  // Field CHTIF2: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF2 = 1U << 6 ;

  // Field CTEIF2: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF2 = 1U << 7 ;

  // Field CGIF3: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF3 = 1U << 8 ;

  // Field CTCIF3: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF3 = 1U << 9 ;

  // Field CHTIF3: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF3 = 1U << 10 ;

  // Field CTEIF3: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF3 = 1U << 11 ;

  // Field CGIF4: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF4 = 1U << 12 ;

  // Field CTCIF4: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF4 = 1U << 13 ;

  // Field CHTIF4: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF4 = 1U << 14 ;

  // Field CTEIF4: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF4 = 1U << 15 ;

  // Field CGIF5: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF5 = 1U << 16 ;

  // Field CTCIF5: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF5 = 1U << 17 ;

  // Field CHTIF5: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF5 = 1U << 18 ;

  // Field CTEIF5: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF5 = 1U << 19 ;

  // Field CGIF6: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF6 = 1U << 20 ;

  // Field CTCIF6: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF6 = 1U << 21 ;

  // Field CHTIF6: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF6 = 1U << 22 ;

  // Field CTEIF6: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF6 = 1U << 23 ;

  // Field CGIF7: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF7 = 1U << 24 ;

  // Field CTCIF7: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF7 = 1U << 25 ;

  // Field CHTIF7: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF7 = 1U << 26 ;

  // Field CTEIF7: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF7 = 1U << 27 ;

  // Field CGIF8: Channel x global interrupt clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CGIF8 = 1U << 28 ;

  // Field CTCIF8: Channel x transfer complete clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTCIF8 = 1U << 29 ;

  // Field CHTIF8: Channel x half transfer clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CHTIF8 = 1U << 30 ;

  // Field CTEIF8: Channel x transfer error clear This bit is set and cleared by software.
    const uint32_t BDMA_IFCR_CTEIF8 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CCR1: DMA channel x configuration register
  #define BDMA_CCR1 (* ((volatile uint32_t *) (0x58025400 + 8)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR1_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR1_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR1_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR1_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR1: DMA channel x number of data register
  #define BDMA_CNDTR1 (* ((volatile uint32_t *) (0x58025400 + 12)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR1_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR1: This register must not be written when the channel is enabled.
  #define BDMA_CPAR1 (* ((volatile uint32_t *) (0x58025400 + 16)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR1_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR1: This register must not be written when the channel is enabled.
  #define BDMA_CMAR1 (* ((volatile uint32_t *) (0x58025400 + 20)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR1_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: DMA channel x configuration register
  #define BDMA_CCR2 (* ((volatile uint32_t *) (0x58025400 + 28)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR2_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR2_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR2_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR2_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR2: DMA channel x number of data register
  #define BDMA_CNDTR2 (* ((volatile uint32_t *) (0x58025400 + 32)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR2_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR2: This register must not be written when the channel is enabled.
  #define BDMA_CPAR2 (* ((volatile uint32_t *) (0x58025400 + 36)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR2_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR2: This register must not be written when the channel is enabled.
  #define BDMA_CMAR2 (* ((volatile uint32_t *) (0x58025400 + 40)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR2_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: DMA channel x configuration register
  #define BDMA_CCR3 (* ((volatile uint32_t *) (0x58025400 + 48)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR3_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR3_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR3_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR3_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR3: DMA channel x number of data register
  #define BDMA_CNDTR3 (* ((volatile uint32_t *) (0x58025400 + 52)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR3_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR3: This register must not be written when the channel is enabled.
  #define BDMA_CPAR3 (* ((volatile uint32_t *) (0x58025400 + 56)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR3_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR3: This register must not be written when the channel is enabled.
  #define BDMA_CMAR3 (* ((volatile uint32_t *) (0x58025400 + 60)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR3_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: DMA channel x configuration register
  #define BDMA_CCR4 (* ((volatile uint32_t *) (0x58025400 + 68)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR4_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR4_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR4_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR4_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR4: DMA channel x number of data register
  #define BDMA_CNDTR4 (* ((volatile uint32_t *) (0x58025400 + 72)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR4_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR4: This register must not be written when the channel is enabled.
  #define BDMA_CPAR4 (* ((volatile uint32_t *) (0x58025400 + 76)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR4_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR4: This register must not be written when the channel is enabled.
  #define BDMA_CMAR4 (* ((volatile uint32_t *) (0x58025400 + 80)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR4_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR5: DMA channel x configuration register
  #define BDMA_CCR5 (* ((volatile uint32_t *) (0x58025400 + 88)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR5_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR5_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR5_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR5_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR5: DMA channel x number of data register
  #define BDMA_CNDTR5 (* ((volatile uint32_t *) (0x58025400 + 92)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR5_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR5: This register must not be written when the channel is enabled.
  #define BDMA_CPAR5 (* ((volatile uint32_t *) (0x58025400 + 96)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR5_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR5: This register must not be written when the channel is enabled.
  #define BDMA_CMAR5 (* ((volatile uint32_t *) (0x58025400 + 100)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR5_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR6: DMA channel x configuration register
  #define BDMA_CCR6 (* ((volatile uint32_t *) (0x58025400 + 108)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR6_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR6_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR6_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR6_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR6: DMA channel x number of data register
  #define BDMA_CNDTR6 (* ((volatile uint32_t *) (0x58025400 + 112)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR6_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR6: This register must not be written when the channel is enabled.
  #define BDMA_CPAR6 (* ((volatile uint32_t *) (0x58025400 + 116)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR6_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR6: This register must not be written when the channel is enabled.
  #define BDMA_CMAR6 (* ((volatile uint32_t *) (0x58025400 + 120)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR6_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR7: DMA channel x configuration register
  #define BDMA_CCR7 (* ((volatile uint32_t *) (0x58025400 + 128)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR7_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR7_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR7_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR7_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR7: DMA channel x number of data register
  #define BDMA_CNDTR7 (* ((volatile uint32_t *) (0x58025400 + 132)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR7_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR7: This register must not be written when the channel is enabled.
  #define BDMA_CPAR7 (* ((volatile uint32_t *) (0x58025400 + 136)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR7_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR7: This register must not be written when the channel is enabled.
  #define BDMA_CMAR7 (* ((volatile uint32_t *) (0x58025400 + 140)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR7_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR8: DMA channel x configuration register
  #define BDMA_CCR8 (* ((volatile uint32_t *) (0x58025400 + 148)))

  // Field EN: Channel enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_EN = 1U << 0 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_TCIE = 1U << 1 ;

  // Field HTIE: Half transfer interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_HTIE = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_TEIE = 1U << 3 ;

  // Field DIR: Data transfer direction This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_DIR = 1U << 4 ;

  // Field CIRC: Circular mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_CIRC = 1U << 5 ;

  // Field PINC: Peripheral increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_PINC = 1U << 6 ;

  // Field MINC: Memory increment mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_MINC = 1U << 7 ;

  // Field PSIZE: Peripheral size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR8_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MSIZE: Memory size These bits are set and cleared by software.
    inline uint32_t BDMA_CCR8_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PL: Channel priority level These bits are set and cleared by software.
    inline uint32_t BDMA_CCR8_PL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MEM2MEM: Memory to memory mode This bit is set and cleared by software.
    const uint32_t BDMA_CCR8_MEM2MEM = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register CNDTR8: DMA channel x number of data register
  #define BDMA_CNDTR8 (* ((volatile uint32_t *) (0x58025400 + 152)))

  // Field NDT: Number of data to transfer Number of data to be transferred (0 up to 65535). This register can only be written when the channel is disabled. Once the channel is enabled, this register is read-only, indicating the remaining bytes to be transmitted. This register decrements after each DMA transfer. Once the transfer is completed, this register can either stay at zero or be reloaded automatically by the value previously programmed if the channel is configured in auto-reload mode. If this register is zero, no transaction can be served whether the channel is enabled or not.
    inline uint32_t BDMA_CNDTR8_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPAR8: This register must not be written when the channel is enabled.
  #define BDMA_CPAR8 (* ((volatile uint32_t *) (0x58025400 + 156)))

  // Field PA: Peripheral address Base address of the peripheral data register from/to which the data will be read/written. When PSIZE is 01 (16-bit), the PA[0] bit is ignored. Access is automatically aligned to a half-word address. When PSIZE is 10 (32-bit), PA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CPAR8_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMAR8: This register must not be written when the channel is enabled.
  #define BDMA_CMAR8 (* ((volatile uint32_t *) (0x58025400 + 160)))

  // Field MA: Memory address Base address of the memory area from/to which the data will be read/written. When MSIZE is 01 (16-bit), the MA[0] bit is ignored. Access is automatically aligned to a half-word address. When MSIZE is 10 (32-bit), MA[1:0] are ignored. Access is automatically aligned to a word address.
    inline uint32_t BDMA_CMAR8_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral CAN_CCU: CCU registers
//------------------------------------------------------------------------------

//---  Register CREL: Clock Calibration Unit Core Release Register
  #define CAN_CCU_CREL (* ((volatile uint32_t *) (0x4000A800 + 0)))

  // Field DAY: Time Stamp Day
    inline uint32_t CAN_CCU_CREL_DAY (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MON: Time Stamp Month
    inline uint32_t CAN_CCU_CREL_MON (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field YEAR: Time Stamp Year
    inline uint32_t CAN_CCU_CREL_YEAR (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field SUBSTEP: Sub-step of Core Release
    inline uint32_t CAN_CCU_CREL_SUBSTEP (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field STEP: Step of Core Release
    inline uint32_t CAN_CCU_CREL_STEP (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field REL: Core Release
    inline uint32_t CAN_CCU_CREL_REL (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register CCFG: Calibration Configuration Register
  #define CAN_CCU_CCFG (* ((volatile uint32_t *) (0x4000A800 + 4)))

  // Field TQBT: Time Quanta per Bit Time
    inline uint32_t CAN_CCU_CCFG_TQBT (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field BCC: Bypass Clock Calibration
    const uint32_t CAN_CCU_CCFG_BCC = 1U << 6 ;

  // Field CFL: Calibration Field Length
    const uint32_t CAN_CCU_CCFG_CFL = 1U << 7 ;

  // Field OCPM: Oscillator Clock Periods Minimum
    inline uint32_t CAN_CCU_CCFG_OCPM (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field CDIV: Clock Divider
    inline uint32_t CAN_CCU_CCFG_CDIV (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field SWR: Software Reset
    const uint32_t CAN_CCU_CCFG_SWR = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CSTAT: Calibration Status Register
  #define CAN_CCU_CSTAT (* ((volatile uint32_t *) (0x4000A800 + 8)))

  // Field OCPC: Oscillator Clock Period Counter
    inline uint32_t CAN_CCU_CSTAT_OCPC (const uint32_t inValue) {return (inValue & 0x3FFFFU) << 0 ; }

  // Field TQC: Time Quanta Counter
    inline uint32_t CAN_CCU_CSTAT_TQC (const uint32_t inValue) {return (inValue & 0x7FFU) << 18 ; }

  // Field CALS: Calibration State
    inline uint32_t CAN_CCU_CSTAT_CALS (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register CWD: Calibration Watchdog Register
  #define CAN_CCU_CWD (* ((volatile uint32_t *) (0x4000A800 + 12)))

  // Field WDC: WDC
    inline uint32_t CAN_CCU_CWD_WDC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field WDV: WDV
    inline uint32_t CAN_CCU_CWD_WDV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IR: Clock Calibration Unit Interrupt Register
  #define CAN_CCU_IR (* ((volatile uint32_t *) (0x4000A800 + 16)))

  // Field CWE: Calibration Watchdog Event
    const uint32_t CAN_CCU_IR_CWE = 1U << 0 ;

  // Field CSC: Calibration State Changed
    const uint32_t CAN_CCU_IR_CSC = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register IE: Clock Calibration Unit Interrupt Enable Register
  #define CAN_CCU_IE (* ((volatile uint32_t *) (0x4000A800 + 20)))

  // Field CWEE: Calibration Watchdog Event Enable
    const uint32_t CAN_CCU_IE_CWEE = 1U << 0 ;

  // Field CSCE: Calibration State Changed Enable
    const uint32_t CAN_CCU_IE_CSCE = 1U << 1 ;

//------------------------------------------------------------------------------
// Peripheral CEC: CEC
//------------------------------------------------------------------------------

//---  Register CR: CEC control register
  #define CEC_CR (* ((volatile uint32_t *) (0x40006C00 + 0)))

  // Field CECEN: CEC Enable The CECEN bit is set and cleared by software. CECEN=1 starts message reception and enables the TXSOM control. CECEN=0 disables the CEC peripheral, clears all bits of CEC_CR register and aborts any on-going reception or transmission.
    const uint32_t CEC_CR_CECEN = 1U << 0 ;

  // Field TXSOM: Tx Start Of Message TXSOM is set by software to command transmission of the first byte of a CEC message. If the CEC message consists of only one byte, TXEOM must be set before of TXSOM. Start-Bit is effectively started on the CEC line after SFT is counted. If TXSOM is set while a message reception is ongoing, transmission will start after the end of reception. TXSOM is cleared by hardware after the last byte of the message is sent with a positive acknowledge (TXEND=1), in case of transmission underrun (TXUDR=1), negative acknowledge (TXACKE=1), and transmission error (TXERR=1). It is also cleared by CECEN=0. It is not cleared and transmission is automatically retried in case of arbitration lost (ARBLST=1). TXSOM can be also used as a status bit informing application whether any transmission request is pending or under execution. The application can abort a transmission request at any time by clearing the CECEN bit. Note: TXSOM must be set when CECEN=1 TXSOM must be set when transmission data is available into TXDR HEADERs first four bits containing own peripheral address are taken from TXDR[7:4], not from CEC_CFGR.OAR which is used only for reception
    const uint32_t CEC_CR_TXSOM = 1U << 1 ;

  // Field TXEOM: Tx End Of Message The TXEOM bit is set by software to command transmission of the last byte of a CEC message. TXEOM is cleared by hardware at the same time and under the same conditions as for TXSOM. Note: TXEOM must be set when CECEN=1 TXEOM must be set before writing transmission data to TXDR If TXEOM is set when TXSOM=0, transmitted message will consist of 1 byte (HEADER) only (PING message)
    const uint32_t CEC_CR_TXEOM = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register CFGR: This register is used to configure the HDMI-CEC controller. It is mandatory to write CEC_CFGR only when CECEN=0.
  #define CEC_CFGR (* ((volatile uint32_t *) (0x40006C00 + 4)))

  // Field SFT: Signal Free Time SFT bits are set by software. In the SFT=0x0 configuration the number of nominal data bit periods waited before transmission is ruled by hardware according to the transmission history. In all the other configurations the SFT number is determined by software. * 0x0 ** 2.5 Data-Bit periods if CEC is the last bus initiator with unsuccessful transmission (ARBLST=1, TXERR=1, TXUDR=1 or TXACKE= 1) ** 4 Data-Bit periods if CEC is the new bus initiator ** 6 Data-Bit periods if CEC is the last bus initiator with successful transmission (TXEOM=1) * 0x1: 0.5 nominal data bit periods * 0x2: 1.5 nominal data bit periods * 0x3: 2.5 nominal data bit periods * 0x4: 3.5 nominal data bit periods * 0x5: 4.5 nominal data bit periods * 0x6: 5.5 nominal data bit periods * 0x7: 6.5 nominal data bit periods
    inline uint32_t CEC_CFGR_SFT (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RXTOL: Rx-Tolerance The RXTOL bit is set and cleared by software. ** Start-Bit, +/- 200 s rise, +/- 200 s fall. ** Data-Bit: +/- 200 s rise. +/- 350 s fall. ** Start-Bit: +/- 400 s rise, +/- 400 s fall ** Data-Bit: +/-300 s rise, +/- 500 s fall
    const uint32_t CEC_CFGR_RXTOL = 1U << 3 ;

  // Field BRESTP: Rx-Stop on Bit Rising Error The BRESTP bit is set and cleared by software.
    const uint32_t CEC_CFGR_BRESTP = 1U << 4 ;

  // Field BREGEN: Generate Error-Bit on Bit Rising Error The BREGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon BRE detection with BRESTP=1 in broadcast even if BREGEN=0
    const uint32_t CEC_CFGR_BREGEN = 1U << 5 ;

  // Field LBPEGEN: Generate Error-Bit on Long Bit Period Error The LBPEGEN bit is set and cleared by software. Note: If BRDNOGEN=0, an Error-bit is generated upon LBPE detection in broadcast even if LBPEGEN=0
    const uint32_t CEC_CFGR_LBPEGEN = 1U << 6 ;

  // Field BRDNOGEN: Avoid Error-Bit Generation in Broadcast The BRDNOGEN bit is set and cleared by software.
    const uint32_t CEC_CFGR_BRDNOGEN = 1U << 7 ;

  // Field SFTOPT: SFT Option Bit The SFTOPT bit is set and cleared by software.
    const uint32_t CEC_CFGR_SFTOPT = 1U << 8 ;

  // Field OAR: Own addresses configuration The OAR bits are set by software to select which destination logical addresses has to be considered in receive mode. Each bit, when set, enables the CEC logical address identified by the given bit position. At the end of HEADER reception, the received destination address is compared with the enabled addresses. In case of matching address, the incoming message is acknowledged and received. In case of non-matching address, the incoming message is received only in listen mode (LSTN=1), but without acknowledge sent. Broadcast messages are always received. Example: OAR = 0b000 0000 0010 0001 means that CEC acknowledges addresses 0x0 and 0x5. Consequently, each message directed to one of these addresses is received.
    inline uint32_t CEC_CFGR_OAR (const uint32_t inValue) {return (inValue & 0x7FFFU) << 16 ; }

  // Field LSTN: Listen mode LSTN bit is set and cleared by software.
    const uint32_t CEC_CFGR_LSTN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register TXDR: CEC Tx data register
  #define CEC_TXDR (* ((volatile uint32_t *) (0x40006C00 + 8)))

  // Field TXD: Tx Data register. TXD is a write-only register containing the data byte to be transmitted. Note: TXD must be written when TXSTART=1
    inline uint32_t CEC_TXDR_TXD (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: CEC Rx Data Register
  #define CEC_RXDR (* ((const volatile uint32_t *) (0x40006C00 + 12)))

  // Field RXD: Rx Data register. RXD is read-only and contains the last data byte which has been received from the CEC line.
    inline uint32_t CEC_RXDR_RXD (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISR: CEC Interrupt and Status Register
  #define CEC_ISR (* ((volatile uint32_t *) (0x40006C00 + 16)))

  // Field RXBR: Rx-Byte Received The RXBR bit is set by hardware to inform application that a new byte has been received from the CEC line and stored into the RXD buffer. RXBR is cleared by software write at 1.
    const uint32_t CEC_ISR_RXBR = 1U << 0 ;

  // Field RXEND: End Of Reception RXEND is set by hardware to inform application that the last byte of a CEC message is received from the CEC line and stored into the RXD buffer. RXEND is set at the same time of RXBR. RXEND is cleared by software write at 1.
    const uint32_t CEC_ISR_RXEND = 1U << 1 ;

  // Field RXOVR: Rx-Overrun RXOVR is set by hardware if RXBR is not yet cleared at the time a new byte is received on the CEC line and stored into RXD. RXOVR assertion stops message reception so that no acknowledge is sent. In case of broadcast, a negative acknowledge is sent. RXOVR is cleared by software write at 1.
    const uint32_t CEC_ISR_RXOVR = 1U << 2 ;

  // Field BRE: Rx-Bit Rising Error BRE is set by hardware in case a Data-Bit waveform is detected with Bit Rising Error. BRE is set either at the time the misplaced rising edge occurs, or at the end of the maximum BRE tolerance allowed by RXTOL, in case rising edge is still longing. BRE stops message reception if BRESTP=1. BRE generates an Error-Bit on the CEC line if BREGEN=1. BRE is cleared by software write at 1.
    const uint32_t CEC_ISR_BRE = 1U << 3 ;

  // Field SBPE: Rx-Short Bit Period Error SBPE is set by hardware in case a Data-Bit waveform is detected with Short Bit Period Error. SBPE is set at the time the anticipated falling edge occurs. SBPE generates an Error-Bit on the CEC line. SBPE is cleared by software write at 1.
    const uint32_t CEC_ISR_SBPE = 1U << 4 ;

  // Field LBPE: Rx-Long Bit Period Error LBPE is set by hardware in case a Data-Bit waveform is detected with Long Bit Period Error. LBPE is set at the end of the maximum bit-extension tolerance allowed by RXTOL, in case falling edge is still longing. LBPE always stops reception of the CEC message. LBPE generates an Error-Bit on the CEC line if LBPEGEN=1. In case of broadcast, Error-Bit is generated even in case of LBPEGEN=0. LBPE is cleared by software write at 1.
    const uint32_t CEC_ISR_LBPE = 1U << 5 ;

  // Field RXACKE: Rx-Missing Acknowledge In receive mode, RXACKE is set by hardware to inform application that no acknowledge was seen on the CEC line. RXACKE applies only for broadcast messages and in listen mode also for not directly addressed messages (destination address not enabled in OAR). RXACKE aborts message reception. RXACKE is cleared by software write at 1.
    const uint32_t CEC_ISR_RXACKE = 1U << 6 ;

  // Field ARBLST: Arbitration Lost ARBLST is set by hardware to inform application that CEC device is switching to reception due to arbitration lost event following the TXSOM command. ARBLST can be due either to a contending CEC device starting earlier or starting at the same time but with higher HEADER priority. After ARBLST assertion TXSOM bit keeps pending for next transmission attempt. ARBLST is cleared by software write at 1.
    const uint32_t CEC_ISR_ARBLST = 1U << 7 ;

  // Field TXBR: Tx-Byte Request TXBR is set by hardware to inform application that the next transmission data has to be written to TXDR. TXBR is set when the 4th bit of currently transmitted byte is sent. Application must write the next byte to TXDR within 6 nominal data-bit periods before transmission underrun error occurs (TXUDR). TXBR is cleared by software write at 1.
    const uint32_t CEC_ISR_TXBR = 1U << 8 ;

  // Field TXEND: End of Transmission TXEND is set by hardware to inform application that the last byte of the CEC message has been successfully transmitted. TXEND clears the TXSOM and TXEOM control bits. TXEND is cleared by software write at 1.
    const uint32_t CEC_ISR_TXEND = 1U << 9 ;

  // Field TXUDR: Tx-Buffer Underrun In transmission mode, TXUDR is set by hardware if application was not in time to load TXDR before of next byte transmission. TXUDR aborts message transmission and clears TXSOM and TXEOM control bits. TXUDR is cleared by software write at 1
    const uint32_t CEC_ISR_TXUDR = 1U << 10 ;

  // Field TXERR: Tx-Error In transmission mode, TXERR is set by hardware if the CEC initiator detects low impedance on the CEC line while it is released. TXERR aborts message transmission and clears TXSOM and TXEOM controls. TXERR is cleared by software write at 1.
    const uint32_t CEC_ISR_TXERR = 1U << 11 ;

  // Field TXACKE: Tx-Missing Acknowledge Error In transmission mode, TXACKE is set by hardware to inform application that no acknowledge was received. In case of broadcast transmission, TXACKE informs application that a negative acknowledge was received. TXACKE aborts message transmission and clears TXSOM and TXEOM controls. TXACKE is cleared by software write at 1.
    const uint32_t CEC_ISR_TXACKE = 1U << 12 ;

//------------------------------------------------------------------------------

//---  Register IER: CEC interrupt enable register
  #define CEC_IER (* ((volatile uint32_t *) (0x40006C00 + 20)))

  // Field RXBRIE: Rx-Byte Received Interrupt Enable The RXBRIE bit is set and cleared by software.
    const uint32_t CEC_IER_RXBRIE = 1U << 0 ;

  // Field RXENDIE: End Of Reception Interrupt Enable The RXENDIE bit is set and cleared by software.
    const uint32_t CEC_IER_RXENDIE = 1U << 1 ;

  // Field RXOVRIE: Rx-Buffer Overrun Interrupt Enable The RXOVRIE bit is set and cleared by software.
    const uint32_t CEC_IER_RXOVRIE = 1U << 2 ;

  // Field BREIE: Bit Rising Error Interrupt Enable The BREIE bit is set and cleared by software.
    const uint32_t CEC_IER_BREIE = 1U << 3 ;

  // Field SBPEIE: Short Bit Period Error Interrupt Enable The SBPEIE bit is set and cleared by software.
    const uint32_t CEC_IER_SBPEIE = 1U << 4 ;

  // Field LBPEIE: Long Bit Period Error Interrupt Enable The LBPEIE bit is set and cleared by software.
    const uint32_t CEC_IER_LBPEIE = 1U << 5 ;

  // Field RXACKIE: Rx-Missing Acknowledge Error Interrupt Enable The RXACKIE bit is set and cleared by software.
    const uint32_t CEC_IER_RXACKIE = 1U << 6 ;

  // Field ARBLSTIE: Arbitration Lost Interrupt Enable The ARBLSTIE bit is set and cleared by software.
    const uint32_t CEC_IER_ARBLSTIE = 1U << 7 ;

  // Field TXBRIE: Tx-Byte Request Interrupt Enable The TXBRIE bit is set and cleared by software.
    const uint32_t CEC_IER_TXBRIE = 1U << 8 ;

  // Field TXENDIE: Tx-End Of Message Interrupt Enable The TXENDIE bit is set and cleared by software.
    const uint32_t CEC_IER_TXENDIE = 1U << 9 ;

  // Field TXUDRIE: Tx-Underrun Interrupt Enable The TXUDRIE bit is set and cleared by software.
    const uint32_t CEC_IER_TXUDRIE = 1U << 10 ;

  // Field TXERRIE: Tx-Error Interrupt Enable The TXERRIE bit is set and cleared by software.
    const uint32_t CEC_IER_TXERRIE = 1U << 11 ;

  // Field TXACKIE: Tx-Missing Acknowledge Error Interrupt Enable The TXACKEIE bit is set and cleared by software.
    const uint32_t CEC_IER_TXACKIE = 1U << 12 ;

//------------------------------------------------------------------------------
// Peripheral COMP1: COMP1
//------------------------------------------------------------------------------

//---  Register SR: Comparator status register
  #define COMP1_SR (* ((const volatile uint32_t *) (0x58003800 + 0)))

  // Field C1VAL: COMP channel 1 output status bit
    const uint32_t COMP1_SR_C1VAL = 1U << 0 ;

  // Field C2VAL: COMP channel 2 output status bit
    const uint32_t COMP1_SR_C2VAL = 1U << 1 ;

  // Field C1IF: COMP channel 1 Interrupt Flag
    const uint32_t COMP1_SR_C1IF = 1U << 16 ;

  // Field C2IF: COMP channel 2 Interrupt Flag
    const uint32_t COMP1_SR_C2IF = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register ICFR: Comparator interrupt clear flag register
  #define COMP1_ICFR (* ((volatile uint32_t *) (0x58003800 + 4)))

  // Field CC1IF: Clear COMP channel 1 Interrupt Flag
    const uint32_t COMP1_ICFR_CC1IF = 1U << 16 ;

  // Field CC2IF: Clear COMP channel 2 Interrupt Flag
    const uint32_t COMP1_ICFR_CC2IF = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register OR: Comparator option register
  #define COMP1_OR (* ((volatile uint32_t *) (0x58003800 + 8)))

  // Field AFOP: Selection of source for alternate function of output ports
    inline uint32_t COMP1_OR_AFOP (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field OR: Option Register
    inline uint32_t COMP1_OR_OR (const uint32_t inValue) {return (inValue & 0x1FFFFFU) << 11 ; }

//------------------------------------------------------------------------------

//---  Register CFGR1: Comparator configuration register 1
  #define COMP1_CFGR1 (* ((volatile uint32_t *) (0x58003800 + 12)))

  // Field EN: COMP channel 1 enable bit
    const uint32_t COMP1_CFGR1_EN = 1U << 0 ;

  // Field BRGEN: Scaler bridge enable
    const uint32_t COMP1_CFGR1_BRGEN = 1U << 1 ;

  // Field SCALEN: Voltage scaler enable bit
    const uint32_t COMP1_CFGR1_SCALEN = 1U << 2 ;

  // Field POLARITY: COMP channel 1 polarity selection bit
    const uint32_t COMP1_CFGR1_POLARITY = 1U << 3 ;

  // Field ITEN: COMP channel 1 interrupt enable
    const uint32_t COMP1_CFGR1_ITEN = 1U << 6 ;

  // Field HYST: COMP channel 1 hysteresis selection bits
    inline uint32_t COMP1_CFGR1_HYST (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PWRMODE: Power Mode of the COMP channel 1
    inline uint32_t COMP1_CFGR1_PWRMODE (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INMSEL: COMP channel 1 inverting input selection field
    inline uint32_t COMP1_CFGR1_INMSEL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field INPSEL: COMP channel 1 non-inverting input selection bit
    const uint32_t COMP1_CFGR1_INPSEL = 1U << 20 ;

  // Field BLANKING: COMP channel 1 blanking source selection bits
    inline uint32_t COMP1_CFGR1_BLANKING (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field LOCK: Lock bit
    const uint32_t COMP1_CFGR1_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CFGR2: Comparator configuration register 2
  #define COMP1_CFGR2 (* ((volatile uint32_t *) (0x58003800 + 16)))

  // Field EN: COMP channel 1 enable bit
    const uint32_t COMP1_CFGR2_EN = 1U << 0 ;

  // Field BRGEN: Scaler bridge enable
    const uint32_t COMP1_CFGR2_BRGEN = 1U << 1 ;

  // Field SCALEN: Voltage scaler enable bit
    const uint32_t COMP1_CFGR2_SCALEN = 1U << 2 ;

  // Field POLARITY: COMP channel 1 polarity selection bit
    const uint32_t COMP1_CFGR2_POLARITY = 1U << 3 ;

  // Field WINMODE: Window comparator mode selection bit
    const uint32_t COMP1_CFGR2_WINMODE = 1U << 4 ;

  // Field ITEN: COMP channel 1 interrupt enable
    const uint32_t COMP1_CFGR2_ITEN = 1U << 6 ;

  // Field HYST: COMP channel 1 hysteresis selection bits
    inline uint32_t COMP1_CFGR2_HYST (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PWRMODE: Power Mode of the COMP channel 1
    inline uint32_t COMP1_CFGR2_PWRMODE (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field INMSEL: COMP channel 1 inverting input selection field
    inline uint32_t COMP1_CFGR2_INMSEL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field INPSEL: COMP channel 1 non-inverting input selection bit
    const uint32_t COMP1_CFGR2_INPSEL = 1U << 20 ;

  // Field BLANKING: COMP channel 1 blanking source selection bits
    inline uint32_t COMP1_CFGR2_BLANKING (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field LOCK: Lock bit
    const uint32_t COMP1_CFGR2_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral CRC: Cryptographic processor
//------------------------------------------------------------------------------

//---  Register DR: Data register
  #define CRC_DR (* ((volatile uint32_t *) (0x58024C00 + 0)))

  // Field DR: Data Register
    inline uint32_t CRC_DR_DR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IDR: Independent Data register
  #define CRC_IDR (* ((volatile uint32_t *) (0x58024C00 + 4)))

  // Field IDR: Independent Data register
    inline uint32_t CRC_IDR_IDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CR: Control register
  #define CRC_CR (* ((volatile uint32_t *) (0x58024C00 + 8)))

  // Field RESET: RESET bit
    const uint32_t CRC_CR_RESET = 1U << 0 ;

  // Field POLYSIZE: Polynomial size
    inline uint32_t CRC_CR_POLYSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field REV_IN: Reverse input data
    inline uint32_t CRC_CR_REV_IN (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field REV_OUT: Reverse output data
    const uint32_t CRC_CR_REV_OUT = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register INIT: Initial CRC value
  #define CRC_INIT (* ((volatile uint32_t *) (0x58024C00 + 12)))

  // Field CRC_INIT: Programmable initial CRC value
    inline uint32_t CRC_INIT_CRC_INIT (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register POL: CRC polynomial
  #define CRC_POL (* ((volatile uint32_t *) (0x58024C00 + 16)))

  // Field POL: Programmable polynomial
    inline uint32_t CRC_POL_POL (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral CRS: CRS
//------------------------------------------------------------------------------

//---  Register CR: CRS control register
  #define CRS_CR (* ((volatile uint32_t *) (0x40008400 + 0)))

  // Field SYNCOKIE: SYNC event OK interrupt enable
    const uint32_t CRS_CR_SYNCOKIE = 1U << 0 ;

  // Field SYNCWARNIE: SYNC warning interrupt enable
    const uint32_t CRS_CR_SYNCWARNIE = 1U << 1 ;

  // Field ERRIE: Synchronization or trimming error interrupt enable
    const uint32_t CRS_CR_ERRIE = 1U << 2 ;

  // Field ESYNCIE: Expected SYNC interrupt enable
    const uint32_t CRS_CR_ESYNCIE = 1U << 3 ;

  // Field CEN: Frequency error counter enable This bit enables the oscillator clock for the frequency error counter. When this bit is set, the CRS_CFGR register is write-protected and cannot be modified.
    const uint32_t CRS_CR_CEN = 1U << 5 ;

  // Field AUTOTRIMEN: Automatic trimming enable This bit enables the automatic hardware adjustment of TRIM bits according to the measured frequency error between two SYNC events. If this bit is set, the TRIM bits are read-only. The TRIM value can be adjusted by hardware by one or two steps at a time, depending on the measured frequency error value. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details.
    const uint32_t CRS_CR_AUTOTRIMEN = 1U << 6 ;

  // Field SWSYNC: Generate software SYNC event This bit is set by software in order to generate a software SYNC event. It is automatically cleared by hardware.
    const uint32_t CRS_CR_SWSYNC = 1U << 7 ;

  // Field TRIM: HSI48 oscillator smooth trimming These bits provide a user-programmable trimming value to the HSI48 oscillator. They can be programmed to adjust to variations in voltage and temperature that influence the frequency of the HSI48. The default value is 32, which corresponds to the middle of the trimming interval. The trimming step is around 67 kHz between two consecutive TRIM steps. A higher TRIM value corresponds to a higher output frequency. When the AUTOTRIMEN bit is set, this field is controlled by hardware and is read-only.
    inline uint32_t CRS_CR_TRIM (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register CFGR: This register can be written only when the frequency error counter is disabled (CEN bit is cleared in CRS_CR). When the counter is enabled, this register is write-protected.
  #define CRS_CFGR (* ((volatile uint32_t *) (0x40008400 + 4)))

  // Field RELOAD: Counter reload value RELOAD is the value to be loaded in the frequency error counter with each SYNC event. Refer to Section7.3.3: Frequency error measurement for more details about counter behavior.
    inline uint32_t CRS_CFGR_RELOAD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field FELIM: Frequency error limit FELIM contains the value to be used to evaluate the captured frequency error value latched in the FECAP[15:0] bits of the CRS_ISR register. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP evaluation.
    inline uint32_t CRS_CFGR_FELIM (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field SYNCDIV: SYNC divider These bits are set and cleared by software to control the division factor of the SYNC signal.
    inline uint32_t CRS_CFGR_SYNCDIV (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SYNCSRC: SYNC signal source selection These bits are set and cleared by software to select the SYNC signal source. Note: When using USB LPM (Link Power Management) and the device is in Sleep mode, the periodic USB SOF will not be generated by the host. No SYNC signal will therefore be provided to the CRS to calibrate the HSI48 on the run. To guarantee the required clock precision after waking up from Sleep mode, the LSE or reference clock on the GPIOs should be used as SYNC signal.
    inline uint32_t CRS_CFGR_SYNCSRC (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SYNCPOL: SYNC polarity selection This bit is set and cleared by software to select the input polarity for the SYNC signal source.
    const uint32_t CRS_CFGR_SYNCPOL = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register ISR: CRS interrupt and status register
  #define CRS_ISR (* ((const volatile uint32_t *) (0x40008400 + 8)))

  // Field SYNCOKF: SYNC event OK flag This flag is set by hardware when the measured frequency error is smaller than FELIM * 3. This means that either no adjustment of the TRIM value is needed or that an adjustment by one trimming step is enough to compensate the frequency error. An interrupt is generated if the SYNCOKIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCOKC bit in the CRS_ICR register.
    const uint32_t CRS_ISR_SYNCOKF = 1U << 0 ;

  // Field SYNCWARNF: SYNC warning flag This flag is set by hardware when the measured frequency error is greater than or equal to FELIM * 3, but smaller than FELIM * 128. This means that to compensate the frequency error, the TRIM value must be adjusted by two steps or more. An interrupt is generated if the SYNCWARNIE bit is set in the CRS_CR register. It is cleared by software by setting the SYNCWARNC bit in the CRS_ICR register.
    const uint32_t CRS_ISR_SYNCWARNF = 1U << 1 ;

  // Field ERRF: Error flag This flag is set by hardware in case of any synchronization or trimming error. It is the logical OR of the TRIMOVF, SYNCMISS and SYNCERR bits. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software in reaction to setting the ERRC bit in the CRS_ICR register, which clears the TRIMOVF, SYNCMISS and SYNCERR bits.
    const uint32_t CRS_ISR_ERRF = 1U << 2 ;

  // Field ESYNCF: Expected SYNC flag This flag is set by hardware when the frequency error counter reached a zero value. An interrupt is generated if the ESYNCIE bit is set in the CRS_CR register. It is cleared by software by setting the ESYNCC bit in the CRS_ICR register.
    const uint32_t CRS_ISR_ESYNCF = 1U << 3 ;

  // Field SYNCERR: SYNC error This flag is set by hardware when the SYNC pulse arrives before the ESYNC event and the measured frequency error is greater than or equal to FELIM * 128. This means that the frequency error is too big (internal frequency too low) to be compensated by adjusting the TRIM value, and that some other action should be taken. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
    const uint32_t CRS_ISR_SYNCERR = 1U << 8 ;

  // Field SYNCMISS: SYNC missed This flag is set by hardware when the frequency error counter reached value FELIM * 128 and no SYNC was detected, meaning either that a SYNC pulse was missed or that the frequency error is too big (internal frequency too high) to be compensated by adjusting the TRIM value, and that some other action should be taken. At this point, the frequency error counter is stopped (waiting for a next SYNC) and an interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
    const uint32_t CRS_ISR_SYNCMISS = 1U << 9 ;

  // Field TRIMOVF: Trimming overflow or underflow This flag is set by hardware when the automatic trimming tries to over- or under-flow the TRIM value. An interrupt is generated if the ERRIE bit is set in the CRS_CR register. It is cleared by software by setting the ERRC bit in the CRS_ICR register.
    const uint32_t CRS_ISR_TRIMOVF = 1U << 10 ;

  // Field FEDIR: Frequency error direction FEDIR is the counting direction of the frequency error counter latched in the time of the last SYNC event. It shows whether the actual frequency is below or above the target.
    const uint32_t CRS_ISR_FEDIR = 1U << 15 ;

  // Field FECAP: Frequency error capture FECAP is the frequency error counter value latched in the time of the last SYNC event. Refer to Section7.3.4: Frequency error evaluation and automatic trimming for more details about FECAP usage.
    inline uint32_t CRS_ISR_FECAP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register ICR: CRS interrupt flag clear register
  #define CRS_ICR (* ((volatile uint32_t *) (0x40008400 + 12)))

  // Field SYNCOKC: SYNC event OK clear flag Writing 1 to this bit clears the SYNCOKF flag in the CRS_ISR register.
    const uint32_t CRS_ICR_SYNCOKC = 1U << 0 ;

  // Field SYNCWARNC: SYNC warning clear flag Writing 1 to this bit clears the SYNCWARNF flag in the CRS_ISR register.
    const uint32_t CRS_ICR_SYNCWARNC = 1U << 1 ;

  // Field ERRC: Error clear flag Writing 1 to this bit clears TRIMOVF, SYNCMISS and SYNCERR bits and consequently also the ERRF flag in the CRS_ISR register.
    const uint32_t CRS_ICR_ERRC = 1U << 2 ;

  // Field ESYNCC: Expected SYNC clear flag Writing 1 to this bit clears the ESYNCF flag in the CRS_ISR register.
    const uint32_t CRS_ICR_ESYNCC = 1U << 3 ;

//------------------------------------------------------------------------------
// Peripheral DAC: DAC
//------------------------------------------------------------------------------

//---  Register CR: DAC control register
  #define DAC_CR (* ((volatile uint32_t *) (0x40007400 + 0)))

  // Field EN1: DAC channel1 enable This bit is set and cleared by software to enable/disable DAC channel1.
    const uint32_t DAC_CR_EN1 = 1U << 0 ;

  // Field TEN1: DAC channel1 trigger enable
    const uint32_t DAC_CR_TEN1 = 1U << 1 ;

  // Field TSEL1: DAC channel1 trigger selection These bits select the external event used to trigger DAC channel1. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
    inline uint32_t DAC_CR_TSEL1 (const uint32_t inValue) {return (inValue & 0x7U) << 2 ; }

  // Field WAVE1: DAC channel1 noise/triangle wave generation enable These bits are set and cleared by software. Note: Only used if bit TEN1 = 1 (DAC channel1 trigger enabled).
    inline uint32_t DAC_CR_WAVE1 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MAMP1: DAC channel1 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
    inline uint32_t DAC_CR_MAMP1 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field DMAEN1: DAC channel1 DMA enable This bit is set and cleared by software.
    const uint32_t DAC_CR_DMAEN1 = 1U << 12 ;

  // Field DMAUDRIE1: DAC channel1 DMA Underrun Interrupt enable This bit is set and cleared by software.
    const uint32_t DAC_CR_DMAUDRIE1 = 1U << 13 ;

  // Field CEN1: DAC Channel 1 calibration enable This bit is set and cleared by software to enable/disable DAC channel 1 calibration, it can be written only if bit EN1=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    const uint32_t DAC_CR_CEN1 = 1U << 14 ;

  // Field EN2: DAC channel2 enable This bit is set and cleared by software to enable/disable DAC channel2.
    const uint32_t DAC_CR_EN2 = 1U << 16 ;

  // Field TEN2: DAC channel2 trigger enable
    const uint32_t DAC_CR_TEN2 = 1U << 17 ;

  // Field TSEL2: DAC channel2 trigger selection These bits select the external event used to trigger DAC channel2 Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled).
    inline uint32_t DAC_CR_TSEL2 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field WAVE2: DAC channel2 noise/triangle wave generation enable These bits are set/reset by software. 1x: Triangle wave generation enabled Note: Only used if bit TEN2 = 1 (DAC channel2 trigger enabled)
    inline uint32_t DAC_CR_WAVE2 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MAMP2: DAC channel2 mask/amplitude selector These bits are written by software to select mask in wave generation mode or amplitude in triangle generation mode. = 1011: Unmask bits[11:0] of LFSR/ triangle amplitude equal to 4095
    inline uint32_t DAC_CR_MAMP2 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field DMAEN2: DAC channel2 DMA enable This bit is set and cleared by software.
    const uint32_t DAC_CR_DMAEN2 = 1U << 28 ;

  // Field DMAUDRIE2: DAC channel2 DMA underrun interrupt enable This bit is set and cleared by software.
    const uint32_t DAC_CR_DMAUDRIE2 = 1U << 29 ;

  // Field CEN2: DAC Channel 2 calibration enable This bit is set and cleared by software to enable/disable DAC channel 2 calibration, it can be written only if bit EN2=0 into DAC_CR (the calibration mode can be entered/exit only when the DAC channel is disabled) Otherwise, the write operation is ignored.
    const uint32_t DAC_CR_CEN2 = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register SWTRGR: DAC software trigger register
  #define DAC_SWTRGR (* ((volatile uint32_t *) (0x40007400 + 4)))

  // Field SWTRIG1: DAC channel1 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR1 register value has been loaded into the DAC_DOR1 register.
    const uint32_t DAC_SWTRGR_SWTRIG1 = 1U << 0 ;

  // Field SWTRIG2: DAC channel2 software trigger This bit is set by software to trigger the DAC in software trigger mode. Note: This bit is cleared by hardware (one APB1 clock cycle later) once the DAC_DHR2 register value has been loaded into the DAC_DOR2 register.
    const uint32_t DAC_SWTRGR_SWTRIG2 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register DHR12R1: DAC channel1 12-bit right-aligned data holding register
  #define DAC_DHR12R1 (* ((volatile uint32_t *) (0x40007400 + 8)))

  // Field DACC1DHR: DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    inline uint32_t DAC_DHR12R1_DACC1DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DHR12L1: DAC channel1 12-bit left aligned data holding register
  #define DAC_DHR12L1 (* ((volatile uint32_t *) (0x40007400 + 12)))

  // Field DACC1DHR: DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    inline uint32_t DAC_DHR12L1_DACC1DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DHR8R1: DAC channel1 8-bit right aligned data holding register
  #define DAC_DHR8R1 (* ((volatile uint32_t *) (0x40007400 + 16)))

  // Field DACC1DHR: DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
    inline uint32_t DAC_DHR8R1_DACC1DHR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DHR12R2: DAC channel2 12-bit right aligned data holding register
  #define DAC_DHR12R2 (* ((volatile uint32_t *) (0x40007400 + 20)))

  // Field DACC2DHR: DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    inline uint32_t DAC_DHR12R2_DACC2DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DHR12L2: DAC channel2 12-bit left aligned data holding register
  #define DAC_DHR12L2 (* ((volatile uint32_t *) (0x40007400 + 24)))

  // Field DACC2DHR: DAC channel2 12-bit left-aligned data These bits are written by software which specify 12-bit data for DAC channel2.
    inline uint32_t DAC_DHR12L2_DACC2DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DHR8R2: DAC channel2 8-bit right-aligned data holding register
  #define DAC_DHR8R2 (* ((volatile uint32_t *) (0x40007400 + 28)))

  // Field DACC2DHR: DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    inline uint32_t DAC_DHR8R2_DACC2DHR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DHR12RD: Dual DAC 12-bit right-aligned data holding register
  #define DAC_DHR12RD (* ((volatile uint32_t *) (0x40007400 + 32)))

  // Field DACC1DHR: DAC channel1 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    inline uint32_t DAC_DHR12RD_DACC1DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field DACC2DHR: DAC channel2 12-bit right-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    inline uint32_t DAC_DHR12RD_DACC2DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DHR12LD: DUAL DAC 12-bit left aligned data holding register
  #define DAC_DHR12LD (* ((volatile uint32_t *) (0x40007400 + 36)))

  // Field DACC1DHR: DAC channel1 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel1.
    inline uint32_t DAC_DHR12LD_DACC1DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field DACC2DHR: DAC channel2 12-bit left-aligned data These bits are written by software which specifies 12-bit data for DAC channel2.
    inline uint32_t DAC_DHR12LD_DACC2DHR (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register DHR8RD: DUAL DAC 8-bit right aligned data holding register
  #define DAC_DHR8RD (* ((volatile uint32_t *) (0x40007400 + 40)))

  // Field DACC1DHR: DAC channel1 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel1.
    inline uint32_t DAC_DHR8RD_DACC1DHR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field DACC2DHR: DAC channel2 8-bit right-aligned data These bits are written by software which specifies 8-bit data for DAC channel2.
    inline uint32_t DAC_DHR8RD_DACC2DHR (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DOR1: DAC channel1 data output register
  #define DAC_DOR1 (* ((const volatile uint32_t *) (0x40007400 + 44)))

  // Field DACC1DOR: DAC channel1 data output These bits are read-only, they contain data output for DAC channel1.
    inline uint32_t DAC_DOR1_DACC1DOR (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOR2: DAC channel2 data output register
  #define DAC_DOR2 (* ((const volatile uint32_t *) (0x40007400 + 48)))

  // Field DACC2DOR: DAC channel2 data output These bits are read-only, they contain data output for DAC channel2.
    inline uint32_t DAC_DOR2_DACC2DOR (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SR: DAC status register
  #define DAC_SR (* ((volatile uint32_t *) (0x40007400 + 52)))

  // Field DMAUDR1: DAC channel1 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
    const uint32_t DAC_SR_DMAUDR1 = 1U << 13 ;

  // Field CAL_FLAG1: DAC Channel 1 calibration offset status This bit is set and cleared by hardware
    const uint32_t DAC_SR_CAL_FLAG1 = 1U << 14 ;

  // Field BWST1: DAC Channel 1 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR1, It is cleared by hardware when the write operation of DAC_SHSR1 is complete. (It takes about 3LSI periods of synchronization).
    const uint32_t DAC_SR_BWST1 = 1U << 15 ;

  // Field DMAUDR2: DAC channel2 DMA underrun flag This bit is set by hardware and cleared by software (by writing it to 1).
    const uint32_t DAC_SR_DMAUDR2 = 1U << 29 ;

  // Field CAL_FLAG2: DAC Channel 2 calibration offset status This bit is set and cleared by hardware
    const uint32_t DAC_SR_CAL_FLAG2 = 1U << 30 ;

  // Field BWST2: DAC Channel 2 busy writing sample time flag This bit is systematically set just after Sample & Hold mode enable and is set each time the software writes the register DAC_SHSR2, It is cleared by hardware when the write operation of DAC_SHSR2 is complete. (It takes about 3 LSI periods of synchronization).
    const uint32_t DAC_SR_BWST2 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CCR: DAC calibration control register
  #define DAC_CCR (* ((volatile uint32_t *) (0x40007400 + 56)))

  // Field OTRIM1: DAC Channel 1 offset trimming value
    inline uint32_t DAC_CCR_OTRIM1 (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OTRIM2: DAC Channel 2 offset trimming value
    inline uint32_t DAC_CCR_OTRIM2 (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MCR: DAC mode control register
  #define DAC_MCR (* ((volatile uint32_t *) (0x40007400 + 60)))

  // Field MODE1: DAC Channel 1 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN1=0 and bit CEN1 =0 in the DAC_CR register). If EN1=1 or CEN1 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 1 mode: DAC Channel 1 in normal Mode DAC Channel 1 in sample &amp; hold mode
    inline uint32_t DAC_MCR_MODE1 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field MODE2: DAC Channel 2 mode These bits can be written only when the DAC is disabled and not in the calibration mode (when bit EN2=0 and bit CEN2 =0 in the DAC_CR register). If EN2=1 or CEN2 =1 the write operation is ignored. They can be set and cleared by software to select the DAC Channel 2 mode: DAC Channel 2 in normal Mode DAC Channel 2 in sample &amp; hold mode
    inline uint32_t DAC_MCR_MODE2 (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SHSR1: DAC Sample and Hold sample time register 1
  #define DAC_SHSR1 (* ((volatile uint32_t *) (0x40007400 + 64)))

  // Field TSAMPLE1: DAC Channel 1 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel1 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, If BWSTx=1, the write operation is ignored.
    inline uint32_t DAC_SHSR1_TSAMPLE1 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SHSR2: DAC Sample and Hold sample time register 2
  #define DAC_SHSR2 (* ((volatile uint32_t *) (0x40007400 + 68)))

  // Field TSAMPLE2: DAC Channel 2 sample Time (only valid in sample &amp; hold mode) These bits can be written when the DAC channel2 is disabled or also during normal operation. in the latter case, the write can be done only when BWSTx of DAC_SR register is low, if BWSTx=1, the write operation is ignored.
    inline uint32_t DAC_SHSR2_TSAMPLE2 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SHHR: DAC Sample and Hold hold time register
  #define DAC_SHHR (* ((volatile uint32_t *) (0x40007400 + 72)))

  // Field THOLD1: DAC Channel 1 hold Time (only valid in sample &amp; hold mode) Hold time= (THOLD[9:0]) x T LSI
    inline uint32_t DAC_SHHR_THOLD1 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field THOLD2: DAC Channel 2 hold time (only valid in sample &amp; hold mode). Hold time= (THOLD[9:0]) x T LSI
    inline uint32_t DAC_SHHR_THOLD2 (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SHRR: DAC Sample and Hold refresh time register
  #define DAC_SHRR (* ((volatile uint32_t *) (0x40007400 + 76)))

  // Field TREFRESH1: DAC Channel 1 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
    inline uint32_t DAC_SHRR_TREFRESH1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field TREFRESH2: DAC Channel 2 refresh Time (only valid in sample &amp; hold mode) Refresh time= (TREFRESH[7:0]) x T LSI
    inline uint32_t DAC_SHRR_TREFRESH2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral DBGMCU: Microcontroller Debug Unit
//------------------------------------------------------------------------------

//---  Register IDC: DBGMCU Identity Code Register
  #define DBGMCU_IDC (* ((const volatile uint32_t *) (0x5C001000 + 0)))

  // Field DEV_ID: Device ID
    inline uint32_t DBGMCU_IDC_DEV_ID (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field REV_ID: Revision
    inline uint32_t DBGMCU_IDC_REV_ID (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CR: DBGMCU Configuration Register
  #define DBGMCU_CR (* ((volatile uint32_t *) (0x5C001000 + 4)))

  // Field DBGSLEEP_D1: Allow D1 domain debug in Sleep mode
    const uint32_t DBGMCU_CR_DBGSLEEP_D1 = 1U << 0 ;

  // Field DBGSTOP_D1: Allow D1 domain debug in Stop mode
    const uint32_t DBGMCU_CR_DBGSTOP_D1 = 1U << 1 ;

  // Field DBGSTBY_D1: Allow D1 domain debug in Standby mode
    const uint32_t DBGMCU_CR_DBGSTBY_D1 = 1U << 2 ;

  // Field DBGSLEEP_D2: Allow D2 domain debug in Sleep mode
    const uint32_t DBGMCU_CR_DBGSLEEP_D2 = 1U << 3 ;

  // Field DBGSTOP_D2: Allow D2 domain debug in Stop mode
    const uint32_t DBGMCU_CR_DBGSTOP_D2 = 1U << 4 ;

  // Field DBGSTBY_D2: Allow D2 domain debug in Standby mode
    const uint32_t DBGMCU_CR_DBGSTBY_D2 = 1U << 5 ;

  // Field DBGSTOP_D3: Allow debug in D3 Stop mode
    const uint32_t DBGMCU_CR_DBGSTOP_D3 = 1U << 7 ;

  // Field DBGSTBY_D3: Allow debug in D3 Standby mode
    const uint32_t DBGMCU_CR_DBGSTBY_D3 = 1U << 8 ;

  // Field TRACECLKEN: Trace port clock enable
    const uint32_t DBGMCU_CR_TRACECLKEN = 1U << 20 ;

  // Field D1DBGCKEN: D1 debug clock enable
    const uint32_t DBGMCU_CR_D1DBGCKEN = 1U << 21 ;

  // Field D3DBGCKEN: D3 debug clock enable
    const uint32_t DBGMCU_CR_D3DBGCKEN = 1U << 22 ;

  // Field TRGOEN: External trigger output enable
    const uint32_t DBGMCU_CR_TRGOEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register APB3FZ1: DBGMCU APB3 peripheral freeze register
  #define DBGMCU_APB3FZ1 (* ((volatile uint32_t *) (0x5C001000 + 52)))

  // Field WWDG1: WWDG1 stop in debug
    const uint32_t DBGMCU_APB3FZ1_WWDG1 = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register APB1LFZ1: DBGMCU APB1L peripheral freeze register
  #define DBGMCU_APB1LFZ1 (* ((volatile uint32_t *) (0x5C001000 + 60)))

  // Field DBG_TIM2: TIM2 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM2 = 1U << 0 ;

  // Field DBG_TIM3: TIM3 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM3 = 1U << 1 ;

  // Field DBG_TIM4: TIM4 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM4 = 1U << 2 ;

  // Field DBG_TIM5: TIM5 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM5 = 1U << 3 ;

  // Field DBG_TIM6: TIM6 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM6 = 1U << 4 ;

  // Field DBG_TIM7: TIM7 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM7 = 1U << 5 ;

  // Field DBG_TIM12: TIM12 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM12 = 1U << 6 ;

  // Field DBG_TIM13: TIM13 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM13 = 1U << 7 ;

  // Field DBG_TIM14: TIM14 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_TIM14 = 1U << 8 ;

  // Field DBG_LPTIM1: LPTIM1 stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_LPTIM1 = 1U << 9 ;

  // Field DBG_I2C1: I2C1 SMBUS timeout stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_I2C1 = 1U << 21 ;

  // Field DBG_I2C2: I2C2 SMBUS timeout stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_I2C2 = 1U << 22 ;

  // Field DBG_I2C3: I2C3 SMBUS timeout stop in debug
    const uint32_t DBGMCU_APB1LFZ1_DBG_I2C3 = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register APB2FZ1: DBGMCU APB2 peripheral freeze register
  #define DBGMCU_APB2FZ1 (* ((volatile uint32_t *) (0x5C001000 + 76)))

  // Field DBG_TIM1: TIM1 stop in debug
    const uint32_t DBGMCU_APB2FZ1_DBG_TIM1 = 1U << 0 ;

  // Field DBG_TIM8: TIM8 stop in debug
    const uint32_t DBGMCU_APB2FZ1_DBG_TIM8 = 1U << 1 ;

  // Field DBG_TIM15: TIM15 stop in debug
    const uint32_t DBGMCU_APB2FZ1_DBG_TIM15 = 1U << 16 ;

  // Field DBG_TIM16: TIM16 stop in debug
    const uint32_t DBGMCU_APB2FZ1_DBG_TIM16 = 1U << 17 ;

  // Field DBG_TIM17: TIM17 stop in debug
    const uint32_t DBGMCU_APB2FZ1_DBG_TIM17 = 1U << 18 ;

  // Field DBG_HRTIM: HRTIM stop in debug
    const uint32_t DBGMCU_APB2FZ1_DBG_HRTIM = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register APB4FZ1: DBGMCU APB4 peripheral freeze register
  #define DBGMCU_APB4FZ1 (* ((volatile uint32_t *) (0x5C001000 + 84)))

  // Field DBG_I2C4: I2C4 SMBUS timeout stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_I2C4 = 1U << 7 ;

  // Field DBG_LPTIM2: LPTIM2 stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_LPTIM2 = 1U << 9 ;

  // Field DBG_LPTIM3: LPTIM2 stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_LPTIM3 = 1U << 10 ;

  // Field DBG_LPTIM4: LPTIM4 stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_LPTIM4 = 1U << 11 ;

  // Field DBG_LPTIM5: LPTIM5 stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_LPTIM5 = 1U << 12 ;

  // Field DBG_RTC: RTC stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_RTC = 1U << 16 ;

  // Field DBG_IWDG1: Independent watchdog for D1 stop in debug
    const uint32_t DBGMCU_APB4FZ1_DBG_IWDG1 = 1U << 18 ;

//------------------------------------------------------------------------------
// Peripheral DCMI: Digital camera interface
//------------------------------------------------------------------------------

//---  Register CR: control register 1
  #define DCMI_CR (* ((volatile uint32_t *) (0x48020000 + 0)))

  // Field OELS: Odd/Even Line Select (Line Select Start)
    const uint32_t DCMI_CR_OELS = 1U << 20 ;

  // Field LSM: Line Select mode
    const uint32_t DCMI_CR_LSM = 1U << 19 ;

  // Field OEBS: Odd/Even Byte Select (Byte Select Start)
    const uint32_t DCMI_CR_OEBS = 1U << 18 ;

  // Field BSM: Byte Select mode
    inline uint32_t DCMI_CR_BSM (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field ENABLE: DCMI enable
    const uint32_t DCMI_CR_ENABLE = 1U << 14 ;

  // Field EDM: Extended data mode
    inline uint32_t DCMI_CR_EDM (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field FCRC: Frame capture rate control
    inline uint32_t DCMI_CR_FCRC (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field VSPOL: Vertical synchronization polarity
    const uint32_t DCMI_CR_VSPOL = 1U << 7 ;

  // Field HSPOL: Horizontal synchronization polarity
    const uint32_t DCMI_CR_HSPOL = 1U << 6 ;

  // Field PCKPOL: Pixel clock polarity
    const uint32_t DCMI_CR_PCKPOL = 1U << 5 ;

  // Field ESS: Embedded synchronization select
    const uint32_t DCMI_CR_ESS = 1U << 4 ;

  // Field JPEG: JPEG format
    const uint32_t DCMI_CR_JPEG = 1U << 3 ;

  // Field CROP: Crop feature
    const uint32_t DCMI_CR_CROP = 1U << 2 ;

  // Field CM: Capture mode
    const uint32_t DCMI_CR_CM = 1U << 1 ;

  // Field CAPTURE: Capture enable
    const uint32_t DCMI_CR_CAPTURE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define DCMI_SR (* ((const volatile uint32_t *) (0x48020000 + 4)))

  // Field FNE: FIFO not empty
    const uint32_t DCMI_SR_FNE = 1U << 2 ;

  // Field VSYNC: VSYNC
    const uint32_t DCMI_SR_VSYNC = 1U << 1 ;

  // Field HSYNC: HSYNC
    const uint32_t DCMI_SR_HSYNC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RIS: raw interrupt status register
  #define DCMI_RIS (* ((const volatile uint32_t *) (0x48020000 + 8)))

  // Field LINE_RIS: Line raw interrupt status
    const uint32_t DCMI_RIS_LINE_RIS = 1U << 4 ;

  // Field VSYNC_RIS: VSYNC raw interrupt status
    const uint32_t DCMI_RIS_VSYNC_RIS = 1U << 3 ;

  // Field ERR_RIS: Synchronization error raw interrupt status
    const uint32_t DCMI_RIS_ERR_RIS = 1U << 2 ;

  // Field OVR_RIS: Overrun raw interrupt status
    const uint32_t DCMI_RIS_OVR_RIS = 1U << 1 ;

  // Field FRAME_RIS: Capture complete raw interrupt status
    const uint32_t DCMI_RIS_FRAME_RIS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: interrupt enable register
  #define DCMI_IER (* ((volatile uint32_t *) (0x48020000 + 12)))

  // Field LINE_IE: Line interrupt enable
    const uint32_t DCMI_IER_LINE_IE = 1U << 4 ;

  // Field VSYNC_IE: VSYNC interrupt enable
    const uint32_t DCMI_IER_VSYNC_IE = 1U << 3 ;

  // Field ERR_IE: Synchronization error interrupt enable
    const uint32_t DCMI_IER_ERR_IE = 1U << 2 ;

  // Field OVR_IE: Overrun interrupt enable
    const uint32_t DCMI_IER_OVR_IE = 1U << 1 ;

  // Field FRAME_IE: Capture complete interrupt enable
    const uint32_t DCMI_IER_FRAME_IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MIS: masked interrupt status register
  #define DCMI_MIS (* ((const volatile uint32_t *) (0x48020000 + 16)))

  // Field LINE_MIS: Line masked interrupt status
    const uint32_t DCMI_MIS_LINE_MIS = 1U << 4 ;

  // Field VSYNC_MIS: VSYNC masked interrupt status
    const uint32_t DCMI_MIS_VSYNC_MIS = 1U << 3 ;

  // Field ERR_MIS: Synchronization error masked interrupt status
    const uint32_t DCMI_MIS_ERR_MIS = 1U << 2 ;

  // Field OVR_MIS: Overrun masked interrupt status
    const uint32_t DCMI_MIS_OVR_MIS = 1U << 1 ;

  // Field FRAME_MIS: Capture complete masked interrupt status
    const uint32_t DCMI_MIS_FRAME_MIS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: interrupt clear register
  #define DCMI_ICR (* ((volatile uint32_t *) (0x48020000 + 20)))

  // Field LINE_ISC: line interrupt status clear
    const uint32_t DCMI_ICR_LINE_ISC = 1U << 4 ;

  // Field VSYNC_ISC: Vertical synch interrupt status clear
    const uint32_t DCMI_ICR_VSYNC_ISC = 1U << 3 ;

  // Field ERR_ISC: Synchronization error interrupt status clear
    const uint32_t DCMI_ICR_ERR_ISC = 1U << 2 ;

  // Field OVR_ISC: Overrun interrupt status clear
    const uint32_t DCMI_ICR_OVR_ISC = 1U << 1 ;

  // Field FRAME_ISC: Capture complete interrupt status clear
    const uint32_t DCMI_ICR_FRAME_ISC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ESCR: embedded synchronization code register
  #define DCMI_ESCR (* ((volatile uint32_t *) (0x48020000 + 24)))

  // Field FEC: Frame end delimiter code
    inline uint32_t DCMI_ESCR_FEC (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field LEC: Line end delimiter code
    inline uint32_t DCMI_ESCR_LEC (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field LSC: Line start delimiter code
    inline uint32_t DCMI_ESCR_LSC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field FSC: Frame start delimiter code
    inline uint32_t DCMI_ESCR_FSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ESUR: embedded synchronization unmask register
  #define DCMI_ESUR (* ((volatile uint32_t *) (0x48020000 + 28)))

  // Field FEU: Frame end delimiter unmask
    inline uint32_t DCMI_ESUR_FEU (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field LEU: Line end delimiter unmask
    inline uint32_t DCMI_ESUR_LEU (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field LSU: Line start delimiter unmask
    inline uint32_t DCMI_ESUR_LSU (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field FSU: Frame start delimiter unmask
    inline uint32_t DCMI_ESUR_FSU (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CWSTRT: crop window start
  #define DCMI_CWSTRT (* ((volatile uint32_t *) (0x48020000 + 32)))

  // Field VST: Vertical start line count
    inline uint32_t DCMI_CWSTRT_VST (const uint32_t inValue) {return (inValue & 0x1FFFU) << 16 ; }

  // Field HOFFCNT: Horizontal offset count
    inline uint32_t DCMI_CWSTRT_HOFFCNT (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CWSIZE: crop window size
  #define DCMI_CWSIZE (* ((volatile uint32_t *) (0x48020000 + 36)))

  // Field VLINE: Vertical line count
    inline uint32_t DCMI_CWSIZE_VLINE (const uint32_t inValue) {return (inValue & 0x3FFFU) << 16 ; }

  // Field CAPCNT: Capture count
    inline uint32_t DCMI_CWSIZE_CAPCNT (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR: data register
  #define DCMI_DR (* ((const volatile uint32_t *) (0x48020000 + 40)))

  // Field Byte3: Data byte 3
    inline uint32_t DCMI_DR_Byte3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field Byte2: Data byte 2
    inline uint32_t DCMI_DR_Byte2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field Byte1: Data byte 1
    inline uint32_t DCMI_DR_Byte1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field Byte0: Data byte 0
    inline uint32_t DCMI_DR_Byte0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral DELAY_Block_QUADSPI
//------------------------------------------------------------------------------

//---  Register CR: DLYB control register
  #define DELAY_Block_QUADSPI_CR (* ((volatile uint32_t *) (0x52006000 + 0)))

  // Field DEN: Delay block enable bit
    const uint32_t DELAY_Block_QUADSPI_CR_DEN = 1U << 0 ;

  // Field SEN: Sampler length enable bit
    const uint32_t DELAY_Block_QUADSPI_CR_SEN = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CFGR: DLYB configuration register
  #define DELAY_Block_QUADSPI_CFGR (* ((volatile uint32_t *) (0x52006000 + 4)))

  // Field SEL: Select the phase for the Output clock
    inline uint32_t DELAY_Block_QUADSPI_CFGR_SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field UNIT: Delay Defines the delay of a Unit delay cell
    inline uint32_t DELAY_Block_QUADSPI_CFGR_UNIT (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field LNG: Delay line length value
    inline uint32_t DELAY_Block_QUADSPI_CFGR_LNG (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field LNGF: Length valid flag
    const uint32_t DELAY_Block_QUADSPI_CFGR_LNGF = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral DELAY_Block_SDMMC1: DELAY_Block_SDMMC1
//------------------------------------------------------------------------------

//---  Register CR: DLYB control register
  #define DELAY_Block_SDMMC1_CR (* ((volatile uint32_t *) (0x52008000 + 0)))

  // Field DEN: Delay block enable bit
    const uint32_t DELAY_Block_SDMMC1_CR_DEN = 1U << 0 ;

  // Field SEN: Sampler length enable bit
    const uint32_t DELAY_Block_SDMMC1_CR_SEN = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CFGR: DLYB configuration register
  #define DELAY_Block_SDMMC1_CFGR (* ((volatile uint32_t *) (0x52008000 + 4)))

  // Field SEL: Select the phase for the Output clock
    inline uint32_t DELAY_Block_SDMMC1_CFGR_SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field UNIT: Delay Defines the delay of a Unit delay cell
    inline uint32_t DELAY_Block_SDMMC1_CFGR_UNIT (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field LNG: Delay line length value
    inline uint32_t DELAY_Block_SDMMC1_CFGR_LNG (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field LNGF: Length valid flag
    const uint32_t DELAY_Block_SDMMC1_CFGR_LNGF = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral DELAY_Block_SDMMC2
//------------------------------------------------------------------------------

//---  Register CR: DLYB control register
  #define DELAY_Block_SDMMC2_CR (* ((volatile uint32_t *) (0x48022800 + 0)))

  // Field DEN: Delay block enable bit
    const uint32_t DELAY_Block_SDMMC2_CR_DEN = 1U << 0 ;

  // Field SEN: Sampler length enable bit
    const uint32_t DELAY_Block_SDMMC2_CR_SEN = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CFGR: DLYB configuration register
  #define DELAY_Block_SDMMC2_CFGR (* ((volatile uint32_t *) (0x48022800 + 4)))

  // Field SEL: Select the phase for the Output clock
    inline uint32_t DELAY_Block_SDMMC2_CFGR_SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field UNIT: Delay Defines the delay of a Unit delay cell
    inline uint32_t DELAY_Block_SDMMC2_CFGR_UNIT (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field LNG: Delay line length value
    inline uint32_t DELAY_Block_SDMMC2_CFGR_LNG (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field LNGF: Length valid flag
    const uint32_t DELAY_Block_SDMMC2_CFGR_LNGF = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral DFSDM: Digital filter for sigma delta       modulators
//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG0R1: DFSDM channel configuration 0 register 1
  #define DFSDM_DFSDM_CHCFG0R1 (* ((volatile uint32_t *) (0x40017000 + 0)))

  // Field SITP: Serial interface type for channel 0
    inline uint32_t DFSDM_DFSDM_CHCFG0R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 0
    inline uint32_t DFSDM_DFSDM_CHCFG0R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 0
    const uint32_t DFSDM_DFSDM_CHCFG0R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 0
    const uint32_t DFSDM_DFSDM_CHCFG0R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 0 enable
    const uint32_t DFSDM_DFSDM_CHCFG0R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG0R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 0
    inline uint32_t DFSDM_DFSDM_CHCFG0R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG0R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG0R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG0R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG0R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG1R1: DFSDM channel configuration 1 register 1
  #define DFSDM_DFSDM_CHCFG1R1 (* ((volatile uint32_t *) (0x40017000 + 4)))

  // Field SITP: Serial interface type for channel 1
    inline uint32_t DFSDM_DFSDM_CHCFG1R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 1
    inline uint32_t DFSDM_DFSDM_CHCFG1R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 1
    const uint32_t DFSDM_DFSDM_CHCFG1R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 1
    const uint32_t DFSDM_DFSDM_CHCFG1R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 1 enable
    const uint32_t DFSDM_DFSDM_CHCFG1R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG1R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 1
    inline uint32_t DFSDM_DFSDM_CHCFG1R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG1R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG1R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG1R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG1R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG2R1: DFSDM channel configuration 2 register 1
  #define DFSDM_DFSDM_CHCFG2R1 (* ((volatile uint32_t *) (0x40017000 + 8)))

  // Field SITP: Serial interface type for channel 2
    inline uint32_t DFSDM_DFSDM_CHCFG2R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 2
    inline uint32_t DFSDM_DFSDM_CHCFG2R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 2
    const uint32_t DFSDM_DFSDM_CHCFG2R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 2
    const uint32_t DFSDM_DFSDM_CHCFG2R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 2 enable
    const uint32_t DFSDM_DFSDM_CHCFG2R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG2R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 2
    inline uint32_t DFSDM_DFSDM_CHCFG2R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG2R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG2R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG2R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG2R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG3R1: DFSDM channel configuration 3 register 1
  #define DFSDM_DFSDM_CHCFG3R1 (* ((volatile uint32_t *) (0x40017000 + 12)))

  // Field SITP: Serial interface type for channel 3
    inline uint32_t DFSDM_DFSDM_CHCFG3R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 3
    inline uint32_t DFSDM_DFSDM_CHCFG3R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 3
    const uint32_t DFSDM_DFSDM_CHCFG3R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 3
    const uint32_t DFSDM_DFSDM_CHCFG3R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 3 enable
    const uint32_t DFSDM_DFSDM_CHCFG3R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG3R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 3
    inline uint32_t DFSDM_DFSDM_CHCFG3R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG3R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG3R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG3R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG3R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG4R1: DFSDM channel configuration 4 register 1
  #define DFSDM_DFSDM_CHCFG4R1 (* ((volatile uint32_t *) (0x40017000 + 16)))

  // Field SITP: Serial interface type for channel 4
    inline uint32_t DFSDM_DFSDM_CHCFG4R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 4
    inline uint32_t DFSDM_DFSDM_CHCFG4R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 4
    const uint32_t DFSDM_DFSDM_CHCFG4R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 4
    const uint32_t DFSDM_DFSDM_CHCFG4R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 4 enable
    const uint32_t DFSDM_DFSDM_CHCFG4R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG4R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 4
    inline uint32_t DFSDM_DFSDM_CHCFG4R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG4R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG4R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG4R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG4R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG5R1: DFSDM channel configuration 5 register 1
  #define DFSDM_DFSDM_CHCFG5R1 (* ((volatile uint32_t *) (0x40017000 + 20)))

  // Field SITP: Serial interface type for channel 5
    inline uint32_t DFSDM_DFSDM_CHCFG5R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 5
    inline uint32_t DFSDM_DFSDM_CHCFG5R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 5
    const uint32_t DFSDM_DFSDM_CHCFG5R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 5
    const uint32_t DFSDM_DFSDM_CHCFG5R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 5 enable
    const uint32_t DFSDM_DFSDM_CHCFG5R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG5R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 5
    inline uint32_t DFSDM_DFSDM_CHCFG5R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG5R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG5R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG5R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG5R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG6R1: DFSDM channel configuration 6 register 1
  #define DFSDM_DFSDM_CHCFG6R1 (* ((volatile uint32_t *) (0x40017000 + 24)))

  // Field SITP: Serial interface type for channel 6
    inline uint32_t DFSDM_DFSDM_CHCFG6R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 6
    inline uint32_t DFSDM_DFSDM_CHCFG6R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 6
    const uint32_t DFSDM_DFSDM_CHCFG6R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 6
    const uint32_t DFSDM_DFSDM_CHCFG6R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 6 enable
    const uint32_t DFSDM_DFSDM_CHCFG6R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG6R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 6
    inline uint32_t DFSDM_DFSDM_CHCFG6R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG6R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG6R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG6R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG6R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG7R1: DFSDM channel configuration 7 register 1
  #define DFSDM_DFSDM_CHCFG7R1 (* ((volatile uint32_t *) (0x40017000 + 28)))

  // Field SITP: Serial interface type for channel 7
    inline uint32_t DFSDM_DFSDM_CHCFG7R1_SITP (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field SPICKSEL: SPI clock select for channel 7
    inline uint32_t DFSDM_DFSDM_CHCFG7R1_SPICKSEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SCDEN: Short-circuit detector enable on channel 7
    const uint32_t DFSDM_DFSDM_CHCFG7R1_SCDEN = 1U << 5 ;

  // Field CKABEN: Clock absence detector enable on channel 7
    const uint32_t DFSDM_DFSDM_CHCFG7R1_CKABEN = 1U << 6 ;

  // Field CHEN: Channel 7 enable
    const uint32_t DFSDM_DFSDM_CHCFG7R1_CHEN = 1U << 7 ;

  // Field CHINSEL: Channel inputs selection
    const uint32_t DFSDM_DFSDM_CHCFG7R1_CHINSEL = 1U << 8 ;

  // Field DATMPX: Input data multiplexer for channel 7
    inline uint32_t DFSDM_DFSDM_CHCFG7R1_DATMPX (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field DATPACK: Data packing mode in DFSDM_CHDATINyR register
    inline uint32_t DFSDM_DFSDM_CHCFG7R1_DATPACK (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field CKOUTDIV: Output serial clock divider
    inline uint32_t DFSDM_DFSDM_CHCFG7R1_CKOUTDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKOUTSRC: Output serial clock source selection
    const uint32_t DFSDM_DFSDM_CHCFG7R1_CKOUTSRC = 1U << 30 ;

  // Field DFSDMEN: Global enable for DFSDM interface
    const uint32_t DFSDM_DFSDM_CHCFG7R1_DFSDMEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG0R2: DFSDM channel configuration 0 register 2
  #define DFSDM_DFSDM_CHCFG0R2 (* ((volatile uint32_t *) (0x40017000 + 32)))

  // Field DTRBS: Data right bit-shift for channel 0
    inline uint32_t DFSDM_DFSDM_CHCFG0R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 0
    inline uint32_t DFSDM_DFSDM_CHCFG0R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG1R2: DFSDM channel configuration 1 register 2
  #define DFSDM_DFSDM_CHCFG1R2 (* ((volatile uint32_t *) (0x40017000 + 36)))

  // Field DTRBS: Data right bit-shift for channel 1
    inline uint32_t DFSDM_DFSDM_CHCFG1R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 1
    inline uint32_t DFSDM_DFSDM_CHCFG1R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG2R2: DFSDM channel configuration 2 register 2
  #define DFSDM_DFSDM_CHCFG2R2 (* ((volatile uint32_t *) (0x40017000 + 40)))

  // Field DTRBS: Data right bit-shift for channel 2
    inline uint32_t DFSDM_DFSDM_CHCFG2R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 2
    inline uint32_t DFSDM_DFSDM_CHCFG2R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG3R2: DFSDM channel configuration 3 register 2
  #define DFSDM_DFSDM_CHCFG3R2 (* ((volatile uint32_t *) (0x40017000 + 44)))

  // Field DTRBS: Data right bit-shift for channel 3
    inline uint32_t DFSDM_DFSDM_CHCFG3R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 3
    inline uint32_t DFSDM_DFSDM_CHCFG3R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG4R2: DFSDM channel configuration 4 register 2
  #define DFSDM_DFSDM_CHCFG4R2 (* ((volatile uint32_t *) (0x40017000 + 48)))

  // Field DTRBS: Data right bit-shift for channel 4
    inline uint32_t DFSDM_DFSDM_CHCFG4R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 4
    inline uint32_t DFSDM_DFSDM_CHCFG4R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG5R2: DFSDM channel configuration 5 register 2
  #define DFSDM_DFSDM_CHCFG5R2 (* ((volatile uint32_t *) (0x40017000 + 52)))

  // Field DTRBS: Data right bit-shift for channel 5
    inline uint32_t DFSDM_DFSDM_CHCFG5R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 5
    inline uint32_t DFSDM_DFSDM_CHCFG5R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG6R2: DFSDM channel configuration 6 register 2
  #define DFSDM_DFSDM_CHCFG6R2 (* ((volatile uint32_t *) (0x40017000 + 56)))

  // Field DTRBS: Data right bit-shift for channel 6
    inline uint32_t DFSDM_DFSDM_CHCFG6R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 6
    inline uint32_t DFSDM_DFSDM_CHCFG6R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHCFG7R2: DFSDM channel configuration 7 register 2
  #define DFSDM_DFSDM_CHCFG7R2 (* ((volatile uint32_t *) (0x40017000 + 60)))

  // Field DTRBS: Data right bit-shift for channel 7
    inline uint32_t DFSDM_DFSDM_CHCFG7R2_DTRBS (const uint32_t inValue) {return (inValue & 0x1FU) << 3 ; }

  // Field OFFSET: 24-bit calibration offset for channel 7
    inline uint32_t DFSDM_DFSDM_CHCFG7R2_OFFSET (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD0R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD0R (* ((volatile uint32_t *) (0x40017000 + 64)))

  // Field SCDT: short-circuit detector threshold for channel 0
    inline uint32_t DFSDM_DFSDM_AWSCD0R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 0
    inline uint32_t DFSDM_DFSDM_AWSCD0R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 0
    inline uint32_t DFSDM_DFSDM_AWSCD0R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 0
    inline uint32_t DFSDM_DFSDM_AWSCD0R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD1R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD1R (* ((volatile uint32_t *) (0x40017000 + 68)))

  // Field SCDT: short-circuit detector threshold for channel 1
    inline uint32_t DFSDM_DFSDM_AWSCD1R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 1
    inline uint32_t DFSDM_DFSDM_AWSCD1R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 1
    inline uint32_t DFSDM_DFSDM_AWSCD1R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 1
    inline uint32_t DFSDM_DFSDM_AWSCD1R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD2R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD2R (* ((volatile uint32_t *) (0x40017000 + 72)))

  // Field SCDT: short-circuit detector threshold for channel 2
    inline uint32_t DFSDM_DFSDM_AWSCD2R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 2
    inline uint32_t DFSDM_DFSDM_AWSCD2R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 2
    inline uint32_t DFSDM_DFSDM_AWSCD2R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 2
    inline uint32_t DFSDM_DFSDM_AWSCD2R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD3R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD3R (* ((volatile uint32_t *) (0x40017000 + 76)))

  // Field SCDT: short-circuit detector threshold for channel 3
    inline uint32_t DFSDM_DFSDM_AWSCD3R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 3
    inline uint32_t DFSDM_DFSDM_AWSCD3R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 3
    inline uint32_t DFSDM_DFSDM_AWSCD3R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 3
    inline uint32_t DFSDM_DFSDM_AWSCD3R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD4R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD4R (* ((volatile uint32_t *) (0x40017000 + 80)))

  // Field SCDT: short-circuit detector threshold for channel 4
    inline uint32_t DFSDM_DFSDM_AWSCD4R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 4
    inline uint32_t DFSDM_DFSDM_AWSCD4R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 4
    inline uint32_t DFSDM_DFSDM_AWSCD4R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 4
    inline uint32_t DFSDM_DFSDM_AWSCD4R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD5R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD5R (* ((volatile uint32_t *) (0x40017000 + 84)))

  // Field SCDT: short-circuit detector threshold for channel 5
    inline uint32_t DFSDM_DFSDM_AWSCD5R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 5
    inline uint32_t DFSDM_DFSDM_AWSCD5R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 5
    inline uint32_t DFSDM_DFSDM_AWSCD5R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 5
    inline uint32_t DFSDM_DFSDM_AWSCD5R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD6R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD6R (* ((volatile uint32_t *) (0x40017000 + 88)))

  // Field SCDT: short-circuit detector threshold for channel 6
    inline uint32_t DFSDM_DFSDM_AWSCD6R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 6
    inline uint32_t DFSDM_DFSDM_AWSCD6R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 6
    inline uint32_t DFSDM_DFSDM_AWSCD6R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 6
    inline uint32_t DFSDM_DFSDM_AWSCD6R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_AWSCD7R: DFSDM analog watchdog and short-circuit detector register
  #define DFSDM_DFSDM_AWSCD7R (* ((volatile uint32_t *) (0x40017000 + 92)))

  // Field SCDT: short-circuit detector threshold for channel 7
    inline uint32_t DFSDM_DFSDM_AWSCD7R_SCDT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKSCD: Break signal assignment for short-circuit detector on channel 7
    inline uint32_t DFSDM_DFSDM_AWSCD7R_BKSCD (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AWFOSR: Analog watchdog filter oversampling ratio (decimation rate) on channel 7
    inline uint32_t DFSDM_DFSDM_AWSCD7R_AWFOSR (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field AWFORD: Analog watchdog Sinc filter order on channel 7
    inline uint32_t DFSDM_DFSDM_AWSCD7R_AWFORD (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT0R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT0R (* ((const volatile uint32_t *) (0x40017000 + 96)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT0R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT1R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT1R (* ((const volatile uint32_t *) (0x40017000 + 100)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT1R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT2R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT2R (* ((const volatile uint32_t *) (0x40017000 + 104)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT2R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT3R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT3R (* ((const volatile uint32_t *) (0x40017000 + 108)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT3R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT4R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT4R (* ((const volatile uint32_t *) (0x40017000 + 112)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT4R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT5R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT5R (* ((const volatile uint32_t *) (0x40017000 + 116)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT5R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT6R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT6R (* ((const volatile uint32_t *) (0x40017000 + 120)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT6R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHWDAT7R: DFSDM channel watchdog filter data register
  #define DFSDM_DFSDM_CHWDAT7R (* ((const volatile uint32_t *) (0x40017000 + 124)))

  // Field WDATA: Input channel y watchdog data
    inline uint32_t DFSDM_DFSDM_CHWDAT7R_WDATA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN0R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN0R (* ((volatile uint32_t *) (0x40017000 + 128)))

  // Field INDAT0: Input data for channel 0
    inline uint32_t DFSDM_DFSDM_CHDATIN0R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 1
    inline uint32_t DFSDM_DFSDM_CHDATIN0R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN1R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN1R (* ((volatile uint32_t *) (0x40017000 + 132)))

  // Field INDAT0: Input data for channel 1
    inline uint32_t DFSDM_DFSDM_CHDATIN1R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 2
    inline uint32_t DFSDM_DFSDM_CHDATIN1R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN2R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN2R (* ((volatile uint32_t *) (0x40017000 + 136)))

  // Field INDAT0: Input data for channel 2
    inline uint32_t DFSDM_DFSDM_CHDATIN2R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 3
    inline uint32_t DFSDM_DFSDM_CHDATIN2R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN3R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN3R (* ((volatile uint32_t *) (0x40017000 + 140)))

  // Field INDAT0: Input data for channel 3
    inline uint32_t DFSDM_DFSDM_CHDATIN3R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 4
    inline uint32_t DFSDM_DFSDM_CHDATIN3R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN4R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN4R (* ((volatile uint32_t *) (0x40017000 + 144)))

  // Field INDAT0: Input data for channel 4
    inline uint32_t DFSDM_DFSDM_CHDATIN4R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 5
    inline uint32_t DFSDM_DFSDM_CHDATIN4R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN5R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN5R (* ((volatile uint32_t *) (0x40017000 + 148)))

  // Field INDAT0: Input data for channel 5
    inline uint32_t DFSDM_DFSDM_CHDATIN5R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 6
    inline uint32_t DFSDM_DFSDM_CHDATIN5R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN6R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN6R (* ((volatile uint32_t *) (0x40017000 + 152)))

  // Field INDAT0: Input data for channel 6
    inline uint32_t DFSDM_DFSDM_CHDATIN6R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 7
    inline uint32_t DFSDM_DFSDM_CHDATIN6R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM_CHDATIN7R: DFSDM channel data input register
  #define DFSDM_DFSDM_CHDATIN7R (* ((volatile uint32_t *) (0x40017000 + 156)))

  // Field INDAT0: Input data for channel 7
    inline uint32_t DFSDM_DFSDM_CHDATIN7R_INDAT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INDAT1: Input data for channel 8
    inline uint32_t DFSDM_DFSDM_CHDATIN7R_INDAT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_CR1: DFSDM control register 1
  #define DFSDM_DFSDM0_CR1 (* ((volatile uint32_t *) (0x40017000 + 160)))

  // Field DFEN: DFSDM enable
    const uint32_t DFSDM_DFSDM0_CR1_DFEN = 1U << 0 ;

  // Field JSWSTART: Start a conversion of the injected group of channels
    const uint32_t DFSDM_DFSDM0_CR1_JSWSTART = 1U << 1 ;

  // Field JSYNC: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    const uint32_t DFSDM_DFSDM0_CR1_JSYNC = 1U << 3 ;

  // Field JSCAN: Scanning conversion mode for injected conversions
    const uint32_t DFSDM_DFSDM0_CR1_JSCAN = 1U << 4 ;

  // Field JDMAEN: DMA channel enabled to read data for the injected channel group
    const uint32_t DFSDM_DFSDM0_CR1_JDMAEN = 1U << 5 ;

  // Field JEXTSEL: Trigger signal selection for launching injected conversions
    inline uint32_t DFSDM_DFSDM0_CR1_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field JEXTEN: Trigger enable and trigger edge selection for injected conversions
    inline uint32_t DFSDM_DFSDM0_CR1_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field RSWSTART: Software start of a conversion on the regular channel
    const uint32_t DFSDM_DFSDM0_CR1_RSWSTART = 1U << 17 ;

  // Field RCONT: Continuous mode selection for regular conversions
    const uint32_t DFSDM_DFSDM0_CR1_RCONT = 1U << 18 ;

  // Field RSYNC: Launch regular conversion synchronously with DFSDM0
    const uint32_t DFSDM_DFSDM0_CR1_RSYNC = 1U << 19 ;

  // Field RDMAEN: DMA channel enabled to read data for the regular conversion
    const uint32_t DFSDM_DFSDM0_CR1_RDMAEN = 1U << 21 ;

  // Field RCH: Regular channel selection
    inline uint32_t DFSDM_DFSDM0_CR1_RCH (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field FAST: Fast conversion mode selection for regular conversions
    const uint32_t DFSDM_DFSDM0_CR1_FAST = 1U << 29 ;

  // Field AWFSEL: Analog watchdog fast mode select
    const uint32_t DFSDM_DFSDM0_CR1_AWFSEL = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register DFSDM1_CR1: DFSDM control register 1
  #define DFSDM_DFSDM1_CR1 (* ((volatile uint32_t *) (0x40017000 + 164)))

  // Field DFEN: DFSDM enable
    const uint32_t DFSDM_DFSDM1_CR1_DFEN = 1U << 0 ;

  // Field JSWSTART: Start a conversion of the injected group of channels
    const uint32_t DFSDM_DFSDM1_CR1_JSWSTART = 1U << 1 ;

  // Field JSYNC: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    const uint32_t DFSDM_DFSDM1_CR1_JSYNC = 1U << 3 ;

  // Field JSCAN: Scanning conversion mode for injected conversions
    const uint32_t DFSDM_DFSDM1_CR1_JSCAN = 1U << 4 ;

  // Field JDMAEN: DMA channel enabled to read data for the injected channel group
    const uint32_t DFSDM_DFSDM1_CR1_JDMAEN = 1U << 5 ;

  // Field JEXTSEL: Trigger signal selection for launching injected conversions
    inline uint32_t DFSDM_DFSDM1_CR1_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field JEXTEN: Trigger enable and trigger edge selection for injected conversions
    inline uint32_t DFSDM_DFSDM1_CR1_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field RSWSTART: Software start of a conversion on the regular channel
    const uint32_t DFSDM_DFSDM1_CR1_RSWSTART = 1U << 17 ;

  // Field RCONT: Continuous mode selection for regular conversions
    const uint32_t DFSDM_DFSDM1_CR1_RCONT = 1U << 18 ;

  // Field RSYNC: Launch regular conversion synchronously with DFSDM0
    const uint32_t DFSDM_DFSDM1_CR1_RSYNC = 1U << 19 ;

  // Field RDMAEN: DMA channel enabled to read data for the regular conversion
    const uint32_t DFSDM_DFSDM1_CR1_RDMAEN = 1U << 21 ;

  // Field RCH: Regular channel selection
    inline uint32_t DFSDM_DFSDM1_CR1_RCH (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field FAST: Fast conversion mode selection for regular conversions
    const uint32_t DFSDM_DFSDM1_CR1_FAST = 1U << 29 ;

  // Field AWFSEL: Analog watchdog fast mode select
    const uint32_t DFSDM_DFSDM1_CR1_AWFSEL = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register DFSDM2_CR1: DFSDM control register 1
  #define DFSDM_DFSDM2_CR1 (* ((volatile uint32_t *) (0x40017000 + 168)))

  // Field DFEN: DFSDM enable
    const uint32_t DFSDM_DFSDM2_CR1_DFEN = 1U << 0 ;

  // Field JSWSTART: Start a conversion of the injected group of channels
    const uint32_t DFSDM_DFSDM2_CR1_JSWSTART = 1U << 1 ;

  // Field JSYNC: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    const uint32_t DFSDM_DFSDM2_CR1_JSYNC = 1U << 3 ;

  // Field JSCAN: Scanning conversion mode for injected conversions
    const uint32_t DFSDM_DFSDM2_CR1_JSCAN = 1U << 4 ;

  // Field JDMAEN: DMA channel enabled to read data for the injected channel group
    const uint32_t DFSDM_DFSDM2_CR1_JDMAEN = 1U << 5 ;

  // Field JEXTSEL: Trigger signal selection for launching injected conversions
    inline uint32_t DFSDM_DFSDM2_CR1_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field JEXTEN: Trigger enable and trigger edge selection for injected conversions
    inline uint32_t DFSDM_DFSDM2_CR1_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field RSWSTART: Software start of a conversion on the regular channel
    const uint32_t DFSDM_DFSDM2_CR1_RSWSTART = 1U << 17 ;

  // Field RCONT: Continuous mode selection for regular conversions
    const uint32_t DFSDM_DFSDM2_CR1_RCONT = 1U << 18 ;

  // Field RSYNC: Launch regular conversion synchronously with DFSDM0
    const uint32_t DFSDM_DFSDM2_CR1_RSYNC = 1U << 19 ;

  // Field RDMAEN: DMA channel enabled to read data for the regular conversion
    const uint32_t DFSDM_DFSDM2_CR1_RDMAEN = 1U << 21 ;

  // Field RCH: Regular channel selection
    inline uint32_t DFSDM_DFSDM2_CR1_RCH (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field FAST: Fast conversion mode selection for regular conversions
    const uint32_t DFSDM_DFSDM2_CR1_FAST = 1U << 29 ;

  // Field AWFSEL: Analog watchdog fast mode select
    const uint32_t DFSDM_DFSDM2_CR1_AWFSEL = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register DFSDM3_CR1: DFSDM control register 1
  #define DFSDM_DFSDM3_CR1 (* ((volatile uint32_t *) (0x40017000 + 172)))

  // Field DFEN: DFSDM enable
    const uint32_t DFSDM_DFSDM3_CR1_DFEN = 1U << 0 ;

  // Field JSWSTART: Start a conversion of the injected group of channels
    const uint32_t DFSDM_DFSDM3_CR1_JSWSTART = 1U << 1 ;

  // Field JSYNC: Launch an injected conversion synchronously with the DFSDM0 JSWSTART trigger
    const uint32_t DFSDM_DFSDM3_CR1_JSYNC = 1U << 3 ;

  // Field JSCAN: Scanning conversion mode for injected conversions
    const uint32_t DFSDM_DFSDM3_CR1_JSCAN = 1U << 4 ;

  // Field JDMAEN: DMA channel enabled to read data for the injected channel group
    const uint32_t DFSDM_DFSDM3_CR1_JDMAEN = 1U << 5 ;

  // Field JEXTSEL: Trigger signal selection for launching injected conversions
    inline uint32_t DFSDM_DFSDM3_CR1_JEXTSEL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field JEXTEN: Trigger enable and trigger edge selection for injected conversions
    inline uint32_t DFSDM_DFSDM3_CR1_JEXTEN (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field RSWSTART: Software start of a conversion on the regular channel
    const uint32_t DFSDM_DFSDM3_CR1_RSWSTART = 1U << 17 ;

  // Field RCONT: Continuous mode selection for regular conversions
    const uint32_t DFSDM_DFSDM3_CR1_RCONT = 1U << 18 ;

  // Field RSYNC: Launch regular conversion synchronously with DFSDM0
    const uint32_t DFSDM_DFSDM3_CR1_RSYNC = 1U << 19 ;

  // Field RDMAEN: DMA channel enabled to read data for the regular conversion
    const uint32_t DFSDM_DFSDM3_CR1_RDMAEN = 1U << 21 ;

  // Field RCH: Regular channel selection
    inline uint32_t DFSDM_DFSDM3_CR1_RCH (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field FAST: Fast conversion mode selection for regular conversions
    const uint32_t DFSDM_DFSDM3_CR1_FAST = 1U << 29 ;

  // Field AWFSEL: Analog watchdog fast mode select
    const uint32_t DFSDM_DFSDM3_CR1_AWFSEL = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register DFSDM0_CR2: DFSDM control register 2
  #define DFSDM_DFSDM0_CR2 (* ((volatile uint32_t *) (0x40017000 + 176)))

  // Field JEOCIE: Injected end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_JEOCIE = 1U << 0 ;

  // Field REOCIE: Regular end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_REOCIE = 1U << 1 ;

  // Field JOVRIE: Injected data overrun interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_JOVRIE = 1U << 2 ;

  // Field ROVRIE: Regular data overrun interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_ROVRIE = 1U << 3 ;

  // Field AWDIE: Analog watchdog interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_AWDIE = 1U << 4 ;

  // Field SCDIE: Short-circuit detector interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_SCDIE = 1U << 5 ;

  // Field CKABIE: Clock absence interrupt enable
    const uint32_t DFSDM_DFSDM0_CR2_CKABIE = 1U << 6 ;

  // Field EXCH: Extremes detector channel selection
    inline uint32_t DFSDM_DFSDM0_CR2_EXCH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field AWDCH: Analog watchdog channel selection
    inline uint32_t DFSDM_DFSDM0_CR2_AWDCH (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_CR2: DFSDM control register 2
  #define DFSDM_DFSDM1_CR2 (* ((volatile uint32_t *) (0x40017000 + 180)))

  // Field JEOCIE: Injected end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_JEOCIE = 1U << 0 ;

  // Field REOCIE: Regular end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_REOCIE = 1U << 1 ;

  // Field JOVRIE: Injected data overrun interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_JOVRIE = 1U << 2 ;

  // Field ROVRIE: Regular data overrun interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_ROVRIE = 1U << 3 ;

  // Field AWDIE: Analog watchdog interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_AWDIE = 1U << 4 ;

  // Field SCDIE: Short-circuit detector interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_SCDIE = 1U << 5 ;

  // Field CKABIE: Clock absence interrupt enable
    const uint32_t DFSDM_DFSDM1_CR2_CKABIE = 1U << 6 ;

  // Field EXCH: Extremes detector channel selection
    inline uint32_t DFSDM_DFSDM1_CR2_EXCH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field AWDCH: Analog watchdog channel selection
    inline uint32_t DFSDM_DFSDM1_CR2_AWDCH (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_CR2: DFSDM control register 2
  #define DFSDM_DFSDM2_CR2 (* ((volatile uint32_t *) (0x40017000 + 184)))

  // Field JEOCIE: Injected end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_JEOCIE = 1U << 0 ;

  // Field REOCIE: Regular end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_REOCIE = 1U << 1 ;

  // Field JOVRIE: Injected data overrun interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_JOVRIE = 1U << 2 ;

  // Field ROVRIE: Regular data overrun interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_ROVRIE = 1U << 3 ;

  // Field AWDIE: Analog watchdog interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_AWDIE = 1U << 4 ;

  // Field SCDIE: Short-circuit detector interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_SCDIE = 1U << 5 ;

  // Field CKABIE: Clock absence interrupt enable
    const uint32_t DFSDM_DFSDM2_CR2_CKABIE = 1U << 6 ;

  // Field EXCH: Extremes detector channel selection
    inline uint32_t DFSDM_DFSDM2_CR2_EXCH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field AWDCH: Analog watchdog channel selection
    inline uint32_t DFSDM_DFSDM2_CR2_AWDCH (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_CR2: DFSDM control register 2
  #define DFSDM_DFSDM3_CR2 (* ((volatile uint32_t *) (0x40017000 + 188)))

  // Field JEOCIE: Injected end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_JEOCIE = 1U << 0 ;

  // Field REOCIE: Regular end of conversion interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_REOCIE = 1U << 1 ;

  // Field JOVRIE: Injected data overrun interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_JOVRIE = 1U << 2 ;

  // Field ROVRIE: Regular data overrun interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_ROVRIE = 1U << 3 ;

  // Field AWDIE: Analog watchdog interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_AWDIE = 1U << 4 ;

  // Field SCDIE: Short-circuit detector interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_SCDIE = 1U << 5 ;

  // Field CKABIE: Clock absence interrupt enable
    const uint32_t DFSDM_DFSDM3_CR2_CKABIE = 1U << 6 ;

  // Field EXCH: Extremes detector channel selection
    inline uint32_t DFSDM_DFSDM3_CR2_EXCH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field AWDCH: Analog watchdog channel selection
    inline uint32_t DFSDM_DFSDM3_CR2_AWDCH (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_ISR: DFSDM interrupt and status register
  #define DFSDM_DFSDM0_ISR (* ((const volatile uint32_t *) (0x40017000 + 192)))

  // Field JEOCF: End of injected conversion flag
    const uint32_t DFSDM_DFSDM0_ISR_JEOCF = 1U << 0 ;

  // Field REOCF: End of regular conversion flag
    const uint32_t DFSDM_DFSDM0_ISR_REOCF = 1U << 1 ;

  // Field JOVRF: Injected conversion overrun flag
    const uint32_t DFSDM_DFSDM0_ISR_JOVRF = 1U << 2 ;

  // Field ROVRF: Regular conversion overrun flag
    const uint32_t DFSDM_DFSDM0_ISR_ROVRF = 1U << 3 ;

  // Field AWDF: Analog watchdog
    const uint32_t DFSDM_DFSDM0_ISR_AWDF = 1U << 4 ;

  // Field JCIP: Injected conversion in progress status
    const uint32_t DFSDM_DFSDM0_ISR_JCIP = 1U << 13 ;

  // Field RCIP: Regular conversion in progress status
    const uint32_t DFSDM_DFSDM0_ISR_RCIP = 1U << 14 ;

  // Field CKABF: Clock absence flag
    inline uint32_t DFSDM_DFSDM0_ISR_CKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field SCDF: short-circuit detector flag
    inline uint32_t DFSDM_DFSDM0_ISR_SCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_ISR: DFSDM interrupt and status register
  #define DFSDM_DFSDM1_ISR (* ((const volatile uint32_t *) (0x40017000 + 196)))

  // Field JEOCF: End of injected conversion flag
    const uint32_t DFSDM_DFSDM1_ISR_JEOCF = 1U << 0 ;

  // Field REOCF: End of regular conversion flag
    const uint32_t DFSDM_DFSDM1_ISR_REOCF = 1U << 1 ;

  // Field JOVRF: Injected conversion overrun flag
    const uint32_t DFSDM_DFSDM1_ISR_JOVRF = 1U << 2 ;

  // Field ROVRF: Regular conversion overrun flag
    const uint32_t DFSDM_DFSDM1_ISR_ROVRF = 1U << 3 ;

  // Field AWDF: Analog watchdog
    const uint32_t DFSDM_DFSDM1_ISR_AWDF = 1U << 4 ;

  // Field JCIP: Injected conversion in progress status
    const uint32_t DFSDM_DFSDM1_ISR_JCIP = 1U << 13 ;

  // Field RCIP: Regular conversion in progress status
    const uint32_t DFSDM_DFSDM1_ISR_RCIP = 1U << 14 ;

  // Field CKABF: Clock absence flag
    inline uint32_t DFSDM_DFSDM1_ISR_CKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field SCDF: short-circuit detector flag
    inline uint32_t DFSDM_DFSDM1_ISR_SCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_ISR: DFSDM interrupt and status register
  #define DFSDM_DFSDM2_ISR (* ((const volatile uint32_t *) (0x40017000 + 200)))

  // Field JEOCF: End of injected conversion flag
    const uint32_t DFSDM_DFSDM2_ISR_JEOCF = 1U << 0 ;

  // Field REOCF: End of regular conversion flag
    const uint32_t DFSDM_DFSDM2_ISR_REOCF = 1U << 1 ;

  // Field JOVRF: Injected conversion overrun flag
    const uint32_t DFSDM_DFSDM2_ISR_JOVRF = 1U << 2 ;

  // Field ROVRF: Regular conversion overrun flag
    const uint32_t DFSDM_DFSDM2_ISR_ROVRF = 1U << 3 ;

  // Field AWDF: Analog watchdog
    const uint32_t DFSDM_DFSDM2_ISR_AWDF = 1U << 4 ;

  // Field JCIP: Injected conversion in progress status
    const uint32_t DFSDM_DFSDM2_ISR_JCIP = 1U << 13 ;

  // Field RCIP: Regular conversion in progress status
    const uint32_t DFSDM_DFSDM2_ISR_RCIP = 1U << 14 ;

  // Field CKABF: Clock absence flag
    inline uint32_t DFSDM_DFSDM2_ISR_CKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field SCDF: short-circuit detector flag
    inline uint32_t DFSDM_DFSDM2_ISR_SCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_ISR: DFSDM interrupt and status register
  #define DFSDM_DFSDM3_ISR (* ((const volatile uint32_t *) (0x40017000 + 204)))

  // Field JEOCF: End of injected conversion flag
    const uint32_t DFSDM_DFSDM3_ISR_JEOCF = 1U << 0 ;

  // Field REOCF: End of regular conversion flag
    const uint32_t DFSDM_DFSDM3_ISR_REOCF = 1U << 1 ;

  // Field JOVRF: Injected conversion overrun flag
    const uint32_t DFSDM_DFSDM3_ISR_JOVRF = 1U << 2 ;

  // Field ROVRF: Regular conversion overrun flag
    const uint32_t DFSDM_DFSDM3_ISR_ROVRF = 1U << 3 ;

  // Field AWDF: Analog watchdog
    const uint32_t DFSDM_DFSDM3_ISR_AWDF = 1U << 4 ;

  // Field JCIP: Injected conversion in progress status
    const uint32_t DFSDM_DFSDM3_ISR_JCIP = 1U << 13 ;

  // Field RCIP: Regular conversion in progress status
    const uint32_t DFSDM_DFSDM3_ISR_RCIP = 1U << 14 ;

  // Field CKABF: Clock absence flag
    inline uint32_t DFSDM_DFSDM3_ISR_CKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field SCDF: short-circuit detector flag
    inline uint32_t DFSDM_DFSDM3_ISR_SCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_ICR: DFSDM interrupt flag clear register
  #define DFSDM_DFSDM0_ICR (* ((volatile uint32_t *) (0x40017000 + 208)))

  // Field CLRJOVRF: Clear the injected conversion overrun flag
    const uint32_t DFSDM_DFSDM0_ICR_CLRJOVRF = 1U << 2 ;

  // Field CLRROVRF: Clear the regular conversion overrun flag
    const uint32_t DFSDM_DFSDM0_ICR_CLRROVRF = 1U << 3 ;

  // Field CLRCKABF: Clear the clock absence flag
    inline uint32_t DFSDM_DFSDM0_ICR_CLRCKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CLRSCDF: Clear the short-circuit detector flag
    inline uint32_t DFSDM_DFSDM0_ICR_CLRSCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_ICR: DFSDM interrupt flag clear register
  #define DFSDM_DFSDM1_ICR (* ((volatile uint32_t *) (0x40017000 + 212)))

  // Field CLRJOVRF: Clear the injected conversion overrun flag
    const uint32_t DFSDM_DFSDM1_ICR_CLRJOVRF = 1U << 2 ;

  // Field CLRROVRF: Clear the regular conversion overrun flag
    const uint32_t DFSDM_DFSDM1_ICR_CLRROVRF = 1U << 3 ;

  // Field CLRCKABF: Clear the clock absence flag
    inline uint32_t DFSDM_DFSDM1_ICR_CLRCKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CLRSCDF: Clear the short-circuit detector flag
    inline uint32_t DFSDM_DFSDM1_ICR_CLRSCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_ICR: DFSDM interrupt flag clear register
  #define DFSDM_DFSDM2_ICR (* ((volatile uint32_t *) (0x40017000 + 216)))

  // Field CLRJOVRF: Clear the injected conversion overrun flag
    const uint32_t DFSDM_DFSDM2_ICR_CLRJOVRF = 1U << 2 ;

  // Field CLRROVRF: Clear the regular conversion overrun flag
    const uint32_t DFSDM_DFSDM2_ICR_CLRROVRF = 1U << 3 ;

  // Field CLRCKABF: Clear the clock absence flag
    inline uint32_t DFSDM_DFSDM2_ICR_CLRCKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CLRSCDF: Clear the short-circuit detector flag
    inline uint32_t DFSDM_DFSDM2_ICR_CLRSCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_ICR: DFSDM interrupt flag clear register
  #define DFSDM_DFSDM3_ICR (* ((volatile uint32_t *) (0x40017000 + 220)))

  // Field CLRJOVRF: Clear the injected conversion overrun flag
    const uint32_t DFSDM_DFSDM3_ICR_CLRJOVRF = 1U << 2 ;

  // Field CLRROVRF: Clear the regular conversion overrun flag
    const uint32_t DFSDM_DFSDM3_ICR_CLRROVRF = 1U << 3 ;

  // Field CLRCKABF: Clear the clock absence flag
    inline uint32_t DFSDM_DFSDM3_ICR_CLRCKABF (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CLRSCDF: Clear the short-circuit detector flag
    inline uint32_t DFSDM_DFSDM3_ICR_CLRSCDF (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_JCHGR: DFSDM injected channel group selection register
  #define DFSDM_DFSDM0_JCHGR (* ((volatile uint32_t *) (0x40017000 + 224)))

  // Field JCHG: Injected channel group selection
    inline uint32_t DFSDM_DFSDM0_JCHGR_JCHG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_JCHGR: DFSDM injected channel group selection register
  #define DFSDM_DFSDM1_JCHGR (* ((volatile uint32_t *) (0x40017000 + 228)))

  // Field JCHG: Injected channel group selection
    inline uint32_t DFSDM_DFSDM1_JCHGR_JCHG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_JCHGR: DFSDM injected channel group selection register
  #define DFSDM_DFSDM2_JCHGR (* ((volatile uint32_t *) (0x40017000 + 232)))

  // Field JCHG: Injected channel group selection
    inline uint32_t DFSDM_DFSDM2_JCHGR_JCHG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_JCHGR: DFSDM injected channel group selection register
  #define DFSDM_DFSDM3_JCHGR (* ((volatile uint32_t *) (0x40017000 + 236)))

  // Field JCHG: Injected channel group selection
    inline uint32_t DFSDM_DFSDM3_JCHGR_JCHG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_FCR: DFSDM filter control register
  #define DFSDM_DFSDM0_FCR (* ((volatile uint32_t *) (0x40017000 + 240)))

  // Field IOSR: Integrator oversampling ratio (averaging length)
    inline uint32_t DFSDM_DFSDM0_FCR_IOSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FOSR: Sinc filter oversampling ratio (decimation rate)
    inline uint32_t DFSDM_DFSDM0_FCR_FOSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field FORD: Sinc filter order
    inline uint32_t DFSDM_DFSDM0_FCR_FORD (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_FCR: DFSDM filter control register
  #define DFSDM_DFSDM1_FCR (* ((volatile uint32_t *) (0x40017000 + 244)))

  // Field IOSR: Integrator oversampling ratio (averaging length)
    inline uint32_t DFSDM_DFSDM1_FCR_IOSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FOSR: Sinc filter oversampling ratio (decimation rate)
    inline uint32_t DFSDM_DFSDM1_FCR_FOSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field FORD: Sinc filter order
    inline uint32_t DFSDM_DFSDM1_FCR_FORD (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_FCR: DFSDM filter control register
  #define DFSDM_DFSDM2_FCR (* ((volatile uint32_t *) (0x40017000 + 248)))

  // Field IOSR: Integrator oversampling ratio (averaging length)
    inline uint32_t DFSDM_DFSDM2_FCR_IOSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FOSR: Sinc filter oversampling ratio (decimation rate)
    inline uint32_t DFSDM_DFSDM2_FCR_FOSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field FORD: Sinc filter order
    inline uint32_t DFSDM_DFSDM2_FCR_FORD (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_FCR: DFSDM filter control register
  #define DFSDM_DFSDM3_FCR (* ((volatile uint32_t *) (0x40017000 + 252)))

  // Field IOSR: Integrator oversampling ratio (averaging length)
    inline uint32_t DFSDM_DFSDM3_FCR_IOSR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FOSR: Sinc filter oversampling ratio (decimation rate)
    inline uint32_t DFSDM_DFSDM3_FCR_FOSR (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field FORD: Sinc filter order
    inline uint32_t DFSDM_DFSDM3_FCR_FORD (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_JDATAR: DFSDM data register for injected group
  #define DFSDM_DFSDM0_JDATAR (* ((const volatile uint32_t *) (0x40017000 + 256)))

  // Field JDATACH: Injected channel most recently converted
    inline uint32_t DFSDM_DFSDM0_JDATAR_JDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field JDATA: Injected group conversion data
    inline uint32_t DFSDM_DFSDM0_JDATAR_JDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_JDATAR: DFSDM data register for injected group
  #define DFSDM_DFSDM1_JDATAR (* ((const volatile uint32_t *) (0x40017000 + 260)))

  // Field JDATACH: Injected channel most recently converted
    inline uint32_t DFSDM_DFSDM1_JDATAR_JDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field JDATA: Injected group conversion data
    inline uint32_t DFSDM_DFSDM1_JDATAR_JDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_JDATAR: DFSDM data register for injected group
  #define DFSDM_DFSDM2_JDATAR (* ((const volatile uint32_t *) (0x40017000 + 264)))

  // Field JDATACH: Injected channel most recently converted
    inline uint32_t DFSDM_DFSDM2_JDATAR_JDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field JDATA: Injected group conversion data
    inline uint32_t DFSDM_DFSDM2_JDATAR_JDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_JDATAR: DFSDM data register for injected group
  #define DFSDM_DFSDM3_JDATAR (* ((const volatile uint32_t *) (0x40017000 + 268)))

  // Field JDATACH: Injected channel most recently converted
    inline uint32_t DFSDM_DFSDM3_JDATAR_JDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field JDATA: Injected group conversion data
    inline uint32_t DFSDM_DFSDM3_JDATAR_JDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_RDATAR: DFSDM data register for the regular channel
  #define DFSDM_DFSDM0_RDATAR (* ((const volatile uint32_t *) (0x40017000 + 272)))

  // Field RDATACH: Regular channel most recently converted
    inline uint32_t DFSDM_DFSDM0_RDATAR_RDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RPEND: Regular channel pending data
    const uint32_t DFSDM_DFSDM0_RDATAR_RPEND = 1U << 4 ;

  // Field RDATA: Regular channel conversion data
    inline uint32_t DFSDM_DFSDM0_RDATAR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_RDATAR: DFSDM data register for the regular channel
  #define DFSDM_DFSDM1_RDATAR (* ((const volatile uint32_t *) (0x40017000 + 276)))

  // Field RDATACH: Regular channel most recently converted
    inline uint32_t DFSDM_DFSDM1_RDATAR_RDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RPEND: Regular channel pending data
    const uint32_t DFSDM_DFSDM1_RDATAR_RPEND = 1U << 4 ;

  // Field RDATA: Regular channel conversion data
    inline uint32_t DFSDM_DFSDM1_RDATAR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_RDATAR: DFSDM data register for the regular channel
  #define DFSDM_DFSDM2_RDATAR (* ((const volatile uint32_t *) (0x40017000 + 280)))

  // Field RDATACH: Regular channel most recently converted
    inline uint32_t DFSDM_DFSDM2_RDATAR_RDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RPEND: Regular channel pending data
    const uint32_t DFSDM_DFSDM2_RDATAR_RPEND = 1U << 4 ;

  // Field RDATA: Regular channel conversion data
    inline uint32_t DFSDM_DFSDM2_RDATAR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_RDATAR: DFSDM data register for the regular channel
  #define DFSDM_DFSDM3_RDATAR (* ((const volatile uint32_t *) (0x40017000 + 284)))

  // Field RDATACH: Regular channel most recently converted
    inline uint32_t DFSDM_DFSDM3_RDATAR_RDATACH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field RPEND: Regular channel pending data
    const uint32_t DFSDM_DFSDM3_RDATAR_RPEND = 1U << 4 ;

  // Field RDATA: Regular channel conversion data
    inline uint32_t DFSDM_DFSDM3_RDATAR_RDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_AWHTR: DFSDM analog watchdog high threshold register
  #define DFSDM_DFSDM0_AWHTR (* ((volatile uint32_t *) (0x40017000 + 288)))

  // Field BKAWH: Break signal assignment to analog watchdog high threshold event
    inline uint32_t DFSDM_DFSDM0_AWHTR_BKAWH (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWHT: Analog watchdog high threshold
    inline uint32_t DFSDM_DFSDM0_AWHTR_AWHT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_AWHTR: DFSDM analog watchdog high threshold register
  #define DFSDM_DFSDM1_AWHTR (* ((volatile uint32_t *) (0x40017000 + 292)))

  // Field BKAWH: Break signal assignment to analog watchdog high threshold event
    inline uint32_t DFSDM_DFSDM1_AWHTR_BKAWH (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWHT: Analog watchdog high threshold
    inline uint32_t DFSDM_DFSDM1_AWHTR_AWHT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_AWHTR: DFSDM analog watchdog high threshold register
  #define DFSDM_DFSDM2_AWHTR (* ((volatile uint32_t *) (0x40017000 + 296)))

  // Field BKAWH: Break signal assignment to analog watchdog high threshold event
    inline uint32_t DFSDM_DFSDM2_AWHTR_BKAWH (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWHT: Analog watchdog high threshold
    inline uint32_t DFSDM_DFSDM2_AWHTR_AWHT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_AWHTR: DFSDM analog watchdog high threshold register
  #define DFSDM_DFSDM3_AWHTR (* ((volatile uint32_t *) (0x40017000 + 300)))

  // Field BKAWH: Break signal assignment to analog watchdog high threshold event
    inline uint32_t DFSDM_DFSDM3_AWHTR_BKAWH (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWHT: Analog watchdog high threshold
    inline uint32_t DFSDM_DFSDM3_AWHTR_AWHT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_AWLTR: DFSDM analog watchdog low threshold register
  #define DFSDM_DFSDM0_AWLTR (* ((volatile uint32_t *) (0x40017000 + 304)))

  // Field BKAWL: Break signal assignment to analog watchdog low threshold event
    inline uint32_t DFSDM_DFSDM0_AWLTR_BKAWL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWLT: Analog watchdog low threshold
    inline uint32_t DFSDM_DFSDM0_AWLTR_AWLT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_AWLTR: DFSDM analog watchdog low threshold register
  #define DFSDM_DFSDM1_AWLTR (* ((volatile uint32_t *) (0x40017000 + 308)))

  // Field BKAWL: Break signal assignment to analog watchdog low threshold event
    inline uint32_t DFSDM_DFSDM1_AWLTR_BKAWL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWLT: Analog watchdog low threshold
    inline uint32_t DFSDM_DFSDM1_AWLTR_AWLT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_AWLTR: DFSDM analog watchdog low threshold register
  #define DFSDM_DFSDM2_AWLTR (* ((volatile uint32_t *) (0x40017000 + 312)))

  // Field BKAWL: Break signal assignment to analog watchdog low threshold event
    inline uint32_t DFSDM_DFSDM2_AWLTR_BKAWL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWLT: Analog watchdog low threshold
    inline uint32_t DFSDM_DFSDM2_AWLTR_AWLT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_AWLTR: DFSDM analog watchdog low threshold register
  #define DFSDM_DFSDM3_AWLTR (* ((volatile uint32_t *) (0x40017000 + 316)))

  // Field BKAWL: Break signal assignment to analog watchdog low threshold event
    inline uint32_t DFSDM_DFSDM3_AWLTR_BKAWL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AWLT: Analog watchdog low threshold
    inline uint32_t DFSDM_DFSDM3_AWLTR_AWLT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_AWSR: DFSDM analog watchdog status register
  #define DFSDM_DFSDM0_AWSR (* ((const volatile uint32_t *) (0x40017000 + 320)))

  // Field AWLTF: Analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM0_AWSR_AWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field AWHTF: Analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM0_AWSR_AWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_AWSR: DFSDM analog watchdog status register
  #define DFSDM_DFSDM1_AWSR (* ((const volatile uint32_t *) (0x40017000 + 324)))

  // Field AWLTF: Analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM1_AWSR_AWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field AWHTF: Analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM1_AWSR_AWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_AWSR: DFSDM analog watchdog status register
  #define DFSDM_DFSDM2_AWSR (* ((const volatile uint32_t *) (0x40017000 + 328)))

  // Field AWLTF: Analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM2_AWSR_AWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field AWHTF: Analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM2_AWSR_AWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_AWSR: DFSDM analog watchdog status register
  #define DFSDM_DFSDM3_AWSR (* ((const volatile uint32_t *) (0x40017000 + 332)))

  // Field AWLTF: Analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM3_AWSR_AWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field AWHTF: Analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM3_AWSR_AWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_AWCFR: DFSDM analog watchdog clear flag register
  #define DFSDM_DFSDM0_AWCFR (* ((volatile uint32_t *) (0x40017000 + 336)))

  // Field CLRAWLTF: Clear the analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM0_AWCFR_CLRAWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field CLRAWHTF: Clear the analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM0_AWCFR_CLRAWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_AWCFR: DFSDM analog watchdog clear flag register
  #define DFSDM_DFSDM1_AWCFR (* ((volatile uint32_t *) (0x40017000 + 340)))

  // Field CLRAWLTF: Clear the analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM1_AWCFR_CLRAWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field CLRAWHTF: Clear the analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM1_AWCFR_CLRAWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_AWCFR: DFSDM analog watchdog clear flag register
  #define DFSDM_DFSDM2_AWCFR (* ((volatile uint32_t *) (0x40017000 + 344)))

  // Field CLRAWLTF: Clear the analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM2_AWCFR_CLRAWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field CLRAWHTF: Clear the analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM2_AWCFR_CLRAWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_AWCFR: DFSDM analog watchdog clear flag register
  #define DFSDM_DFSDM3_AWCFR (* ((volatile uint32_t *) (0x40017000 + 348)))

  // Field CLRAWLTF: Clear the analog watchdog low threshold flag
    inline uint32_t DFSDM_DFSDM3_AWCFR_CLRAWLTF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field CLRAWHTF: Clear the analog watchdog high threshold flag
    inline uint32_t DFSDM_DFSDM3_AWCFR_CLRAWHTF (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_EXMAX: DFSDM Extremes detector maximum register
  #define DFSDM_DFSDM0_EXMAX (* ((const volatile uint32_t *) (0x40017000 + 352)))

  // Field EXMAXCH: Extremes detector maximum data channel
    inline uint32_t DFSDM_DFSDM0_EXMAX_EXMAXCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMAX: Extremes detector maximum value
    inline uint32_t DFSDM_DFSDM0_EXMAX_EXMAX (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_EXMAX: DFSDM Extremes detector maximum register
  #define DFSDM_DFSDM1_EXMAX (* ((const volatile uint32_t *) (0x40017000 + 356)))

  // Field EXMAXCH: Extremes detector maximum data channel
    inline uint32_t DFSDM_DFSDM1_EXMAX_EXMAXCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMAX: Extremes detector maximum value
    inline uint32_t DFSDM_DFSDM1_EXMAX_EXMAX (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_EXMAX: DFSDM Extremes detector maximum register
  #define DFSDM_DFSDM2_EXMAX (* ((const volatile uint32_t *) (0x40017000 + 360)))

  // Field EXMAXCH: Extremes detector maximum data channel
    inline uint32_t DFSDM_DFSDM2_EXMAX_EXMAXCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMAX: Extremes detector maximum value
    inline uint32_t DFSDM_DFSDM2_EXMAX_EXMAX (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_EXMAX: DFSDM Extremes detector maximum register
  #define DFSDM_DFSDM3_EXMAX (* ((const volatile uint32_t *) (0x40017000 + 364)))

  // Field EXMAXCH: Extremes detector maximum data channel
    inline uint32_t DFSDM_DFSDM3_EXMAX_EXMAXCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMAX: Extremes detector maximum value
    inline uint32_t DFSDM_DFSDM3_EXMAX_EXMAX (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_EXMIN: DFSDM Extremes detector minimum register
  #define DFSDM_DFSDM0_EXMIN (* ((const volatile uint32_t *) (0x40017000 + 368)))

  // Field EXMINCH: Extremes detector minimum data channel
    inline uint32_t DFSDM_DFSDM0_EXMIN_EXMINCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMIN: Extremes detector minimum value
    inline uint32_t DFSDM_DFSDM0_EXMIN_EXMIN (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_EXMIN: DFSDM Extremes detector minimum register
  #define DFSDM_DFSDM1_EXMIN (* ((const volatile uint32_t *) (0x40017000 + 372)))

  // Field EXMINCH: Extremes detector minimum data channel
    inline uint32_t DFSDM_DFSDM1_EXMIN_EXMINCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMIN: Extremes detector minimum value
    inline uint32_t DFSDM_DFSDM1_EXMIN_EXMIN (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_EXMIN: DFSDM Extremes detector minimum register
  #define DFSDM_DFSDM2_EXMIN (* ((const volatile uint32_t *) (0x40017000 + 376)))

  // Field EXMINCH: Extremes detector minimum data channel
    inline uint32_t DFSDM_DFSDM2_EXMIN_EXMINCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMIN: Extremes detector minimum value
    inline uint32_t DFSDM_DFSDM2_EXMIN_EXMIN (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_EXMIN: DFSDM Extremes detector minimum register
  #define DFSDM_DFSDM3_EXMIN (* ((const volatile uint32_t *) (0x40017000 + 380)))

  // Field EXMINCH: Extremes detector minimum data channel
    inline uint32_t DFSDM_DFSDM3_EXMIN_EXMINCH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field EXMIN: Extremes detector minimum value
    inline uint32_t DFSDM_DFSDM3_EXMIN_EXMIN (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM0_CNVTIMR: DFSDM conversion timer register
  #define DFSDM_DFSDM0_CNVTIMR (* ((const volatile uint32_t *) (0x40017000 + 384)))

  // Field CNVCNT: 28-bit timer counting conversion time
    inline uint32_t DFSDM_DFSDM0_CNVTIMR_CNVCNT (const uint32_t inValue) {return (inValue & 0xFFFFFFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM1_CNVTIMR: DFSDM conversion timer register
  #define DFSDM_DFSDM1_CNVTIMR (* ((const volatile uint32_t *) (0x40017000 + 388)))

  // Field CNVCNT: 28-bit timer counting conversion time
    inline uint32_t DFSDM_DFSDM1_CNVTIMR_CNVCNT (const uint32_t inValue) {return (inValue & 0xFFFFFFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM2_CNVTIMR: DFSDM conversion timer register
  #define DFSDM_DFSDM2_CNVTIMR (* ((const volatile uint32_t *) (0x40017000 + 392)))

  // Field CNVCNT: 28-bit timer counting conversion time
    inline uint32_t DFSDM_DFSDM2_CNVTIMR_CNVCNT (const uint32_t inValue) {return (inValue & 0xFFFFFFFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DFSDM3_CNVTIMR: DFSDM conversion timer register
  #define DFSDM_DFSDM3_CNVTIMR (* ((const volatile uint32_t *) (0x40017000 + 396)))

  // Field CNVCNT: 28-bit timer counting conversion time
    inline uint32_t DFSDM_DFSDM3_CNVTIMR_CNVCNT (const uint32_t inValue) {return (inValue & 0xFFFFFFFU) << 4 ; }

//------------------------------------------------------------------------------
// Peripheral DMA1: DMA controller
//------------------------------------------------------------------------------

//---  Register LISR: low interrupt status register
  #define DMA1_LISR (* ((const volatile uint32_t *) (0x40020000 + 0)))

  // Field TCIF3: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LISR_TCIF3 = 1U << 27 ;

  // Field HTIF3: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_HTIF3 = 1U << 26 ;

  // Field TEIF3: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_TEIF3 = 1U << 25 ;

  // Field DMEIF3: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_DMEIF3 = 1U << 24 ;

  // Field FEIF3: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_FEIF3 = 1U << 22 ;

  // Field TCIF2: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LISR_TCIF2 = 1U << 21 ;

  // Field HTIF2: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_HTIF2 = 1U << 20 ;

  // Field TEIF2: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_TEIF2 = 1U << 19 ;

  // Field DMEIF2: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_DMEIF2 = 1U << 18 ;

  // Field FEIF2: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_FEIF2 = 1U << 16 ;

  // Field TCIF1: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LISR_TCIF1 = 1U << 11 ;

  // Field HTIF1: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_HTIF1 = 1U << 10 ;

  // Field TEIF1: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_TEIF1 = 1U << 9 ;

  // Field DMEIF1: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_DMEIF1 = 1U << 8 ;

  // Field FEIF1: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_FEIF1 = 1U << 6 ;

  // Field TCIF0: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LISR_TCIF0 = 1U << 5 ;

  // Field HTIF0: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_HTIF0 = 1U << 4 ;

  // Field TEIF0: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_TEIF0 = 1U << 3 ;

  // Field DMEIF0: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_DMEIF0 = 1U << 2 ;

  // Field FEIF0: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA1_LISR_FEIF0 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register HISR: high interrupt status register
  #define DMA1_HISR (* ((const volatile uint32_t *) (0x40020000 + 4)))

  // Field TCIF7: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TCIF7 = 1U << 27 ;

  // Field HTIF7: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_HTIF7 = 1U << 26 ;

  // Field TEIF7: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TEIF7 = 1U << 25 ;

  // Field DMEIF7: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_DMEIF7 = 1U << 24 ;

  // Field FEIF7: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_FEIF7 = 1U << 22 ;

  // Field TCIF6: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TCIF6 = 1U << 21 ;

  // Field HTIF6: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_HTIF6 = 1U << 20 ;

  // Field TEIF6: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TEIF6 = 1U << 19 ;

  // Field DMEIF6: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_DMEIF6 = 1U << 18 ;

  // Field FEIF6: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_FEIF6 = 1U << 16 ;

  // Field TCIF5: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TCIF5 = 1U << 11 ;

  // Field HTIF5: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_HTIF5 = 1U << 10 ;

  // Field TEIF5: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TEIF5 = 1U << 9 ;

  // Field DMEIF5: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_DMEIF5 = 1U << 8 ;

  // Field FEIF5: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_FEIF5 = 1U << 6 ;

  // Field TCIF4: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TCIF4 = 1U << 5 ;

  // Field HTIF4: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_HTIF4 = 1U << 4 ;

  // Field TEIF4: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_TEIF4 = 1U << 3 ;

  // Field DMEIF4: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_DMEIF4 = 1U << 2 ;

  // Field FEIF4: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA1_HISR_FEIF4 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register LIFCR: low interrupt flag clear register
  #define DMA1_LIFCR (* ((volatile uint32_t *) (0x40020000 + 8)))

  // Field CTCIF3: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTCIF3 = 1U << 27 ;

  // Field CHTIF3: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CHTIF3 = 1U << 26 ;

  // Field CTEIF3: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTEIF3 = 1U << 25 ;

  // Field CDMEIF3: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CDMEIF3 = 1U << 24 ;

  // Field CFEIF3: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CFEIF3 = 1U << 22 ;

  // Field CTCIF2: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTCIF2 = 1U << 21 ;

  // Field CHTIF2: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CHTIF2 = 1U << 20 ;

  // Field CTEIF2: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTEIF2 = 1U << 19 ;

  // Field CDMEIF2: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CDMEIF2 = 1U << 18 ;

  // Field CFEIF2: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CFEIF2 = 1U << 16 ;

  // Field CTCIF1: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTCIF1 = 1U << 11 ;

  // Field CHTIF1: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CHTIF1 = 1U << 10 ;

  // Field CTEIF1: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTEIF1 = 1U << 9 ;

  // Field CDMEIF1: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CDMEIF1 = 1U << 8 ;

  // Field CFEIF1: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CFEIF1 = 1U << 6 ;

  // Field CTCIF0: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTCIF0 = 1U << 5 ;

  // Field CHTIF0: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CHTIF0 = 1U << 4 ;

  // Field CTEIF0: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CTEIF0 = 1U << 3 ;

  // Field CDMEIF0: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CDMEIF0 = 1U << 2 ;

  // Field CFEIF0: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA1_LIFCR_CFEIF0 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register HIFCR: high interrupt flag clear register
  #define DMA1_HIFCR (* ((volatile uint32_t *) (0x40020000 + 12)))

  // Field CTCIF7: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTCIF7 = 1U << 27 ;

  // Field CHTIF7: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CHTIF7 = 1U << 26 ;

  // Field CTEIF7: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTEIF7 = 1U << 25 ;

  // Field CDMEIF7: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CDMEIF7 = 1U << 24 ;

  // Field CFEIF7: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CFEIF7 = 1U << 22 ;

  // Field CTCIF6: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTCIF6 = 1U << 21 ;

  // Field CHTIF6: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CHTIF6 = 1U << 20 ;

  // Field CTEIF6: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTEIF6 = 1U << 19 ;

  // Field CDMEIF6: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CDMEIF6 = 1U << 18 ;

  // Field CFEIF6: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CFEIF6 = 1U << 16 ;

  // Field CTCIF5: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTCIF5 = 1U << 11 ;

  // Field CHTIF5: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CHTIF5 = 1U << 10 ;

  // Field CTEIF5: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTEIF5 = 1U << 9 ;

  // Field CDMEIF5: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CDMEIF5 = 1U << 8 ;

  // Field CFEIF5: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CFEIF5 = 1U << 6 ;

  // Field CTCIF4: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTCIF4 = 1U << 5 ;

  // Field CHTIF4: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CHTIF4 = 1U << 4 ;

  // Field CTEIF4: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CTEIF4 = 1U << 3 ;

  // Field CDMEIF4: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CDMEIF4 = 1U << 2 ;

  // Field CFEIF4: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA1_HIFCR_CFEIF4 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S0CR: stream x configuration register
  #define DMA1_S0CR (* ((volatile uint32_t *) (0x40020000 + 16)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S0CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S0CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S0CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S0CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S0CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S0CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S0CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S0CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S0CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S0CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S0CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S0CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S0CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S0CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S0CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S0CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S0CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S0CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S0NDTR: stream x number of data register
  #define DMA1_S0NDTR (* ((volatile uint32_t *) (0x40020000 + 20)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S0NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0PAR: stream x peripheral address register
  #define DMA1_S0PAR (* ((volatile uint32_t *) (0x40020000 + 24)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S0PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0M0AR: stream x memory 0 address register
  #define DMA1_S0M0AR (* ((volatile uint32_t *) (0x40020000 + 28)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S0M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0M1AR: stream x memory 1 address register
  #define DMA1_S0M1AR (* ((volatile uint32_t *) (0x40020000 + 32)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S0M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0FCR: stream x FIFO control register
  #define DMA1_S0FCR (* ((volatile uint32_t *) (0x40020000 + 36)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S0FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S0FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S0FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S0FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1CR: stream x configuration register
  #define DMA1_S1CR (* ((volatile uint32_t *) (0x40020000 + 40)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S1CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S1CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S1CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S1CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S1CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S1CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S1CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S1CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S1CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S1CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S1CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S1CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S1CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S1CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S1CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S1CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S1CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S1CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S1CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S1NDTR: stream x number of data register
  #define DMA1_S1NDTR (* ((volatile uint32_t *) (0x40020000 + 44)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S1NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1PAR: stream x peripheral address register
  #define DMA1_S1PAR (* ((volatile uint32_t *) (0x40020000 + 48)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S1PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1M0AR: stream x memory 0 address register
  #define DMA1_S1M0AR (* ((volatile uint32_t *) (0x40020000 + 52)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S1M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1M1AR: stream x memory 1 address register
  #define DMA1_S1M1AR (* ((volatile uint32_t *) (0x40020000 + 56)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S1M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1FCR: stream x FIFO control register
  #define DMA1_S1FCR (* ((volatile uint32_t *) (0x40020000 + 60)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S1FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S1FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S1FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S1FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2CR: stream x configuration register
  #define DMA1_S2CR (* ((volatile uint32_t *) (0x40020000 + 64)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S2CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S2CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S2CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S2CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S2CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S2CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S2CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S2CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S2CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S2CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S2CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S2CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S2CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S2CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S2CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S2CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S2CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S2CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S2CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S2NDTR: stream x number of data register
  #define DMA1_S2NDTR (* ((volatile uint32_t *) (0x40020000 + 68)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S2NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2PAR: stream x peripheral address register
  #define DMA1_S2PAR (* ((volatile uint32_t *) (0x40020000 + 72)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S2PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2M0AR: stream x memory 0 address register
  #define DMA1_S2M0AR (* ((volatile uint32_t *) (0x40020000 + 76)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S2M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2M1AR: stream x memory 1 address register
  #define DMA1_S2M1AR (* ((volatile uint32_t *) (0x40020000 + 80)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S2M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2FCR: stream x FIFO control register
  #define DMA1_S2FCR (* ((volatile uint32_t *) (0x40020000 + 84)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S2FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S2FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S2FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S2FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3CR: stream x configuration register
  #define DMA1_S3CR (* ((volatile uint32_t *) (0x40020000 + 88)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S3CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S3CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S3CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S3CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S3CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S3CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S3CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S3CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S3CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S3CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S3CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S3CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S3CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S3CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S3CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S3CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S3CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S3CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S3CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S3NDTR: stream x number of data register
  #define DMA1_S3NDTR (* ((volatile uint32_t *) (0x40020000 + 92)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S3NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3PAR: stream x peripheral address register
  #define DMA1_S3PAR (* ((volatile uint32_t *) (0x40020000 + 96)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S3PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3M0AR: stream x memory 0 address register
  #define DMA1_S3M0AR (* ((volatile uint32_t *) (0x40020000 + 100)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S3M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3M1AR: stream x memory 1 address register
  #define DMA1_S3M1AR (* ((volatile uint32_t *) (0x40020000 + 104)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S3M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3FCR: stream x FIFO control register
  #define DMA1_S3FCR (* ((volatile uint32_t *) (0x40020000 + 108)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S3FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S3FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S3FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S3FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4CR: stream x configuration register
  #define DMA1_S4CR (* ((volatile uint32_t *) (0x40020000 + 112)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S4CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S4CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S4CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S4CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S4CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S4CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S4CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S4CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S4CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S4CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S4CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S4CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S4CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S4CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S4CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S4CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S4CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S4CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S4CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S4NDTR: stream x number of data register
  #define DMA1_S4NDTR (* ((volatile uint32_t *) (0x40020000 + 116)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S4NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4PAR: stream x peripheral address register
  #define DMA1_S4PAR (* ((volatile uint32_t *) (0x40020000 + 120)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S4PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4M0AR: stream x memory 0 address register
  #define DMA1_S4M0AR (* ((volatile uint32_t *) (0x40020000 + 124)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S4M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4M1AR: stream x memory 1 address register
  #define DMA1_S4M1AR (* ((volatile uint32_t *) (0x40020000 + 128)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S4M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4FCR: stream x FIFO control register
  #define DMA1_S4FCR (* ((volatile uint32_t *) (0x40020000 + 132)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S4FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S4FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S4FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S4FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5CR: stream x configuration register
  #define DMA1_S5CR (* ((volatile uint32_t *) (0x40020000 + 136)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S5CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S5CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S5CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S5CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S5CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S5CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S5CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S5CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S5CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S5CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S5CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S5CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S5CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S5CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S5CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S5CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S5CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S5CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S5CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S5NDTR: stream x number of data register
  #define DMA1_S5NDTR (* ((volatile uint32_t *) (0x40020000 + 140)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S5NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5PAR: stream x peripheral address register
  #define DMA1_S5PAR (* ((volatile uint32_t *) (0x40020000 + 144)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S5PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5M0AR: stream x memory 0 address register
  #define DMA1_S5M0AR (* ((volatile uint32_t *) (0x40020000 + 148)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S5M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5M1AR: stream x memory 1 address register
  #define DMA1_S5M1AR (* ((volatile uint32_t *) (0x40020000 + 152)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S5M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5FCR: stream x FIFO control register
  #define DMA1_S5FCR (* ((volatile uint32_t *) (0x40020000 + 156)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S5FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S5FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S5FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S5FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6CR: stream x configuration register
  #define DMA1_S6CR (* ((volatile uint32_t *) (0x40020000 + 160)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S6CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S6CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S6CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S6CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S6CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S6CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S6CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S6CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S6CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S6CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S6CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S6CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S6CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S6CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S6CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S6CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S6CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S6CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S6CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S6NDTR: stream x number of data register
  #define DMA1_S6NDTR (* ((volatile uint32_t *) (0x40020000 + 164)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S6NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6PAR: stream x peripheral address register
  #define DMA1_S6PAR (* ((volatile uint32_t *) (0x40020000 + 168)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S6PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6M0AR: stream x memory 0 address register
  #define DMA1_S6M0AR (* ((volatile uint32_t *) (0x40020000 + 172)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S6M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6M1AR: stream x memory 1 address register
  #define DMA1_S6M1AR (* ((volatile uint32_t *) (0x40020000 + 176)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S6M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6FCR: stream x FIFO control register
  #define DMA1_S6FCR (* ((volatile uint32_t *) (0x40020000 + 180)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S6FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S6FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S6FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S6FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7CR: stream x configuration register
  #define DMA1_S7CR (* ((volatile uint32_t *) (0x40020000 + 184)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA1_S7CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA1_S7CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA1_S7CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA1_S7CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA1_S7CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA1_S7CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA1_S7CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA1_S7CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA1_S7CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA1_S7CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA1_S7CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA1_S7CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA1_S7CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA1_S7CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA1_S7CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA1_S7CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA1_S7CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA1_S7CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA1_S7CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S7NDTR: stream x number of data register
  #define DMA1_S7NDTR (* ((volatile uint32_t *) (0x40020000 + 188)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA1_S7NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7PAR: stream x peripheral address register
  #define DMA1_S7PAR (* ((volatile uint32_t *) (0x40020000 + 192)))

  // Field PA: Peripheral address
    inline uint32_t DMA1_S7PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7M0AR: stream x memory 0 address register
  #define DMA1_S7M0AR (* ((volatile uint32_t *) (0x40020000 + 196)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA1_S7M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7M1AR: stream x memory 1 address register
  #define DMA1_S7M1AR (* ((volatile uint32_t *) (0x40020000 + 200)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA1_S7M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7FCR: stream x FIFO control register
  #define DMA1_S7FCR (* ((volatile uint32_t *) (0x40020000 + 204)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA1_S7FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA1_S7FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA1_S7FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA1_S7FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral DMA2
//------------------------------------------------------------------------------

//---  Register LISR: low interrupt status register
  #define DMA2_LISR (* ((const volatile uint32_t *) (0x40020400 + 0)))

  // Field TCIF3: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LISR_TCIF3 = 1U << 27 ;

  // Field HTIF3: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_HTIF3 = 1U << 26 ;

  // Field TEIF3: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_TEIF3 = 1U << 25 ;

  // Field DMEIF3: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_DMEIF3 = 1U << 24 ;

  // Field FEIF3: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_FEIF3 = 1U << 22 ;

  // Field TCIF2: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LISR_TCIF2 = 1U << 21 ;

  // Field HTIF2: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_HTIF2 = 1U << 20 ;

  // Field TEIF2: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_TEIF2 = 1U << 19 ;

  // Field DMEIF2: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_DMEIF2 = 1U << 18 ;

  // Field FEIF2: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_FEIF2 = 1U << 16 ;

  // Field TCIF1: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LISR_TCIF1 = 1U << 11 ;

  // Field HTIF1: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_HTIF1 = 1U << 10 ;

  // Field TEIF1: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_TEIF1 = 1U << 9 ;

  // Field DMEIF1: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_DMEIF1 = 1U << 8 ;

  // Field FEIF1: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_FEIF1 = 1U << 6 ;

  // Field TCIF0: Stream x transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LISR_TCIF0 = 1U << 5 ;

  // Field HTIF0: Stream x half transfer interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_HTIF0 = 1U << 4 ;

  // Field TEIF0: Stream x transfer error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_TEIF0 = 1U << 3 ;

  // Field DMEIF0: Stream x direct mode error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_DMEIF0 = 1U << 2 ;

  // Field FEIF0: Stream x FIFO error interrupt flag (x=3..0)
    const uint32_t DMA2_LISR_FEIF0 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register HISR: high interrupt status register
  #define DMA2_HISR (* ((const volatile uint32_t *) (0x40020400 + 4)))

  // Field TCIF7: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TCIF7 = 1U << 27 ;

  // Field HTIF7: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_HTIF7 = 1U << 26 ;

  // Field TEIF7: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TEIF7 = 1U << 25 ;

  // Field DMEIF7: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_DMEIF7 = 1U << 24 ;

  // Field FEIF7: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_FEIF7 = 1U << 22 ;

  // Field TCIF6: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TCIF6 = 1U << 21 ;

  // Field HTIF6: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_HTIF6 = 1U << 20 ;

  // Field TEIF6: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TEIF6 = 1U << 19 ;

  // Field DMEIF6: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_DMEIF6 = 1U << 18 ;

  // Field FEIF6: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_FEIF6 = 1U << 16 ;

  // Field TCIF5: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TCIF5 = 1U << 11 ;

  // Field HTIF5: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_HTIF5 = 1U << 10 ;

  // Field TEIF5: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TEIF5 = 1U << 9 ;

  // Field DMEIF5: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_DMEIF5 = 1U << 8 ;

  // Field FEIF5: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_FEIF5 = 1U << 6 ;

  // Field TCIF4: Stream x transfer complete interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TCIF4 = 1U << 5 ;

  // Field HTIF4: Stream x half transfer interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_HTIF4 = 1U << 4 ;

  // Field TEIF4: Stream x transfer error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_TEIF4 = 1U << 3 ;

  // Field DMEIF4: Stream x direct mode error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_DMEIF4 = 1U << 2 ;

  // Field FEIF4: Stream x FIFO error interrupt flag (x=7..4)
    const uint32_t DMA2_HISR_FEIF4 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register LIFCR: low interrupt flag clear register
  #define DMA2_LIFCR (* ((volatile uint32_t *) (0x40020400 + 8)))

  // Field CTCIF3: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTCIF3 = 1U << 27 ;

  // Field CHTIF3: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CHTIF3 = 1U << 26 ;

  // Field CTEIF3: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTEIF3 = 1U << 25 ;

  // Field CDMEIF3: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CDMEIF3 = 1U << 24 ;

  // Field CFEIF3: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CFEIF3 = 1U << 22 ;

  // Field CTCIF2: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTCIF2 = 1U << 21 ;

  // Field CHTIF2: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CHTIF2 = 1U << 20 ;

  // Field CTEIF2: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTEIF2 = 1U << 19 ;

  // Field CDMEIF2: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CDMEIF2 = 1U << 18 ;

  // Field CFEIF2: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CFEIF2 = 1U << 16 ;

  // Field CTCIF1: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTCIF1 = 1U << 11 ;

  // Field CHTIF1: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CHTIF1 = 1U << 10 ;

  // Field CTEIF1: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTEIF1 = 1U << 9 ;

  // Field CDMEIF1: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CDMEIF1 = 1U << 8 ;

  // Field CFEIF1: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CFEIF1 = 1U << 6 ;

  // Field CTCIF0: Stream x clear transfer complete interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTCIF0 = 1U << 5 ;

  // Field CHTIF0: Stream x clear half transfer interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CHTIF0 = 1U << 4 ;

  // Field CTEIF0: Stream x clear transfer error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CTEIF0 = 1U << 3 ;

  // Field CDMEIF0: Stream x clear direct mode error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CDMEIF0 = 1U << 2 ;

  // Field CFEIF0: Stream x clear FIFO error interrupt flag (x = 3..0)
    const uint32_t DMA2_LIFCR_CFEIF0 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register HIFCR: high interrupt flag clear register
  #define DMA2_HIFCR (* ((volatile uint32_t *) (0x40020400 + 12)))

  // Field CTCIF7: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTCIF7 = 1U << 27 ;

  // Field CHTIF7: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CHTIF7 = 1U << 26 ;

  // Field CTEIF7: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTEIF7 = 1U << 25 ;

  // Field CDMEIF7: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CDMEIF7 = 1U << 24 ;

  // Field CFEIF7: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CFEIF7 = 1U << 22 ;

  // Field CTCIF6: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTCIF6 = 1U << 21 ;

  // Field CHTIF6: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CHTIF6 = 1U << 20 ;

  // Field CTEIF6: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTEIF6 = 1U << 19 ;

  // Field CDMEIF6: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CDMEIF6 = 1U << 18 ;

  // Field CFEIF6: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CFEIF6 = 1U << 16 ;

  // Field CTCIF5: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTCIF5 = 1U << 11 ;

  // Field CHTIF5: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CHTIF5 = 1U << 10 ;

  // Field CTEIF5: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTEIF5 = 1U << 9 ;

  // Field CDMEIF5: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CDMEIF5 = 1U << 8 ;

  // Field CFEIF5: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CFEIF5 = 1U << 6 ;

  // Field CTCIF4: Stream x clear transfer complete interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTCIF4 = 1U << 5 ;

  // Field CHTIF4: Stream x clear half transfer interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CHTIF4 = 1U << 4 ;

  // Field CTEIF4: Stream x clear transfer error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CTEIF4 = 1U << 3 ;

  // Field CDMEIF4: Stream x clear direct mode error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CDMEIF4 = 1U << 2 ;

  // Field CFEIF4: Stream x clear FIFO error interrupt flag (x = 7..4)
    const uint32_t DMA2_HIFCR_CFEIF4 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S0CR: stream x configuration register
  #define DMA2_S0CR (* ((volatile uint32_t *) (0x40020400 + 16)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S0CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S0CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S0CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S0CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S0CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S0CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S0CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S0CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S0CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S0CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S0CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S0CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S0CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S0CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S0CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S0CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S0CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S0CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S0NDTR: stream x number of data register
  #define DMA2_S0NDTR (* ((volatile uint32_t *) (0x40020400 + 20)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S0NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0PAR: stream x peripheral address register
  #define DMA2_S0PAR (* ((volatile uint32_t *) (0x40020400 + 24)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S0PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0M0AR: stream x memory 0 address register
  #define DMA2_S0M0AR (* ((volatile uint32_t *) (0x40020400 + 28)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S0M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0M1AR: stream x memory 1 address register
  #define DMA2_S0M1AR (* ((volatile uint32_t *) (0x40020400 + 32)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S0M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S0FCR: stream x FIFO control register
  #define DMA2_S0FCR (* ((volatile uint32_t *) (0x40020400 + 36)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S0FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S0FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S0FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S0FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1CR: stream x configuration register
  #define DMA2_S1CR (* ((volatile uint32_t *) (0x40020400 + 40)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S1CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S1CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S1CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S1CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S1CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S1CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S1CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S1CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S1CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S1CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S1CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S1CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S1CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S1CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S1CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S1CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S1CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S1CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S1CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S1NDTR: stream x number of data register
  #define DMA2_S1NDTR (* ((volatile uint32_t *) (0x40020400 + 44)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S1NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1PAR: stream x peripheral address register
  #define DMA2_S1PAR (* ((volatile uint32_t *) (0x40020400 + 48)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S1PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1M0AR: stream x memory 0 address register
  #define DMA2_S1M0AR (* ((volatile uint32_t *) (0x40020400 + 52)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S1M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1M1AR: stream x memory 1 address register
  #define DMA2_S1M1AR (* ((volatile uint32_t *) (0x40020400 + 56)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S1M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S1FCR: stream x FIFO control register
  #define DMA2_S1FCR (* ((volatile uint32_t *) (0x40020400 + 60)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S1FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S1FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S1FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S1FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2CR: stream x configuration register
  #define DMA2_S2CR (* ((volatile uint32_t *) (0x40020400 + 64)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S2CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S2CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S2CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S2CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S2CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S2CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S2CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S2CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S2CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S2CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S2CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S2CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S2CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S2CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S2CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S2CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S2CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S2CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S2CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S2NDTR: stream x number of data register
  #define DMA2_S2NDTR (* ((volatile uint32_t *) (0x40020400 + 68)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S2NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2PAR: stream x peripheral address register
  #define DMA2_S2PAR (* ((volatile uint32_t *) (0x40020400 + 72)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S2PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2M0AR: stream x memory 0 address register
  #define DMA2_S2M0AR (* ((volatile uint32_t *) (0x40020400 + 76)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S2M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2M1AR: stream x memory 1 address register
  #define DMA2_S2M1AR (* ((volatile uint32_t *) (0x40020400 + 80)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S2M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S2FCR: stream x FIFO control register
  #define DMA2_S2FCR (* ((volatile uint32_t *) (0x40020400 + 84)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S2FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S2FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S2FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S2FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3CR: stream x configuration register
  #define DMA2_S3CR (* ((volatile uint32_t *) (0x40020400 + 88)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S3CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S3CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S3CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S3CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S3CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S3CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S3CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S3CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S3CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S3CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S3CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S3CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S3CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S3CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S3CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S3CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S3CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S3CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S3CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S3NDTR: stream x number of data register
  #define DMA2_S3NDTR (* ((volatile uint32_t *) (0x40020400 + 92)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S3NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3PAR: stream x peripheral address register
  #define DMA2_S3PAR (* ((volatile uint32_t *) (0x40020400 + 96)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S3PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3M0AR: stream x memory 0 address register
  #define DMA2_S3M0AR (* ((volatile uint32_t *) (0x40020400 + 100)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S3M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3M1AR: stream x memory 1 address register
  #define DMA2_S3M1AR (* ((volatile uint32_t *) (0x40020400 + 104)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S3M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S3FCR: stream x FIFO control register
  #define DMA2_S3FCR (* ((volatile uint32_t *) (0x40020400 + 108)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S3FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S3FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S3FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S3FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4CR: stream x configuration register
  #define DMA2_S4CR (* ((volatile uint32_t *) (0x40020400 + 112)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S4CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S4CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S4CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S4CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S4CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S4CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S4CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S4CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S4CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S4CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S4CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S4CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S4CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S4CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S4CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S4CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S4CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S4CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S4CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S4NDTR: stream x number of data register
  #define DMA2_S4NDTR (* ((volatile uint32_t *) (0x40020400 + 116)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S4NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4PAR: stream x peripheral address register
  #define DMA2_S4PAR (* ((volatile uint32_t *) (0x40020400 + 120)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S4PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4M0AR: stream x memory 0 address register
  #define DMA2_S4M0AR (* ((volatile uint32_t *) (0x40020400 + 124)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S4M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4M1AR: stream x memory 1 address register
  #define DMA2_S4M1AR (* ((volatile uint32_t *) (0x40020400 + 128)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S4M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S4FCR: stream x FIFO control register
  #define DMA2_S4FCR (* ((volatile uint32_t *) (0x40020400 + 132)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S4FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S4FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S4FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S4FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5CR: stream x configuration register
  #define DMA2_S5CR (* ((volatile uint32_t *) (0x40020400 + 136)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S5CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S5CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S5CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S5CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S5CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S5CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S5CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S5CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S5CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S5CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S5CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S5CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S5CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S5CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S5CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S5CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S5CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S5CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S5CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S5NDTR: stream x number of data register
  #define DMA2_S5NDTR (* ((volatile uint32_t *) (0x40020400 + 140)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S5NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5PAR: stream x peripheral address register
  #define DMA2_S5PAR (* ((volatile uint32_t *) (0x40020400 + 144)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S5PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5M0AR: stream x memory 0 address register
  #define DMA2_S5M0AR (* ((volatile uint32_t *) (0x40020400 + 148)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S5M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5M1AR: stream x memory 1 address register
  #define DMA2_S5M1AR (* ((volatile uint32_t *) (0x40020400 + 152)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S5M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S5FCR: stream x FIFO control register
  #define DMA2_S5FCR (* ((volatile uint32_t *) (0x40020400 + 156)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S5FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S5FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S5FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S5FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6CR: stream x configuration register
  #define DMA2_S6CR (* ((volatile uint32_t *) (0x40020400 + 160)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S6CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S6CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S6CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S6CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S6CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S6CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S6CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S6CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S6CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S6CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S6CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S6CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S6CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S6CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S6CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S6CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S6CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S6CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S6CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S6NDTR: stream x number of data register
  #define DMA2_S6NDTR (* ((volatile uint32_t *) (0x40020400 + 164)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S6NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6PAR: stream x peripheral address register
  #define DMA2_S6PAR (* ((volatile uint32_t *) (0x40020400 + 168)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S6PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6M0AR: stream x memory 0 address register
  #define DMA2_S6M0AR (* ((volatile uint32_t *) (0x40020400 + 172)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S6M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6M1AR: stream x memory 1 address register
  #define DMA2_S6M1AR (* ((volatile uint32_t *) (0x40020400 + 176)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S6M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S6FCR: stream x FIFO control register
  #define DMA2_S6FCR (* ((volatile uint32_t *) (0x40020400 + 180)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S6FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S6FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S6FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S6FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7CR: stream x configuration register
  #define DMA2_S7CR (* ((volatile uint32_t *) (0x40020400 + 184)))

  // Field MBURST: Memory burst transfer configuration
    inline uint32_t DMA2_S7CR_MBURST (const uint32_t inValue) {return (inValue & 0x3U) << 23 ; }

  // Field PBURST: Peripheral burst transfer configuration
    inline uint32_t DMA2_S7CR_PBURST (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field ACK: ACK
    const uint32_t DMA2_S7CR_ACK = 1U << 20 ;

  // Field CT: Current target (only in double buffer mode)
    const uint32_t DMA2_S7CR_CT = 1U << 19 ;

  // Field DBM: Double buffer mode
    const uint32_t DMA2_S7CR_DBM = 1U << 18 ;

  // Field PL: Priority level
    inline uint32_t DMA2_S7CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PINCOS: Peripheral increment offset size
    const uint32_t DMA2_S7CR_PINCOS = 1U << 15 ;

  // Field MSIZE: Memory data size
    inline uint32_t DMA2_S7CR_MSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field PSIZE: Peripheral data size
    inline uint32_t DMA2_S7CR_PSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field MINC: Memory increment mode
    const uint32_t DMA2_S7CR_MINC = 1U << 10 ;

  // Field PINC: Peripheral increment mode
    const uint32_t DMA2_S7CR_PINC = 1U << 9 ;

  // Field CIRC: Circular mode
    const uint32_t DMA2_S7CR_CIRC = 1U << 8 ;

  // Field DIR: Data transfer direction
    inline uint32_t DMA2_S7CR_DIR (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PFCTRL: Peripheral flow controller
    const uint32_t DMA2_S7CR_PFCTRL = 1U << 5 ;

  // Field TCIE: Transfer complete interrupt enable
    const uint32_t DMA2_S7CR_TCIE = 1U << 4 ;

  // Field HTIE: Half transfer interrupt enable
    const uint32_t DMA2_S7CR_HTIE = 1U << 3 ;

  // Field TEIE: Transfer error interrupt enable
    const uint32_t DMA2_S7CR_TEIE = 1U << 2 ;

  // Field DMEIE: Direct mode error interrupt enable
    const uint32_t DMA2_S7CR_DMEIE = 1U << 1 ;

  // Field EN: Stream enable / flag stream ready when read low
    const uint32_t DMA2_S7CR_EN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register S7NDTR: stream x number of data register
  #define DMA2_S7NDTR (* ((volatile uint32_t *) (0x40020400 + 188)))

  // Field NDT: Number of data items to transfer
    inline uint32_t DMA2_S7NDTR_NDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7PAR: stream x peripheral address register
  #define DMA2_S7PAR (* ((volatile uint32_t *) (0x40020400 + 192)))

  // Field PA: Peripheral address
    inline uint32_t DMA2_S7PAR_PA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7M0AR: stream x memory 0 address register
  #define DMA2_S7M0AR (* ((volatile uint32_t *) (0x40020400 + 196)))

  // Field M0A: Memory 0 address
    inline uint32_t DMA2_S7M0AR_M0A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7M1AR: stream x memory 1 address register
  #define DMA2_S7M1AR (* ((volatile uint32_t *) (0x40020400 + 200)))

  // Field M1A: Memory 1 address (used in case of Double buffer mode)
    inline uint32_t DMA2_S7M1AR_M1A (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register S7FCR: stream x FIFO control register
  #define DMA2_S7FCR (* ((volatile uint32_t *) (0x40020400 + 204)))

  // Field FEIE: FIFO error interrupt enable
    const uint32_t DMA2_S7FCR_FEIE = 1U << 7 ;

  // Field FS: FIFO status
    inline uint32_t DMA2_S7FCR_FS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field DMDIS: Direct mode disable
    const uint32_t DMA2_S7FCR_DMDIS = 1U << 2 ;

  // Field FTH: FIFO threshold selection
    inline uint32_t DMA2_S7FCR_FTH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral DMA2D: DMA2D
//------------------------------------------------------------------------------

//---  Register CR: DMA2D control register
  #define DMA2D_CR (* ((volatile uint32_t *) (0x52001000 + 0)))

  // Field START: Start This bit can be used to launch the DMA2D according to the parameters loaded in the various configuration registers
    const uint32_t DMA2D_CR_START = 1U << 0 ;

  // Field SUSP: Suspend This bit can be used to suspend the current transfer. This bit is set and reset by software. It is automatically reset by hardware when the START bit is reset.
    const uint32_t DMA2D_CR_SUSP = 1U << 1 ;

  // Field ABORT: Abort This bit can be used to abort the current transfer. This bit is set by software and is automatically reset by hardware when the START bit is reset.
    const uint32_t DMA2D_CR_ABORT = 1U << 2 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t DMA2D_CR_TEIE = 1U << 8 ;

  // Field TCIE: Transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t DMA2D_CR_TCIE = 1U << 9 ;

  // Field TWIE: Transfer watermark interrupt enable This bit is set and cleared by software.
    const uint32_t DMA2D_CR_TWIE = 1U << 10 ;

  // Field CAEIE: CLUT access error interrupt enable This bit is set and cleared by software.
    const uint32_t DMA2D_CR_CAEIE = 1U << 11 ;

  // Field CTCIE: CLUT transfer complete interrupt enable This bit is set and cleared by software.
    const uint32_t DMA2D_CR_CTCIE = 1U << 12 ;

  // Field CEIE: Configuration Error Interrupt Enable This bit is set and cleared by software.
    const uint32_t DMA2D_CR_CEIE = 1U << 13 ;

  // Field MODE: DMA2D mode This bit is set and cleared by software. It cannot be modified while a transfer is ongoing.
    inline uint32_t DMA2D_CR_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register ISR: DMA2D Interrupt Status Register
  #define DMA2D_ISR (* ((const volatile uint32_t *) (0x52001000 + 4)))

  // Field TEIF: Transfer error interrupt flag This bit is set when an error occurs during a DMA transfer (data transfer or automatic CLUT loading).
    const uint32_t DMA2D_ISR_TEIF = 1U << 0 ;

  // Field TCIF: Transfer complete interrupt flag This bit is set when a DMA2D transfer operation is complete (data transfer only).
    const uint32_t DMA2D_ISR_TCIF = 1U << 1 ;

  // Field TWIF: Transfer watermark interrupt flag This bit is set when the last pixel of the watermarked line has been transferred.
    const uint32_t DMA2D_ISR_TWIF = 1U << 2 ;

  // Field CAEIF: CLUT access error interrupt flag This bit is set when the CPU accesses the CLUT while the CLUT is being automatically copied from a system memory to the internal DMA2D.
    const uint32_t DMA2D_ISR_CAEIF = 1U << 3 ;

  // Field CTCIF: CLUT transfer complete interrupt flag This bit is set when the CLUT copy from a system memory area to the internal DMA2D memory is complete.
    const uint32_t DMA2D_ISR_CTCIF = 1U << 4 ;

  // Field CEIF: Configuration error interrupt flag This bit is set when the START bit of DMA2D_CR, DMA2DFGPFCCR or DMA2D_BGPFCCR is set and a wrong configuration has been programmed.
    const uint32_t DMA2D_ISR_CEIF = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register IFCR: DMA2D interrupt flag clear register
  #define DMA2D_IFCR (* ((volatile uint32_t *) (0x52001000 + 8)))

  // Field CTEIF: Clear Transfer error interrupt flag Programming this bit to 1 clears the TEIF flag in the DMA2D_ISR register
    const uint32_t DMA2D_IFCR_CTEIF = 1U << 0 ;

  // Field CTCIF: Clear transfer complete interrupt flag Programming this bit to 1 clears the TCIF flag in the DMA2D_ISR register
    const uint32_t DMA2D_IFCR_CTCIF = 1U << 1 ;

  // Field CTWIF: Clear transfer watermark interrupt flag Programming this bit to 1 clears the TWIF flag in the DMA2D_ISR register
    const uint32_t DMA2D_IFCR_CTWIF = 1U << 2 ;

  // Field CAECIF: Clear CLUT access error interrupt flag Programming this bit to 1 clears the CAEIF flag in the DMA2D_ISR register
    const uint32_t DMA2D_IFCR_CAECIF = 1U << 3 ;

  // Field CCTCIF: Clear CLUT transfer complete interrupt flag Programming this bit to 1 clears the CTCIF flag in the DMA2D_ISR register
    const uint32_t DMA2D_IFCR_CCTCIF = 1U << 4 ;

  // Field CCEIF: Clear configuration error interrupt flag Programming this bit to 1 clears the CEIF flag in the DMA2D_ISR register
    const uint32_t DMA2D_IFCR_CCEIF = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register FGMAR: DMA2D foreground memory address register
  #define DMA2D_FGMAR (* ((volatile uint32_t *) (0x52001000 + 12)))

  // Field MA: Memory address Address of the data used for the foreground image. This register can only be written when data transfers are disabled. Once the data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned.
    inline uint32_t DMA2D_FGMAR_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FGOR: DMA2D foreground offset register
  #define DMA2D_FGOR (* ((volatile uint32_t *) (0x52001000 + 16)))

  // Field LO: Line offset Line offset used for the foreground expressed in pixel. This value is used to generate the address. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once a data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.
    inline uint32_t DMA2D_FGOR_LO (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BGMAR: DMA2D background memory address register
  #define DMA2D_BGMAR (* ((volatile uint32_t *) (0x52001000 + 20)))

  // Field MA: Memory address Address of the data used for the background image. This register can only be written when data transfers are disabled. Once a data transfer has started, this register is read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned, a 16-bit per pixel format must be 16-bit aligned and a 4-bit per pixel format must be 8-bit aligned.
    inline uint32_t DMA2D_BGMAR_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BGOR: DMA2D background offset register
  #define DMA2D_BGOR (* ((volatile uint32_t *) (0x52001000 + 24)))

  // Field LO: Line offset Line offset used for the background image (expressed in pixel). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once data transfer has started, they become read-only. If the image format is 4-bit per pixel, the line offset must be even.
    inline uint32_t DMA2D_BGOR_LO (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FGPFCCR: DMA2D foreground PFC control register
  #define DMA2D_FGPFCCR (* ((volatile uint32_t *) (0x52001000 + 28)))

  // Field CM: Color mode These bits defines the color format of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
    inline uint32_t DMA2D_FGPFCCR_CM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field CCM: CLUT color mode This bit defines the color format of the CLUT. It can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
    const uint32_t DMA2D_FGPFCCR_CCM = 1U << 4 ;

  // Field START: Start This bit can be set to start the automatic loading of the CLUT. It is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already ongoing (data transfer or automatic background CLUT transfer).
    const uint32_t DMA2D_FGPFCCR_START = 1U << 5 ;

  // Field CS: CLUT size These bits define the size of the CLUT used for the foreground image. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
    inline uint32_t DMA2D_FGPFCCR_CS (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field AM: Alpha mode These bits select the alpha channel value to be used for the foreground image. They can only be written data the transfer are disabled. Once the transfer has started, they become read-only. other configurations are meaningless
    inline uint32_t DMA2D_FGPFCCR_AM (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field CSS: Chroma Sub-Sampling These bits define the chroma sub-sampling mode for YCbCr color mode. Once the transfer has started, these bits are read-only. others: meaningless
    inline uint32_t DMA2D_FGPFCCR_CSS (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field AI: Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
    const uint32_t DMA2D_FGPFCCR_AI = 1U << 20 ;

  // Field RBS: Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
    const uint32_t DMA2D_FGPFCCR_RBS = 1U << 21 ;

  // Field ALPHA: Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied by the original alpha value according to the alpha mode selected through the AM[1:0] bits. These bits can only be written when data transfers are disabled. Once a transfer has started, they become read-only.
    inline uint32_t DMA2D_FGPFCCR_ALPHA (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FGCOLR: DMA2D foreground color register
  #define DMA2D_FGCOLR (* ((volatile uint32_t *) (0x52001000 + 32)))

  // Field BLUE: Blue Value These bits defines the blue value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
    inline uint32_t DMA2D_FGCOLR_BLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field GREEN: Green Value These bits defines the green value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, They are read-only.
    inline uint32_t DMA2D_FGCOLR_GREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field RED: Red Value These bits defines the red value for the A4 or A8 mode of the foreground image. They can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_FGCOLR_RED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register BGPFCCR: DMA2D background PFC control register
  #define DMA2D_BGPFCCR (* ((volatile uint32_t *) (0x52001000 + 36)))

  // Field CM: Color mode These bits define the color format of the foreground image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
    inline uint32_t DMA2D_BGPFCCR_CM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field CCM: CLUT Color mode These bits define the color format of the CLUT. This register can only be written when the transfer is disabled. Once the CLUT transfer has started, this bit is read-only.
    const uint32_t DMA2D_BGPFCCR_CCM = 1U << 4 ;

  // Field START: Start This bit is set to start the automatic loading of the CLUT. This bit is automatically reset: ** at the end of the transfer ** when the transfer is aborted by the user application by setting the ABORT bit in the DMA2D_CR ** when a transfer error occurs ** when the transfer has not started due to a configuration error or another transfer operation already on going (data transfer or automatic BackGround CLUT transfer).
    const uint32_t DMA2D_BGPFCCR_START = 1U << 5 ;

  // Field CS: CLUT size These bits define the size of the CLUT used for the BG. Once the CLUT transfer has started, this field is read-only. The number of CLUT entries is equal to CS[7:0] + 1.
    inline uint32_t DMA2D_BGPFCCR_CS (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field AM: Alpha mode These bits define which alpha channel value to be used for the background image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
    inline uint32_t DMA2D_BGPFCCR_AM (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field AI: Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
    const uint32_t DMA2D_BGPFCCR_AI = 1U << 20 ;

  // Field RBS: Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
    const uint32_t DMA2D_BGPFCCR_RBS = 1U << 21 ;

  // Field ALPHA: Alpha value These bits define a fixed alpha channel value which can replace the original alpha value or be multiplied with the original alpha value according to the alpha mode selected with bits AM[1: 0]. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_BGPFCCR_ALPHA (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register BGCOLR: DMA2D background color register
  #define DMA2D_BGCOLR (* ((volatile uint32_t *) (0x52001000 + 40)))

  // Field BLUE: Blue Value These bits define the blue value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_BGCOLR_BLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field GREEN: Green Value These bits define the green value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_BGCOLR_GREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field RED: Red Value These bits define the red value for the A4 or A8 mode of the background. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_BGCOLR_RED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FGCMAR: DMA2D foreground CLUT memory address register
  #define DMA2D_FGCMAR (* ((volatile uint32_t *) (0x52001000 + 44)))

  // Field MA: Memory Address Address of the data used for the CLUT address dedicated to the foreground image. This register can only be written when no transfer is ongoing. Once the CLUT transfer has started, this register is read-only. If the foreground CLUT format is 32-bit, the address must be 32-bit aligned.
    inline uint32_t DMA2D_FGCMAR_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BGCMAR: DMA2D background CLUT memory address register
  #define DMA2D_BGCMAR (* ((volatile uint32_t *) (0x52001000 + 48)))

  // Field MA: Memory address Address of the data used for the CLUT address dedicated to the background image. This register can only be written when no transfer is on going. Once the CLUT transfer has started, this register is read-only. If the background CLUT format is 32-bit, the address must be 32-bit aligned.
    inline uint32_t DMA2D_BGCMAR_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OPFCCR: DMA2D output PFC control register
  #define DMA2D_OPFCCR (* ((volatile uint32_t *) (0x52001000 + 52)))

  // Field CM: Color mode These bits define the color format of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. others: meaningless
    inline uint32_t DMA2D_OPFCCR_CM (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field AI: Alpha Inverted This bit inverts the alpha value. Once the transfer has started, this bit is read-only.
    const uint32_t DMA2D_OPFCCR_AI = 1U << 20 ;

  // Field RBS: Red Blue Swap This bit allows to swap the R &amp; B to support BGR or ABGR color formats. Once the transfer has started, this bit is read-only.
    const uint32_t DMA2D_OPFCCR_RBS = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register OCOLR: DMA2D output color register
  #define DMA2D_OCOLR (* ((volatile uint32_t *) (0x52001000 + 56)))

  // Field BLUE: Blue Value These bits define the blue value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_OCOLR_BLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field GREEN: Green Value These bits define the green value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_OCOLR_GREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field RED: Red Value These bits define the red value of the output image. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_OCOLR_RED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field ALPHA: Alpha Channel Value These bits define the alpha channel of the output color. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_OCOLR_ALPHA (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OMAR: DMA2D output memory address register
  #define DMA2D_OMAR (* ((volatile uint32_t *) (0x52001000 + 60)))

  // Field MA: Memory Address Address of the data used for the output FIFO. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. The address alignment must match the image format selected e.g. a 32-bit per pixel format must be 32-bit aligned and a 16-bit per pixel format must be 16-bit aligned.
    inline uint32_t DMA2D_OMAR_MA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OOR: DMA2D output offset register
  #define DMA2D_OOR (* ((volatile uint32_t *) (0x52001000 + 64)))

  // Field LO: Line Offset Line offset used for the output (expressed in pixels). This value is used for the address generation. It is added at the end of each line to determine the starting address of the next line. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_OOR_LO (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register NLR: DMA2D number of line register
  #define DMA2D_NLR (* ((volatile uint32_t *) (0x52001000 + 68)))

  // Field NL: Number of lines Number of lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_NLR_NL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field PL: Pixel per lines Number of pixels per lines of the area to be transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only. If any of the input image format is 4-bit per pixel, pixel per lines must be even.
    inline uint32_t DMA2D_NLR_PL (const uint32_t inValue) {return (inValue & 0x3FFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register LWR: DMA2D line watermark register
  #define DMA2D_LWR (* ((volatile uint32_t *) (0x52001000 + 72)))

  // Field LW: Line watermark These bits allow to configure the line watermark for interrupt generation. An interrupt is raised when the last pixel of the watermarked line has been transferred. These bits can only be written when data transfers are disabled. Once the transfer has started, they are read-only.
    inline uint32_t DMA2D_LWR_LW (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AMTCR: DMA2D AXI master timer configuration register
  #define DMA2D_AMTCR (* ((volatile uint32_t *) (0x52001000 + 76)))

  // Field EN: Enable Enables the dead time functionality.
    const uint32_t DMA2D_AMTCR_EN = 1U << 0 ;

  // Field DT: Dead Time Dead time value in the AXI clock cycle inserted between two consecutive accesses on the AXI master port. These bits represent the minimum guaranteed number of cycles between two consecutive AXI accesses.
    inline uint32_t DMA2D_AMTCR_DT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------
// Peripheral DMAMUX1: DMAMUX
//------------------------------------------------------------------------------

//---  Register C0CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C0CR (* ((volatile uint32_t *) (0x40020800 + 0)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C0CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C0CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C0CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C0CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C0CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C0CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C0CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C1CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C1CR (* ((volatile uint32_t *) (0x40020800 + 4)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C1CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C1CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C1CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C1CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C1CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C1CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C1CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C2CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C2CR (* ((volatile uint32_t *) (0x40020800 + 8)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C2CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C2CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C2CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C2CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C2CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C2CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C2CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C3CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C3CR (* ((volatile uint32_t *) (0x40020800 + 12)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C3CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C3CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C3CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C3CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C3CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C3CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C3CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C4CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C4CR (* ((volatile uint32_t *) (0x40020800 + 16)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C4CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C4CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C4CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C4CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C4CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C4CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C4CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C5CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C5CR (* ((volatile uint32_t *) (0x40020800 + 20)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C5CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C5CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C5CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C5CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C5CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C5CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C5CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C6CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C6CR (* ((volatile uint32_t *) (0x40020800 + 24)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C6CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C6CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C6CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C6CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C6CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C6CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C6CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C7CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C7CR (* ((volatile uint32_t *) (0x40020800 + 28)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C7CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C7CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C7CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C7CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C7CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C7CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C7CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C8CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C8CR (* ((volatile uint32_t *) (0x40020800 + 32)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C8CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C8CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C8CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C8CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C8CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C8CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C8CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C9CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C9CR (* ((volatile uint32_t *) (0x40020800 + 36)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C9CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C9CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C9CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C9CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C9CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C9CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C9CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C10CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C10CR (* ((volatile uint32_t *) (0x40020800 + 40)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C10CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C10CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C10CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C10CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C10CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C10CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C10CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C11CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C11CR (* ((volatile uint32_t *) (0x40020800 + 44)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C11CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C11CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C11CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C11CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C11CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C11CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C11CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C12CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C12CR (* ((volatile uint32_t *) (0x40020800 + 48)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C12CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C12CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C12CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C12CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C12CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C12CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C12CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C13CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C13CR (* ((volatile uint32_t *) (0x40020800 + 52)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C13CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C13CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C13CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C13CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C13CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C13CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C13CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C14CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C14CR (* ((volatile uint32_t *) (0x40020800 + 56)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C14CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C14CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C14CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C14CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C14CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C14CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C14CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C15CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX1_C15CR (* ((volatile uint32_t *) (0x40020800 + 60)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX1_C15CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX1_C15CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX1_C15CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX1_C15CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX1_C15CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX1_C15CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX1_C15CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register RG0CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG0CR (* ((volatile uint32_t *) (0x40020800 + 256)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG0CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG0CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG0CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG0CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG0CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG1CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG1CR (* ((volatile uint32_t *) (0x40020800 + 260)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG1CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG1CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG1CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG1CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG1CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG2CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG2CR (* ((volatile uint32_t *) (0x40020800 + 264)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG2CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG2CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG2CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG2CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG2CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG3CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG3CR (* ((volatile uint32_t *) (0x40020800 + 268)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG3CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG3CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG3CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG3CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG3CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG4CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG4CR (* ((volatile uint32_t *) (0x40020800 + 272)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG4CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG4CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG4CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG4CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG4CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG5CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG5CR (* ((volatile uint32_t *) (0x40020800 + 276)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG5CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG5CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG5CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG5CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG5CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG6CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG6CR (* ((volatile uint32_t *) (0x40020800 + 280)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG6CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG6CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG6CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG6CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG6CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG7CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX1_RG7CR (* ((volatile uint32_t *) (0x40020800 + 284)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX1_RG7CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX1_RG7CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX1_RG7CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX1_RG7CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX1_RG7CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RGSR: DMAMux - DMA request generator status register
  #define DMAMUX1_RGSR (* ((const volatile uint32_t *) (0x40020800 + 320)))

  // Field OF: Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
    inline uint32_t DMAMUX1_RGSR_OF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RGCFR: DMAMux - DMA request generator clear flag register
  #define DMAMUX1_RGCFR (* ((volatile uint32_t *) (0x40020800 + 324)))

  // Field COF: Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
    inline uint32_t DMAMUX1_RGCFR_COF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CSR: DMAMUX request line multiplexer interrupt channel status register
  #define DMAMUX1_CSR (* ((const volatile uint32_t *) (0x40020800 + 128)))

  // Field SOF: Synchronization overrun event flag
    inline uint32_t DMAMUX1_CSR_SOF (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFR: DMAMUX request line multiplexer interrupt clear flag register
  #define DMAMUX1_CFR (* ((volatile uint32_t *) (0x40020800 + 132)))

  // Field CSOF: Clear synchronization overrun event flag
    inline uint32_t DMAMUX1_CFR_CSOF (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral DMAMUX2: DMAMUX
//------------------------------------------------------------------------------

//---  Register C0CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C0CR (* ((volatile uint32_t *) (0x58025800 + 0)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C0CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C0CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C0CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C0CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C0CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C0CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C0CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C1CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C1CR (* ((volatile uint32_t *) (0x58025800 + 4)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C1CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C1CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C1CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C1CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C1CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C1CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C1CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C2CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C2CR (* ((volatile uint32_t *) (0x58025800 + 8)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C2CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C2CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C2CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C2CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C2CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C2CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C2CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C3CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C3CR (* ((volatile uint32_t *) (0x58025800 + 12)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C3CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C3CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C3CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C3CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C3CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C3CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C3CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C4CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C4CR (* ((volatile uint32_t *) (0x58025800 + 16)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C4CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C4CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C4CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C4CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C4CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C4CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C4CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C5CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C5CR (* ((volatile uint32_t *) (0x58025800 + 20)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C5CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C5CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C5CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C5CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C5CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C5CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C5CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C6CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C6CR (* ((volatile uint32_t *) (0x58025800 + 24)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C6CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C6CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C6CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C6CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C6CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C6CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C6CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register C7CR: DMAMux - DMA request line multiplexer channel x control register
  #define DMAMUX2_C7CR (* ((volatile uint32_t *) (0x58025800 + 28)))

  // Field DMAREQ_ID: Input DMA request line selected
    inline uint32_t DMAMUX2_C7CR_DMAREQ_ID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SOIE: Interrupt enable at synchronization event overrun
    const uint32_t DMAMUX2_C7CR_SOIE = 1U << 8 ;

  // Field EGE: Event generation enable/disable
    const uint32_t DMAMUX2_C7CR_EGE = 1U << 9 ;

  // Field SE: Synchronous operating mode enable/disable
    const uint32_t DMAMUX2_C7CR_SE = 1U << 16 ;

  // Field SPOL: Synchronization event type selector Defines the synchronization event on the selected synchronization input:
    inline uint32_t DMAMUX2_C7CR_SPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field NBREQ: Number of DMA requests to forward Defines the number of DMA requests forwarded before output event is generated. In synchronous mode, it also defines the number of DMA requests to forward after a synchronization event, then stop forwarding. The actual number of DMA requests forwarded is NBREQ+1. Note: This field can only be written when both SE and EGE bits are reset.
    inline uint32_t DMAMUX2_C7CR_NBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

  // Field SYNC_ID: Synchronization input selected
    inline uint32_t DMAMUX2_C7CR_SYNC_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register RG0CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG0CR (* ((volatile uint32_t *) (0x58025800 + 256)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG0CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG0CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG0CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG0CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG0CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG1CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG1CR (* ((volatile uint32_t *) (0x58025800 + 260)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG1CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG1CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG1CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG1CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG1CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG2CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG2CR (* ((volatile uint32_t *) (0x58025800 + 264)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG2CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG2CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG2CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG2CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG2CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG3CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG3CR (* ((volatile uint32_t *) (0x58025800 + 268)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG3CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG3CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG3CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG3CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG3CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG4CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG4CR (* ((volatile uint32_t *) (0x58025800 + 272)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG4CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG4CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG4CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG4CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG4CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG5CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG5CR (* ((volatile uint32_t *) (0x58025800 + 276)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG5CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG5CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG5CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG5CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG5CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG6CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG6CR (* ((volatile uint32_t *) (0x58025800 + 280)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG6CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG6CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG6CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG6CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG6CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RG7CR: DMAMux - DMA request generator channel x control register
  #define DMAMUX2_RG7CR (* ((volatile uint32_t *) (0x58025800 + 284)))

  // Field SIG_ID: DMA request trigger input selected
    inline uint32_t DMAMUX2_RG7CR_SIG_ID (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field OIE: Interrupt enable at trigger event overrun
    const uint32_t DMAMUX2_RG7CR_OIE = 1U << 8 ;

  // Field GE: DMA request generator channel enable/disable
    const uint32_t DMAMUX2_RG7CR_GE = 1U << 16 ;

  // Field GPOL: DMA request generator trigger event type selection Defines the trigger event on the selected DMA request trigger input
    inline uint32_t DMAMUX2_RG7CR_GPOL (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field GNBREQ: Number of DMA requests to generate Defines the number of DMA requests generated after a trigger event, then stop generating. The actual number of generated DMA requests is GNBREQ+1. Note: This field can only be written when GE bit is reset.
    inline uint32_t DMAMUX2_RG7CR_GNBREQ (const uint32_t inValue) {return (inValue & 0x1FU) << 19 ; }

//------------------------------------------------------------------------------

//---  Register RGSR: DMAMux - DMA request generator status register
  #define DMAMUX2_RGSR (* ((const volatile uint32_t *) (0x58025800 + 320)))

  // Field OF: Trigger event overrun flag The flag is set when a trigger event occurs on DMA request generator channel x, while the DMA request generator counter value is lower than GNBREQ. The flag is cleared by writing 1 to the corresponding COFx bit in DMAMUX_RGCFR register.
    inline uint32_t DMAMUX2_RGSR_OF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RGCFR: DMAMux - DMA request generator clear flag register
  #define DMAMUX2_RGCFR (* ((volatile uint32_t *) (0x58025800 + 324)))

  // Field COF: Clear trigger event overrun flag Upon setting, this bit clears the corresponding overrun flag OFx in the DMAMUX_RGCSR register.
    inline uint32_t DMAMUX2_RGCFR_COF (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CSR: DMAMUX request line multiplexer interrupt channel status register
  #define DMAMUX2_CSR (* ((const volatile uint32_t *) (0x58025800 + 128)))

  // Field SOF: Synchronization overrun event flag
    inline uint32_t DMAMUX2_CSR_SOF (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFR: DMAMUX request line multiplexer interrupt clear flag register
  #define DMAMUX2_CFR (* ((volatile uint32_t *) (0x58025800 + 132)))

  // Field CSOF: Clear synchronization overrun event flag
    inline uint32_t DMAMUX2_CFR_CSOF (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral EXTI: External interrupt/event       controller
//------------------------------------------------------------------------------

//---  Register RTSR1: EXTI rising trigger selection register
  #define EXTI_RTSR1 (* ((volatile uint32_t *) (0x58000000 + 0)))

  // Field TR0: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR0 = 1U << 0 ;

  // Field TR1: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR1 = 1U << 1 ;

  // Field TR2: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR2 = 1U << 2 ;

  // Field TR3: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR3 = 1U << 3 ;

  // Field TR4: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR4 = 1U << 4 ;

  // Field TR5: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR5 = 1U << 5 ;

  // Field TR6: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR6 = 1U << 6 ;

  // Field TR7: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR7 = 1U << 7 ;

  // Field TR8: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR8 = 1U << 8 ;

  // Field TR9: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR9 = 1U << 9 ;

  // Field TR10: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR10 = 1U << 10 ;

  // Field TR11: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR11 = 1U << 11 ;

  // Field TR12: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR12 = 1U << 12 ;

  // Field TR13: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR13 = 1U << 13 ;

  // Field TR14: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR14 = 1U << 14 ;

  // Field TR15: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR15 = 1U << 15 ;

  // Field TR16: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR16 = 1U << 16 ;

  // Field TR17: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR17 = 1U << 17 ;

  // Field TR18: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR18 = 1U << 18 ;

  // Field TR19: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR19 = 1U << 19 ;

  // Field TR20: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR20 = 1U << 20 ;

  // Field TR21: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_RTSR1_TR21 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register FTSR1: EXTI falling trigger selection register
  #define EXTI_FTSR1 (* ((volatile uint32_t *) (0x58000000 + 4)))

  // Field TR0: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR0 = 1U << 0 ;

  // Field TR1: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR1 = 1U << 1 ;

  // Field TR2: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR2 = 1U << 2 ;

  // Field TR3: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR3 = 1U << 3 ;

  // Field TR4: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR4 = 1U << 4 ;

  // Field TR5: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR5 = 1U << 5 ;

  // Field TR6: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR6 = 1U << 6 ;

  // Field TR7: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR7 = 1U << 7 ;

  // Field TR8: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR8 = 1U << 8 ;

  // Field TR9: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR9 = 1U << 9 ;

  // Field TR10: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR10 = 1U << 10 ;

  // Field TR11: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR11 = 1U << 11 ;

  // Field TR12: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR12 = 1U << 12 ;

  // Field TR13: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR13 = 1U << 13 ;

  // Field TR14: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR14 = 1U << 14 ;

  // Field TR15: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR15 = 1U << 15 ;

  // Field TR16: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR16 = 1U << 16 ;

  // Field TR17: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR17 = 1U << 17 ;

  // Field TR18: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR18 = 1U << 18 ;

  // Field TR19: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR19 = 1U << 19 ;

  // Field TR20: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR20 = 1U << 20 ;

  // Field TR21: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_FTSR1_TR21 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register SWIER1: EXTI software interrupt event register
  #define EXTI_SWIER1 (* ((volatile uint32_t *) (0x58000000 + 8)))

  // Field SWIER0: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER0 = 1U << 0 ;

  // Field SWIER1: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER1 = 1U << 1 ;

  // Field SWIER2: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER2 = 1U << 2 ;

  // Field SWIER3: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER3 = 1U << 3 ;

  // Field SWIER4: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER4 = 1U << 4 ;

  // Field SWIER5: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER5 = 1U << 5 ;

  // Field SWIER6: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER6 = 1U << 6 ;

  // Field SWIER7: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER7 = 1U << 7 ;

  // Field SWIER8: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER8 = 1U << 8 ;

  // Field SWIER9: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER9 = 1U << 9 ;

  // Field SWIER10: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER10 = 1U << 10 ;

  // Field SWIER11: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER11 = 1U << 11 ;

  // Field SWIER12: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER12 = 1U << 12 ;

  // Field SWIER13: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER13 = 1U << 13 ;

  // Field SWIER14: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER14 = 1U << 14 ;

  // Field SWIER15: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER15 = 1U << 15 ;

  // Field SWIER16: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER16 = 1U << 16 ;

  // Field SWIER17: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER17 = 1U << 17 ;

  // Field SWIER18: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER18 = 1U << 18 ;

  // Field SWIER19: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER19 = 1U << 19 ;

  // Field SWIER20: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER20 = 1U << 20 ;

  // Field SWIER21: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_SWIER1_SWIER21 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register D3PMR1: EXTI D3 pending mask register
  #define EXTI_D3PMR1 (* ((volatile uint32_t *) (0x58000000 + 12)))

  // Field MR0: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR0 = 1U << 0 ;

  // Field MR1: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR1 = 1U << 1 ;

  // Field MR2: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR2 = 1U << 2 ;

  // Field MR3: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR3 = 1U << 3 ;

  // Field MR4: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR4 = 1U << 4 ;

  // Field MR5: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR5 = 1U << 5 ;

  // Field MR6: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR6 = 1U << 6 ;

  // Field MR7: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR7 = 1U << 7 ;

  // Field MR8: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR8 = 1U << 8 ;

  // Field MR9: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR9 = 1U << 9 ;

  // Field MR10: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR10 = 1U << 10 ;

  // Field MR11: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR11 = 1U << 11 ;

  // Field MR12: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR12 = 1U << 12 ;

  // Field MR13: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR13 = 1U << 13 ;

  // Field MR14: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR14 = 1U << 14 ;

  // Field MR15: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR15 = 1U << 15 ;

  // Field MR19: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR19 = 1U << 19 ;

  // Field MR20: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR20 = 1U << 20 ;

  // Field MR21: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR21 = 1U << 21 ;

  // Field MR25: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_D3PMR1_MR25 = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register D3PCR1L: EXTI D3 pending clear selection register low
  #define EXTI_D3PCR1L (* ((volatile uint32_t *) (0x58000000 + 16)))

  // Field PCS0: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PCS1: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PCS2: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PCS3: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PCS4: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCS5: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PCS6: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PCS7: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PCS8: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PCS9: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PCS10: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PCS11: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PCS12: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PCS13: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PCS14: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PCS15: D3 Pending request clear input signal selection on Event input x = truncate (n/2)
    inline uint32_t EXTI_D3PCR1L_PCS15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register D3PCR1H: EXTI D3 pending clear selection register high
  #define EXTI_D3PCR1H (* ((volatile uint32_t *) (0x58000000 + 20)))

  // Field PCS19: D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
    inline uint32_t EXTI_D3PCR1H_PCS19 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PCS20: D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
    inline uint32_t EXTI_D3PCR1H_PCS20 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCS21: D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
    inline uint32_t EXTI_D3PCR1H_PCS21 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PCS25: D3 Pending request clear input signal selection on Event input x = truncate ((n+32)/2)
    inline uint32_t EXTI_D3PCR1H_PCS25 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

//------------------------------------------------------------------------------

//---  Register RTSR2: EXTI rising trigger selection register
  #define EXTI_RTSR2 (* ((volatile uint32_t *) (0x58000000 + 32)))

  // Field TR49: Rising trigger event configuration bit of Configurable Event input x+32
    const uint32_t EXTI_RTSR2_TR49 = 1U << 17 ;

  // Field TR51: Rising trigger event configuration bit of Configurable Event input x+32
    const uint32_t EXTI_RTSR2_TR51 = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register FTSR2: EXTI falling trigger selection register
  #define EXTI_FTSR2 (* ((volatile uint32_t *) (0x58000000 + 36)))

  // Field TR49: Falling trigger event configuration bit of Configurable Event input x+32
    const uint32_t EXTI_FTSR2_TR49 = 1U << 17 ;

  // Field TR51: Falling trigger event configuration bit of Configurable Event input x+32
    const uint32_t EXTI_FTSR2_TR51 = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register SWIER2: EXTI software interrupt event register
  #define EXTI_SWIER2 (* ((volatile uint32_t *) (0x58000000 + 40)))

  // Field SWIER49: Software interrupt on line x+32
    const uint32_t EXTI_SWIER2_SWIER49 = 1U << 17 ;

  // Field SWIER51: Software interrupt on line x+32
    const uint32_t EXTI_SWIER2_SWIER51 = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register D3PMR2: EXTI D3 pending mask register
  #define EXTI_D3PMR2 (* ((volatile uint32_t *) (0x58000000 + 44)))

  // Field MR34: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR34 = 1U << 2 ;

  // Field MR35: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR35 = 1U << 3 ;

  // Field MR41: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR41 = 1U << 9 ;

  // Field MR48: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR48 = 1U << 16 ;

  // Field MR49: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR49 = 1U << 17 ;

  // Field MR50: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR50 = 1U << 18 ;

  // Field MR51: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR51 = 1U << 19 ;

  // Field MR52: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR52 = 1U << 20 ;

  // Field MR53: D3 Pending Mask on Event input x+32
    const uint32_t EXTI_D3PMR2_MR53 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register D3PCR2L: EXTI D3 pending clear selection register low
  #define EXTI_D3PCR2L (* ((volatile uint32_t *) (0x58000000 + 48)))

  // Field PCS35: D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
    inline uint32_t EXTI_D3PCR2L_PCS35 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PCS34: D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
    inline uint32_t EXTI_D3PCR2L_PCS34 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PCS41: D3 Pending request clear input signal selection on Event input x = truncate ((n+64)/2)
    inline uint32_t EXTI_D3PCR2L_PCS41 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

//------------------------------------------------------------------------------

//---  Register D3PCR2H: EXTI D3 pending clear selection register high
  #define EXTI_D3PCR2H (* ((volatile uint32_t *) (0x58000000 + 52)))

  // Field PCS48: Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    inline uint32_t EXTI_D3PCR2H_PCS48 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PCS49: Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    inline uint32_t EXTI_D3PCR2H_PCS49 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PCS50: Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    inline uint32_t EXTI_D3PCR2H_PCS50 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PCS51: Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    inline uint32_t EXTI_D3PCR2H_PCS51 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PCS52: Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    inline uint32_t EXTI_D3PCR2H_PCS52 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCS53: Pending request clear input signal selection on Event input x= truncate ((n+96)/2)
    inline uint32_t EXTI_D3PCR2H_PCS53 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

//------------------------------------------------------------------------------

//---  Register RTSR3: EXTI rising trigger selection register
  #define EXTI_RTSR3 (* ((volatile uint32_t *) (0x58000000 + 64)))

  // Field TR82: Rising trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_RTSR3_TR82 = 1U << 18 ;

  // Field TR84: Rising trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_RTSR3_TR84 = 1U << 20 ;

  // Field TR85: Rising trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_RTSR3_TR85 = 1U << 21 ;

  // Field TR86: Rising trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_RTSR3_TR86 = 1U << 22 ;

//------------------------------------------------------------------------------

//---  Register FTSR3: EXTI falling trigger selection register
  #define EXTI_FTSR3 (* ((volatile uint32_t *) (0x58000000 + 68)))

  // Field TR82: Falling trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_FTSR3_TR82 = 1U << 18 ;

  // Field TR84: Falling trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_FTSR3_TR84 = 1U << 20 ;

  // Field TR85: Falling trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_FTSR3_TR85 = 1U << 21 ;

  // Field TR86: Falling trigger event configuration bit of Configurable Event input x+64
    const uint32_t EXTI_FTSR3_TR86 = 1U << 22 ;

//------------------------------------------------------------------------------

//---  Register SWIER3: EXTI software interrupt event register
  #define EXTI_SWIER3 (* ((volatile uint32_t *) (0x58000000 + 72)))

  // Field SWIER82: Software interrupt on line x+64
    const uint32_t EXTI_SWIER3_SWIER82 = 1U << 18 ;

  // Field SWIER84: Software interrupt on line x+64
    const uint32_t EXTI_SWIER3_SWIER84 = 1U << 20 ;

  // Field SWIER85: Software interrupt on line x+64
    const uint32_t EXTI_SWIER3_SWIER85 = 1U << 21 ;

  // Field SWIER86: Software interrupt on line x+64
    const uint32_t EXTI_SWIER3_SWIER86 = 1U << 22 ;

//------------------------------------------------------------------------------

//---  Register D3PMR3: EXTI D3 pending mask register
  #define EXTI_D3PMR3 (* ((volatile uint32_t *) (0x58000000 + 76)))

  // Field MR88: D3 Pending Mask on Event input x+64
    const uint32_t EXTI_D3PMR3_MR88 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register D3PCR3H: EXTI D3 pending clear selection register high
  #define EXTI_D3PCR3H (* ((volatile uint32_t *) (0x58000000 + 84)))

  // Field PCS88: D3 Pending request clear input signal selection on Event input x= truncate N+160/2
    inline uint32_t EXTI_D3PCR3H_PCS88 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

//------------------------------------------------------------------------------

//---  Register CPUIMR1: EXTI interrupt mask register
  #define EXTI_CPUIMR1 (* ((volatile uint32_t *) (0x58000000 + 128)))

  // Field MR0: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR0 = 1U << 0 ;

  // Field MR1: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR1 = 1U << 1 ;

  // Field MR2: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR2 = 1U << 2 ;

  // Field MR3: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR3 = 1U << 3 ;

  // Field MR4: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR4 = 1U << 4 ;

  // Field MR5: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR5 = 1U << 5 ;

  // Field MR6: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR6 = 1U << 6 ;

  // Field MR7: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR7 = 1U << 7 ;

  // Field MR8: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR8 = 1U << 8 ;

  // Field MR9: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR9 = 1U << 9 ;

  // Field MR10: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR10 = 1U << 10 ;

  // Field MR11: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR11 = 1U << 11 ;

  // Field MR12: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR12 = 1U << 12 ;

  // Field MR13: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR13 = 1U << 13 ;

  // Field MR14: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR14 = 1U << 14 ;

  // Field MR15: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR15 = 1U << 15 ;

  // Field MR16: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR16 = 1U << 16 ;

  // Field MR17: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR17 = 1U << 17 ;

  // Field MR18: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR18 = 1U << 18 ;

  // Field MR19: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR19 = 1U << 19 ;

  // Field MR20: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR20 = 1U << 20 ;

  // Field MR21: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR21 = 1U << 21 ;

  // Field MR22: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR22 = 1U << 22 ;

  // Field MR23: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR23 = 1U << 23 ;

  // Field MR24: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR24 = 1U << 24 ;

  // Field MR25: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR25 = 1U << 25 ;

  // Field MR26: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR26 = 1U << 26 ;

  // Field MR27: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR27 = 1U << 27 ;

  // Field MR28: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR28 = 1U << 28 ;

  // Field MR29: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR29 = 1U << 29 ;

  // Field MR30: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR30 = 1U << 30 ;

  // Field MR31: Rising trigger event configuration bit of Configurable Event input
    const uint32_t EXTI_CPUIMR1_MR31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CPUEMR1: EXTI event mask register
  #define EXTI_CPUEMR1 (* ((volatile uint32_t *) (0x58000000 + 132)))

  // Field MR0: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR0 = 1U << 0 ;

  // Field MR1: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR1 = 1U << 1 ;

  // Field MR2: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR2 = 1U << 2 ;

  // Field MR3: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR3 = 1U << 3 ;

  // Field MR4: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR4 = 1U << 4 ;

  // Field MR5: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR5 = 1U << 5 ;

  // Field MR6: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR6 = 1U << 6 ;

  // Field MR7: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR7 = 1U << 7 ;

  // Field MR8: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR8 = 1U << 8 ;

  // Field MR9: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR9 = 1U << 9 ;

  // Field MR10: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR10 = 1U << 10 ;

  // Field MR11: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR11 = 1U << 11 ;

  // Field MR12: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR12 = 1U << 12 ;

  // Field MR13: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR13 = 1U << 13 ;

  // Field MR14: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR14 = 1U << 14 ;

  // Field MR15: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR15 = 1U << 15 ;

  // Field MR16: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR16 = 1U << 16 ;

  // Field MR17: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR17 = 1U << 17 ;

  // Field MR18: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR18 = 1U << 18 ;

  // Field MR19: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR19 = 1U << 19 ;

  // Field MR20: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR20 = 1U << 20 ;

  // Field MR21: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR21 = 1U << 21 ;

  // Field MR22: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR22 = 1U << 22 ;

  // Field MR23: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR23 = 1U << 23 ;

  // Field MR24: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR24 = 1U << 24 ;

  // Field MR25: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR25 = 1U << 25 ;

  // Field MR26: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR26 = 1U << 26 ;

  // Field MR27: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR27 = 1U << 27 ;

  // Field MR28: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR28 = 1U << 28 ;

  // Field MR29: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR29 = 1U << 29 ;

  // Field MR30: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR30 = 1U << 30 ;

  // Field MR31: CPU Event mask on Event input x
    const uint32_t EXTI_CPUEMR1_MR31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CPUPR1: EXTI pending register
  #define EXTI_CPUPR1 (* ((volatile uint32_t *) (0x58000000 + 136)))

  // Field PR0: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR0 = 1U << 0 ;

  // Field PR1: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR1 = 1U << 1 ;

  // Field PR2: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR2 = 1U << 2 ;

  // Field PR3: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR3 = 1U << 3 ;

  // Field PR4: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR4 = 1U << 4 ;

  // Field PR5: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR5 = 1U << 5 ;

  // Field PR6: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR6 = 1U << 6 ;

  // Field PR7: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR7 = 1U << 7 ;

  // Field PR8: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR8 = 1U << 8 ;

  // Field PR9: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR9 = 1U << 9 ;

  // Field PR10: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR10 = 1U << 10 ;

  // Field PR11: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR11 = 1U << 11 ;

  // Field PR12: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR12 = 1U << 12 ;

  // Field PR13: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR13 = 1U << 13 ;

  // Field PR14: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR14 = 1U << 14 ;

  // Field PR15: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR15 = 1U << 15 ;

  // Field PR16: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR16 = 1U << 16 ;

  // Field PR17: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR17 = 1U << 17 ;

  // Field PR18: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR18 = 1U << 18 ;

  // Field PR19: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR19 = 1U << 19 ;

  // Field PR20: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR20 = 1U << 20 ;

  // Field PR21: CPU Event mask on Event input x
    const uint32_t EXTI_CPUPR1_PR21 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register CPUIMR2: EXTI interrupt mask register
  #define EXTI_CPUIMR2 (* ((volatile uint32_t *) (0x58000000 + 144)))

  // Field MR0: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR0 = 1U << 0 ;

  // Field MR1: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR1 = 1U << 1 ;

  // Field MR2: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR2 = 1U << 2 ;

  // Field MR3: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR3 = 1U << 3 ;

  // Field MR4: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR4 = 1U << 4 ;

  // Field MR5: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR5 = 1U << 5 ;

  // Field MR6: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR6 = 1U << 6 ;

  // Field MR7: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR7 = 1U << 7 ;

  // Field MR8: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR8 = 1U << 8 ;

  // Field MR9: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR9 = 1U << 9 ;

  // Field MR10: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR10 = 1U << 10 ;

  // Field MR11: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR11 = 1U << 11 ;

  // Field MR12: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR12 = 1U << 12 ;

  // Field MR14: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR14 = 1U << 14 ;

  // Field MR15: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR15 = 1U << 15 ;

  // Field MR16: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR16 = 1U << 16 ;

  // Field MR17: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR17 = 1U << 17 ;

  // Field MR18: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR18 = 1U << 18 ;

  // Field MR19: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR19 = 1U << 19 ;

  // Field MR20: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR20 = 1U << 20 ;

  // Field MR21: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR21 = 1U << 21 ;

  // Field MR22: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR22 = 1U << 22 ;

  // Field MR23: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR23 = 1U << 23 ;

  // Field MR24: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR24 = 1U << 24 ;

  // Field MR25: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR25 = 1U << 25 ;

  // Field MR26: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR26 = 1U << 26 ;

  // Field MR27: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR27 = 1U << 27 ;

  // Field MR28: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR28 = 1U << 28 ;

  // Field MR29: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR29 = 1U << 29 ;

  // Field MR30: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR30 = 1U << 30 ;

  // Field MR31: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUIMR2_MR31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CPUEMR2: EXTI event mask register
  #define EXTI_CPUEMR2 (* ((volatile uint32_t *) (0x58000000 + 148)))

  // Field MR32: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR32 = 1U << 0 ;

  // Field MR33: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR33 = 1U << 1 ;

  // Field MR34: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR34 = 1U << 2 ;

  // Field MR35: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR35 = 1U << 3 ;

  // Field MR36: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR36 = 1U << 4 ;

  // Field MR37: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR37 = 1U << 5 ;

  // Field MR38: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR38 = 1U << 6 ;

  // Field MR39: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR39 = 1U << 7 ;

  // Field MR40: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR40 = 1U << 8 ;

  // Field MR41: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR41 = 1U << 9 ;

  // Field MR42: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR42 = 1U << 10 ;

  // Field MR43: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR43 = 1U << 11 ;

  // Field MR44: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR44 = 1U << 12 ;

  // Field MR46: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR46 = 1U << 14 ;

  // Field MR47: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR47 = 1U << 15 ;

  // Field MR48: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR48 = 1U << 16 ;

  // Field MR49: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR49 = 1U << 17 ;

  // Field MR50: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR50 = 1U << 18 ;

  // Field MR51: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR51 = 1U << 19 ;

  // Field MR52: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR52 = 1U << 20 ;

  // Field MR53: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR53 = 1U << 21 ;

  // Field MR54: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR54 = 1U << 22 ;

  // Field MR55: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR55 = 1U << 23 ;

  // Field MR56: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR56 = 1U << 24 ;

  // Field MR57: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR57 = 1U << 25 ;

  // Field MR58: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR58 = 1U << 26 ;

  // Field MR59: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR59 = 1U << 27 ;

  // Field MR60: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR60 = 1U << 28 ;

  // Field MR61: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR61 = 1U << 29 ;

  // Field MR62: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR62 = 1U << 30 ;

  // Field MR63: CPU Interrupt Mask on Direct Event input x+32
    const uint32_t EXTI_CPUEMR2_MR63 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CPUPR2: EXTI pending register
  #define EXTI_CPUPR2 (* ((const volatile uint32_t *) (0x58000000 + 152)))

  // Field PR49: Configurable event inputs x+32 Pending bit
    const uint32_t EXTI_CPUPR2_PR49 = 1U << 17 ;

  // Field PR51: Configurable event inputs x+32 Pending bit
    const uint32_t EXTI_CPUPR2_PR51 = 1U << 19 ;

//------------------------------------------------------------------------------

//---  Register CPUIMR3: EXTI interrupt mask register
  #define EXTI_CPUIMR3 (* ((const volatile uint32_t *) (0x58000000 + 160)))

  // Field MR64: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR64 = 1U << 0 ;

  // Field MR65: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR65 = 1U << 1 ;

  // Field MR66: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR66 = 1U << 2 ;

  // Field MR67: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR67 = 1U << 3 ;

  // Field MR68: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR68 = 1U << 4 ;

  // Field MR69: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR69 = 1U << 5 ;

  // Field MR70: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR70 = 1U << 6 ;

  // Field MR71: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR71 = 1U << 7 ;

  // Field MR72: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR72 = 1U << 8 ;

  // Field MR73: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR73 = 1U << 9 ;

  // Field MR74: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR74 = 1U << 10 ;

  // Field MR75: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR75 = 1U << 11 ;

  // Field MR76: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR76 = 1U << 12 ;

  // Field MR77: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR77 = 1U << 13 ;

  // Field MR78: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR78 = 1U << 14 ;

  // Field MR79: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR79 = 1U << 15 ;

  // Field MR80: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR80 = 1U << 16 ;

  // Field MR82: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR82 = 1U << 18 ;

  // Field MR84: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR84 = 1U << 20 ;

  // Field MR85: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR85 = 1U << 21 ;

  // Field MR86: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR86 = 1U << 22 ;

  // Field MR87: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR87 = 1U << 23 ;

  // Field MR88: CPU Interrupt Mask on Direct Event input x+64
    const uint32_t EXTI_CPUIMR3_MR88 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CPUEMR3: EXTI event mask register
  #define EXTI_CPUEMR3 (* ((const volatile uint32_t *) (0x58000000 + 164)))

  // Field MR64: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR64 = 1U << 0 ;

  // Field MR65: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR65 = 1U << 1 ;

  // Field MR66: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR66 = 1U << 2 ;

  // Field MR67: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR67 = 1U << 3 ;

  // Field MR68: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR68 = 1U << 4 ;

  // Field MR69: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR69 = 1U << 5 ;

  // Field MR70: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR70 = 1U << 6 ;

  // Field MR71: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR71 = 1U << 7 ;

  // Field MR72: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR72 = 1U << 8 ;

  // Field MR73: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR73 = 1U << 9 ;

  // Field MR74: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR74 = 1U << 10 ;

  // Field MR75: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR75 = 1U << 11 ;

  // Field MR76: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR76 = 1U << 12 ;

  // Field MR77: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR77 = 1U << 13 ;

  // Field MR78: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR78 = 1U << 14 ;

  // Field MR79: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR79 = 1U << 15 ;

  // Field MR80: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR80 = 1U << 16 ;

  // Field MR82: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR82 = 1U << 18 ;

  // Field MR84: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR84 = 1U << 20 ;

  // Field MR85: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR85 = 1U << 21 ;

  // Field MR86: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR86 = 1U << 22 ;

  // Field MR87: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR87 = 1U << 23 ;

  // Field MR88: CPU Event mask on Event input x+64
    const uint32_t EXTI_CPUEMR3_MR88 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CPUPR3: EXTI pending register
  #define EXTI_CPUPR3 (* ((const volatile uint32_t *) (0x58000000 + 168)))

  // Field PR82: Configurable event inputs x+64 Pending bit
    const uint32_t EXTI_CPUPR3_PR82 = 1U << 18 ;

  // Field PR84: Configurable event inputs x+64 Pending bit
    const uint32_t EXTI_CPUPR3_PR84 = 1U << 20 ;

  // Field PR85: Configurable event inputs x+64 Pending bit
    const uint32_t EXTI_CPUPR3_PR85 = 1U << 21 ;

  // Field PR86: Configurable event inputs x+64 Pending bit
    const uint32_t EXTI_CPUPR3_PR86 = 1U << 22 ;

//------------------------------------------------------------------------------
// Peripheral Ethernet_DMA: Ethernet: DMA mode register (DMA)
//------------------------------------------------------------------------------

//---  Register DMAMR: DMA mode register
  #define Ethernet_DMA_DMAMR (* ((volatile uint32_t *) (0x40029000 + 0)))

  // Field SWR: Software Reset
    const uint32_t Ethernet_DMA_DMAMR_SWR = 1U << 0 ;

  // Field DA: DMA Tx or Rx Arbitration Scheme
    const uint32_t Ethernet_DMA_DMAMR_DA = 1U << 1 ;

  // Field TXPR: Transmit priority
    const uint32_t Ethernet_DMA_DMAMR_TXPR = 1U << 11 ;

  // Field PR: Priority ratio
    inline uint32_t Ethernet_DMA_DMAMR_PR (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field INTM: Interrupt Mode
    const uint32_t Ethernet_DMA_DMAMR_INTM = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register DMASBMR: System bus mode register
  #define Ethernet_DMA_DMASBMR (* ((volatile uint32_t *) (0x40029000 + 4)))

  // Field FB: Fixed Burst Length
    const uint32_t Ethernet_DMA_DMASBMR_FB = 1U << 0 ;

  // Field AAL: Address-Aligned Beats
    const uint32_t Ethernet_DMA_DMASBMR_AAL = 1U << 12 ;

  // Field MB: Mixed Burst
    const uint32_t Ethernet_DMA_DMASBMR_MB = 1U << 14 ;

  // Field RB: Rebuild INCRx Burst
    const uint32_t Ethernet_DMA_DMASBMR_RB = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register DMAISR: Interrupt status register
  #define Ethernet_DMA_DMAISR (* ((const volatile uint32_t *) (0x40029000 + 8)))

  // Field DC0IS: DMA Channel Interrupt Status
    const uint32_t Ethernet_DMA_DMAISR_DC0IS = 1U << 0 ;

  // Field MTLIS: MTL Interrupt Status
    const uint32_t Ethernet_DMA_DMAISR_MTLIS = 1U << 16 ;

  // Field MACIS: MAC Interrupt Status
    const uint32_t Ethernet_DMA_DMAISR_MACIS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register DMADSR: Debug status register
  #define Ethernet_DMA_DMADSR (* ((const volatile uint32_t *) (0x40029000 + 12)))

  // Field AXWHSTS: AHB Master Write Channel
    const uint32_t Ethernet_DMA_DMADSR_AXWHSTS = 1U << 0 ;

  // Field RPS0: DMA Channel Receive Process State
    inline uint32_t Ethernet_DMA_DMADSR_RPS0 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TPS0: DMA Channel Transmit Process State
    inline uint32_t Ethernet_DMA_DMADSR_TPS0 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register DMACCR: Channel control register
  #define Ethernet_DMA_DMACCR (* ((volatile uint32_t *) (0x40029000 + 256)))

  // Field MSS: Maximum Segment Size
    inline uint32_t Ethernet_DMA_DMACCR_MSS (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

  // Field PBLX8: 8xPBL mode
    const uint32_t Ethernet_DMA_DMACCR_PBLX8 = 1U << 16 ;

  // Field DSL: Descriptor Skip Length
    inline uint32_t Ethernet_DMA_DMACCR_DSL (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

//------------------------------------------------------------------------------

//---  Register DMACTxCR: Channel transmit control register
  #define Ethernet_DMA_DMACTxCR (* ((volatile uint32_t *) (0x40029000 + 260)))

  // Field ST: Start or Stop Transmission Command
    const uint32_t Ethernet_DMA_DMACTxCR_ST = 1U << 0 ;

  // Field OSF: Operate on Second Packet
    const uint32_t Ethernet_DMA_DMACTxCR_OSF = 1U << 4 ;

  // Field TSE: TCP Segmentation Enabled
    const uint32_t Ethernet_DMA_DMACTxCR_TSE = 1U << 12 ;

  // Field TXPBL: Transmit Programmable Burst Length
    inline uint32_t Ethernet_DMA_DMACTxCR_TXPBL (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DMACRxCR: Channel receive control register
  #define Ethernet_DMA_DMACRxCR (* ((volatile uint32_t *) (0x40029000 + 264)))

  // Field SR: Start or Stop Receive Command
    const uint32_t Ethernet_DMA_DMACRxCR_SR = 1U << 0 ;

  // Field RBSZ: Receive Buffer size
    inline uint32_t Ethernet_DMA_DMACRxCR_RBSZ (const uint32_t inValue) {return (inValue & 0x3FFFU) << 1 ; }

  // Field RXPBL: RXPBL
    inline uint32_t Ethernet_DMA_DMACRxCR_RXPBL (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field RPF: DMA Rx Channel Packet Flush
    const uint32_t Ethernet_DMA_DMACRxCR_RPF = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register DMACTxDLAR: Channel Tx descriptor list address register
  #define Ethernet_DMA_DMACTxDLAR (* ((volatile uint32_t *) (0x40029000 + 276)))

  // Field TDESLA: Start of Transmit List
    inline uint32_t Ethernet_DMA_DMACTxDLAR_TDESLA (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register DMACRxDLAR: Channel Rx descriptor list address register
  #define Ethernet_DMA_DMACRxDLAR (* ((volatile uint32_t *) (0x40029000 + 284)))

  // Field RDESLA: Start of Receive List
    inline uint32_t Ethernet_DMA_DMACRxDLAR_RDESLA (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register DMACTxDTPR: Channel Tx descriptor tail pointer register
  #define Ethernet_DMA_DMACTxDTPR (* ((volatile uint32_t *) (0x40029000 + 288)))

  // Field TDT: Transmit Descriptor Tail Pointer
    inline uint32_t Ethernet_DMA_DMACTxDTPR_TDT (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register DMACRxDTPR: Channel Rx descriptor tail pointer register
  #define Ethernet_DMA_DMACRxDTPR (* ((volatile uint32_t *) (0x40029000 + 296)))

  // Field RDT: Receive Descriptor Tail Pointer
    inline uint32_t Ethernet_DMA_DMACRxDTPR_RDT (const uint32_t inValue) {return (inValue & 0x3FFFFFFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register DMACTxRLR: Channel Tx descriptor ring length register
  #define Ethernet_DMA_DMACTxRLR (* ((volatile uint32_t *) (0x40029000 + 300)))

  // Field TDRL: Transmit Descriptor Ring Length
    inline uint32_t Ethernet_DMA_DMACTxRLR_TDRL (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACRxRLR: Channel Rx descriptor ring length register
  #define Ethernet_DMA_DMACRxRLR (* ((volatile uint32_t *) (0x40029000 + 304)))

  // Field RDRL: Receive Descriptor Ring Length
    inline uint32_t Ethernet_DMA_DMACRxRLR_RDRL (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACIER: Channel interrupt enable register
  #define Ethernet_DMA_DMACIER (* ((volatile uint32_t *) (0x40029000 + 308)))

  // Field TIE: Transmit Interrupt Enable
    const uint32_t Ethernet_DMA_DMACIER_TIE = 1U << 0 ;

  // Field TXSE: Transmit Stopped Enable
    const uint32_t Ethernet_DMA_DMACIER_TXSE = 1U << 1 ;

  // Field TBUE: Transmit Buffer Unavailable Enable
    const uint32_t Ethernet_DMA_DMACIER_TBUE = 1U << 2 ;

  // Field RIE: Receive Interrupt Enable
    const uint32_t Ethernet_DMA_DMACIER_RIE = 1U << 6 ;

  // Field RBUE: Receive Buffer Unavailable Enable
    const uint32_t Ethernet_DMA_DMACIER_RBUE = 1U << 7 ;

  // Field RSE: Receive Stopped Enable
    const uint32_t Ethernet_DMA_DMACIER_RSE = 1U << 8 ;

  // Field RWTE: Receive Watchdog Timeout Enable
    const uint32_t Ethernet_DMA_DMACIER_RWTE = 1U << 9 ;

  // Field ETIE: Early Transmit Interrupt Enable
    const uint32_t Ethernet_DMA_DMACIER_ETIE = 1U << 10 ;

  // Field ERIE: Early Receive Interrupt Enable
    const uint32_t Ethernet_DMA_DMACIER_ERIE = 1U << 11 ;

  // Field FBEE: Fatal Bus Error Enable
    const uint32_t Ethernet_DMA_DMACIER_FBEE = 1U << 12 ;

  // Field CDEE: Context Descriptor Error Enable
    const uint32_t Ethernet_DMA_DMACIER_CDEE = 1U << 13 ;

  // Field AIE: Abnormal Interrupt Summary Enable
    const uint32_t Ethernet_DMA_DMACIER_AIE = 1U << 14 ;

  // Field NIE: Normal Interrupt Summary Enable
    const uint32_t Ethernet_DMA_DMACIER_NIE = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register DMACRxIWTR: Channel Rx interrupt watchdog timer register
  #define Ethernet_DMA_DMACRxIWTR (* ((volatile uint32_t *) (0x40029000 + 312)))

  // Field RWT: Receive Interrupt Watchdog Timer Count
    inline uint32_t Ethernet_DMA_DMACRxIWTR_RWT (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACCATxDR: Channel current application transmit descriptor register
  #define Ethernet_DMA_DMACCATxDR (* ((const volatile uint32_t *) (0x40029000 + 324)))

  // Field CURTDESAPTR: Application Transmit Descriptor Address Pointer
    inline uint32_t Ethernet_DMA_DMACCATxDR_CURTDESAPTR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACCARxDR: Channel current application receive descriptor register
  #define Ethernet_DMA_DMACCARxDR (* ((const volatile uint32_t *) (0x40029000 + 332)))

  // Field CURRDESAPTR: Application Receive Descriptor Address Pointer
    inline uint32_t Ethernet_DMA_DMACCARxDR_CURRDESAPTR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACCATxBR: Channel current application transmit buffer register
  #define Ethernet_DMA_DMACCATxBR (* ((const volatile uint32_t *) (0x40029000 + 340)))

  // Field CURTBUFAPTR: Application Transmit Buffer Address Pointer
    inline uint32_t Ethernet_DMA_DMACCATxBR_CURTBUFAPTR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACCARxBR: Channel current application receive buffer register
  #define Ethernet_DMA_DMACCARxBR (* ((const volatile uint32_t *) (0x40029000 + 348)))

  // Field CURRBUFAPTR: Application Receive Buffer Address Pointer
    inline uint32_t Ethernet_DMA_DMACCARxBR_CURRBUFAPTR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMACSR: Channel status register
  #define Ethernet_DMA_DMACSR (* ((volatile uint32_t *) (0x40029000 + 352)))

  // Field TI: Transmit Interrupt
    const uint32_t Ethernet_DMA_DMACSR_TI = 1U << 0 ;

  // Field TPS: Transmit Process Stopped
    const uint32_t Ethernet_DMA_DMACSR_TPS = 1U << 1 ;

  // Field TBU: Transmit Buffer Unavailable
    const uint32_t Ethernet_DMA_DMACSR_TBU = 1U << 2 ;

  // Field RI: Receive Interrupt
    const uint32_t Ethernet_DMA_DMACSR_RI = 1U << 6 ;

  // Field RBU: Receive Buffer Unavailable
    const uint32_t Ethernet_DMA_DMACSR_RBU = 1U << 7 ;

  // Field RPS: Receive Process Stopped
    const uint32_t Ethernet_DMA_DMACSR_RPS = 1U << 8 ;

  // Field RWT: Receive Watchdog Timeout
    const uint32_t Ethernet_DMA_DMACSR_RWT = 1U << 9 ;

  // Field ET: Early Transmit Interrupt
    const uint32_t Ethernet_DMA_DMACSR_ET = 1U << 10 ;

  // Field ER: Early Receive Interrupt
    const uint32_t Ethernet_DMA_DMACSR_ER = 1U << 11 ;

  // Field FBE: Fatal Bus Error
    const uint32_t Ethernet_DMA_DMACSR_FBE = 1U << 12 ;

  // Field CDE: Context Descriptor Error
    const uint32_t Ethernet_DMA_DMACSR_CDE = 1U << 13 ;

  // Field AIS: Abnormal Interrupt Summary
    const uint32_t Ethernet_DMA_DMACSR_AIS = 1U << 14 ;

  // Field NIS: Normal Interrupt Summary
    const uint32_t Ethernet_DMA_DMACSR_NIS = 1U << 15 ;

  // Field TEB: Tx DMA Error Bits
    inline uint32_t Ethernet_DMA_DMACSR_TEB (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field REB: Rx DMA Error Bits
    inline uint32_t Ethernet_DMA_DMACSR_REB (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

//------------------------------------------------------------------------------

//---  Register DMACMFCR: Channel missed frame count register
  #define Ethernet_DMA_DMACMFCR (* ((const volatile uint32_t *) (0x40029000 + 364)))

  // Field MFC: Dropped Packet Counters
    inline uint32_t Ethernet_DMA_DMACMFCR_MFC (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field MFCO: Overflow status of the MFC Counter
    const uint32_t Ethernet_DMA_DMACMFCR_MFCO = 1U << 15 ;

//------------------------------------------------------------------------------
// Peripheral Ethernet_MAC: Ethernet: media access control (MAC)
//------------------------------------------------------------------------------

//---  Register MACCR: Operating mode configuration register
  #define Ethernet_MAC_MACCR (* ((volatile uint32_t *) (0x40028000 + 0)))

  // Field RE: Receiver Enable
    const uint32_t Ethernet_MAC_MACCR_RE = 1U << 0 ;

  // Field TE: TE
    const uint32_t Ethernet_MAC_MACCR_TE = 1U << 1 ;

  // Field PRELEN: PRELEN
    inline uint32_t Ethernet_MAC_MACCR_PRELEN (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DC: DC
    const uint32_t Ethernet_MAC_MACCR_DC = 1U << 4 ;

  // Field BL: BL
    inline uint32_t Ethernet_MAC_MACCR_BL (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DR: DR
    const uint32_t Ethernet_MAC_MACCR_DR = 1U << 8 ;

  // Field DCRS: DCRS
    const uint32_t Ethernet_MAC_MACCR_DCRS = 1U << 9 ;

  // Field DO: DO
    const uint32_t Ethernet_MAC_MACCR_DO = 1U << 10 ;

  // Field ECRSFD: ECRSFD
    const uint32_t Ethernet_MAC_MACCR_ECRSFD = 1U << 11 ;

  // Field LM: LM
    const uint32_t Ethernet_MAC_MACCR_LM = 1U << 12 ;

  // Field DM: DM
    const uint32_t Ethernet_MAC_MACCR_DM = 1U << 13 ;

  // Field FES: FES
    const uint32_t Ethernet_MAC_MACCR_FES = 1U << 14 ;

  // Field JE: JE
    const uint32_t Ethernet_MAC_MACCR_JE = 1U << 16 ;

  // Field JD: JD
    const uint32_t Ethernet_MAC_MACCR_JD = 1U << 17 ;

  // Field WD: WD
    const uint32_t Ethernet_MAC_MACCR_WD = 1U << 19 ;

  // Field ACS: ACS
    const uint32_t Ethernet_MAC_MACCR_ACS = 1U << 20 ;

  // Field CST: CST
    const uint32_t Ethernet_MAC_MACCR_CST = 1U << 21 ;

  // Field S2KP: S2KP
    const uint32_t Ethernet_MAC_MACCR_S2KP = 1U << 22 ;

  // Field GPSLCE: GPSLCE
    const uint32_t Ethernet_MAC_MACCR_GPSLCE = 1U << 23 ;

  // Field IPG: IPG
    inline uint32_t Ethernet_MAC_MACCR_IPG (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field IPC: IPC
    const uint32_t Ethernet_MAC_MACCR_IPC = 1U << 27 ;

  // Field SARC: SARC
    inline uint32_t Ethernet_MAC_MACCR_SARC (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field ARPEN: ARPEN
    const uint32_t Ethernet_MAC_MACCR_ARPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACECR: Extended operating mode configuration register
  #define Ethernet_MAC_MACECR (* ((volatile uint32_t *) (0x40028000 + 4)))

  // Field GPSL: GPSL
    inline uint32_t Ethernet_MAC_MACECR_GPSL (const uint32_t inValue) {return (inValue & 0x3FFFU) << 0 ; }

  // Field DCRCC: DCRCC
    const uint32_t Ethernet_MAC_MACECR_DCRCC = 1U << 16 ;

  // Field SPEN: SPEN
    const uint32_t Ethernet_MAC_MACECR_SPEN = 1U << 17 ;

  // Field USP: USP
    const uint32_t Ethernet_MAC_MACECR_USP = 1U << 18 ;

  // Field EIPGEN: EIPGEN
    const uint32_t Ethernet_MAC_MACECR_EIPGEN = 1U << 24 ;

  // Field EIPG: EIPG
    inline uint32_t Ethernet_MAC_MACECR_EIPG (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

//------------------------------------------------------------------------------

//---  Register MACPFR: Packet filtering control register
  #define Ethernet_MAC_MACPFR (* ((volatile uint32_t *) (0x40028000 + 8)))

  // Field PR: PR
    const uint32_t Ethernet_MAC_MACPFR_PR = 1U << 0 ;

  // Field HUC: HUC
    const uint32_t Ethernet_MAC_MACPFR_HUC = 1U << 1 ;

  // Field HMC: HMC
    const uint32_t Ethernet_MAC_MACPFR_HMC = 1U << 2 ;

  // Field DAIF: DAIF
    const uint32_t Ethernet_MAC_MACPFR_DAIF = 1U << 3 ;

  // Field PM: PM
    const uint32_t Ethernet_MAC_MACPFR_PM = 1U << 4 ;

  // Field DBF: DBF
    const uint32_t Ethernet_MAC_MACPFR_DBF = 1U << 5 ;

  // Field PCF: PCF
    inline uint32_t Ethernet_MAC_MACPFR_PCF (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SAIF: SAIF
    const uint32_t Ethernet_MAC_MACPFR_SAIF = 1U << 8 ;

  // Field SAF: SAF
    const uint32_t Ethernet_MAC_MACPFR_SAF = 1U << 9 ;

  // Field HPF: HPF
    const uint32_t Ethernet_MAC_MACPFR_HPF = 1U << 10 ;

  // Field VTFE: VTFE
    const uint32_t Ethernet_MAC_MACPFR_VTFE = 1U << 16 ;

  // Field IPFE: IPFE
    const uint32_t Ethernet_MAC_MACPFR_IPFE = 1U << 20 ;

  // Field DNTU: DNTU
    const uint32_t Ethernet_MAC_MACPFR_DNTU = 1U << 21 ;

  // Field RA: RA
    const uint32_t Ethernet_MAC_MACPFR_RA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACWTR: Watchdog timeout register
  #define Ethernet_MAC_MACWTR (* ((volatile uint32_t *) (0x40028000 + 12)))

  // Field WTO: WTO
    inline uint32_t Ethernet_MAC_MACWTR_WTO (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field PWE: PWE
    const uint32_t Ethernet_MAC_MACWTR_PWE = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register MACHT0R: Hash Table 0 register
  #define Ethernet_MAC_MACHT0R (* ((volatile uint32_t *) (0x40028000 + 16)))

  // Field HT31T0: HT31T0
    inline uint32_t Ethernet_MAC_MACHT0R_HT31T0 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACHT1R: Hash Table 1 register
  #define Ethernet_MAC_MACHT1R (* ((volatile uint32_t *) (0x40028000 + 20)))

  // Field HT63T32: HT63T32
    inline uint32_t Ethernet_MAC_MACHT1R_HT63T32 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACVTR: VLAN tag register
  #define Ethernet_MAC_MACVTR (* ((volatile uint32_t *) (0x40028000 + 80)))

  // Field VL: VL
    inline uint32_t Ethernet_MAC_MACVTR_VL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field ETV: ETV
    const uint32_t Ethernet_MAC_MACVTR_ETV = 1U << 16 ;

  // Field VTIM: VTIM
    const uint32_t Ethernet_MAC_MACVTR_VTIM = 1U << 17 ;

  // Field ESVL: ESVL
    const uint32_t Ethernet_MAC_MACVTR_ESVL = 1U << 18 ;

  // Field ERSVLM: ERSVLM
    const uint32_t Ethernet_MAC_MACVTR_ERSVLM = 1U << 19 ;

  // Field DOVLTC: DOVLTC
    const uint32_t Ethernet_MAC_MACVTR_DOVLTC = 1U << 20 ;

  // Field EVLS: EVLS
    inline uint32_t Ethernet_MAC_MACVTR_EVLS (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field EVLRXS: EVLRXS
    const uint32_t Ethernet_MAC_MACVTR_EVLRXS = 1U << 24 ;

  // Field VTHM: VTHM
    const uint32_t Ethernet_MAC_MACVTR_VTHM = 1U << 25 ;

  // Field EDVLP: EDVLP
    const uint32_t Ethernet_MAC_MACVTR_EDVLP = 1U << 26 ;

  // Field ERIVLT: ERIVLT
    const uint32_t Ethernet_MAC_MACVTR_ERIVLT = 1U << 27 ;

  // Field EIVLS: EIVLS
    inline uint32_t Ethernet_MAC_MACVTR_EIVLS (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field EIVLRXS: EIVLRXS
    const uint32_t Ethernet_MAC_MACVTR_EIVLRXS = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACVHTR: VLAN Hash table register
  #define Ethernet_MAC_MACVHTR (* ((volatile uint32_t *) (0x40028000 + 88)))

  // Field VLHT: VLHT
    inline uint32_t Ethernet_MAC_MACVHTR_VLHT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACVIR: VLAN inclusion register
  #define Ethernet_MAC_MACVIR (* ((volatile uint32_t *) (0x40028000 + 96)))

  // Field VLT: VLT
    inline uint32_t Ethernet_MAC_MACVIR_VLT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field VLC: VLC
    inline uint32_t Ethernet_MAC_MACVIR_VLC (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field VLP: VLP
    const uint32_t Ethernet_MAC_MACVIR_VLP = 1U << 18 ;

  // Field CSVL: CSVL
    const uint32_t Ethernet_MAC_MACVIR_CSVL = 1U << 19 ;

  // Field VLTI: VLTI
    const uint32_t Ethernet_MAC_MACVIR_VLTI = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register MACIVIR: Inner VLAN inclusion register
  #define Ethernet_MAC_MACIVIR (* ((volatile uint32_t *) (0x40028000 + 100)))

  // Field VLT: VLT
    inline uint32_t Ethernet_MAC_MACIVIR_VLT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field VLC: VLC
    inline uint32_t Ethernet_MAC_MACIVIR_VLC (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field VLP: VLP
    const uint32_t Ethernet_MAC_MACIVIR_VLP = 1U << 18 ;

  // Field CSVL: CSVL
    const uint32_t Ethernet_MAC_MACIVIR_CSVL = 1U << 19 ;

  // Field VLTI: VLTI
    const uint32_t Ethernet_MAC_MACIVIR_VLTI = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register MACQTxFCR: Tx Queue flow control register
  #define Ethernet_MAC_MACQTxFCR (* ((volatile uint32_t *) (0x40028000 + 112)))

  // Field FCB_BPA: FCB_BPA
    const uint32_t Ethernet_MAC_MACQTxFCR_FCB_BPA = 1U << 0 ;

  // Field TFE: TFE
    const uint32_t Ethernet_MAC_MACQTxFCR_TFE = 1U << 1 ;

  // Field PLT: PLT
    inline uint32_t Ethernet_MAC_MACQTxFCR_PLT (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DZPQ: DZPQ
    const uint32_t Ethernet_MAC_MACQTxFCR_DZPQ = 1U << 7 ;

  // Field PT: PT
    inline uint32_t Ethernet_MAC_MACQTxFCR_PT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MACRxFCR: Rx flow control register
  #define Ethernet_MAC_MACRxFCR (* ((volatile uint32_t *) (0x40028000 + 144)))

  // Field RFE: RFE
    const uint32_t Ethernet_MAC_MACRxFCR_RFE = 1U << 0 ;

  // Field UP: UP
    const uint32_t Ethernet_MAC_MACRxFCR_UP = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register MACISR: Interrupt status register
  #define Ethernet_MAC_MACISR (* ((const volatile uint32_t *) (0x40028000 + 176)))

  // Field PHYIS: PHYIS
    const uint32_t Ethernet_MAC_MACISR_PHYIS = 1U << 3 ;

  // Field PMTIS: PMTIS
    const uint32_t Ethernet_MAC_MACISR_PMTIS = 1U << 4 ;

  // Field LPIIS: LPIIS
    const uint32_t Ethernet_MAC_MACISR_LPIIS = 1U << 5 ;

  // Field MMCIS: MMCIS
    const uint32_t Ethernet_MAC_MACISR_MMCIS = 1U << 8 ;

  // Field MMCRXIS: MMCRXIS
    const uint32_t Ethernet_MAC_MACISR_MMCRXIS = 1U << 9 ;

  // Field MMCTXIS: MMCTXIS
    const uint32_t Ethernet_MAC_MACISR_MMCTXIS = 1U << 10 ;

  // Field TSIS: TSIS
    const uint32_t Ethernet_MAC_MACISR_TSIS = 1U << 12 ;

  // Field TXSTSIS: TXSTSIS
    const uint32_t Ethernet_MAC_MACISR_TXSTSIS = 1U << 13 ;

  // Field RXSTSIS: RXSTSIS
    const uint32_t Ethernet_MAC_MACISR_RXSTSIS = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register MACIER: Interrupt enable register
  #define Ethernet_MAC_MACIER (* ((volatile uint32_t *) (0x40028000 + 180)))

  // Field PHYIE: PHYIE
    const uint32_t Ethernet_MAC_MACIER_PHYIE = 1U << 3 ;

  // Field PMTIE: PMTIE
    const uint32_t Ethernet_MAC_MACIER_PMTIE = 1U << 4 ;

  // Field LPIIE: LPIIE
    const uint32_t Ethernet_MAC_MACIER_LPIIE = 1U << 5 ;

  // Field TSIE: TSIE
    const uint32_t Ethernet_MAC_MACIER_TSIE = 1U << 12 ;

  // Field TXSTSIE: TXSTSIE
    const uint32_t Ethernet_MAC_MACIER_TXSTSIE = 1U << 13 ;

  // Field RXSTSIE: RXSTSIE
    const uint32_t Ethernet_MAC_MACIER_RXSTSIE = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register MACRxTxSR: Rx Tx status register
  #define Ethernet_MAC_MACRxTxSR (* ((const volatile uint32_t *) (0x40028000 + 184)))

  // Field TJT: TJT
    const uint32_t Ethernet_MAC_MACRxTxSR_TJT = 1U << 0 ;

  // Field NCARR: NCARR
    const uint32_t Ethernet_MAC_MACRxTxSR_NCARR = 1U << 1 ;

  // Field LCARR: LCARR
    const uint32_t Ethernet_MAC_MACRxTxSR_LCARR = 1U << 2 ;

  // Field EXDEF: EXDEF
    const uint32_t Ethernet_MAC_MACRxTxSR_EXDEF = 1U << 3 ;

  // Field LCOL: LCOL
    const uint32_t Ethernet_MAC_MACRxTxSR_LCOL = 1U << 4 ;

  // Field EXCOL: LCOL
    const uint32_t Ethernet_MAC_MACRxTxSR_EXCOL = 1U << 5 ;

  // Field RWT: RWT
    const uint32_t Ethernet_MAC_MACRxTxSR_RWT = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register MACPCSR: PMT control status register
  #define Ethernet_MAC_MACPCSR (* ((volatile uint32_t *) (0x40028000 + 192)))

  // Field PWRDWN: PWRDWN
    const uint32_t Ethernet_MAC_MACPCSR_PWRDWN = 1U << 0 ;

  // Field MGKPKTEN: MGKPKTEN
    const uint32_t Ethernet_MAC_MACPCSR_MGKPKTEN = 1U << 1 ;

  // Field RWKPKTEN: RWKPKTEN
    const uint32_t Ethernet_MAC_MACPCSR_RWKPKTEN = 1U << 2 ;

  // Field MGKPRCVD: MGKPRCVD
    const uint32_t Ethernet_MAC_MACPCSR_MGKPRCVD = 1U << 5 ;

  // Field RWKPRCVD: RWKPRCVD
    const uint32_t Ethernet_MAC_MACPCSR_RWKPRCVD = 1U << 6 ;

  // Field GLBLUCAST: GLBLUCAST
    const uint32_t Ethernet_MAC_MACPCSR_GLBLUCAST = 1U << 9 ;

  // Field RWKPFE: RWKPFE
    const uint32_t Ethernet_MAC_MACPCSR_RWKPFE = 1U << 10 ;

  // Field RWKPTR: RWKPTR
    inline uint32_t Ethernet_MAC_MACPCSR_RWKPTR (const uint32_t inValue) {return (inValue & 0x1FU) << 24 ; }

  // Field RWKFILTRST: RWKFILTRST
    const uint32_t Ethernet_MAC_MACPCSR_RWKFILTRST = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACRWKPFR: Remove wakeup packet filter register
  #define Ethernet_MAC_MACRWKPFR (* ((volatile uint32_t *) (0x40028000 + 196)))

  // Field MACRWKPFR: MACRWKPFR
    inline uint32_t Ethernet_MAC_MACRWKPFR_MACRWKPFR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACLCSR: LPI control status register
  #define Ethernet_MAC_MACLCSR (* ((volatile uint32_t *) (0x40028000 + 208)))

  // Field TLPIEN: TLPIEN
    const uint32_t Ethernet_MAC_MACLCSR_TLPIEN = 1U << 0 ;

  // Field TLPIEX: TLPIEX
    const uint32_t Ethernet_MAC_MACLCSR_TLPIEX = 1U << 1 ;

  // Field RLPIEN: RLPIEN
    const uint32_t Ethernet_MAC_MACLCSR_RLPIEN = 1U << 2 ;

  // Field RLPIEX: RLPIEX
    const uint32_t Ethernet_MAC_MACLCSR_RLPIEX = 1U << 3 ;

  // Field TLPIST: TLPIST
    const uint32_t Ethernet_MAC_MACLCSR_TLPIST = 1U << 8 ;

  // Field RLPIST: RLPIST
    const uint32_t Ethernet_MAC_MACLCSR_RLPIST = 1U << 9 ;

  // Field LPIEN: LPIEN
    const uint32_t Ethernet_MAC_MACLCSR_LPIEN = 1U << 16 ;

  // Field PLS: PLS
    const uint32_t Ethernet_MAC_MACLCSR_PLS = 1U << 17 ;

  // Field PLSEN: PLSEN
    const uint32_t Ethernet_MAC_MACLCSR_PLSEN = 1U << 18 ;

  // Field LPITXA: LPITXA
    const uint32_t Ethernet_MAC_MACLCSR_LPITXA = 1U << 19 ;

  // Field LPITE: LPITE
    const uint32_t Ethernet_MAC_MACLCSR_LPITE = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register MACLTCR: LPI timers control register
  #define Ethernet_MAC_MACLTCR (* ((volatile uint32_t *) (0x40028000 + 212)))

  // Field TWT: TWT
    inline uint32_t Ethernet_MAC_MACLTCR_TWT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field LST: LST
    inline uint32_t Ethernet_MAC_MACLTCR_LST (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MACLETR: LPI entry timer register
  #define Ethernet_MAC_MACLETR (* ((volatile uint32_t *) (0x40028000 + 216)))

  // Field LPIET: LPIET
    inline uint32_t Ethernet_MAC_MACLETR_LPIET (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MAC1USTCR: 1-microsecond-tick counter register
  #define Ethernet_MAC_MAC1USTCR (* ((volatile uint32_t *) (0x40028000 + 220)))

  // Field TIC_1US_CNTR: TIC_1US_CNTR
    inline uint32_t Ethernet_MAC_MAC1USTCR_TIC_1US_CNTR (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACVR: Version register
  #define Ethernet_MAC_MACVR (* ((const volatile uint32_t *) (0x40028000 + 272)))

  // Field SNPSVER: SNPSVER
    inline uint32_t Ethernet_MAC_MACVR_SNPSVER (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field USERVER: USERVER
    inline uint32_t Ethernet_MAC_MACVR_USERVER (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register MACDR: Debug register
  #define Ethernet_MAC_MACDR (* ((const volatile uint32_t *) (0x40028000 + 276)))

  // Field RPESTS: RPESTS
    const uint32_t Ethernet_MAC_MACDR_RPESTS = 1U << 0 ;

  // Field RFCFCSTS: RFCFCSTS
    inline uint32_t Ethernet_MAC_MACDR_RFCFCSTS (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field TPESTS: TPESTS
    const uint32_t Ethernet_MAC_MACDR_TPESTS = 1U << 16 ;

  // Field TFCSTS: TFCSTS
    inline uint32_t Ethernet_MAC_MACDR_TFCSTS (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

//------------------------------------------------------------------------------

//---  Register MACHWF1R: HW feature 1 register
  #define Ethernet_MAC_MACHWF1R (* ((const volatile uint32_t *) (0x40028000 + 288)))

  // Field RXFIFOSIZE: RXFIFOSIZE
    inline uint32_t Ethernet_MAC_MACHWF1R_RXFIFOSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field TXFIFOSIZE: TXFIFOSIZE
    inline uint32_t Ethernet_MAC_MACHWF1R_TXFIFOSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field OSTEN: OSTEN
    const uint32_t Ethernet_MAC_MACHWF1R_OSTEN = 1U << 11 ;

  // Field PTOEN: PTOEN
    const uint32_t Ethernet_MAC_MACHWF1R_PTOEN = 1U << 12 ;

  // Field ADVTHWORD: ADVTHWORD
    const uint32_t Ethernet_MAC_MACHWF1R_ADVTHWORD = 1U << 13 ;

  // Field ADDR64: ADDR64
    inline uint32_t Ethernet_MAC_MACHWF1R_ADDR64 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field DCBEN: DCBEN
    const uint32_t Ethernet_MAC_MACHWF1R_DCBEN = 1U << 16 ;

  // Field SPHEN: SPHEN
    const uint32_t Ethernet_MAC_MACHWF1R_SPHEN = 1U << 17 ;

  // Field TSOEN: TSOEN
    const uint32_t Ethernet_MAC_MACHWF1R_TSOEN = 1U << 18 ;

  // Field DBGMEMA: DBGMEMA
    const uint32_t Ethernet_MAC_MACHWF1R_DBGMEMA = 1U << 19 ;

  // Field AVSEL: AVSEL
    const uint32_t Ethernet_MAC_MACHWF1R_AVSEL = 1U << 20 ;

  // Field HASHTBLSZ: HASHTBLSZ
    inline uint32_t Ethernet_MAC_MACHWF1R_HASHTBLSZ (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field L3L4FNUM: L3L4FNUM
    inline uint32_t Ethernet_MAC_MACHWF1R_L3L4FNUM (const uint32_t inValue) {return (inValue & 0xFU) << 27 ; }

//------------------------------------------------------------------------------

//---  Register MACHWF2R: HW feature 2 register
  #define Ethernet_MAC_MACHWF2R (* ((const volatile uint32_t *) (0x40028000 + 292)))

  // Field RXQCNT: RXQCNT
    inline uint32_t Ethernet_MAC_MACHWF2R_RXQCNT (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TXQCNT: TXQCNT
    inline uint32_t Ethernet_MAC_MACHWF2R_TXQCNT (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field RXCHCNT: RXCHCNT
    inline uint32_t Ethernet_MAC_MACHWF2R_RXCHCNT (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field TXCHCNT: TXCHCNT
    inline uint32_t Ethernet_MAC_MACHWF2R_TXCHCNT (const uint32_t inValue) {return (inValue & 0xFU) << 18 ; }

  // Field PPSOUTNUM: PPSOUTNUM
    inline uint32_t Ethernet_MAC_MACHWF2R_PPSOUTNUM (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field AUXSNAPNUM: AUXSNAPNUM
    inline uint32_t Ethernet_MAC_MACHWF2R_AUXSNAPNUM (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register MACMDIOAR: MDIO address register
  #define Ethernet_MAC_MACMDIOAR (* ((volatile uint32_t *) (0x40028000 + 512)))

  // Field MB: MB
    const uint32_t Ethernet_MAC_MACMDIOAR_MB = 1U << 0 ;

  // Field C45E: C45E
    const uint32_t Ethernet_MAC_MACMDIOAR_C45E = 1U << 1 ;

  // Field GOC: GOC
    inline uint32_t Ethernet_MAC_MACMDIOAR_GOC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SKAP: SKAP
    const uint32_t Ethernet_MAC_MACMDIOAR_SKAP = 1U << 4 ;

  // Field CR: CR
    inline uint32_t Ethernet_MAC_MACMDIOAR_CR (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field NTC: NTC
    inline uint32_t Ethernet_MAC_MACMDIOAR_NTC (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field RDA: RDA
    inline uint32_t Ethernet_MAC_MACMDIOAR_RDA (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field PA: PA
    inline uint32_t Ethernet_MAC_MACMDIOAR_PA (const uint32_t inValue) {return (inValue & 0x1FU) << 21 ; }

  // Field BTB: BTB
    const uint32_t Ethernet_MAC_MACMDIOAR_BTB = 1U << 26 ;

  // Field PSE: PSE
    const uint32_t Ethernet_MAC_MACMDIOAR_PSE = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register MACMDIODR: MDIO data register
  #define Ethernet_MAC_MACMDIODR (* ((volatile uint32_t *) (0x40028000 + 516)))

  // Field MD: MD
    inline uint32_t Ethernet_MAC_MACMDIODR_MD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field RA: RA
    inline uint32_t Ethernet_MAC_MACMDIODR_RA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MACARPAR: ARP address register
  #define Ethernet_MAC_MACARPAR (* ((volatile uint32_t *) (0x40028000 + 2784)))

  // Field ARPPA: ARPPA
    inline uint32_t Ethernet_MAC_MACARPAR_ARPPA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACA0HR: Address 0 high register
  #define Ethernet_MAC_MACA0HR (* ((volatile uint32_t *) (0x40028000 + 768)))

  // Field ADDRHI: ADDRHI
    inline uint32_t Ethernet_MAC_MACA0HR_ADDRHI (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field AE: AE
    const uint32_t Ethernet_MAC_MACA0HR_AE = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACA0LR: Address 0 low register
  #define Ethernet_MAC_MACA0LR (* ((volatile uint32_t *) (0x40028000 + 772)))

  // Field ADDRLO: ADDRLO
    inline uint32_t Ethernet_MAC_MACA0LR_ADDRLO (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACA1LR: Address 1 low register
  #define Ethernet_MAC_MACA1LR (* ((volatile uint32_t *) (0x40028000 + 780)))

  // Field ADDRLO: ADDRLO
    inline uint32_t Ethernet_MAC_MACA1LR_ADDRLO (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACA2LR: Address 2 low register
  #define Ethernet_MAC_MACA2LR (* ((volatile uint32_t *) (0x40028000 + 788)))

  // Field ADDRLO: ADDRLO
    inline uint32_t Ethernet_MAC_MACA2LR_ADDRLO (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACA1HR: Address 1 high register
  #define Ethernet_MAC_MACA1HR (* ((volatile uint32_t *) (0x40028000 + 776)))

  // Field ADDRHI: ADDRHI
    inline uint32_t Ethernet_MAC_MACA1HR_ADDRHI (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field MBC: MBC
    inline uint32_t Ethernet_MAC_MACA1HR_MBC (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

  // Field SA: SA
    const uint32_t Ethernet_MAC_MACA1HR_SA = 1U << 30 ;

  // Field AE: AE
    const uint32_t Ethernet_MAC_MACA1HR_AE = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACA2HR: Address 2 high register
  #define Ethernet_MAC_MACA2HR (* ((volatile uint32_t *) (0x40028000 + 784)))

  // Field ADDRHI: ADDRHI
    inline uint32_t Ethernet_MAC_MACA2HR_ADDRHI (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field MBC: MBC
    inline uint32_t Ethernet_MAC_MACA2HR_MBC (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

  // Field SA: SA
    const uint32_t Ethernet_MAC_MACA2HR_SA = 1U << 30 ;

  // Field AE: AE
    const uint32_t Ethernet_MAC_MACA2HR_AE = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACA3HR: Address 3 high register
  #define Ethernet_MAC_MACA3HR (* ((volatile uint32_t *) (0x40028000 + 792)))

  // Field ADDRHI: ADDRHI
    inline uint32_t Ethernet_MAC_MACA3HR_ADDRHI (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field MBC: MBC
    inline uint32_t Ethernet_MAC_MACA3HR_MBC (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

  // Field SA: SA
    const uint32_t Ethernet_MAC_MACA3HR_SA = 1U << 30 ;

  // Field AE: AE
    const uint32_t Ethernet_MAC_MACA3HR_AE = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACA3LR: Address 3 low register
  #define Ethernet_MAC_MACA3LR (* ((volatile uint32_t *) (0x40028000 + 796)))

  // Field ADDRLO: ADDRLO
    inline uint32_t Ethernet_MAC_MACA3LR_ADDRLO (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MMC_CONTROL: MMC control register
  #define Ethernet_MAC_MMC_CONTROL (* ((volatile uint32_t *) (0x40028000 + 1792)))

  // Field CNTRST: CNTRST
    const uint32_t Ethernet_MAC_MMC_CONTROL_CNTRST = 1U << 0 ;

  // Field CNTSTOPRO: CNTSTOPRO
    const uint32_t Ethernet_MAC_MMC_CONTROL_CNTSTOPRO = 1U << 1 ;

  // Field RSTONRD: RSTONRD
    const uint32_t Ethernet_MAC_MMC_CONTROL_RSTONRD = 1U << 2 ;

  // Field CNTFREEZ: CNTFREEZ
    const uint32_t Ethernet_MAC_MMC_CONTROL_CNTFREEZ = 1U << 3 ;

  // Field CNTPRST: CNTPRST
    const uint32_t Ethernet_MAC_MMC_CONTROL_CNTPRST = 1U << 4 ;

  // Field CNTPRSTLVL: CNTPRSTLVL
    const uint32_t Ethernet_MAC_MMC_CONTROL_CNTPRSTLVL = 1U << 5 ;

  // Field UCDBC: UCDBC
    const uint32_t Ethernet_MAC_MMC_CONTROL_UCDBC = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register MMC_RX_INTERRUPT: MMC Rx interrupt register
  #define Ethernet_MAC_MMC_RX_INTERRUPT (* ((const volatile uint32_t *) (0x40028000 + 1796)))

  // Field RXCRCERPIS: RXCRCERPIS
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_RXCRCERPIS = 1U << 5 ;

  // Field RXALGNERPIS: RXALGNERPIS
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_RXALGNERPIS = 1U << 6 ;

  // Field RXUCGPIS: RXUCGPIS
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_RXUCGPIS = 1U << 17 ;

  // Field RXLPIUSCIS: RXLPIUSCIS
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_RXLPIUSCIS = 1U << 26 ;

  // Field RXLPITRCIS: RXLPITRCIS
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_RXLPITRCIS = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register MMC_TX_INTERRUPT: MMC Tx interrupt register
  #define Ethernet_MAC_MMC_TX_INTERRUPT (* ((const volatile uint32_t *) (0x40028000 + 1800)))

  // Field TXSCOLGPIS: TXSCOLGPIS
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_TXSCOLGPIS = 1U << 14 ;

  // Field TXMCOLGPIS: TXMCOLGPIS
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_TXMCOLGPIS = 1U << 15 ;

  // Field TXGPKTIS: TXGPKTIS
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_TXGPKTIS = 1U << 21 ;

  // Field TXLPIUSCIS: TXLPIUSCIS
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_TXLPIUSCIS = 1U << 26 ;

  // Field TXLPITRCIS: TXLPITRCIS
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_TXLPITRCIS = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register MMC_RX_INTERRUPT_MASK: MMC Rx interrupt mask register
  #define Ethernet_MAC_MMC_RX_INTERRUPT_MASK (* ((volatile uint32_t *) (0x40028000 + 1804)))

  // Field RXCRCERPIM: RXCRCERPIM
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXCRCERPIM = 1U << 5 ;

  // Field RXALGNERPIM: RXALGNERPIM
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXALGNERPIM = 1U << 6 ;

  // Field RXUCGPIM: RXUCGPIM
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXUCGPIM = 1U << 17 ;

  // Field RXLPIUSCIM: RXLPIUSCIM
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXLPIUSCIM = 1U << 26 ;

  // Field RXLPITRCIM: RXLPITRCIM
    const uint32_t Ethernet_MAC_MMC_RX_INTERRUPT_MASK_RXLPITRCIM = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register MMC_TX_INTERRUPT_MASK: MMC Tx interrupt mask register
  #define Ethernet_MAC_MMC_TX_INTERRUPT_MASK (* ((volatile uint32_t *) (0x40028000 + 1808)))

  // Field TXSCOLGPIM: TXSCOLGPIM
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXSCOLGPIM = 1U << 14 ;

  // Field TXMCOLGPIM: TXMCOLGPIM
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXMCOLGPIM = 1U << 15 ;

  // Field TXGPKTIM: TXGPKTIM
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXGPKTIM = 1U << 21 ;

  // Field TXLPIUSCIM: TXLPIUSCIM
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXLPIUSCIM = 1U << 26 ;

  // Field TXLPITRCIM: TXLPITRCIM
    const uint32_t Ethernet_MAC_MMC_TX_INTERRUPT_MASK_TXLPITRCIM = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register TX_SINGLE_COLLISION_GOOD_PACKETS: Tx single collision good packets register
  #define Ethernet_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS (* ((const volatile uint32_t *) (0x40028000 + 1868)))

  // Field TXSNGLCOLG: TXSNGLCOLG
    inline uint32_t Ethernet_MAC_TX_SINGLE_COLLISION_GOOD_PACKETS_TXSNGLCOLG (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TX_MULTIPLE_COLLISION_GOOD_PACKETS: Tx multiple collision good packets register
  #define Ethernet_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS (* ((const volatile uint32_t *) (0x40028000 + 1872)))

  // Field TXMULTCOLG: TXMULTCOLG
    inline uint32_t Ethernet_MAC_TX_MULTIPLE_COLLISION_GOOD_PACKETS_TXMULTCOLG (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TX_PACKET_COUNT_GOOD: Tx packet count good register
  #define Ethernet_MAC_TX_PACKET_COUNT_GOOD (* ((const volatile uint32_t *) (0x40028000 + 1896)))

  // Field TXPKTG: TXPKTG
    inline uint32_t Ethernet_MAC_TX_PACKET_COUNT_GOOD_TXPKTG (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RX_CRC_ERROR_PACKETS: Rx CRC error packets register
  #define Ethernet_MAC_RX_CRC_ERROR_PACKETS (* ((const volatile uint32_t *) (0x40028000 + 1940)))

  // Field RXCRCERR: RXCRCERR
    inline uint32_t Ethernet_MAC_RX_CRC_ERROR_PACKETS_RXCRCERR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RX_ALIGNMENT_ERROR_PACKETS: Rx alignment error packets register
  #define Ethernet_MAC_RX_ALIGNMENT_ERROR_PACKETS (* ((const volatile uint32_t *) (0x40028000 + 1944)))

  // Field RXALGNERR: RXALGNERR
    inline uint32_t Ethernet_MAC_RX_ALIGNMENT_ERROR_PACKETS_RXALGNERR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RX_UNICAST_PACKETS_GOOD: Rx unicast packets good register
  #define Ethernet_MAC_RX_UNICAST_PACKETS_GOOD (* ((const volatile uint32_t *) (0x40028000 + 1988)))

  // Field RXUCASTG: RXUCASTG
    inline uint32_t Ethernet_MAC_RX_UNICAST_PACKETS_GOOD_RXUCASTG (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TX_LPI_USEC_CNTR: Tx LPI microsecond timer register
  #define Ethernet_MAC_TX_LPI_USEC_CNTR (* ((const volatile uint32_t *) (0x40028000 + 2028)))

  // Field TXLPIUSC: TXLPIUSC
    inline uint32_t Ethernet_MAC_TX_LPI_USEC_CNTR_TXLPIUSC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TX_LPI_TRAN_CNTR: Tx LPI transition counter register
  #define Ethernet_MAC_TX_LPI_TRAN_CNTR (* ((const volatile uint32_t *) (0x40028000 + 2032)))

  // Field TXLPITRC: TXLPITRC
    inline uint32_t Ethernet_MAC_TX_LPI_TRAN_CNTR_TXLPITRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RX_LPI_USEC_CNTR: Rx LPI microsecond counter register
  #define Ethernet_MAC_RX_LPI_USEC_CNTR (* ((const volatile uint32_t *) (0x40028000 + 2036)))

  // Field RXLPIUSC: RXLPIUSC
    inline uint32_t Ethernet_MAC_RX_LPI_USEC_CNTR_RXLPIUSC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RX_LPI_TRAN_CNTR: Rx LPI transition counter register
  #define Ethernet_MAC_RX_LPI_TRAN_CNTR (* ((const volatile uint32_t *) (0x40028000 + 2040)))

  // Field RXLPITRC: RXLPITRC
    inline uint32_t Ethernet_MAC_RX_LPI_TRAN_CNTR_RXLPITRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3L4C0R: L3 and L4 control 0 register
  #define Ethernet_MAC_MACL3L4C0R (* ((volatile uint32_t *) (0x40028000 + 2304)))

  // Field L3PEN0: L3PEN0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L3PEN0 = 1U << 0 ;

  // Field L3SAM0: L3SAM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L3SAM0 = 1U << 2 ;

  // Field L3SAIM0: L3SAIM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L3SAIM0 = 1U << 3 ;

  // Field L3DAM0: L3DAM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L3DAM0 = 1U << 4 ;

  // Field L3DAIM0: L3DAIM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L3DAIM0 = 1U << 5 ;

  // Field L3HSBM0: L3HSBM0
    inline uint32_t Ethernet_MAC_MACL3L4C0R_L3HSBM0 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field L3HDBM0: L3HDBM0
    inline uint32_t Ethernet_MAC_MACL3L4C0R_L3HDBM0 (const uint32_t inValue) {return (inValue & 0x1FU) << 11 ; }

  // Field L4PEN0: L4PEN0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L4PEN0 = 1U << 16 ;

  // Field L4SPM0: L4SPM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L4SPM0 = 1U << 18 ;

  // Field L4SPIM0: L4SPIM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L4SPIM0 = 1U << 19 ;

  // Field L4DPM0: L4DPM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L4DPM0 = 1U << 20 ;

  // Field L4DPIM0: L4DPIM0
    const uint32_t Ethernet_MAC_MACL3L4C0R_L4DPIM0 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register MACL4A0R: Layer4 address filter 0 register
  #define Ethernet_MAC_MACL4A0R (* ((volatile uint32_t *) (0x40028000 + 2308)))

  // Field L4SP0: L4SP0
    inline uint32_t Ethernet_MAC_MACL4A0R_L4SP0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field L4DP0: L4DP0
    inline uint32_t Ethernet_MAC_MACL4A0R_L4DP0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A00R: MACL3A00R
  #define Ethernet_MAC_MACL3A00R (* ((volatile uint32_t *) (0x40028000 + 2320)))

  // Field L3A00: L3A00
    inline uint32_t Ethernet_MAC_MACL3A00R_L3A00 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A10R: Layer3 address 1 filter 0 register
  #define Ethernet_MAC_MACL3A10R (* ((volatile uint32_t *) (0x40028000 + 2324)))

  // Field L3A10: L3A10
    inline uint32_t Ethernet_MAC_MACL3A10R_L3A10 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A20: Layer3 Address 2 filter 0 register
  #define Ethernet_MAC_MACL3A20 (* ((volatile uint32_t *) (0x40028000 + 2328)))

  // Field L3A20: L3A20
    inline uint32_t Ethernet_MAC_MACL3A20_L3A20 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A30: Layer3 Address 3 filter 0 register
  #define Ethernet_MAC_MACL3A30 (* ((volatile uint32_t *) (0x40028000 + 2332)))

  // Field L3A30: L3A30
    inline uint32_t Ethernet_MAC_MACL3A30_L3A30 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3L4C1R: L3 and L4 control 1 register
  #define Ethernet_MAC_MACL3L4C1R (* ((volatile uint32_t *) (0x40028000 + 2352)))

  // Field L3PEN1: L3PEN1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L3PEN1 = 1U << 0 ;

  // Field L3SAM1: L3SAM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L3SAM1 = 1U << 2 ;

  // Field L3SAIM1: L3SAIM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L3SAIM1 = 1U << 3 ;

  // Field L3DAM1: L3DAM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L3DAM1 = 1U << 4 ;

  // Field L3DAIM1: L3DAIM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L3DAIM1 = 1U << 5 ;

  // Field L3HSBM1: L3HSBM1
    inline uint32_t Ethernet_MAC_MACL3L4C1R_L3HSBM1 (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field L3HDBM1: L3HDBM1
    inline uint32_t Ethernet_MAC_MACL3L4C1R_L3HDBM1 (const uint32_t inValue) {return (inValue & 0x1FU) << 11 ; }

  // Field L4PEN1: L4PEN1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L4PEN1 = 1U << 16 ;

  // Field L4SPM1: L4SPM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L4SPM1 = 1U << 18 ;

  // Field L4SPIM1: L4SPIM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L4SPIM1 = 1U << 19 ;

  // Field L4DPM1: L4DPM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L4DPM1 = 1U << 20 ;

  // Field L4DPIM1: L4DPIM1
    const uint32_t Ethernet_MAC_MACL3L4C1R_L4DPIM1 = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register MACL4A1R: Layer 4 address filter 1 register
  #define Ethernet_MAC_MACL4A1R (* ((volatile uint32_t *) (0x40028000 + 2356)))

  // Field L4SP1: L4SP1
    inline uint32_t Ethernet_MAC_MACL4A1R_L4SP1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field L4DP1: L4DP1
    inline uint32_t Ethernet_MAC_MACL4A1R_L4DP1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A01R: Layer3 address 0 filter 1 Register
  #define Ethernet_MAC_MACL3A01R (* ((volatile uint32_t *) (0x40028000 + 2368)))

  // Field L3A01: L3A01
    inline uint32_t Ethernet_MAC_MACL3A01R_L3A01 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A11R: Layer3 address 1 filter 1 register
  #define Ethernet_MAC_MACL3A11R (* ((volatile uint32_t *) (0x40028000 + 2372)))

  // Field L3A11: L3A11
    inline uint32_t Ethernet_MAC_MACL3A11R_L3A11 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A21R: Layer3 address 2 filter 1 Register
  #define Ethernet_MAC_MACL3A21R (* ((volatile uint32_t *) (0x40028000 + 2376)))

  // Field L3A21: L3A21
    inline uint32_t Ethernet_MAC_MACL3A21R_L3A21 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACL3A31R: Layer3 address 3 filter 1 register
  #define Ethernet_MAC_MACL3A31R (* ((volatile uint32_t *) (0x40028000 + 2380)))

  // Field L3A31: L3A31
    inline uint32_t Ethernet_MAC_MACL3A31R_L3A31 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACTSCR: Timestamp control Register
  #define Ethernet_MAC_MACTSCR (* ((volatile uint32_t *) (0x40028000 + 2816)))

  // Field TSENA: TSENA
    const uint32_t Ethernet_MAC_MACTSCR_TSENA = 1U << 0 ;

  // Field TSCFUPDT: TSCFUPDT
    const uint32_t Ethernet_MAC_MACTSCR_TSCFUPDT = 1U << 1 ;

  // Field TSINIT: TSINIT
    const uint32_t Ethernet_MAC_MACTSCR_TSINIT = 1U << 2 ;

  // Field TSUPDT: TSUPDT
    const uint32_t Ethernet_MAC_MACTSCR_TSUPDT = 1U << 3 ;

  // Field TSADDREG: TSADDREG
    const uint32_t Ethernet_MAC_MACTSCR_TSADDREG = 1U << 5 ;

  // Field TSENALL: TSENALL
    const uint32_t Ethernet_MAC_MACTSCR_TSENALL = 1U << 8 ;

  // Field TSCTRLSSR: TSCTRLSSR
    const uint32_t Ethernet_MAC_MACTSCR_TSCTRLSSR = 1U << 9 ;

  // Field TSVER2ENA: TSVER2ENA
    const uint32_t Ethernet_MAC_MACTSCR_TSVER2ENA = 1U << 10 ;

  // Field TSIPENA: TSIPENA
    const uint32_t Ethernet_MAC_MACTSCR_TSIPENA = 1U << 11 ;

  // Field TSIPV6ENA: TSIPV6ENA
    const uint32_t Ethernet_MAC_MACTSCR_TSIPV6ENA = 1U << 12 ;

  // Field TSIPV4ENA: TSIPV4ENA
    const uint32_t Ethernet_MAC_MACTSCR_TSIPV4ENA = 1U << 13 ;

  // Field TSEVNTENA: TSEVNTENA
    const uint32_t Ethernet_MAC_MACTSCR_TSEVNTENA = 1U << 14 ;

  // Field TSMSTRENA: TSMSTRENA
    const uint32_t Ethernet_MAC_MACTSCR_TSMSTRENA = 1U << 15 ;

  // Field SNAPTYPSEL: SNAPTYPSEL
    inline uint32_t Ethernet_MAC_MACTSCR_SNAPTYPSEL (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field TSENMACADDR: TSENMACADDR
    const uint32_t Ethernet_MAC_MACTSCR_TSENMACADDR = 1U << 18 ;

  // Field CSC: CSC
    const uint32_t Ethernet_MAC_MACTSCR_CSC = 1U << 19 ;

  // Field TXTSSTSM: TXTSSTSM
    const uint32_t Ethernet_MAC_MACTSCR_TXTSSTSM = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register MACSSIR: Sub-second increment register
  #define Ethernet_MAC_MACSSIR (* ((volatile uint32_t *) (0x40028000 + 2820)))

  // Field SNSINC: SNSINC
    inline uint32_t Ethernet_MAC_MACSSIR_SNSINC (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field SSINC: SSINC
    inline uint32_t Ethernet_MAC_MACSSIR_SSINC (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MACSTSR: System time seconds register
  #define Ethernet_MAC_MACSTSR (* ((const volatile uint32_t *) (0x40028000 + 2824)))

  // Field TSS: TSS
    inline uint32_t Ethernet_MAC_MACSTSR_TSS (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACSTNR: System time nanoseconds register
  #define Ethernet_MAC_MACSTNR (* ((const volatile uint32_t *) (0x40028000 + 2828)))

  // Field TSSS: TSSS
    inline uint32_t Ethernet_MAC_MACSTNR_TSSS (const uint32_t inValue) {return (inValue & 0x7FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACSTSUR: System time seconds update register
  #define Ethernet_MAC_MACSTSUR (* ((volatile uint32_t *) (0x40028000 + 2832)))

  // Field TSS: TSS
    inline uint32_t Ethernet_MAC_MACSTSUR_TSS (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACSTNUR: System time nanoseconds update register
  #define Ethernet_MAC_MACSTNUR (* ((volatile uint32_t *) (0x40028000 + 2836)))

  // Field TSSS: TSSS
    inline uint32_t Ethernet_MAC_MACSTNUR_TSSS (const uint32_t inValue) {return (inValue & 0x7FFFFFFFU) << 0 ; }

  // Field ADDSUB: ADDSUB
    const uint32_t Ethernet_MAC_MACSTNUR_ADDSUB = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACTSAR: Timestamp addend register
  #define Ethernet_MAC_MACTSAR (* ((volatile uint32_t *) (0x40028000 + 2840)))

  // Field TSAR: TSAR
    inline uint32_t Ethernet_MAC_MACTSAR_TSAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACTSSR: Timestamp status register
  #define Ethernet_MAC_MACTSSR (* ((const volatile uint32_t *) (0x40028000 + 2848)))

  // Field TSSOVF: TSSOVF
    const uint32_t Ethernet_MAC_MACTSSR_TSSOVF = 1U << 0 ;

  // Field TSTARGT0: TSTARGT0
    const uint32_t Ethernet_MAC_MACTSSR_TSTARGT0 = 1U << 1 ;

  // Field AUXTSTRIG: AUXTSTRIG
    const uint32_t Ethernet_MAC_MACTSSR_AUXTSTRIG = 1U << 2 ;

  // Field TSTRGTERR0: TSTRGTERR0
    const uint32_t Ethernet_MAC_MACTSSR_TSTRGTERR0 = 1U << 3 ;

  // Field TXTSSIS: TXTSSIS
    const uint32_t Ethernet_MAC_MACTSSR_TXTSSIS = 1U << 15 ;

  // Field ATSSTN: ATSSTN
    inline uint32_t Ethernet_MAC_MACTSSR_ATSSTN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field ATSSTM: ATSSTM
    const uint32_t Ethernet_MAC_MACTSSR_ATSSTM = 1U << 24 ;

  // Field ATSNS: ATSNS
    inline uint32_t Ethernet_MAC_MACTSSR_ATSNS (const uint32_t inValue) {return (inValue & 0x1FU) << 25 ; }

//------------------------------------------------------------------------------

//---  Register MACTxTSSNR: Tx timestamp status nanoseconds register
  #define Ethernet_MAC_MACTxTSSNR (* ((const volatile uint32_t *) (0x40028000 + 2864)))

  // Field TXTSSLO: TXTSSLO
    inline uint32_t Ethernet_MAC_MACTxTSSNR_TXTSSLO (const uint32_t inValue) {return (inValue & 0x7FFFFFFFU) << 0 ; }

  // Field TXTSSMIS: TXTSSMIS
    const uint32_t Ethernet_MAC_MACTxTSSNR_TXTSSMIS = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACTxTSSSR: Tx timestamp status seconds register
  #define Ethernet_MAC_MACTxTSSSR (* ((const volatile uint32_t *) (0x40028000 + 2868)))

  // Field TXTSSHI: TXTSSHI
    inline uint32_t Ethernet_MAC_MACTxTSSSR_TXTSSHI (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACACR: Auxiliary control register
  #define Ethernet_MAC_MACACR (* ((volatile uint32_t *) (0x40028000 + 2880)))

  // Field ATSFC: ATSFC
    const uint32_t Ethernet_MAC_MACACR_ATSFC = 1U << 0 ;

  // Field ATSEN0: ATSEN0
    const uint32_t Ethernet_MAC_MACACR_ATSEN0 = 1U << 4 ;

  // Field ATSEN1: ATSEN1
    const uint32_t Ethernet_MAC_MACACR_ATSEN1 = 1U << 5 ;

  // Field ATSEN2: ATSEN2
    const uint32_t Ethernet_MAC_MACACR_ATSEN2 = 1U << 6 ;

  // Field ATSEN3: ATSEN3
    const uint32_t Ethernet_MAC_MACACR_ATSEN3 = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register MACATSNR: Auxiliary timestamp nanoseconds register
  #define Ethernet_MAC_MACATSNR (* ((const volatile uint32_t *) (0x40028000 + 2888)))

  // Field AUXTSLO: AUXTSLO
    inline uint32_t Ethernet_MAC_MACATSNR_AUXTSLO (const uint32_t inValue) {return (inValue & 0x7FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACATSSR: Auxiliary timestamp seconds register
  #define Ethernet_MAC_MACATSSR (* ((const volatile uint32_t *) (0x40028000 + 2892)))

  // Field AUXTSHI: AUXTSHI
    inline uint32_t Ethernet_MAC_MACATSSR_AUXTSHI (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACTSIACR: Timestamp Ingress asymmetric correction register
  #define Ethernet_MAC_MACTSIACR (* ((volatile uint32_t *) (0x40028000 + 2896)))

  // Field OSTIAC: OSTIAC
    inline uint32_t Ethernet_MAC_MACTSIACR_OSTIAC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACTSEACR: Timestamp Egress asymmetric correction register
  #define Ethernet_MAC_MACTSEACR (* ((volatile uint32_t *) (0x40028000 + 2900)))

  // Field OSTEAC: OSTEAC
    inline uint32_t Ethernet_MAC_MACTSEACR_OSTEAC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACTSICNR: Timestamp Ingress correction nanosecond register
  #define Ethernet_MAC_MACTSICNR (* ((volatile uint32_t *) (0x40028000 + 2904)))

  // Field TSIC: TSIC
    inline uint32_t Ethernet_MAC_MACTSICNR_TSIC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACTSECNR: Timestamp Egress correction nanosecond register
  #define Ethernet_MAC_MACTSECNR (* ((volatile uint32_t *) (0x40028000 + 2908)))

  // Field TSEC: TSEC
    inline uint32_t Ethernet_MAC_MACTSECNR_TSEC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACPPSCR: PPS control register
  #define Ethernet_MAC_MACPPSCR (* ((volatile uint32_t *) (0x40028000 + 2928)))

  // Field PPSCTRL: PPSCTRL
    inline uint32_t Ethernet_MAC_MACPPSCR_PPSCTRL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field PPSEN0: PPSEN0
    const uint32_t Ethernet_MAC_MACPPSCR_PPSEN0 = 1U << 4 ;

  // Field TRGTMODSEL0: TRGTMODSEL0
    inline uint32_t Ethernet_MAC_MACPPSCR_TRGTMODSEL0 (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

//------------------------------------------------------------------------------

//---  Register MACPPSTTSR: PPS target time seconds register
  #define Ethernet_MAC_MACPPSTTSR (* ((volatile uint32_t *) (0x40028000 + 2944)))

  // Field TSTRH0: TSTRH0
    inline uint32_t Ethernet_MAC_MACPPSTTSR_TSTRH0 (const uint32_t inValue) {return (inValue & 0x7FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACPPSTTNR: PPS target time nanoseconds register
  #define Ethernet_MAC_MACPPSTTNR (* ((volatile uint32_t *) (0x40028000 + 2948)))

  // Field TTSL0: TTSL0
    inline uint32_t Ethernet_MAC_MACPPSTTNR_TTSL0 (const uint32_t inValue) {return (inValue & 0x7FFFFFFFU) << 0 ; }

  // Field TRGTBUSY0: TRGTBUSY0
    const uint32_t Ethernet_MAC_MACPPSTTNR_TRGTBUSY0 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MACPPSIR: PPS interval register
  #define Ethernet_MAC_MACPPSIR (* ((volatile uint32_t *) (0x40028000 + 2952)))

  // Field PPSINT0: PPSINT0
    inline uint32_t Ethernet_MAC_MACPPSIR_PPSINT0 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACPPSWR: PPS width register
  #define Ethernet_MAC_MACPPSWR (* ((volatile uint32_t *) (0x40028000 + 2956)))

  // Field PPSWIDTH0: PPSWIDTH0
    inline uint32_t Ethernet_MAC_MACPPSWR_PPSWIDTH0 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACPOCR: PTP Offload control register
  #define Ethernet_MAC_MACPOCR (* ((volatile uint32_t *) (0x40028000 + 3008)))

  // Field PTOEN: PTOEN
    const uint32_t Ethernet_MAC_MACPOCR_PTOEN = 1U << 0 ;

  // Field ASYNCEN: ASYNCEN
    const uint32_t Ethernet_MAC_MACPOCR_ASYNCEN = 1U << 1 ;

  // Field APDREQEN: APDREQEN
    const uint32_t Ethernet_MAC_MACPOCR_APDREQEN = 1U << 2 ;

  // Field ASYNCTRIG: ASYNCTRIG
    const uint32_t Ethernet_MAC_MACPOCR_ASYNCTRIG = 1U << 4 ;

  // Field APDREQTRIG: APDREQTRIG
    const uint32_t Ethernet_MAC_MACPOCR_APDREQTRIG = 1U << 5 ;

  // Field DRRDIS: DRRDIS
    const uint32_t Ethernet_MAC_MACPOCR_DRRDIS = 1U << 6 ;

  // Field DN: DN
    inline uint32_t Ethernet_MAC_MACPOCR_DN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register MACSPI0R: PTP Source Port Identity 0 Register
  #define Ethernet_MAC_MACSPI0R (* ((volatile uint32_t *) (0x40028000 + 3012)))

  // Field SPI0: SPI0
    inline uint32_t Ethernet_MAC_MACSPI0R_SPI0 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACSPI1R: PTP Source port identity 1 register
  #define Ethernet_MAC_MACSPI1R (* ((volatile uint32_t *) (0x40028000 + 3016)))

  // Field SPI1: SPI1
    inline uint32_t Ethernet_MAC_MACSPI1R_SPI1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACSPI2R: PTP Source port identity 2 register
  #define Ethernet_MAC_MACSPI2R (* ((volatile uint32_t *) (0x40028000 + 3020)))

  // Field SPI2: SPI2
    inline uint32_t Ethernet_MAC_MACSPI2R_SPI2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MACLMIR: Log message interval register
  #define Ethernet_MAC_MACLMIR (* ((volatile uint32_t *) (0x40028000 + 3024)))

  // Field LSI: LSI
    inline uint32_t Ethernet_MAC_MACLMIR_LSI (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field DRSYNCR: DRSYNCR
    inline uint32_t Ethernet_MAC_MACLMIR_DRSYNCR (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field LMPDRI: LMPDRI
    inline uint32_t Ethernet_MAC_MACLMIR_LMPDRI (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral Ethernet_MTL: Ethernet: MTL mode register (MTL)
//------------------------------------------------------------------------------

//---  Register MTLOMR: Operating mode Register
  #define Ethernet_MTL_MTLOMR (* ((volatile uint32_t *) (0x40028C00 + 0)))

  // Field DTXSTS: DTXSTS
    const uint32_t Ethernet_MTL_MTLOMR_DTXSTS = 1U << 1 ;

  // Field CNTPRST: CNTPRST
    const uint32_t Ethernet_MTL_MTLOMR_CNTPRST = 1U << 8 ;

  // Field CNTCLR: CNTCLR
    const uint32_t Ethernet_MTL_MTLOMR_CNTCLR = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register MTLISR: Interrupt status Register
  #define Ethernet_MTL_MTLISR (* ((const volatile uint32_t *) (0x40028C00 + 32)))

  // Field Q0IS: Queue interrupt status
    const uint32_t Ethernet_MTL_MTLISR_Q0IS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MTLTxQOMR: Tx queue operating mode Register
  #define Ethernet_MTL_MTLTxQOMR (* ((volatile uint32_t *) (0x40028C00 + 256)))

  // Field FTQ: Flush Transmit Queue
    const uint32_t Ethernet_MTL_MTLTxQOMR_FTQ = 1U << 0 ;

  // Field TSF: Transmit Store and Forward
    const uint32_t Ethernet_MTL_MTLTxQOMR_TSF = 1U << 1 ;

  // Field TXQEN: Transmit Queue Enable
    inline uint32_t Ethernet_MTL_MTLTxQOMR_TXQEN (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field TTC: Transmit Threshold Control
    inline uint32_t Ethernet_MTL_MTLTxQOMR_TTC (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field TQS: Transmit Queue Size
    inline uint32_t Ethernet_MTL_MTLTxQOMR_TQS (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MTLTxQUR: Tx queue underflow register
  #define Ethernet_MTL_MTLTxQUR (* ((const volatile uint32_t *) (0x40028C00 + 260)))

  // Field UFFRMCNT: Underflow Packet Counter
    inline uint32_t Ethernet_MTL_MTLTxQUR_UFFRMCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field UFCNTOVF: UFCNTOVF
    const uint32_t Ethernet_MTL_MTLTxQUR_UFCNTOVF = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MTLTxQDR: Tx queue debug Register
  #define Ethernet_MTL_MTLTxQDR (* ((const volatile uint32_t *) (0x40028C00 + 264)))

  // Field TXQPAUSED: TXQPAUSED
    const uint32_t Ethernet_MTL_MTLTxQDR_TXQPAUSED = 1U << 0 ;

  // Field TRCSTS: TRCSTS
    inline uint32_t Ethernet_MTL_MTLTxQDR_TRCSTS (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field TWCSTS: TWCSTS
    const uint32_t Ethernet_MTL_MTLTxQDR_TWCSTS = 1U << 3 ;

  // Field TXQSTS: TXQSTS
    const uint32_t Ethernet_MTL_MTLTxQDR_TXQSTS = 1U << 4 ;

  // Field TXSTSFSTS: TXSTSFSTS
    const uint32_t Ethernet_MTL_MTLTxQDR_TXSTSFSTS = 1U << 5 ;

  // Field PTXQ: PTXQ
    inline uint32_t Ethernet_MTL_MTLTxQDR_PTXQ (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field STXSTSF: STXSTSF
    inline uint32_t Ethernet_MTL_MTLTxQDR_STXSTSF (const uint32_t inValue) {return (inValue & 0x7U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MTLQICSR: Queue interrupt control status Register
  #define Ethernet_MTL_MTLQICSR (* ((volatile uint32_t *) (0x40028C00 + 300)))

  // Field TXUNFIS: TXUNFIS
    const uint32_t Ethernet_MTL_MTLQICSR_TXUNFIS = 1U << 0 ;

  // Field TXUIE: TXUIE
    const uint32_t Ethernet_MTL_MTLQICSR_TXUIE = 1U << 8 ;

  // Field RXOVFIS: RXOVFIS
    const uint32_t Ethernet_MTL_MTLQICSR_RXOVFIS = 1U << 16 ;

  // Field RXOIE: RXOIE
    const uint32_t Ethernet_MTL_MTLQICSR_RXOIE = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register MTLRxQOMR: Rx queue operating mode register
  #define Ethernet_MTL_MTLRxQOMR (* ((volatile uint32_t *) (0x40028C00 + 304)))

  // Field RTC: RTC
    inline uint32_t Ethernet_MTL_MTLRxQOMR_RTC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field FUP: FUP
    const uint32_t Ethernet_MTL_MTLRxQOMR_FUP = 1U << 3 ;

  // Field FEP: FEP
    const uint32_t Ethernet_MTL_MTLRxQOMR_FEP = 1U << 4 ;

  // Field RSF: RSF
    const uint32_t Ethernet_MTL_MTLRxQOMR_RSF = 1U << 5 ;

  // Field DIS_TCP_EF: DIS_TCP_EF
    const uint32_t Ethernet_MTL_MTLRxQOMR_DIS_TCP_EF = 1U << 6 ;

  // Field EHFC: EHFC
    const uint32_t Ethernet_MTL_MTLRxQOMR_EHFC = 1U << 7 ;

  // Field RFA: RFA
    inline uint32_t Ethernet_MTL_MTLRxQOMR_RFA (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field RFD: RFD
    inline uint32_t Ethernet_MTL_MTLRxQOMR_RFD (const uint32_t inValue) {return (inValue & 0x7U) << 14 ; }

  // Field RQS: RQS
    inline uint32_t Ethernet_MTL_MTLRxQOMR_RQS (const uint32_t inValue) {return (inValue & 0x7U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MTLRxQMPOCR: Rx queue missed packet and overflow counter register
  #define Ethernet_MTL_MTLRxQMPOCR (* ((const volatile uint32_t *) (0x40028C00 + 308)))

  // Field OVFPKTCNT: OVFPKTCNT
    inline uint32_t Ethernet_MTL_MTLRxQMPOCR_OVFPKTCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field OVFCNTOVF: OVFCNTOVF
    const uint32_t Ethernet_MTL_MTLRxQMPOCR_OVFCNTOVF = 1U << 11 ;

  // Field MISPKTCNT: MISPKTCNT
    inline uint32_t Ethernet_MTL_MTLRxQMPOCR_MISPKTCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 16 ; }

  // Field MISCNTOVF: MISCNTOVF
    const uint32_t Ethernet_MTL_MTLRxQMPOCR_MISCNTOVF = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register MTLRxQDR: Rx queue debug register
  #define Ethernet_MTL_MTLRxQDR (* ((const volatile uint32_t *) (0x40028C00 + 312)))

  // Field RWCSTS: RWCSTS
    const uint32_t Ethernet_MTL_MTLRxQDR_RWCSTS = 1U << 0 ;

  // Field RRCSTS: RRCSTS
    inline uint32_t Ethernet_MTL_MTLRxQDR_RRCSTS (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field RXQSTS: RXQSTS
    inline uint32_t Ethernet_MTL_MTLRxQDR_RXQSTS (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PRXQ: PRXQ
    inline uint32_t Ethernet_MTL_MTLRxQDR_PRXQ (const uint32_t inValue) {return (inValue & 0x3FFFU) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral FDCAN1: FDCAN1
//------------------------------------------------------------------------------

//---  Register FDCAN_CREL: FDCAN Core Release Register
  #define FDCAN1_FDCAN_CREL (* ((const volatile uint32_t *) (0x4000A000 + 0)))

  // Field REL: Core release
    inline uint32_t FDCAN1_FDCAN_CREL_REL (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field STEP: Step of Core release
    inline uint32_t FDCAN1_FDCAN_CREL_STEP (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field SUBSTEP: Sub-step of Core release
    inline uint32_t FDCAN1_FDCAN_CREL_SUBSTEP (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field YEAR: Timestamp Year
    inline uint32_t FDCAN1_FDCAN_CREL_YEAR (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field MON: Timestamp Month
    inline uint32_t FDCAN1_FDCAN_CREL_MON (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field DAY: Timestamp Day
    inline uint32_t FDCAN1_FDCAN_CREL_DAY (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_ENDN: FDCAN Core Release Register
  #define FDCAN1_FDCAN_ENDN (* ((const volatile uint32_t *) (0x4000A000 + 4)))

  // Field ETV: Endiannes Test Value
    inline uint32_t FDCAN1_FDCAN_ENDN_ETV (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_DBTP: FDCAN Data Bit Timing and Prescaler Register
  #define FDCAN1_FDCAN_DBTP (* ((const volatile uint32_t *) (0x4000A000 + 12)))

  // Field DSJW: Synchronization Jump Width
    inline uint32_t FDCAN1_FDCAN_DBTP_DSJW (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DTSEG2: Data time segment after sample point
    inline uint32_t FDCAN1_FDCAN_DBTP_DTSEG2 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DTSEG1: Data time segment after sample point
    inline uint32_t FDCAN1_FDCAN_DBTP_DTSEG1 (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBRP: Data BIt Rate Prescaler
    inline uint32_t FDCAN1_FDCAN_DBTP_DBRP (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TDC: Transceiver Delay Compensation
    const uint32_t FDCAN1_FDCAN_DBTP_TDC = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TEST: FDCAN Test Register
  #define FDCAN1_FDCAN_TEST (* ((const volatile uint32_t *) (0x4000A000 + 16)))

  // Field LBCK: Loop Back mode
    const uint32_t FDCAN1_FDCAN_TEST_LBCK = 1U << 4 ;

  // Field TX: Loop Back mode
    inline uint32_t FDCAN1_FDCAN_TEST_TX (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field RX: Control of Transmit Pin
    const uint32_t FDCAN1_FDCAN_TEST_RX = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_RWD: FDCAN RAM Watchdog Register
  #define FDCAN1_FDCAN_RWD (* ((const volatile uint32_t *) (0x4000A000 + 20)))

  // Field WDV: Watchdog value
    inline uint32_t FDCAN1_FDCAN_RWD_WDV (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field WDC: Watchdog configuration
    inline uint32_t FDCAN1_FDCAN_RWD_WDC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_CCCR: FDCAN CC Control Register
  #define FDCAN1_FDCAN_CCCR (* ((volatile uint32_t *) (0x4000A000 + 24)))

  // Field INIT: Initialization
    const uint32_t FDCAN1_FDCAN_CCCR_INIT = 1U << 0 ;

  // Field CCE: Configuration Change Enable
    const uint32_t FDCAN1_FDCAN_CCCR_CCE = 1U << 1 ;

  // Field ASM: ASM Restricted Operation Mode
    const uint32_t FDCAN1_FDCAN_CCCR_ASM = 1U << 2 ;

  // Field CSA: Clock Stop Acknowledge
    const uint32_t FDCAN1_FDCAN_CCCR_CSA = 1U << 3 ;

  // Field CSR: Clock Stop Request
    const uint32_t FDCAN1_FDCAN_CCCR_CSR = 1U << 4 ;

  // Field MON: Bus Monitoring Mode
    const uint32_t FDCAN1_FDCAN_CCCR_MON = 1U << 5 ;

  // Field DAR: Disable Automatic Retransmission
    const uint32_t FDCAN1_FDCAN_CCCR_DAR = 1U << 6 ;

  // Field TEST: Test Mode Enable
    const uint32_t FDCAN1_FDCAN_CCCR_TEST = 1U << 7 ;

  // Field FDOE: FD Operation Enable
    const uint32_t FDCAN1_FDCAN_CCCR_FDOE = 1U << 8 ;

  // Field BSE: FDCAN Bit Rate Switching
    const uint32_t FDCAN1_FDCAN_CCCR_BSE = 1U << 9 ;

  // Field PXHD: Protocol Exception Handling Disable
    const uint32_t FDCAN1_FDCAN_CCCR_PXHD = 1U << 12 ;

  // Field EFBI: Edge Filtering during Bus Integration
    const uint32_t FDCAN1_FDCAN_CCCR_EFBI = 1U << 13 ;

  // Field TXP: TXP
    const uint32_t FDCAN1_FDCAN_CCCR_TXP = 1U << 14 ;

  // Field NISO: Non ISO Operation
    const uint32_t FDCAN1_FDCAN_CCCR_NISO = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_NBTP: FDCAN Nominal Bit Timing and Prescaler Register
  #define FDCAN1_FDCAN_NBTP (* ((volatile uint32_t *) (0x4000A000 + 28)))

  // Field NSJW: NSJW: Nominal (Re)Synchronization Jump Width
    inline uint32_t FDCAN1_FDCAN_NBTP_NSJW (const uint32_t inValue) {return (inValue & 0x7FU) << 25 ; }

  // Field NBRP: Bit Rate Prescaler
    inline uint32_t FDCAN1_FDCAN_NBTP_NBRP (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field NTSEG1: Nominal Time segment before sample point
    inline uint32_t FDCAN1_FDCAN_NBTP_NTSEG1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field TSEG2: Nominal Time segment after sample point
    inline uint32_t FDCAN1_FDCAN_NBTP_TSEG2 (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TSCC: FDCAN Timestamp Counter Configuration Register
  #define FDCAN1_FDCAN_TSCC (* ((volatile uint32_t *) (0x4000A000 + 32)))

  // Field TCP: Timestamp Counter Prescaler
    inline uint32_t FDCAN1_FDCAN_TSCC_TCP (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TSS: Timestamp Select
    inline uint32_t FDCAN1_FDCAN_TSCC_TSS (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TSCV: FDCAN Timestamp Counter Value Register
  #define FDCAN1_FDCAN_TSCV (* ((volatile uint32_t *) (0x4000A000 + 36)))

  // Field TSC: Timestamp Counter
    inline uint32_t FDCAN1_FDCAN_TSCV_TSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TOCC: FDCAN Timeout Counter Configuration Register
  #define FDCAN1_FDCAN_TOCC (* ((volatile uint32_t *) (0x4000A000 + 40)))

  // Field ETOC: Enable Timeout Counter
    const uint32_t FDCAN1_FDCAN_TOCC_ETOC = 1U << 0 ;

  // Field TOS: Timeout Select
    inline uint32_t FDCAN1_FDCAN_TOCC_TOS (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field TOP: Timeout Period
    inline uint32_t FDCAN1_FDCAN_TOCC_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TOCV: FDCAN Timeout Counter Value Register
  #define FDCAN1_FDCAN_TOCV (* ((volatile uint32_t *) (0x4000A000 + 44)))

  // Field TOC: Timeout Counter
    inline uint32_t FDCAN1_FDCAN_TOCV_TOC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_ECR: FDCAN Error Counter Register
  #define FDCAN1_FDCAN_ECR (* ((volatile uint32_t *) (0x4000A000 + 64)))

  // Field CEL: AN Error Logging
    inline uint32_t FDCAN1_FDCAN_ECR_CEL (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field RP: Receive Error Passive
    const uint32_t FDCAN1_FDCAN_ECR_RP = 1U << 15 ;

  // Field TREC: Receive Error Counter
    inline uint32_t FDCAN1_FDCAN_ECR_TREC (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field TEC: Transmit Error Counter
    inline uint32_t FDCAN1_FDCAN_ECR_TEC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_PSR: FDCAN Protocol Status Register
  #define FDCAN1_FDCAN_PSR (* ((volatile uint32_t *) (0x4000A000 + 68)))

  // Field LEC: Last Error Code
    inline uint32_t FDCAN1_FDCAN_PSR_LEC (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field ACT: Activity
    inline uint32_t FDCAN1_FDCAN_PSR_ACT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field EP: Error Passive
    const uint32_t FDCAN1_FDCAN_PSR_EP = 1U << 5 ;

  // Field EW: Warning Status
    const uint32_t FDCAN1_FDCAN_PSR_EW = 1U << 6 ;

  // Field BO: Bus_Off Status
    const uint32_t FDCAN1_FDCAN_PSR_BO = 1U << 7 ;

  // Field DLEC: Data Last Error Code
    inline uint32_t FDCAN1_FDCAN_PSR_DLEC (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field RESI: ESI flag of last received FDCAN Message
    const uint32_t FDCAN1_FDCAN_PSR_RESI = 1U << 11 ;

  // Field RBRS: BRS flag of last received FDCAN Message
    const uint32_t FDCAN1_FDCAN_PSR_RBRS = 1U << 12 ;

  // Field REDL: Received FDCAN Message
    const uint32_t FDCAN1_FDCAN_PSR_REDL = 1U << 13 ;

  // Field PXE: Protocol Exception Event
    const uint32_t FDCAN1_FDCAN_PSR_PXE = 1U << 14 ;

  // Field TDCV: Transmitter Delay Compensation Value
    inline uint32_t FDCAN1_FDCAN_PSR_TDCV (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TDCR: FDCAN Transmitter Delay Compensation Register
  #define FDCAN1_FDCAN_TDCR (* ((const volatile uint32_t *) (0x4000A000 + 72)))

  // Field TDCF: Transmitter Delay Compensation Filter Window Length
    inline uint32_t FDCAN1_FDCAN_TDCR_TDCF (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TDCO: Transmitter Delay Compensation Offset
    inline uint32_t FDCAN1_FDCAN_TDCR_TDCO (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_IR: FDCAN Interrupt Register
  #define FDCAN1_FDCAN_IR (* ((const volatile uint32_t *) (0x4000A000 + 80)))

  // Field RF0N: Rx FIFO 0 New Message
    const uint32_t FDCAN1_FDCAN_IR_RF0N = 1U << 0 ;

  // Field RF0W: Rx FIFO 0 Full
    const uint32_t FDCAN1_FDCAN_IR_RF0W = 1U << 1 ;

  // Field RF0F: Rx FIFO 0 Full
    const uint32_t FDCAN1_FDCAN_IR_RF0F = 1U << 2 ;

  // Field RF0L: Rx FIFO 0 Message Lost
    const uint32_t FDCAN1_FDCAN_IR_RF0L = 1U << 3 ;

  // Field RF1N: Rx FIFO 1 New Message
    const uint32_t FDCAN1_FDCAN_IR_RF1N = 1U << 4 ;

  // Field RF1W: Rx FIFO 1 Watermark Reached
    const uint32_t FDCAN1_FDCAN_IR_RF1W = 1U << 5 ;

  // Field RF1F: Rx FIFO 1 Watermark Reached
    const uint32_t FDCAN1_FDCAN_IR_RF1F = 1U << 6 ;

  // Field RF1L: Rx FIFO 1 Message Lost
    const uint32_t FDCAN1_FDCAN_IR_RF1L = 1U << 7 ;

  // Field HPM: High Priority Message
    const uint32_t FDCAN1_FDCAN_IR_HPM = 1U << 8 ;

  // Field TC: Transmission Completed
    const uint32_t FDCAN1_FDCAN_IR_TC = 1U << 9 ;

  // Field TCF: Transmission Cancellation Finished
    const uint32_t FDCAN1_FDCAN_IR_TCF = 1U << 10 ;

  // Field TEF: Tx FIFO Empty
    const uint32_t FDCAN1_FDCAN_IR_TEF = 1U << 11 ;

  // Field TEFN: Tx Event FIFO New Entry
    const uint32_t FDCAN1_FDCAN_IR_TEFN = 1U << 12 ;

  // Field TEFW: Tx Event FIFO Watermark Reached
    const uint32_t FDCAN1_FDCAN_IR_TEFW = 1U << 13 ;

  // Field TEFF: Tx Event FIFO Full
    const uint32_t FDCAN1_FDCAN_IR_TEFF = 1U << 14 ;

  // Field TEFL: Tx Event FIFO Element Lost
    const uint32_t FDCAN1_FDCAN_IR_TEFL = 1U << 15 ;

  // Field TSW: Timestamp Wraparound
    const uint32_t FDCAN1_FDCAN_IR_TSW = 1U << 16 ;

  // Field MRAF: Message RAM Access Failure
    const uint32_t FDCAN1_FDCAN_IR_MRAF = 1U << 17 ;

  // Field TOO: Timeout Occurred
    const uint32_t FDCAN1_FDCAN_IR_TOO = 1U << 18 ;

  // Field DRX: Message stored to Dedicated Rx Buffer
    const uint32_t FDCAN1_FDCAN_IR_DRX = 1U << 19 ;

  // Field ELO: Error Logging Overflow
    const uint32_t FDCAN1_FDCAN_IR_ELO = 1U << 22 ;

  // Field EP: Error Passive
    const uint32_t FDCAN1_FDCAN_IR_EP = 1U << 23 ;

  // Field EW: Warning Status
    const uint32_t FDCAN1_FDCAN_IR_EW = 1U << 24 ;

  // Field BO: Bus_Off Status
    const uint32_t FDCAN1_FDCAN_IR_BO = 1U << 25 ;

  // Field WDI: Watchdog Interrupt
    const uint32_t FDCAN1_FDCAN_IR_WDI = 1U << 26 ;

  // Field PEA: Protocol Error in Arbitration Phase (Nominal Bit Time is used)
    const uint32_t FDCAN1_FDCAN_IR_PEA = 1U << 27 ;

  // Field PED: Protocol Error in Data Phase (Data Bit Time is used)
    const uint32_t FDCAN1_FDCAN_IR_PED = 1U << 28 ;

  // Field ARA: Access to Reserved Address
    const uint32_t FDCAN1_FDCAN_IR_ARA = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_IE: FDCAN Interrupt Enable Register
  #define FDCAN1_FDCAN_IE (* ((const volatile uint32_t *) (0x4000A000 + 84)))

  // Field RF0NE: Rx FIFO 0 New Message Enable
    const uint32_t FDCAN1_FDCAN_IE_RF0NE = 1U << 0 ;

  // Field RF0WE: Rx FIFO 0 Full Enable
    const uint32_t FDCAN1_FDCAN_IE_RF0WE = 1U << 1 ;

  // Field RF0FE: Rx FIFO 0 Full Enable
    const uint32_t FDCAN1_FDCAN_IE_RF0FE = 1U << 2 ;

  // Field RF0LE: Rx FIFO 0 Message Lost Enable
    const uint32_t FDCAN1_FDCAN_IE_RF0LE = 1U << 3 ;

  // Field RF1NE: Rx FIFO 1 New Message Enable
    const uint32_t FDCAN1_FDCAN_IE_RF1NE = 1U << 4 ;

  // Field RF1WE: Rx FIFO 1 Watermark Reached Enable
    const uint32_t FDCAN1_FDCAN_IE_RF1WE = 1U << 5 ;

  // Field RF1FE: Rx FIFO 1 Watermark Reached Enable
    const uint32_t FDCAN1_FDCAN_IE_RF1FE = 1U << 6 ;

  // Field RF1LE: Rx FIFO 1 Message Lost Enable
    const uint32_t FDCAN1_FDCAN_IE_RF1LE = 1U << 7 ;

  // Field HPME: High Priority Message Enable
    const uint32_t FDCAN1_FDCAN_IE_HPME = 1U << 8 ;

  // Field TCE: Transmission Completed Enable
    const uint32_t FDCAN1_FDCAN_IE_TCE = 1U << 9 ;

  // Field TCFE: Transmission Cancellation Finished Enable
    const uint32_t FDCAN1_FDCAN_IE_TCFE = 1U << 10 ;

  // Field TEFE: Tx FIFO Empty Enable
    const uint32_t FDCAN1_FDCAN_IE_TEFE = 1U << 11 ;

  // Field TEFNE: Tx Event FIFO New Entry Enable
    const uint32_t FDCAN1_FDCAN_IE_TEFNE = 1U << 12 ;

  // Field TEFWE: Tx Event FIFO Watermark Reached Enable
    const uint32_t FDCAN1_FDCAN_IE_TEFWE = 1U << 13 ;

  // Field TEFFE: Tx Event FIFO Full Enable
    const uint32_t FDCAN1_FDCAN_IE_TEFFE = 1U << 14 ;

  // Field TEFLE: Tx Event FIFO Element Lost Enable
    const uint32_t FDCAN1_FDCAN_IE_TEFLE = 1U << 15 ;

  // Field TSWE: Timestamp Wraparound Enable
    const uint32_t FDCAN1_FDCAN_IE_TSWE = 1U << 16 ;

  // Field MRAFE: Message RAM Access Failure Enable
    const uint32_t FDCAN1_FDCAN_IE_MRAFE = 1U << 17 ;

  // Field TOOE: Timeout Occurred Enable
    const uint32_t FDCAN1_FDCAN_IE_TOOE = 1U << 18 ;

  // Field DRXE: Message stored to Dedicated Rx Buffer Enable
    const uint32_t FDCAN1_FDCAN_IE_DRXE = 1U << 19 ;

  // Field BECE: Bit Error Corrected Interrupt Enable
    const uint32_t FDCAN1_FDCAN_IE_BECE = 1U << 20 ;

  // Field BEUE: Bit Error Uncorrected Interrupt Enable
    const uint32_t FDCAN1_FDCAN_IE_BEUE = 1U << 21 ;

  // Field ELOE: Error Logging Overflow Enable
    const uint32_t FDCAN1_FDCAN_IE_ELOE = 1U << 22 ;

  // Field EPE: Error Passive Enable
    const uint32_t FDCAN1_FDCAN_IE_EPE = 1U << 23 ;

  // Field EWE: Warning Status Enable
    const uint32_t FDCAN1_FDCAN_IE_EWE = 1U << 24 ;

  // Field BOE: Bus_Off Status Enable
    const uint32_t FDCAN1_FDCAN_IE_BOE = 1U << 25 ;

  // Field WDIE: Watchdog Interrupt Enable
    const uint32_t FDCAN1_FDCAN_IE_WDIE = 1U << 26 ;

  // Field PEAE: Protocol Error in Arbitration Phase Enable
    const uint32_t FDCAN1_FDCAN_IE_PEAE = 1U << 27 ;

  // Field PEDE: Protocol Error in Data Phase Enable
    const uint32_t FDCAN1_FDCAN_IE_PEDE = 1U << 28 ;

  // Field ARAE: Access to Reserved Address Enable
    const uint32_t FDCAN1_FDCAN_IE_ARAE = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_ILS: FDCAN Interrupt Line Select Register
  #define FDCAN1_FDCAN_ILS (* ((const volatile uint32_t *) (0x4000A000 + 88)))

  // Field RF0NL: Rx FIFO 0 New Message Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF0NL = 1U << 0 ;

  // Field RF0WL: Rx FIFO 0 Watermark Reached Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF0WL = 1U << 1 ;

  // Field RF0FL: Rx FIFO 0 Full Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF0FL = 1U << 2 ;

  // Field RF0LL: Rx FIFO 0 Message Lost Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF0LL = 1U << 3 ;

  // Field RF1NL: Rx FIFO 1 New Message Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF1NL = 1U << 4 ;

  // Field RF1WL: Rx FIFO 1 Watermark Reached Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF1WL = 1U << 5 ;

  // Field RF1FL: Rx FIFO 1 Full Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF1FL = 1U << 6 ;

  // Field RF1LL: Rx FIFO 1 Message Lost Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_RF1LL = 1U << 7 ;

  // Field HPML: High Priority Message Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_HPML = 1U << 8 ;

  // Field TCL: Transmission Completed Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TCL = 1U << 9 ;

  // Field TCFL: Transmission Cancellation Finished Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TCFL = 1U << 10 ;

  // Field TEFL: Tx FIFO Empty Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TEFL = 1U << 11 ;

  // Field TEFNL: Tx Event FIFO New Entry Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TEFNL = 1U << 12 ;

  // Field TEFWL: Tx Event FIFO Watermark Reached Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TEFWL = 1U << 13 ;

  // Field TEFFL: Tx Event FIFO Full Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TEFFL = 1U << 14 ;

  // Field TEFLL: Tx Event FIFO Element Lost Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TEFLL = 1U << 15 ;

  // Field TSWL: Timestamp Wraparound Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TSWL = 1U << 16 ;

  // Field MRAFL: Message RAM Access Failure Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_MRAFL = 1U << 17 ;

  // Field TOOL: Timeout Occurred Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_TOOL = 1U << 18 ;

  // Field DRXL: Message stored to Dedicated Rx Buffer Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_DRXL = 1U << 19 ;

  // Field BECL: Bit Error Corrected Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_BECL = 1U << 20 ;

  // Field BEUL: Bit Error Uncorrected Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_BEUL = 1U << 21 ;

  // Field ELOL: Error Logging Overflow Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_ELOL = 1U << 22 ;

  // Field EPL: Error Passive Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_EPL = 1U << 23 ;

  // Field EWL: Warning Status Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_EWL = 1U << 24 ;

  // Field BOL: Bus_Off Status
    const uint32_t FDCAN1_FDCAN_ILS_BOL = 1U << 25 ;

  // Field WDIL: Watchdog Interrupt Line
    const uint32_t FDCAN1_FDCAN_ILS_WDIL = 1U << 26 ;

  // Field PEAL: Protocol Error in Arbitration Phase Line
    const uint32_t FDCAN1_FDCAN_ILS_PEAL = 1U << 27 ;

  // Field PEDL: Protocol Error in Data Phase Line
    const uint32_t FDCAN1_FDCAN_ILS_PEDL = 1U << 28 ;

  // Field ARAL: Access to Reserved Address Line
    const uint32_t FDCAN1_FDCAN_ILS_ARAL = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_ILE: FDCAN Interrupt Line Enable Register
  #define FDCAN1_FDCAN_ILE (* ((volatile uint32_t *) (0x4000A000 + 92)))

  // Field EINT0: Enable Interrupt Line 0
    const uint32_t FDCAN1_FDCAN_ILE_EINT0 = 1U << 0 ;

  // Field EINT1: Enable Interrupt Line 1
    const uint32_t FDCAN1_FDCAN_ILE_EINT1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_GFC: FDCAN Global Filter Configuration Register
  #define FDCAN1_FDCAN_GFC (* ((volatile uint32_t *) (0x4000A000 + 128)))

  // Field RRFE: Reject Remote Frames Extended
    const uint32_t FDCAN1_FDCAN_GFC_RRFE = 1U << 0 ;

  // Field RRFS: Reject Remote Frames Standard
    const uint32_t FDCAN1_FDCAN_GFC_RRFS = 1U << 1 ;

  // Field ANFE: Accept Non-matching Frames Extended
    inline uint32_t FDCAN1_FDCAN_GFC_ANFE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field ANFS: Accept Non-matching Frames Standard
    inline uint32_t FDCAN1_FDCAN_GFC_ANFS (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_SIDFC: FDCAN Standard ID Filter Configuration Register
  #define FDCAN1_FDCAN_SIDFC (* ((volatile uint32_t *) (0x4000A000 + 132)))

  // Field FLSSA: Filter List Standard Start Address
    inline uint32_t FDCAN1_FDCAN_SIDFC_FLSSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field LSS: List Size Standard
    inline uint32_t FDCAN1_FDCAN_SIDFC_LSS (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_XIDFC: FDCAN Extended ID Filter Configuration Register
  #define FDCAN1_FDCAN_XIDFC (* ((volatile uint32_t *) (0x4000A000 + 136)))

  // Field FLESA: Filter List Standard Start Address
    inline uint32_t FDCAN1_FDCAN_XIDFC_FLESA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field LSE: List Size Extended
    inline uint32_t FDCAN1_FDCAN_XIDFC_LSE (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_XIDAM: FDCAN Extended ID and Mask Register
  #define FDCAN1_FDCAN_XIDAM (* ((volatile uint32_t *) (0x4000A000 + 144)))

  // Field EIDM: Extended ID Mask
    inline uint32_t FDCAN1_FDCAN_XIDAM_EIDM (const uint32_t inValue) {return (inValue & 0x1FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_HPMS: FDCAN High Priority Message Status Register
  #define FDCAN1_FDCAN_HPMS (* ((const volatile uint32_t *) (0x4000A000 + 148)))

  // Field BIDX: Buffer Index
    inline uint32_t FDCAN1_FDCAN_HPMS_BIDX (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field MSI: Message Storage Indicator
    inline uint32_t FDCAN1_FDCAN_HPMS_MSI (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field FIDX: Filter Index
    inline uint32_t FDCAN1_FDCAN_HPMS_FIDX (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FLST: Filter List
    const uint32_t FDCAN1_FDCAN_HPMS_FLST = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_NDAT1: FDCAN New Data 1 Register
  #define FDCAN1_FDCAN_NDAT1 (* ((const volatile uint32_t *) (0x4000A000 + 152)))

  // Field ND0: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND0 = 1U << 0 ;

  // Field ND1: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND1 = 1U << 1 ;

  // Field ND2: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND2 = 1U << 2 ;

  // Field ND3: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND3 = 1U << 3 ;

  // Field ND4: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND4 = 1U << 4 ;

  // Field ND5: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND5 = 1U << 5 ;

  // Field ND6: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND6 = 1U << 6 ;

  // Field ND7: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND7 = 1U << 7 ;

  // Field ND8: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND8 = 1U << 8 ;

  // Field ND9: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND9 = 1U << 9 ;

  // Field ND10: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND10 = 1U << 10 ;

  // Field ND11: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND11 = 1U << 11 ;

  // Field ND12: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND12 = 1U << 12 ;

  // Field ND13: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND13 = 1U << 13 ;

  // Field ND14: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND14 = 1U << 14 ;

  // Field ND15: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND15 = 1U << 15 ;

  // Field ND16: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND16 = 1U << 16 ;

  // Field ND17: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND17 = 1U << 17 ;

  // Field ND18: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND18 = 1U << 18 ;

  // Field ND19: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND19 = 1U << 19 ;

  // Field ND20: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND20 = 1U << 20 ;

  // Field ND21: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND21 = 1U << 21 ;

  // Field ND22: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND22 = 1U << 22 ;

  // Field ND23: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND23 = 1U << 23 ;

  // Field ND24: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND24 = 1U << 24 ;

  // Field ND25: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND25 = 1U << 25 ;

  // Field ND26: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND26 = 1U << 26 ;

  // Field ND27: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND27 = 1U << 27 ;

  // Field ND28: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND28 = 1U << 28 ;

  // Field ND29: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND29 = 1U << 29 ;

  // Field ND30: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND30 = 1U << 30 ;

  // Field ND31: New data
    const uint32_t FDCAN1_FDCAN_NDAT1_ND31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_NDAT2: FDCAN New Data 2 Register
  #define FDCAN1_FDCAN_NDAT2 (* ((const volatile uint32_t *) (0x4000A000 + 156)))

  // Field ND32: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND32 = 1U << 0 ;

  // Field ND33: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND33 = 1U << 1 ;

  // Field ND34: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND34 = 1U << 2 ;

  // Field ND35: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND35 = 1U << 3 ;

  // Field ND36: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND36 = 1U << 4 ;

  // Field ND37: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND37 = 1U << 5 ;

  // Field ND38: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND38 = 1U << 6 ;

  // Field ND39: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND39 = 1U << 7 ;

  // Field ND40: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND40 = 1U << 8 ;

  // Field ND41: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND41 = 1U << 9 ;

  // Field ND42: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND42 = 1U << 10 ;

  // Field ND43: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND43 = 1U << 11 ;

  // Field ND44: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND44 = 1U << 12 ;

  // Field ND45: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND45 = 1U << 13 ;

  // Field ND46: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND46 = 1U << 14 ;

  // Field ND47: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND47 = 1U << 15 ;

  // Field ND48: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND48 = 1U << 16 ;

  // Field ND49: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND49 = 1U << 17 ;

  // Field ND50: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND50 = 1U << 18 ;

  // Field ND51: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND51 = 1U << 19 ;

  // Field ND52: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND52 = 1U << 20 ;

  // Field ND53: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND53 = 1U << 21 ;

  // Field ND54: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND54 = 1U << 22 ;

  // Field ND55: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND55 = 1U << 23 ;

  // Field ND56: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND56 = 1U << 24 ;

  // Field ND57: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND57 = 1U << 25 ;

  // Field ND58: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND58 = 1U << 26 ;

  // Field ND59: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND59 = 1U << 27 ;

  // Field ND60: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND60 = 1U << 28 ;

  // Field ND61: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND61 = 1U << 29 ;

  // Field ND62: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND62 = 1U << 30 ;

  // Field ND63: New data
    const uint32_t FDCAN1_FDCAN_NDAT2_ND63 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF0C: FDCAN Rx FIFO 0 Configuration Register
  #define FDCAN1_FDCAN_RXF0C (* ((volatile uint32_t *) (0x4000A000 + 160)))

  // Field F0SA: Rx FIFO 0 Start Address
    inline uint32_t FDCAN1_FDCAN_RXF0C_F0SA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field F0S: Rx FIFO 0 Size
    inline uint32_t FDCAN1_FDCAN_RXF0C_F0S (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field F0WM: FIFO 0 Watermark
    inline uint32_t FDCAN1_FDCAN_RXF0C_F0WM (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF0S: FDCAN Rx FIFO 0 Status Register
  #define FDCAN1_FDCAN_RXF0S (* ((volatile uint32_t *) (0x4000A000 + 164)))

  // Field F0FL: Rx FIFO 0 Fill Level
    inline uint32_t FDCAN1_FDCAN_RXF0S_F0FL (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field F0G: Rx FIFO 0 Get Index
    inline uint32_t FDCAN1_FDCAN_RXF0S_F0G (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

  // Field F0P: Rx FIFO 0 Put Index
    inline uint32_t FDCAN1_FDCAN_RXF0S_F0P (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field F0F: Rx FIFO 0 Full
    const uint32_t FDCAN1_FDCAN_RXF0S_F0F = 1U << 24 ;

  // Field RF0L: Rx FIFO 0 Message Lost
    const uint32_t FDCAN1_FDCAN_RXF0S_RF0L = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF0A: CAN Rx FIFO 0 Acknowledge Register
  #define FDCAN1_FDCAN_RXF0A (* ((volatile uint32_t *) (0x4000A000 + 168)))

  // Field FA01: Rx FIFO 0 Acknowledge Index
    inline uint32_t FDCAN1_FDCAN_RXF0A_FA01 (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXBC: FDCAN Rx Buffer Configuration Register
  #define FDCAN1_FDCAN_RXBC (* ((volatile uint32_t *) (0x4000A000 + 172)))

  // Field RBSA: Rx Buffer Start Address
    inline uint32_t FDCAN1_FDCAN_RXBC_RBSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF1C: FDCAN Rx FIFO 1 Configuration Register
  #define FDCAN1_FDCAN_RXF1C (* ((volatile uint32_t *) (0x4000A000 + 176)))

  // Field F1SA: Rx FIFO 1 Start Address
    inline uint32_t FDCAN1_FDCAN_RXF1C_F1SA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field F1S: Rx FIFO 1 Size
    inline uint32_t FDCAN1_FDCAN_RXF1C_F1S (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field F1WM: Rx FIFO 1 Watermark
    inline uint32_t FDCAN1_FDCAN_RXF1C_F1WM (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF1S: FDCAN Rx FIFO 1 Status Register
  #define FDCAN1_FDCAN_RXF1S (* ((volatile uint32_t *) (0x4000A000 + 180)))

  // Field F1FL: Rx FIFO 1 Fill Level
    inline uint32_t FDCAN1_FDCAN_RXF1S_F1FL (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field F1GI: Rx FIFO 1 Get Index
    inline uint32_t FDCAN1_FDCAN_RXF1S_F1GI (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field F1PI: Rx FIFO 1 Put Index
    inline uint32_t FDCAN1_FDCAN_RXF1S_F1PI (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field F1F: Rx FIFO 1 Full
    const uint32_t FDCAN1_FDCAN_RXF1S_F1F = 1U << 24 ;

  // Field RF1L: Rx FIFO 1 Message Lost
    const uint32_t FDCAN1_FDCAN_RXF1S_RF1L = 1U << 25 ;

  // Field DMS: Debug Message Status
    inline uint32_t FDCAN1_FDCAN_RXF1S_DMS (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF1A: FDCAN Rx FIFO 1 Acknowledge Register
  #define FDCAN1_FDCAN_RXF1A (* ((volatile uint32_t *) (0x4000A000 + 184)))

  // Field F1AI: Rx FIFO 1 Acknowledge Index
    inline uint32_t FDCAN1_FDCAN_RXF1A_F1AI (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXESC: FDCAN Rx Buffer Element Size Configuration Register
  #define FDCAN1_FDCAN_RXESC (* ((volatile uint32_t *) (0x4000A000 + 188)))

  // Field F0DS: Rx FIFO 1 Data Field Size:
    inline uint32_t FDCAN1_FDCAN_RXESC_F0DS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field F1DS: Rx FIFO 0 Data Field Size:
    inline uint32_t FDCAN1_FDCAN_RXESC_F1DS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field RBDS: Rx Buffer Data Field Size:
    inline uint32_t FDCAN1_FDCAN_RXESC_RBDS (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBC: FDCAN Tx Buffer Configuration Register
  #define FDCAN1_FDCAN_TXBC (* ((volatile uint32_t *) (0x4000A000 + 192)))

  // Field TBSA: Tx Buffers Start Address
    inline uint32_t FDCAN1_FDCAN_TXBC_TBSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field NDTB: Number of Dedicated Transmit Buffers
    inline uint32_t FDCAN1_FDCAN_TXBC_NDTB (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field TFQS: Transmit FIFO/Queue Size
    inline uint32_t FDCAN1_FDCAN_TXBC_TFQS (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

  // Field TFQM: Tx FIFO/Queue Mode
    const uint32_t FDCAN1_FDCAN_TXBC_TFQM = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TXFQS: FDCAN Tx FIFO/Queue Status Register
  #define FDCAN1_FDCAN_TXFQS (* ((const volatile uint32_t *) (0x4000A000 + 196)))

  // Field TFFL: Tx FIFO Free Level
    inline uint32_t FDCAN1_FDCAN_TXFQS_TFFL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field TFGI: TFGI
    inline uint32_t FDCAN1_FDCAN_TXFQS_TFGI (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field TFQPI: Tx FIFO/Queue Put Index
    inline uint32_t FDCAN1_FDCAN_TXFQS_TFQPI (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TFQF: Tx FIFO/Queue Full
    const uint32_t FDCAN1_FDCAN_TXFQS_TFQF = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TXESC: FDCAN Tx Buffer Element Size Configuration Register
  #define FDCAN1_FDCAN_TXESC (* ((volatile uint32_t *) (0x4000A000 + 200)))

  // Field TBDS: Tx Buffer Data Field Size:
    inline uint32_t FDCAN1_FDCAN_TXESC_TBDS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBRP: FDCAN Tx Buffer Request Pending Register
  #define FDCAN1_FDCAN_TXBRP (* ((const volatile uint32_t *) (0x4000A000 + 204)))

  // Field TRP: Transmission Request Pending
    inline uint32_t FDCAN1_FDCAN_TXBRP_TRP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBAR: FDCAN Tx Buffer Add Request Register
  #define FDCAN1_FDCAN_TXBAR (* ((volatile uint32_t *) (0x4000A000 + 208)))

  // Field AR: Add Request
    inline uint32_t FDCAN1_FDCAN_TXBAR_AR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBCR: FDCAN Tx Buffer Cancellation Request Register
  #define FDCAN1_FDCAN_TXBCR (* ((volatile uint32_t *) (0x4000A000 + 212)))

  // Field CR: Cancellation Request
    inline uint32_t FDCAN1_FDCAN_TXBCR_CR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBTO: FDCAN Tx Buffer Transmission Occurred Register
  #define FDCAN1_FDCAN_TXBTO (* ((volatile uint32_t *) (0x4000A000 + 216)))

  // Field TO: Transmission Occurred.
    inline uint32_t FDCAN1_FDCAN_TXBTO_TO (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBCF: FDCAN Tx Buffer Cancellation Finished Register
  #define FDCAN1_FDCAN_TXBCF (* ((const volatile uint32_t *) (0x4000A000 + 220)))

  // Field CF: Cancellation Finished
    inline uint32_t FDCAN1_FDCAN_TXBCF_CF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBTIE: FDCAN Tx Buffer Transmission Interrupt Enable Register
  #define FDCAN1_FDCAN_TXBTIE (* ((volatile uint32_t *) (0x4000A000 + 224)))

  // Field TIE: Transmission Interrupt Enable
    inline uint32_t FDCAN1_FDCAN_TXBTIE_TIE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBCIE: FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
  #define FDCAN1_FDCAN_TXBCIE (* ((volatile uint32_t *) (0x4000A000 + 228)))

  // Field CF: Cancellation Finished Interrupt Enable
    inline uint32_t FDCAN1_FDCAN_TXBCIE_CF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXEFC: FDCAN Tx Event FIFO Configuration Register
  #define FDCAN1_FDCAN_TXEFC (* ((volatile uint32_t *) (0x4000A000 + 240)))

  // Field EFSA: Event FIFO Start Address
    inline uint32_t FDCAN1_FDCAN_TXEFC_EFSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field EFS: Event FIFO Size
    inline uint32_t FDCAN1_FDCAN_TXEFC_EFS (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field EFWM: Event FIFO Watermark
    inline uint32_t FDCAN1_FDCAN_TXEFC_EFWM (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXEFS: FDCAN Tx Event FIFO Status Register
  #define FDCAN1_FDCAN_TXEFS (* ((volatile uint32_t *) (0x4000A000 + 244)))

  // Field EFFL: Event FIFO Fill Level
    inline uint32_t FDCAN1_FDCAN_TXEFS_EFFL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field EFGI: Event FIFO Get Index.
    inline uint32_t FDCAN1_FDCAN_TXEFS_EFGI (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field EFF: Event FIFO Full.
    const uint32_t FDCAN1_FDCAN_TXEFS_EFF = 1U << 24 ;

  // Field TEFL: Tx Event FIFO Element Lost.
    const uint32_t FDCAN1_FDCAN_TXEFS_TEFL = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TXEFA: FDCAN Tx Event FIFO Acknowledge Register
  #define FDCAN1_FDCAN_TXEFA (* ((volatile uint32_t *) (0x4000A000 + 248)))

  // Field EFAI: Event FIFO Acknowledge Index
    inline uint32_t FDCAN1_FDCAN_TXEFA_EFAI (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTTMC: FDCAN TT Trigger Memory Configuration Register
  #define FDCAN1_FDCAN_TTTMC (* ((volatile uint32_t *) (0x4000A000 + 256)))

  // Field TMSA: Trigger Memory Start Address
    inline uint32_t FDCAN1_FDCAN_TTTMC_TMSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field TME: Trigger Memory Elements
    inline uint32_t FDCAN1_FDCAN_TTTMC_TME (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTRMC: FDCAN TT Reference Message Configuration Register
  #define FDCAN1_FDCAN_TTRMC (* ((volatile uint32_t *) (0x4000A000 + 260)))

  // Field RID: Reference Identifier.
    inline uint32_t FDCAN1_FDCAN_TTRMC_RID (const uint32_t inValue) {return (inValue & 0x1FFFFFFFU) << 0 ; }

  // Field XTD: Extended Identifier
    const uint32_t FDCAN1_FDCAN_TTRMC_XTD = 1U << 30 ;

  // Field RMPS: Reference Message Payload Select
    const uint32_t FDCAN1_FDCAN_TTRMC_RMPS = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTOCF: FDCAN TT Operation Configuration Register
  #define FDCAN1_FDCAN_TTOCF (* ((volatile uint32_t *) (0x4000A000 + 264)))

  // Field OM: Operation Mode
    inline uint32_t FDCAN1_FDCAN_TTOCF_OM (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field GEN: Gap Enable
    const uint32_t FDCAN1_FDCAN_TTOCF_GEN = 1U << 3 ;

  // Field TM: Time Master
    const uint32_t FDCAN1_FDCAN_TTOCF_TM = 1U << 4 ;

  // Field LDSDL: LD of Synchronization Deviation Limit
    inline uint32_t FDCAN1_FDCAN_TTOCF_LDSDL (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field IRTO: Initial Reference Trigger Offset
    inline uint32_t FDCAN1_FDCAN_TTOCF_IRTO (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field EECS: Enable External Clock Synchronization
    const uint32_t FDCAN1_FDCAN_TTOCF_EECS = 1U << 15 ;

  // Field AWL: Application Watchdog Limit
    inline uint32_t FDCAN1_FDCAN_TTOCF_AWL (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field EGTF: Enable Global Time Filtering
    const uint32_t FDCAN1_FDCAN_TTOCF_EGTF = 1U << 24 ;

  // Field ECC: Enable Clock Calibration
    const uint32_t FDCAN1_FDCAN_TTOCF_ECC = 1U << 25 ;

  // Field EVTP: Event Trigger Polarity
    const uint32_t FDCAN1_FDCAN_TTOCF_EVTP = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTMLM: FDCAN TT Matrix Limits Register
  #define FDCAN1_FDCAN_TTMLM (* ((volatile uint32_t *) (0x4000A000 + 268)))

  // Field CCM: Cycle Count Max
    inline uint32_t FDCAN1_FDCAN_TTMLM_CCM (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field CSS: Cycle Start Synchronization
    inline uint32_t FDCAN1_FDCAN_TTMLM_CSS (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field TXEW: Tx Enable Window
    inline uint32_t FDCAN1_FDCAN_TTMLM_TXEW (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ENTT: Expected Number of Tx Triggers
    inline uint32_t FDCAN1_FDCAN_TTMLM_ENTT (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TURCF: FDCAN TUR Configuration Register
  #define FDCAN1_FDCAN_TURCF (* ((volatile uint32_t *) (0x4000A000 + 272)))

  // Field NCL: Numerator Configuration Low.
    inline uint32_t FDCAN1_FDCAN_TURCF_NCL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DC: Denominator Configuration.
    inline uint32_t FDCAN1_FDCAN_TURCF_DC (const uint32_t inValue) {return (inValue & 0x3FFFU) << 16 ; }

  // Field ELT: Enable Local Time
    const uint32_t FDCAN1_FDCAN_TURCF_ELT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTOCN: FDCAN TT Operation Control Register
  #define FDCAN1_FDCAN_TTOCN (* ((volatile uint32_t *) (0x4000A000 + 276)))

  // Field SGT: Set Global time
    const uint32_t FDCAN1_FDCAN_TTOCN_SGT = 1U << 0 ;

  // Field ECS: External Clock Synchronization
    const uint32_t FDCAN1_FDCAN_TTOCN_ECS = 1U << 1 ;

  // Field SWP: Stop Watch Polarity
    const uint32_t FDCAN1_FDCAN_TTOCN_SWP = 1U << 2 ;

  // Field SWS: Stop Watch Source.
    inline uint32_t FDCAN1_FDCAN_TTOCN_SWS (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field RTIE: Register Time Mark Interrupt Pulse Enable
    const uint32_t FDCAN1_FDCAN_TTOCN_RTIE = 1U << 5 ;

  // Field TMC: Register Time Mark Compare
    inline uint32_t FDCAN1_FDCAN_TTOCN_TMC (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field TTIE: Trigger Time Mark Interrupt Pulse Enable
    const uint32_t FDCAN1_FDCAN_TTOCN_TTIE = 1U << 8 ;

  // Field GCS: Gap Control Select
    const uint32_t FDCAN1_FDCAN_TTOCN_GCS = 1U << 9 ;

  // Field FGP: Finish Gap.
    const uint32_t FDCAN1_FDCAN_TTOCN_FGP = 1U << 10 ;

  // Field TMG: Time Mark Gap
    const uint32_t FDCAN1_FDCAN_TTOCN_TMG = 1U << 11 ;

  // Field NIG: Next is Gap
    const uint32_t FDCAN1_FDCAN_TTOCN_NIG = 1U << 12 ;

  // Field ESCN: External Synchronization Control
    const uint32_t FDCAN1_FDCAN_TTOCN_ESCN = 1U << 13 ;

  // Field LCKC: TT Operation Control Register Locked
    const uint32_t FDCAN1_FDCAN_TTOCN_LCKC = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register CAN_TTGTP: FDCAN TT Global Time Preset Register
  #define FDCAN1_CAN_TTGTP (* ((volatile uint32_t *) (0x4000A000 + 280)))

  // Field NCL: Time Preset
    inline uint32_t FDCAN1_CAN_TTGTP_NCL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CTP: Cycle Time Target Phase
    inline uint32_t FDCAN1_CAN_TTGTP_CTP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTTMK: FDCAN TT Time Mark Register
  #define FDCAN1_FDCAN_TTTMK (* ((volatile uint32_t *) (0x4000A000 + 284)))

  // Field TM: Time Mark
    inline uint32_t FDCAN1_FDCAN_TTTMK_TM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field TICC: Time Mark Cycle Code
    inline uint32_t FDCAN1_FDCAN_TTTMK_TICC (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field LCKM: TT Time Mark Register Locked
    const uint32_t FDCAN1_FDCAN_TTTMK_LCKM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTIR: FDCAN TT Interrupt Register
  #define FDCAN1_FDCAN_TTIR (* ((volatile uint32_t *) (0x4000A000 + 288)))

  // Field SBC: Start of Basic Cycle
    const uint32_t FDCAN1_FDCAN_TTIR_SBC = 1U << 0 ;

  // Field SMC: Start of Matrix Cycle
    const uint32_t FDCAN1_FDCAN_TTIR_SMC = 1U << 1 ;

  // Field CSM: Change of Synchronization Mode
    const uint32_t FDCAN1_FDCAN_TTIR_CSM = 1U << 2 ;

  // Field SOG: Start of Gap
    const uint32_t FDCAN1_FDCAN_TTIR_SOG = 1U << 3 ;

  // Field RTMI: Register Time Mark Interrupt.
    const uint32_t FDCAN1_FDCAN_TTIR_RTMI = 1U << 4 ;

  // Field TTMI: Trigger Time Mark Event Internal
    const uint32_t FDCAN1_FDCAN_TTIR_TTMI = 1U << 5 ;

  // Field SWE: Stop Watch Event
    const uint32_t FDCAN1_FDCAN_TTIR_SWE = 1U << 6 ;

  // Field GTW: Global Time Wrap
    const uint32_t FDCAN1_FDCAN_TTIR_GTW = 1U << 7 ;

  // Field GTD: Global Time Discontinuity
    const uint32_t FDCAN1_FDCAN_TTIR_GTD = 1U << 8 ;

  // Field GTE: Global Time Error
    const uint32_t FDCAN1_FDCAN_TTIR_GTE = 1U << 9 ;

  // Field TXU: Tx Count Underflow
    const uint32_t FDCAN1_FDCAN_TTIR_TXU = 1U << 10 ;

  // Field TXO: Tx Count Overflow
    const uint32_t FDCAN1_FDCAN_TTIR_TXO = 1U << 11 ;

  // Field SE1: Scheduling Error 1
    const uint32_t FDCAN1_FDCAN_TTIR_SE1 = 1U << 12 ;

  // Field SE2: Scheduling Error 2
    const uint32_t FDCAN1_FDCAN_TTIR_SE2 = 1U << 13 ;

  // Field ELC: Error Level Changed.
    const uint32_t FDCAN1_FDCAN_TTIR_ELC = 1U << 14 ;

  // Field IWTG: Initialization Watch Trigger
    const uint32_t FDCAN1_FDCAN_TTIR_IWTG = 1U << 15 ;

  // Field WT: Watch Trigger
    const uint32_t FDCAN1_FDCAN_TTIR_WT = 1U << 16 ;

  // Field AW: Application Watchdog
    const uint32_t FDCAN1_FDCAN_TTIR_AW = 1U << 17 ;

  // Field CER: Configuration Error
    const uint32_t FDCAN1_FDCAN_TTIR_CER = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTIE: FDCAN TT Interrupt Enable Register
  #define FDCAN1_FDCAN_TTIE (* ((volatile uint32_t *) (0x4000A000 + 292)))

  // Field SBCE: Start of Basic Cycle Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_SBCE = 1U << 0 ;

  // Field SMCE: Start of Matrix Cycle Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_SMCE = 1U << 1 ;

  // Field CSME: Change of Synchronization Mode Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_CSME = 1U << 2 ;

  // Field SOGE: Start of Gap Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_SOGE = 1U << 3 ;

  // Field RTMIE: Register Time Mark Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_RTMIE = 1U << 4 ;

  // Field TTMIE: Trigger Time Mark Event Internal Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_TTMIE = 1U << 5 ;

  // Field SWEE: Stop Watch Event Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_SWEE = 1U << 6 ;

  // Field GTWE: Global Time Wrap Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_GTWE = 1U << 7 ;

  // Field GTDE: Global Time Discontinuity Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_GTDE = 1U << 8 ;

  // Field GTEE: Global Time Error Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_GTEE = 1U << 9 ;

  // Field TXUE: Tx Count Underflow Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_TXUE = 1U << 10 ;

  // Field TXOE: Tx Count Overflow Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_TXOE = 1U << 11 ;

  // Field SE1E: Scheduling Error 1 Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_SE1E = 1U << 12 ;

  // Field SE2E: Scheduling Error 2 Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_SE2E = 1U << 13 ;

  // Field ELCE: Change Error Level Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_ELCE = 1U << 14 ;

  // Field IWTGE: Initialization Watch Trigger Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_IWTGE = 1U << 15 ;

  // Field WTE: Watch Trigger Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_WTE = 1U << 16 ;

  // Field AWE: Application Watchdog Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_AWE = 1U << 17 ;

  // Field CERE: Configuration Error Interrupt Enable
    const uint32_t FDCAN1_FDCAN_TTIE_CERE = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTILS: FDCAN TT Interrupt Line Select Register
  #define FDCAN1_FDCAN_TTILS (* ((volatile uint32_t *) (0x4000A000 + 296)))

  // Field SBCL: Start of Basic Cycle Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_SBCL = 1U << 0 ;

  // Field SMCL: Start of Matrix Cycle Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_SMCL = 1U << 1 ;

  // Field CSML: Change of Synchronization Mode Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_CSML = 1U << 2 ;

  // Field SOGL: Start of Gap Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_SOGL = 1U << 3 ;

  // Field RTMIL: Register Time Mark Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_RTMIL = 1U << 4 ;

  // Field TTMIL: Trigger Time Mark Event Internal Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_TTMIL = 1U << 5 ;

  // Field SWEL: Stop Watch Event Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_SWEL = 1U << 6 ;

  // Field GTWL: Global Time Wrap Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_GTWL = 1U << 7 ;

  // Field GTDL: Global Time Discontinuity Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_GTDL = 1U << 8 ;

  // Field GTEL: Global Time Error Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_GTEL = 1U << 9 ;

  // Field TXUL: Tx Count Underflow Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_TXUL = 1U << 10 ;

  // Field TXOL: Tx Count Overflow Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_TXOL = 1U << 11 ;

  // Field SE1L: Scheduling Error 1 Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_SE1L = 1U << 12 ;

  // Field SE2L: Scheduling Error 2 Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_SE2L = 1U << 13 ;

  // Field ELCL: Change Error Level Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_ELCL = 1U << 14 ;

  // Field IWTGL: Initialization Watch Trigger Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_IWTGL = 1U << 15 ;

  // Field WTL: Watch Trigger Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_WTL = 1U << 16 ;

  // Field AWL: Application Watchdog Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_AWL = 1U << 17 ;

  // Field CERL: Configuration Error Interrupt Line
    const uint32_t FDCAN1_FDCAN_TTILS_CERL = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTOST: FDCAN TT Operation Status Register
  #define FDCAN1_FDCAN_TTOST (* ((volatile uint32_t *) (0x4000A000 + 300)))

  // Field EL: Error Level
    inline uint32_t FDCAN1_FDCAN_TTOST_EL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MS: Master State.
    inline uint32_t FDCAN1_FDCAN_TTOST_MS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SYS: Synchronization State
    inline uint32_t FDCAN1_FDCAN_TTOST_SYS (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field GTP: Quality of Global Time Phase
    const uint32_t FDCAN1_FDCAN_TTOST_GTP = 1U << 6 ;

  // Field QCS: Quality of Clock Speed
    const uint32_t FDCAN1_FDCAN_TTOST_QCS = 1U << 7 ;

  // Field RTO: Reference Trigger Offset
    inline uint32_t FDCAN1_FDCAN_TTOST_RTO (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field WGTD: Wait for Global Time Discontinuity
    const uint32_t FDCAN1_FDCAN_TTOST_WGTD = 1U << 22 ;

  // Field GFI: Gap Finished Indicator.
    const uint32_t FDCAN1_FDCAN_TTOST_GFI = 1U << 23 ;

  // Field TMP: Time Master Priority
    inline uint32_t FDCAN1_FDCAN_TTOST_TMP (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field GSI: Gap Started Indicator.
    const uint32_t FDCAN1_FDCAN_TTOST_GSI = 1U << 27 ;

  // Field WFE: Wait for Event
    const uint32_t FDCAN1_FDCAN_TTOST_WFE = 1U << 28 ;

  // Field AWE: Application Watchdog Event
    const uint32_t FDCAN1_FDCAN_TTOST_AWE = 1U << 29 ;

  // Field WECS: Wait for External Clock Synchronization
    const uint32_t FDCAN1_FDCAN_TTOST_WECS = 1U << 30 ;

  // Field SPL: Schedule Phase Lock
    const uint32_t FDCAN1_FDCAN_TTOST_SPL = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TURNA: FDCAN TUR Numerator Actual Register
  #define FDCAN1_FDCAN_TURNA (* ((const volatile uint32_t *) (0x4000A000 + 304)))

  // Field NAV: Numerator Actual Value
    inline uint32_t FDCAN1_FDCAN_TURNA_NAV (const uint32_t inValue) {return (inValue & 0x3FFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTLGT: FDCAN TT Local and Global Time Register
  #define FDCAN1_FDCAN_TTLGT (* ((const volatile uint32_t *) (0x4000A000 + 308)))

  // Field LT: Local Time
    inline uint32_t FDCAN1_FDCAN_TTLGT_LT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field GT: Global Time
    inline uint32_t FDCAN1_FDCAN_TTLGT_GT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTCTC: FDCAN TT Cycle Time and Count Register
  #define FDCAN1_FDCAN_TTCTC (* ((const volatile uint32_t *) (0x4000A000 + 312)))

  // Field CT: Cycle Time
    inline uint32_t FDCAN1_FDCAN_TTCTC_CT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CC: Cycle Count
    inline uint32_t FDCAN1_FDCAN_TTCTC_CC (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTCPT: FDCAN TT Capture Time Register
  #define FDCAN1_FDCAN_TTCPT (* ((const volatile uint32_t *) (0x4000A000 + 316)))

  // Field CT: Cycle Count Value
    inline uint32_t FDCAN1_FDCAN_TTCPT_CT (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SWV: Stop Watch Value
    inline uint32_t FDCAN1_FDCAN_TTCPT_SWV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTCSM: FDCAN TT Cycle Sync Mark Register
  #define FDCAN1_FDCAN_TTCSM (* ((const volatile uint32_t *) (0x4000A000 + 320)))

  // Field CSM: Cycle Sync Mark
    inline uint32_t FDCAN1_FDCAN_TTCSM_CSM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTTS: FDCAN TT Trigger Select Register
  #define FDCAN1_FDCAN_TTTS (* ((volatile uint32_t *) (0x4000A000 + 768)))

  // Field SWTDEL: Stop watch trigger input selection
    inline uint32_t FDCAN1_FDCAN_TTTS_SWTDEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field EVTSEL: Event trigger input selection
    inline uint32_t FDCAN1_FDCAN_TTTS_EVTSEL (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------
// Peripheral FDCAN2
//------------------------------------------------------------------------------

//---  Register FDCAN_CREL: FDCAN Core Release Register
  #define FDCAN2_FDCAN_CREL (* ((const volatile uint32_t *) (0x4000A400 + 0)))

  // Field REL: Core release
    inline uint32_t FDCAN2_FDCAN_CREL_REL (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field STEP: Step of Core release
    inline uint32_t FDCAN2_FDCAN_CREL_STEP (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field SUBSTEP: Sub-step of Core release
    inline uint32_t FDCAN2_FDCAN_CREL_SUBSTEP (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field YEAR: Timestamp Year
    inline uint32_t FDCAN2_FDCAN_CREL_YEAR (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field MON: Timestamp Month
    inline uint32_t FDCAN2_FDCAN_CREL_MON (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field DAY: Timestamp Day
    inline uint32_t FDCAN2_FDCAN_CREL_DAY (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_ENDN: FDCAN Core Release Register
  #define FDCAN2_FDCAN_ENDN (* ((const volatile uint32_t *) (0x4000A400 + 4)))

  // Field ETV: Endiannes Test Value
    inline uint32_t FDCAN2_FDCAN_ENDN_ETV (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_DBTP: FDCAN Data Bit Timing and Prescaler Register
  #define FDCAN2_FDCAN_DBTP (* ((const volatile uint32_t *) (0x4000A400 + 12)))

  // Field DSJW: Synchronization Jump Width
    inline uint32_t FDCAN2_FDCAN_DBTP_DSJW (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DTSEG2: Data time segment after sample point
    inline uint32_t FDCAN2_FDCAN_DBTP_DTSEG2 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DTSEG1: Data time segment after sample point
    inline uint32_t FDCAN2_FDCAN_DBTP_DTSEG1 (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBRP: Data BIt Rate Prescaler
    inline uint32_t FDCAN2_FDCAN_DBTP_DBRP (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TDC: Transceiver Delay Compensation
    const uint32_t FDCAN2_FDCAN_DBTP_TDC = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TEST: FDCAN Test Register
  #define FDCAN2_FDCAN_TEST (* ((const volatile uint32_t *) (0x4000A400 + 16)))

  // Field LBCK: Loop Back mode
    const uint32_t FDCAN2_FDCAN_TEST_LBCK = 1U << 4 ;

  // Field TX: Loop Back mode
    inline uint32_t FDCAN2_FDCAN_TEST_TX (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field RX: Control of Transmit Pin
    const uint32_t FDCAN2_FDCAN_TEST_RX = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_RWD: FDCAN RAM Watchdog Register
  #define FDCAN2_FDCAN_RWD (* ((const volatile uint32_t *) (0x4000A400 + 20)))

  // Field WDV: Watchdog value
    inline uint32_t FDCAN2_FDCAN_RWD_WDV (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field WDC: Watchdog configuration
    inline uint32_t FDCAN2_FDCAN_RWD_WDC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_CCCR: FDCAN CC Control Register
  #define FDCAN2_FDCAN_CCCR (* ((volatile uint32_t *) (0x4000A400 + 24)))

  // Field INIT: Initialization
    const uint32_t FDCAN2_FDCAN_CCCR_INIT = 1U << 0 ;

  // Field CCE: Configuration Change Enable
    const uint32_t FDCAN2_FDCAN_CCCR_CCE = 1U << 1 ;

  // Field ASM: ASM Restricted Operation Mode
    const uint32_t FDCAN2_FDCAN_CCCR_ASM = 1U << 2 ;

  // Field CSA: Clock Stop Acknowledge
    const uint32_t FDCAN2_FDCAN_CCCR_CSA = 1U << 3 ;

  // Field CSR: Clock Stop Request
    const uint32_t FDCAN2_FDCAN_CCCR_CSR = 1U << 4 ;

  // Field MON: Bus Monitoring Mode
    const uint32_t FDCAN2_FDCAN_CCCR_MON = 1U << 5 ;

  // Field DAR: Disable Automatic Retransmission
    const uint32_t FDCAN2_FDCAN_CCCR_DAR = 1U << 6 ;

  // Field TEST: Test Mode Enable
    const uint32_t FDCAN2_FDCAN_CCCR_TEST = 1U << 7 ;

  // Field FDOE: FD Operation Enable
    const uint32_t FDCAN2_FDCAN_CCCR_FDOE = 1U << 8 ;

  // Field BSE: FDCAN Bit Rate Switching
    const uint32_t FDCAN2_FDCAN_CCCR_BSE = 1U << 9 ;

  // Field PXHD: Protocol Exception Handling Disable
    const uint32_t FDCAN2_FDCAN_CCCR_PXHD = 1U << 12 ;

  // Field EFBI: Edge Filtering during Bus Integration
    const uint32_t FDCAN2_FDCAN_CCCR_EFBI = 1U << 13 ;

  // Field TXP: TXP
    const uint32_t FDCAN2_FDCAN_CCCR_TXP = 1U << 14 ;

  // Field NISO: Non ISO Operation
    const uint32_t FDCAN2_FDCAN_CCCR_NISO = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_NBTP: FDCAN Nominal Bit Timing and Prescaler Register
  #define FDCAN2_FDCAN_NBTP (* ((volatile uint32_t *) (0x4000A400 + 28)))

  // Field NSJW: NSJW: Nominal (Re)Synchronization Jump Width
    inline uint32_t FDCAN2_FDCAN_NBTP_NSJW (const uint32_t inValue) {return (inValue & 0x7FU) << 25 ; }

  // Field NBRP: Bit Rate Prescaler
    inline uint32_t FDCAN2_FDCAN_NBTP_NBRP (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field NTSEG1: Nominal Time segment before sample point
    inline uint32_t FDCAN2_FDCAN_NBTP_NTSEG1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field TSEG2: Nominal Time segment after sample point
    inline uint32_t FDCAN2_FDCAN_NBTP_TSEG2 (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TSCC: FDCAN Timestamp Counter Configuration Register
  #define FDCAN2_FDCAN_TSCC (* ((volatile uint32_t *) (0x4000A400 + 32)))

  // Field TCP: Timestamp Counter Prescaler
    inline uint32_t FDCAN2_FDCAN_TSCC_TCP (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TSS: Timestamp Select
    inline uint32_t FDCAN2_FDCAN_TSCC_TSS (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TSCV: FDCAN Timestamp Counter Value Register
  #define FDCAN2_FDCAN_TSCV (* ((volatile uint32_t *) (0x4000A400 + 36)))

  // Field TSC: Timestamp Counter
    inline uint32_t FDCAN2_FDCAN_TSCV_TSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TOCC: FDCAN Timeout Counter Configuration Register
  #define FDCAN2_FDCAN_TOCC (* ((volatile uint32_t *) (0x4000A400 + 40)))

  // Field ETOC: Enable Timeout Counter
    const uint32_t FDCAN2_FDCAN_TOCC_ETOC = 1U << 0 ;

  // Field TOS: Timeout Select
    inline uint32_t FDCAN2_FDCAN_TOCC_TOS (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field TOP: Timeout Period
    inline uint32_t FDCAN2_FDCAN_TOCC_TOP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TOCV: FDCAN Timeout Counter Value Register
  #define FDCAN2_FDCAN_TOCV (* ((volatile uint32_t *) (0x4000A400 + 44)))

  // Field TOC: Timeout Counter
    inline uint32_t FDCAN2_FDCAN_TOCV_TOC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_ECR: FDCAN Error Counter Register
  #define FDCAN2_FDCAN_ECR (* ((volatile uint32_t *) (0x4000A400 + 64)))

  // Field CEL: AN Error Logging
    inline uint32_t FDCAN2_FDCAN_ECR_CEL (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field RP: Receive Error Passive
    const uint32_t FDCAN2_FDCAN_ECR_RP = 1U << 15 ;

  // Field TREC: Receive Error Counter
    inline uint32_t FDCAN2_FDCAN_ECR_TREC (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field TEC: Transmit Error Counter
    inline uint32_t FDCAN2_FDCAN_ECR_TEC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_PSR: FDCAN Protocol Status Register
  #define FDCAN2_FDCAN_PSR (* ((volatile uint32_t *) (0x4000A400 + 68)))

  // Field LEC: Last Error Code
    inline uint32_t FDCAN2_FDCAN_PSR_LEC (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field ACT: Activity
    inline uint32_t FDCAN2_FDCAN_PSR_ACT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field EP: Error Passive
    const uint32_t FDCAN2_FDCAN_PSR_EP = 1U << 5 ;

  // Field EW: Warning Status
    const uint32_t FDCAN2_FDCAN_PSR_EW = 1U << 6 ;

  // Field BO: Bus_Off Status
    const uint32_t FDCAN2_FDCAN_PSR_BO = 1U << 7 ;

  // Field DLEC: Data Last Error Code
    inline uint32_t FDCAN2_FDCAN_PSR_DLEC (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field RESI: ESI flag of last received FDCAN Message
    const uint32_t FDCAN2_FDCAN_PSR_RESI = 1U << 11 ;

  // Field RBRS: BRS flag of last received FDCAN Message
    const uint32_t FDCAN2_FDCAN_PSR_RBRS = 1U << 12 ;

  // Field REDL: Received FDCAN Message
    const uint32_t FDCAN2_FDCAN_PSR_REDL = 1U << 13 ;

  // Field PXE: Protocol Exception Event
    const uint32_t FDCAN2_FDCAN_PSR_PXE = 1U << 14 ;

  // Field TDCV: Transmitter Delay Compensation Value
    inline uint32_t FDCAN2_FDCAN_PSR_TDCV (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TDCR: FDCAN Transmitter Delay Compensation Register
  #define FDCAN2_FDCAN_TDCR (* ((const volatile uint32_t *) (0x4000A400 + 72)))

  // Field TDCF: Transmitter Delay Compensation Filter Window Length
    inline uint32_t FDCAN2_FDCAN_TDCR_TDCF (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TDCO: Transmitter Delay Compensation Offset
    inline uint32_t FDCAN2_FDCAN_TDCR_TDCO (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_IR: FDCAN Interrupt Register
  #define FDCAN2_FDCAN_IR (* ((const volatile uint32_t *) (0x4000A400 + 80)))

  // Field RF0N: Rx FIFO 0 New Message
    const uint32_t FDCAN2_FDCAN_IR_RF0N = 1U << 0 ;

  // Field RF0W: Rx FIFO 0 Full
    const uint32_t FDCAN2_FDCAN_IR_RF0W = 1U << 1 ;

  // Field RF0F: Rx FIFO 0 Full
    const uint32_t FDCAN2_FDCAN_IR_RF0F = 1U << 2 ;

  // Field RF0L: Rx FIFO 0 Message Lost
    const uint32_t FDCAN2_FDCAN_IR_RF0L = 1U << 3 ;

  // Field RF1N: Rx FIFO 1 New Message
    const uint32_t FDCAN2_FDCAN_IR_RF1N = 1U << 4 ;

  // Field RF1W: Rx FIFO 1 Watermark Reached
    const uint32_t FDCAN2_FDCAN_IR_RF1W = 1U << 5 ;

  // Field RF1F: Rx FIFO 1 Watermark Reached
    const uint32_t FDCAN2_FDCAN_IR_RF1F = 1U << 6 ;

  // Field RF1L: Rx FIFO 1 Message Lost
    const uint32_t FDCAN2_FDCAN_IR_RF1L = 1U << 7 ;

  // Field HPM: High Priority Message
    const uint32_t FDCAN2_FDCAN_IR_HPM = 1U << 8 ;

  // Field TC: Transmission Completed
    const uint32_t FDCAN2_FDCAN_IR_TC = 1U << 9 ;

  // Field TCF: Transmission Cancellation Finished
    const uint32_t FDCAN2_FDCAN_IR_TCF = 1U << 10 ;

  // Field TEF: Tx FIFO Empty
    const uint32_t FDCAN2_FDCAN_IR_TEF = 1U << 11 ;

  // Field TEFN: Tx Event FIFO New Entry
    const uint32_t FDCAN2_FDCAN_IR_TEFN = 1U << 12 ;

  // Field TEFW: Tx Event FIFO Watermark Reached
    const uint32_t FDCAN2_FDCAN_IR_TEFW = 1U << 13 ;

  // Field TEFF: Tx Event FIFO Full
    const uint32_t FDCAN2_FDCAN_IR_TEFF = 1U << 14 ;

  // Field TEFL: Tx Event FIFO Element Lost
    const uint32_t FDCAN2_FDCAN_IR_TEFL = 1U << 15 ;

  // Field TSW: Timestamp Wraparound
    const uint32_t FDCAN2_FDCAN_IR_TSW = 1U << 16 ;

  // Field MRAF: Message RAM Access Failure
    const uint32_t FDCAN2_FDCAN_IR_MRAF = 1U << 17 ;

  // Field TOO: Timeout Occurred
    const uint32_t FDCAN2_FDCAN_IR_TOO = 1U << 18 ;

  // Field DRX: Message stored to Dedicated Rx Buffer
    const uint32_t FDCAN2_FDCAN_IR_DRX = 1U << 19 ;

  // Field ELO: Error Logging Overflow
    const uint32_t FDCAN2_FDCAN_IR_ELO = 1U << 22 ;

  // Field EP: Error Passive
    const uint32_t FDCAN2_FDCAN_IR_EP = 1U << 23 ;

  // Field EW: Warning Status
    const uint32_t FDCAN2_FDCAN_IR_EW = 1U << 24 ;

  // Field BO: Bus_Off Status
    const uint32_t FDCAN2_FDCAN_IR_BO = 1U << 25 ;

  // Field WDI: Watchdog Interrupt
    const uint32_t FDCAN2_FDCAN_IR_WDI = 1U << 26 ;

  // Field PEA: Protocol Error in Arbitration Phase (Nominal Bit Time is used)
    const uint32_t FDCAN2_FDCAN_IR_PEA = 1U << 27 ;

  // Field PED: Protocol Error in Data Phase (Data Bit Time is used)
    const uint32_t FDCAN2_FDCAN_IR_PED = 1U << 28 ;

  // Field ARA: Access to Reserved Address
    const uint32_t FDCAN2_FDCAN_IR_ARA = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_IE: FDCAN Interrupt Enable Register
  #define FDCAN2_FDCAN_IE (* ((const volatile uint32_t *) (0x4000A400 + 84)))

  // Field RF0NE: Rx FIFO 0 New Message Enable
    const uint32_t FDCAN2_FDCAN_IE_RF0NE = 1U << 0 ;

  // Field RF0WE: Rx FIFO 0 Full Enable
    const uint32_t FDCAN2_FDCAN_IE_RF0WE = 1U << 1 ;

  // Field RF0FE: Rx FIFO 0 Full Enable
    const uint32_t FDCAN2_FDCAN_IE_RF0FE = 1U << 2 ;

  // Field RF0LE: Rx FIFO 0 Message Lost Enable
    const uint32_t FDCAN2_FDCAN_IE_RF0LE = 1U << 3 ;

  // Field RF1NE: Rx FIFO 1 New Message Enable
    const uint32_t FDCAN2_FDCAN_IE_RF1NE = 1U << 4 ;

  // Field RF1WE: Rx FIFO 1 Watermark Reached Enable
    const uint32_t FDCAN2_FDCAN_IE_RF1WE = 1U << 5 ;

  // Field RF1FE: Rx FIFO 1 Watermark Reached Enable
    const uint32_t FDCAN2_FDCAN_IE_RF1FE = 1U << 6 ;

  // Field RF1LE: Rx FIFO 1 Message Lost Enable
    const uint32_t FDCAN2_FDCAN_IE_RF1LE = 1U << 7 ;

  // Field HPME: High Priority Message Enable
    const uint32_t FDCAN2_FDCAN_IE_HPME = 1U << 8 ;

  // Field TCE: Transmission Completed Enable
    const uint32_t FDCAN2_FDCAN_IE_TCE = 1U << 9 ;

  // Field TCFE: Transmission Cancellation Finished Enable
    const uint32_t FDCAN2_FDCAN_IE_TCFE = 1U << 10 ;

  // Field TEFE: Tx FIFO Empty Enable
    const uint32_t FDCAN2_FDCAN_IE_TEFE = 1U << 11 ;

  // Field TEFNE: Tx Event FIFO New Entry Enable
    const uint32_t FDCAN2_FDCAN_IE_TEFNE = 1U << 12 ;

  // Field TEFWE: Tx Event FIFO Watermark Reached Enable
    const uint32_t FDCAN2_FDCAN_IE_TEFWE = 1U << 13 ;

  // Field TEFFE: Tx Event FIFO Full Enable
    const uint32_t FDCAN2_FDCAN_IE_TEFFE = 1U << 14 ;

  // Field TEFLE: Tx Event FIFO Element Lost Enable
    const uint32_t FDCAN2_FDCAN_IE_TEFLE = 1U << 15 ;

  // Field TSWE: Timestamp Wraparound Enable
    const uint32_t FDCAN2_FDCAN_IE_TSWE = 1U << 16 ;

  // Field MRAFE: Message RAM Access Failure Enable
    const uint32_t FDCAN2_FDCAN_IE_MRAFE = 1U << 17 ;

  // Field TOOE: Timeout Occurred Enable
    const uint32_t FDCAN2_FDCAN_IE_TOOE = 1U << 18 ;

  // Field DRXE: Message stored to Dedicated Rx Buffer Enable
    const uint32_t FDCAN2_FDCAN_IE_DRXE = 1U << 19 ;

  // Field BECE: Bit Error Corrected Interrupt Enable
    const uint32_t FDCAN2_FDCAN_IE_BECE = 1U << 20 ;

  // Field BEUE: Bit Error Uncorrected Interrupt Enable
    const uint32_t FDCAN2_FDCAN_IE_BEUE = 1U << 21 ;

  // Field ELOE: Error Logging Overflow Enable
    const uint32_t FDCAN2_FDCAN_IE_ELOE = 1U << 22 ;

  // Field EPE: Error Passive Enable
    const uint32_t FDCAN2_FDCAN_IE_EPE = 1U << 23 ;

  // Field EWE: Warning Status Enable
    const uint32_t FDCAN2_FDCAN_IE_EWE = 1U << 24 ;

  // Field BOE: Bus_Off Status Enable
    const uint32_t FDCAN2_FDCAN_IE_BOE = 1U << 25 ;

  // Field WDIE: Watchdog Interrupt Enable
    const uint32_t FDCAN2_FDCAN_IE_WDIE = 1U << 26 ;

  // Field PEAE: Protocol Error in Arbitration Phase Enable
    const uint32_t FDCAN2_FDCAN_IE_PEAE = 1U << 27 ;

  // Field PEDE: Protocol Error in Data Phase Enable
    const uint32_t FDCAN2_FDCAN_IE_PEDE = 1U << 28 ;

  // Field ARAE: Access to Reserved Address Enable
    const uint32_t FDCAN2_FDCAN_IE_ARAE = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_ILS: FDCAN Interrupt Line Select Register
  #define FDCAN2_FDCAN_ILS (* ((const volatile uint32_t *) (0x4000A400 + 88)))

  // Field RF0NL: Rx FIFO 0 New Message Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF0NL = 1U << 0 ;

  // Field RF0WL: Rx FIFO 0 Watermark Reached Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF0WL = 1U << 1 ;

  // Field RF0FL: Rx FIFO 0 Full Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF0FL = 1U << 2 ;

  // Field RF0LL: Rx FIFO 0 Message Lost Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF0LL = 1U << 3 ;

  // Field RF1NL: Rx FIFO 1 New Message Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF1NL = 1U << 4 ;

  // Field RF1WL: Rx FIFO 1 Watermark Reached Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF1WL = 1U << 5 ;

  // Field RF1FL: Rx FIFO 1 Full Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF1FL = 1U << 6 ;

  // Field RF1LL: Rx FIFO 1 Message Lost Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_RF1LL = 1U << 7 ;

  // Field HPML: High Priority Message Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_HPML = 1U << 8 ;

  // Field TCL: Transmission Completed Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TCL = 1U << 9 ;

  // Field TCFL: Transmission Cancellation Finished Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TCFL = 1U << 10 ;

  // Field TEFL: Tx FIFO Empty Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TEFL = 1U << 11 ;

  // Field TEFNL: Tx Event FIFO New Entry Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TEFNL = 1U << 12 ;

  // Field TEFWL: Tx Event FIFO Watermark Reached Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TEFWL = 1U << 13 ;

  // Field TEFFL: Tx Event FIFO Full Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TEFFL = 1U << 14 ;

  // Field TEFLL: Tx Event FIFO Element Lost Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TEFLL = 1U << 15 ;

  // Field TSWL: Timestamp Wraparound Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TSWL = 1U << 16 ;

  // Field MRAFL: Message RAM Access Failure Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_MRAFL = 1U << 17 ;

  // Field TOOL: Timeout Occurred Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_TOOL = 1U << 18 ;

  // Field DRXL: Message stored to Dedicated Rx Buffer Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_DRXL = 1U << 19 ;

  // Field BECL: Bit Error Corrected Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_BECL = 1U << 20 ;

  // Field BEUL: Bit Error Uncorrected Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_BEUL = 1U << 21 ;

  // Field ELOL: Error Logging Overflow Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_ELOL = 1U << 22 ;

  // Field EPL: Error Passive Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_EPL = 1U << 23 ;

  // Field EWL: Warning Status Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_EWL = 1U << 24 ;

  // Field BOL: Bus_Off Status
    const uint32_t FDCAN2_FDCAN_ILS_BOL = 1U << 25 ;

  // Field WDIL: Watchdog Interrupt Line
    const uint32_t FDCAN2_FDCAN_ILS_WDIL = 1U << 26 ;

  // Field PEAL: Protocol Error in Arbitration Phase Line
    const uint32_t FDCAN2_FDCAN_ILS_PEAL = 1U << 27 ;

  // Field PEDL: Protocol Error in Data Phase Line
    const uint32_t FDCAN2_FDCAN_ILS_PEDL = 1U << 28 ;

  // Field ARAL: Access to Reserved Address Line
    const uint32_t FDCAN2_FDCAN_ILS_ARAL = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_ILE: FDCAN Interrupt Line Enable Register
  #define FDCAN2_FDCAN_ILE (* ((volatile uint32_t *) (0x4000A400 + 92)))

  // Field EINT0: Enable Interrupt Line 0
    const uint32_t FDCAN2_FDCAN_ILE_EINT0 = 1U << 0 ;

  // Field EINT1: Enable Interrupt Line 1
    const uint32_t FDCAN2_FDCAN_ILE_EINT1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_GFC: FDCAN Global Filter Configuration Register
  #define FDCAN2_FDCAN_GFC (* ((volatile uint32_t *) (0x4000A400 + 128)))

  // Field RRFE: Reject Remote Frames Extended
    const uint32_t FDCAN2_FDCAN_GFC_RRFE = 1U << 0 ;

  // Field RRFS: Reject Remote Frames Standard
    const uint32_t FDCAN2_FDCAN_GFC_RRFS = 1U << 1 ;

  // Field ANFE: Accept Non-matching Frames Extended
    inline uint32_t FDCAN2_FDCAN_GFC_ANFE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field ANFS: Accept Non-matching Frames Standard
    inline uint32_t FDCAN2_FDCAN_GFC_ANFS (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_SIDFC: FDCAN Standard ID Filter Configuration Register
  #define FDCAN2_FDCAN_SIDFC (* ((volatile uint32_t *) (0x4000A400 + 132)))

  // Field FLSSA: Filter List Standard Start Address
    inline uint32_t FDCAN2_FDCAN_SIDFC_FLSSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field LSS: List Size Standard
    inline uint32_t FDCAN2_FDCAN_SIDFC_LSS (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_XIDFC: FDCAN Extended ID Filter Configuration Register
  #define FDCAN2_FDCAN_XIDFC (* ((volatile uint32_t *) (0x4000A400 + 136)))

  // Field FLESA: Filter List Standard Start Address
    inline uint32_t FDCAN2_FDCAN_XIDFC_FLESA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field LSE: List Size Extended
    inline uint32_t FDCAN2_FDCAN_XIDFC_LSE (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_XIDAM: FDCAN Extended ID and Mask Register
  #define FDCAN2_FDCAN_XIDAM (* ((volatile uint32_t *) (0x4000A400 + 144)))

  // Field EIDM: Extended ID Mask
    inline uint32_t FDCAN2_FDCAN_XIDAM_EIDM (const uint32_t inValue) {return (inValue & 0x1FFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_HPMS: FDCAN High Priority Message Status Register
  #define FDCAN2_FDCAN_HPMS (* ((const volatile uint32_t *) (0x4000A400 + 148)))

  // Field BIDX: Buffer Index
    inline uint32_t FDCAN2_FDCAN_HPMS_BIDX (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field MSI: Message Storage Indicator
    inline uint32_t FDCAN2_FDCAN_HPMS_MSI (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field FIDX: Filter Index
    inline uint32_t FDCAN2_FDCAN_HPMS_FIDX (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FLST: Filter List
    const uint32_t FDCAN2_FDCAN_HPMS_FLST = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_NDAT1: FDCAN New Data 1 Register
  #define FDCAN2_FDCAN_NDAT1 (* ((const volatile uint32_t *) (0x4000A400 + 152)))

  // Field ND0: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND0 = 1U << 0 ;

  // Field ND1: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND1 = 1U << 1 ;

  // Field ND2: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND2 = 1U << 2 ;

  // Field ND3: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND3 = 1U << 3 ;

  // Field ND4: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND4 = 1U << 4 ;

  // Field ND5: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND5 = 1U << 5 ;

  // Field ND6: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND6 = 1U << 6 ;

  // Field ND7: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND7 = 1U << 7 ;

  // Field ND8: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND8 = 1U << 8 ;

  // Field ND9: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND9 = 1U << 9 ;

  // Field ND10: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND10 = 1U << 10 ;

  // Field ND11: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND11 = 1U << 11 ;

  // Field ND12: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND12 = 1U << 12 ;

  // Field ND13: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND13 = 1U << 13 ;

  // Field ND14: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND14 = 1U << 14 ;

  // Field ND15: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND15 = 1U << 15 ;

  // Field ND16: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND16 = 1U << 16 ;

  // Field ND17: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND17 = 1U << 17 ;

  // Field ND18: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND18 = 1U << 18 ;

  // Field ND19: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND19 = 1U << 19 ;

  // Field ND20: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND20 = 1U << 20 ;

  // Field ND21: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND21 = 1U << 21 ;

  // Field ND22: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND22 = 1U << 22 ;

  // Field ND23: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND23 = 1U << 23 ;

  // Field ND24: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND24 = 1U << 24 ;

  // Field ND25: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND25 = 1U << 25 ;

  // Field ND26: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND26 = 1U << 26 ;

  // Field ND27: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND27 = 1U << 27 ;

  // Field ND28: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND28 = 1U << 28 ;

  // Field ND29: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND29 = 1U << 29 ;

  // Field ND30: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND30 = 1U << 30 ;

  // Field ND31: New data
    const uint32_t FDCAN2_FDCAN_NDAT1_ND31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_NDAT2: FDCAN New Data 2 Register
  #define FDCAN2_FDCAN_NDAT2 (* ((const volatile uint32_t *) (0x4000A400 + 156)))

  // Field ND32: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND32 = 1U << 0 ;

  // Field ND33: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND33 = 1U << 1 ;

  // Field ND34: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND34 = 1U << 2 ;

  // Field ND35: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND35 = 1U << 3 ;

  // Field ND36: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND36 = 1U << 4 ;

  // Field ND37: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND37 = 1U << 5 ;

  // Field ND38: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND38 = 1U << 6 ;

  // Field ND39: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND39 = 1U << 7 ;

  // Field ND40: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND40 = 1U << 8 ;

  // Field ND41: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND41 = 1U << 9 ;

  // Field ND42: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND42 = 1U << 10 ;

  // Field ND43: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND43 = 1U << 11 ;

  // Field ND44: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND44 = 1U << 12 ;

  // Field ND45: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND45 = 1U << 13 ;

  // Field ND46: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND46 = 1U << 14 ;

  // Field ND47: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND47 = 1U << 15 ;

  // Field ND48: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND48 = 1U << 16 ;

  // Field ND49: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND49 = 1U << 17 ;

  // Field ND50: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND50 = 1U << 18 ;

  // Field ND51: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND51 = 1U << 19 ;

  // Field ND52: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND52 = 1U << 20 ;

  // Field ND53: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND53 = 1U << 21 ;

  // Field ND54: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND54 = 1U << 22 ;

  // Field ND55: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND55 = 1U << 23 ;

  // Field ND56: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND56 = 1U << 24 ;

  // Field ND57: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND57 = 1U << 25 ;

  // Field ND58: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND58 = 1U << 26 ;

  // Field ND59: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND59 = 1U << 27 ;

  // Field ND60: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND60 = 1U << 28 ;

  // Field ND61: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND61 = 1U << 29 ;

  // Field ND62: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND62 = 1U << 30 ;

  // Field ND63: New data
    const uint32_t FDCAN2_FDCAN_NDAT2_ND63 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF0C: FDCAN Rx FIFO 0 Configuration Register
  #define FDCAN2_FDCAN_RXF0C (* ((volatile uint32_t *) (0x4000A400 + 160)))

  // Field F0SA: Rx FIFO 0 Start Address
    inline uint32_t FDCAN2_FDCAN_RXF0C_F0SA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field F0S: Rx FIFO 0 Size
    inline uint32_t FDCAN2_FDCAN_RXF0C_F0S (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field F0WM: FIFO 0 Watermark
    inline uint32_t FDCAN2_FDCAN_RXF0C_F0WM (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF0S: FDCAN Rx FIFO 0 Status Register
  #define FDCAN2_FDCAN_RXF0S (* ((volatile uint32_t *) (0x4000A400 + 164)))

  // Field F0FL: Rx FIFO 0 Fill Level
    inline uint32_t FDCAN2_FDCAN_RXF0S_F0FL (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field F0G: Rx FIFO 0 Get Index
    inline uint32_t FDCAN2_FDCAN_RXF0S_F0G (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

  // Field F0P: Rx FIFO 0 Put Index
    inline uint32_t FDCAN2_FDCAN_RXF0S_F0P (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field F0F: Rx FIFO 0 Full
    const uint32_t FDCAN2_FDCAN_RXF0S_F0F = 1U << 24 ;

  // Field RF0L: Rx FIFO 0 Message Lost
    const uint32_t FDCAN2_FDCAN_RXF0S_RF0L = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF0A: CAN Rx FIFO 0 Acknowledge Register
  #define FDCAN2_FDCAN_RXF0A (* ((volatile uint32_t *) (0x4000A400 + 168)))

  // Field FA01: Rx FIFO 0 Acknowledge Index
    inline uint32_t FDCAN2_FDCAN_RXF0A_FA01 (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXBC: FDCAN Rx Buffer Configuration Register
  #define FDCAN2_FDCAN_RXBC (* ((volatile uint32_t *) (0x4000A400 + 172)))

  // Field RBSA: Rx Buffer Start Address
    inline uint32_t FDCAN2_FDCAN_RXBC_RBSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF1C: FDCAN Rx FIFO 1 Configuration Register
  #define FDCAN2_FDCAN_RXF1C (* ((volatile uint32_t *) (0x4000A400 + 176)))

  // Field F1SA: Rx FIFO 1 Start Address
    inline uint32_t FDCAN2_FDCAN_RXF1C_F1SA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field F1S: Rx FIFO 1 Size
    inline uint32_t FDCAN2_FDCAN_RXF1C_F1S (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field F1WM: Rx FIFO 1 Watermark
    inline uint32_t FDCAN2_FDCAN_RXF1C_F1WM (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF1S: FDCAN Rx FIFO 1 Status Register
  #define FDCAN2_FDCAN_RXF1S (* ((volatile uint32_t *) (0x4000A400 + 180)))

  // Field F1FL: Rx FIFO 1 Fill Level
    inline uint32_t FDCAN2_FDCAN_RXF1S_F1FL (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field F1GI: Rx FIFO 1 Get Index
    inline uint32_t FDCAN2_FDCAN_RXF1S_F1GI (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field F1PI: Rx FIFO 1 Put Index
    inline uint32_t FDCAN2_FDCAN_RXF1S_F1PI (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field F1F: Rx FIFO 1 Full
    const uint32_t FDCAN2_FDCAN_RXF1S_F1F = 1U << 24 ;

  // Field RF1L: Rx FIFO 1 Message Lost
    const uint32_t FDCAN2_FDCAN_RXF1S_RF1L = 1U << 25 ;

  // Field DMS: Debug Message Status
    inline uint32_t FDCAN2_FDCAN_RXF1S_DMS (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXF1A: FDCAN Rx FIFO 1 Acknowledge Register
  #define FDCAN2_FDCAN_RXF1A (* ((volatile uint32_t *) (0x4000A400 + 184)))

  // Field F1AI: Rx FIFO 1 Acknowledge Index
    inline uint32_t FDCAN2_FDCAN_RXF1A_F1AI (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_RXESC: FDCAN Rx Buffer Element Size Configuration Register
  #define FDCAN2_FDCAN_RXESC (* ((volatile uint32_t *) (0x4000A400 + 188)))

  // Field F0DS: Rx FIFO 1 Data Field Size:
    inline uint32_t FDCAN2_FDCAN_RXESC_F0DS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field F1DS: Rx FIFO 0 Data Field Size:
    inline uint32_t FDCAN2_FDCAN_RXESC_F1DS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field RBDS: Rx Buffer Data Field Size:
    inline uint32_t FDCAN2_FDCAN_RXESC_RBDS (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBC: FDCAN Tx Buffer Configuration Register
  #define FDCAN2_FDCAN_TXBC (* ((volatile uint32_t *) (0x4000A400 + 192)))

  // Field TBSA: Tx Buffers Start Address
    inline uint32_t FDCAN2_FDCAN_TXBC_TBSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field NDTB: Number of Dedicated Transmit Buffers
    inline uint32_t FDCAN2_FDCAN_TXBC_NDTB (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field TFQS: Transmit FIFO/Queue Size
    inline uint32_t FDCAN2_FDCAN_TXBC_TFQS (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

  // Field TFQM: Tx FIFO/Queue Mode
    const uint32_t FDCAN2_FDCAN_TXBC_TFQM = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TXFQS: FDCAN Tx FIFO/Queue Status Register
  #define FDCAN2_FDCAN_TXFQS (* ((const volatile uint32_t *) (0x4000A400 + 196)))

  // Field TFFL: Tx FIFO Free Level
    inline uint32_t FDCAN2_FDCAN_TXFQS_TFFL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field TFGI: TFGI
    inline uint32_t FDCAN2_FDCAN_TXFQS_TFGI (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field TFQPI: Tx FIFO/Queue Put Index
    inline uint32_t FDCAN2_FDCAN_TXFQS_TFQPI (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TFQF: Tx FIFO/Queue Full
    const uint32_t FDCAN2_FDCAN_TXFQS_TFQF = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TXESC: FDCAN Tx Buffer Element Size Configuration Register
  #define FDCAN2_FDCAN_TXESC (* ((volatile uint32_t *) (0x4000A400 + 200)))

  // Field TBDS: Tx Buffer Data Field Size:
    inline uint32_t FDCAN2_FDCAN_TXESC_TBDS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBRP: FDCAN Tx Buffer Request Pending Register
  #define FDCAN2_FDCAN_TXBRP (* ((const volatile uint32_t *) (0x4000A400 + 204)))

  // Field TRP: Transmission Request Pending
    inline uint32_t FDCAN2_FDCAN_TXBRP_TRP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBAR: FDCAN Tx Buffer Add Request Register
  #define FDCAN2_FDCAN_TXBAR (* ((volatile uint32_t *) (0x4000A400 + 208)))

  // Field AR: Add Request
    inline uint32_t FDCAN2_FDCAN_TXBAR_AR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBCR: FDCAN Tx Buffer Cancellation Request Register
  #define FDCAN2_FDCAN_TXBCR (* ((volatile uint32_t *) (0x4000A400 + 212)))

  // Field CR: Cancellation Request
    inline uint32_t FDCAN2_FDCAN_TXBCR_CR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBTO: FDCAN Tx Buffer Transmission Occurred Register
  #define FDCAN2_FDCAN_TXBTO (* ((volatile uint32_t *) (0x4000A400 + 216)))

  // Field TO: Transmission Occurred.
    inline uint32_t FDCAN2_FDCAN_TXBTO_TO (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBCF: FDCAN Tx Buffer Cancellation Finished Register
  #define FDCAN2_FDCAN_TXBCF (* ((const volatile uint32_t *) (0x4000A400 + 220)))

  // Field CF: Cancellation Finished
    inline uint32_t FDCAN2_FDCAN_TXBCF_CF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBTIE: FDCAN Tx Buffer Transmission Interrupt Enable Register
  #define FDCAN2_FDCAN_TXBTIE (* ((volatile uint32_t *) (0x4000A400 + 224)))

  // Field TIE: Transmission Interrupt Enable
    inline uint32_t FDCAN2_FDCAN_TXBTIE_TIE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXBCIE: FDCAN Tx Buffer Cancellation Finished Interrupt Enable Register
  #define FDCAN2_FDCAN_TXBCIE (* ((volatile uint32_t *) (0x4000A400 + 228)))

  // Field CF: Cancellation Finished Interrupt Enable
    inline uint32_t FDCAN2_FDCAN_TXBCIE_CF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXEFC: FDCAN Tx Event FIFO Configuration Register
  #define FDCAN2_FDCAN_TXEFC (* ((volatile uint32_t *) (0x4000A400 + 240)))

  // Field EFSA: Event FIFO Start Address
    inline uint32_t FDCAN2_FDCAN_TXEFC_EFSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field EFS: Event FIFO Size
    inline uint32_t FDCAN2_FDCAN_TXEFC_EFS (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

  // Field EFWM: Event FIFO Watermark
    inline uint32_t FDCAN2_FDCAN_TXEFC_EFWM (const uint32_t inValue) {return (inValue & 0x3FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TXEFS: FDCAN Tx Event FIFO Status Register
  #define FDCAN2_FDCAN_TXEFS (* ((volatile uint32_t *) (0x4000A400 + 244)))

  // Field EFFL: Event FIFO Fill Level
    inline uint32_t FDCAN2_FDCAN_TXEFS_EFFL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field EFGI: Event FIFO Get Index.
    inline uint32_t FDCAN2_FDCAN_TXEFS_EFGI (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field EFF: Event FIFO Full.
    const uint32_t FDCAN2_FDCAN_TXEFS_EFF = 1U << 24 ;

  // Field TEFL: Tx Event FIFO Element Lost.
    const uint32_t FDCAN2_FDCAN_TXEFS_TEFL = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TXEFA: FDCAN Tx Event FIFO Acknowledge Register
  #define FDCAN2_FDCAN_TXEFA (* ((volatile uint32_t *) (0x4000A400 + 248)))

  // Field EFAI: Event FIFO Acknowledge Index
    inline uint32_t FDCAN2_FDCAN_TXEFA_EFAI (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTTMC: FDCAN TT Trigger Memory Configuration Register
  #define FDCAN2_FDCAN_TTTMC (* ((volatile uint32_t *) (0x4000A400 + 256)))

  // Field TMSA: Trigger Memory Start Address
    inline uint32_t FDCAN2_FDCAN_TTTMC_TMSA (const uint32_t inValue) {return (inValue & 0x3FFFU) << 2 ; }

  // Field TME: Trigger Memory Elements
    inline uint32_t FDCAN2_FDCAN_TTTMC_TME (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTRMC: FDCAN TT Reference Message Configuration Register
  #define FDCAN2_FDCAN_TTRMC (* ((volatile uint32_t *) (0x4000A400 + 260)))

  // Field RID: Reference Identifier.
    inline uint32_t FDCAN2_FDCAN_TTRMC_RID (const uint32_t inValue) {return (inValue & 0x1FFFFFFFU) << 0 ; }

  // Field XTD: Extended Identifier
    const uint32_t FDCAN2_FDCAN_TTRMC_XTD = 1U << 30 ;

  // Field RMPS: Reference Message Payload Select
    const uint32_t FDCAN2_FDCAN_TTRMC_RMPS = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTOCF: FDCAN TT Operation Configuration Register
  #define FDCAN2_FDCAN_TTOCF (* ((volatile uint32_t *) (0x4000A400 + 264)))

  // Field OM: Operation Mode
    inline uint32_t FDCAN2_FDCAN_TTOCF_OM (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field GEN: Gap Enable
    const uint32_t FDCAN2_FDCAN_TTOCF_GEN = 1U << 3 ;

  // Field TM: Time Master
    const uint32_t FDCAN2_FDCAN_TTOCF_TM = 1U << 4 ;

  // Field LDSDL: LD of Synchronization Deviation Limit
    inline uint32_t FDCAN2_FDCAN_TTOCF_LDSDL (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field IRTO: Initial Reference Trigger Offset
    inline uint32_t FDCAN2_FDCAN_TTOCF_IRTO (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field EECS: Enable External Clock Synchronization
    const uint32_t FDCAN2_FDCAN_TTOCF_EECS = 1U << 15 ;

  // Field AWL: Application Watchdog Limit
    inline uint32_t FDCAN2_FDCAN_TTOCF_AWL (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field EGTF: Enable Global Time Filtering
    const uint32_t FDCAN2_FDCAN_TTOCF_EGTF = 1U << 24 ;

  // Field ECC: Enable Clock Calibration
    const uint32_t FDCAN2_FDCAN_TTOCF_ECC = 1U << 25 ;

  // Field EVTP: Event Trigger Polarity
    const uint32_t FDCAN2_FDCAN_TTOCF_EVTP = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTMLM: FDCAN TT Matrix Limits Register
  #define FDCAN2_FDCAN_TTMLM (* ((volatile uint32_t *) (0x4000A400 + 268)))

  // Field CCM: Cycle Count Max
    inline uint32_t FDCAN2_FDCAN_TTMLM_CCM (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field CSS: Cycle Start Synchronization
    inline uint32_t FDCAN2_FDCAN_TTMLM_CSS (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field TXEW: Tx Enable Window
    inline uint32_t FDCAN2_FDCAN_TTMLM_TXEW (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ENTT: Expected Number of Tx Triggers
    inline uint32_t FDCAN2_FDCAN_TTMLM_ENTT (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TURCF: FDCAN TUR Configuration Register
  #define FDCAN2_FDCAN_TURCF (* ((volatile uint32_t *) (0x4000A400 + 272)))

  // Field NCL: Numerator Configuration Low.
    inline uint32_t FDCAN2_FDCAN_TURCF_NCL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DC: Denominator Configuration.
    inline uint32_t FDCAN2_FDCAN_TURCF_DC (const uint32_t inValue) {return (inValue & 0x3FFFU) << 16 ; }

  // Field ELT: Enable Local Time
    const uint32_t FDCAN2_FDCAN_TURCF_ELT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTOCN: FDCAN TT Operation Control Register
  #define FDCAN2_FDCAN_TTOCN (* ((volatile uint32_t *) (0x4000A400 + 276)))

  // Field SGT: Set Global time
    const uint32_t FDCAN2_FDCAN_TTOCN_SGT = 1U << 0 ;

  // Field ECS: External Clock Synchronization
    const uint32_t FDCAN2_FDCAN_TTOCN_ECS = 1U << 1 ;

  // Field SWP: Stop Watch Polarity
    const uint32_t FDCAN2_FDCAN_TTOCN_SWP = 1U << 2 ;

  // Field SWS: Stop Watch Source.
    inline uint32_t FDCAN2_FDCAN_TTOCN_SWS (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field RTIE: Register Time Mark Interrupt Pulse Enable
    const uint32_t FDCAN2_FDCAN_TTOCN_RTIE = 1U << 5 ;

  // Field TMC: Register Time Mark Compare
    inline uint32_t FDCAN2_FDCAN_TTOCN_TMC (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field TTIE: Trigger Time Mark Interrupt Pulse Enable
    const uint32_t FDCAN2_FDCAN_TTOCN_TTIE = 1U << 8 ;

  // Field GCS: Gap Control Select
    const uint32_t FDCAN2_FDCAN_TTOCN_GCS = 1U << 9 ;

  // Field FGP: Finish Gap.
    const uint32_t FDCAN2_FDCAN_TTOCN_FGP = 1U << 10 ;

  // Field TMG: Time Mark Gap
    const uint32_t FDCAN2_FDCAN_TTOCN_TMG = 1U << 11 ;

  // Field NIG: Next is Gap
    const uint32_t FDCAN2_FDCAN_TTOCN_NIG = 1U << 12 ;

  // Field ESCN: External Synchronization Control
    const uint32_t FDCAN2_FDCAN_TTOCN_ESCN = 1U << 13 ;

  // Field LCKC: TT Operation Control Register Locked
    const uint32_t FDCAN2_FDCAN_TTOCN_LCKC = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register CAN_TTGTP: FDCAN TT Global Time Preset Register
  #define FDCAN2_CAN_TTGTP (* ((volatile uint32_t *) (0x4000A400 + 280)))

  // Field NCL: Time Preset
    inline uint32_t FDCAN2_CAN_TTGTP_NCL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CTP: Cycle Time Target Phase
    inline uint32_t FDCAN2_CAN_TTGTP_CTP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTTMK: FDCAN TT Time Mark Register
  #define FDCAN2_FDCAN_TTTMK (* ((volatile uint32_t *) (0x4000A400 + 284)))

  // Field TM: Time Mark
    inline uint32_t FDCAN2_FDCAN_TTTMK_TM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field TICC: Time Mark Cycle Code
    inline uint32_t FDCAN2_FDCAN_TTTMK_TICC (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field LCKM: TT Time Mark Register Locked
    const uint32_t FDCAN2_FDCAN_TTTMK_LCKM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTIR: FDCAN TT Interrupt Register
  #define FDCAN2_FDCAN_TTIR (* ((volatile uint32_t *) (0x4000A400 + 288)))

  // Field SBC: Start of Basic Cycle
    const uint32_t FDCAN2_FDCAN_TTIR_SBC = 1U << 0 ;

  // Field SMC: Start of Matrix Cycle
    const uint32_t FDCAN2_FDCAN_TTIR_SMC = 1U << 1 ;

  // Field CSM: Change of Synchronization Mode
    const uint32_t FDCAN2_FDCAN_TTIR_CSM = 1U << 2 ;

  // Field SOG: Start of Gap
    const uint32_t FDCAN2_FDCAN_TTIR_SOG = 1U << 3 ;

  // Field RTMI: Register Time Mark Interrupt.
    const uint32_t FDCAN2_FDCAN_TTIR_RTMI = 1U << 4 ;

  // Field TTMI: Trigger Time Mark Event Internal
    const uint32_t FDCAN2_FDCAN_TTIR_TTMI = 1U << 5 ;

  // Field SWE: Stop Watch Event
    const uint32_t FDCAN2_FDCAN_TTIR_SWE = 1U << 6 ;

  // Field GTW: Global Time Wrap
    const uint32_t FDCAN2_FDCAN_TTIR_GTW = 1U << 7 ;

  // Field GTD: Global Time Discontinuity
    const uint32_t FDCAN2_FDCAN_TTIR_GTD = 1U << 8 ;

  // Field GTE: Global Time Error
    const uint32_t FDCAN2_FDCAN_TTIR_GTE = 1U << 9 ;

  // Field TXU: Tx Count Underflow
    const uint32_t FDCAN2_FDCAN_TTIR_TXU = 1U << 10 ;

  // Field TXO: Tx Count Overflow
    const uint32_t FDCAN2_FDCAN_TTIR_TXO = 1U << 11 ;

  // Field SE1: Scheduling Error 1
    const uint32_t FDCAN2_FDCAN_TTIR_SE1 = 1U << 12 ;

  // Field SE2: Scheduling Error 2
    const uint32_t FDCAN2_FDCAN_TTIR_SE2 = 1U << 13 ;

  // Field ELC: Error Level Changed.
    const uint32_t FDCAN2_FDCAN_TTIR_ELC = 1U << 14 ;

  // Field IWTG: Initialization Watch Trigger
    const uint32_t FDCAN2_FDCAN_TTIR_IWTG = 1U << 15 ;

  // Field WT: Watch Trigger
    const uint32_t FDCAN2_FDCAN_TTIR_WT = 1U << 16 ;

  // Field AW: Application Watchdog
    const uint32_t FDCAN2_FDCAN_TTIR_AW = 1U << 17 ;

  // Field CER: Configuration Error
    const uint32_t FDCAN2_FDCAN_TTIR_CER = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTIE: FDCAN TT Interrupt Enable Register
  #define FDCAN2_FDCAN_TTIE (* ((volatile uint32_t *) (0x4000A400 + 292)))

  // Field SBCE: Start of Basic Cycle Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_SBCE = 1U << 0 ;

  // Field SMCE: Start of Matrix Cycle Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_SMCE = 1U << 1 ;

  // Field CSME: Change of Synchronization Mode Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_CSME = 1U << 2 ;

  // Field SOGE: Start of Gap Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_SOGE = 1U << 3 ;

  // Field RTMIE: Register Time Mark Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_RTMIE = 1U << 4 ;

  // Field TTMIE: Trigger Time Mark Event Internal Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_TTMIE = 1U << 5 ;

  // Field SWEE: Stop Watch Event Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_SWEE = 1U << 6 ;

  // Field GTWE: Global Time Wrap Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_GTWE = 1U << 7 ;

  // Field GTDE: Global Time Discontinuity Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_GTDE = 1U << 8 ;

  // Field GTEE: Global Time Error Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_GTEE = 1U << 9 ;

  // Field TXUE: Tx Count Underflow Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_TXUE = 1U << 10 ;

  // Field TXOE: Tx Count Overflow Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_TXOE = 1U << 11 ;

  // Field SE1E: Scheduling Error 1 Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_SE1E = 1U << 12 ;

  // Field SE2E: Scheduling Error 2 Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_SE2E = 1U << 13 ;

  // Field ELCE: Change Error Level Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_ELCE = 1U << 14 ;

  // Field IWTGE: Initialization Watch Trigger Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_IWTGE = 1U << 15 ;

  // Field WTE: Watch Trigger Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_WTE = 1U << 16 ;

  // Field AWE: Application Watchdog Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_AWE = 1U << 17 ;

  // Field CERE: Configuration Error Interrupt Enable
    const uint32_t FDCAN2_FDCAN_TTIE_CERE = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTILS: FDCAN TT Interrupt Line Select Register
  #define FDCAN2_FDCAN_TTILS (* ((volatile uint32_t *) (0x4000A400 + 296)))

  // Field SBCL: Start of Basic Cycle Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_SBCL = 1U << 0 ;

  // Field SMCL: Start of Matrix Cycle Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_SMCL = 1U << 1 ;

  // Field CSML: Change of Synchronization Mode Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_CSML = 1U << 2 ;

  // Field SOGL: Start of Gap Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_SOGL = 1U << 3 ;

  // Field RTMIL: Register Time Mark Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_RTMIL = 1U << 4 ;

  // Field TTMIL: Trigger Time Mark Event Internal Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_TTMIL = 1U << 5 ;

  // Field SWEL: Stop Watch Event Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_SWEL = 1U << 6 ;

  // Field GTWL: Global Time Wrap Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_GTWL = 1U << 7 ;

  // Field GTDL: Global Time Discontinuity Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_GTDL = 1U << 8 ;

  // Field GTEL: Global Time Error Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_GTEL = 1U << 9 ;

  // Field TXUL: Tx Count Underflow Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_TXUL = 1U << 10 ;

  // Field TXOL: Tx Count Overflow Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_TXOL = 1U << 11 ;

  // Field SE1L: Scheduling Error 1 Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_SE1L = 1U << 12 ;

  // Field SE2L: Scheduling Error 2 Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_SE2L = 1U << 13 ;

  // Field ELCL: Change Error Level Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_ELCL = 1U << 14 ;

  // Field IWTGL: Initialization Watch Trigger Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_IWTGL = 1U << 15 ;

  // Field WTL: Watch Trigger Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_WTL = 1U << 16 ;

  // Field AWL: Application Watchdog Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_AWL = 1U << 17 ;

  // Field CERL: Configuration Error Interrupt Line
    const uint32_t FDCAN2_FDCAN_TTILS_CERL = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TTOST: FDCAN TT Operation Status Register
  #define FDCAN2_FDCAN_TTOST (* ((volatile uint32_t *) (0x4000A400 + 300)))

  // Field EL: Error Level
    inline uint32_t FDCAN2_FDCAN_TTOST_EL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MS: Master State.
    inline uint32_t FDCAN2_FDCAN_TTOST_MS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SYS: Synchronization State
    inline uint32_t FDCAN2_FDCAN_TTOST_SYS (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field GTP: Quality of Global Time Phase
    const uint32_t FDCAN2_FDCAN_TTOST_GTP = 1U << 6 ;

  // Field QCS: Quality of Clock Speed
    const uint32_t FDCAN2_FDCAN_TTOST_QCS = 1U << 7 ;

  // Field RTO: Reference Trigger Offset
    inline uint32_t FDCAN2_FDCAN_TTOST_RTO (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field WGTD: Wait for Global Time Discontinuity
    const uint32_t FDCAN2_FDCAN_TTOST_WGTD = 1U << 22 ;

  // Field GFI: Gap Finished Indicator.
    const uint32_t FDCAN2_FDCAN_TTOST_GFI = 1U << 23 ;

  // Field TMP: Time Master Priority
    inline uint32_t FDCAN2_FDCAN_TTOST_TMP (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field GSI: Gap Started Indicator.
    const uint32_t FDCAN2_FDCAN_TTOST_GSI = 1U << 27 ;

  // Field WFE: Wait for Event
    const uint32_t FDCAN2_FDCAN_TTOST_WFE = 1U << 28 ;

  // Field AWE: Application Watchdog Event
    const uint32_t FDCAN2_FDCAN_TTOST_AWE = 1U << 29 ;

  // Field WECS: Wait for External Clock Synchronization
    const uint32_t FDCAN2_FDCAN_TTOST_WECS = 1U << 30 ;

  // Field SPL: Schedule Phase Lock
    const uint32_t FDCAN2_FDCAN_TTOST_SPL = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FDCAN_TURNA: FDCAN TUR Numerator Actual Register
  #define FDCAN2_FDCAN_TURNA (* ((const volatile uint32_t *) (0x4000A400 + 304)))

  // Field NAV: Numerator Actual Value
    inline uint32_t FDCAN2_FDCAN_TURNA_NAV (const uint32_t inValue) {return (inValue & 0x3FFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTLGT: FDCAN TT Local and Global Time Register
  #define FDCAN2_FDCAN_TTLGT (* ((const volatile uint32_t *) (0x4000A400 + 308)))

  // Field LT: Local Time
    inline uint32_t FDCAN2_FDCAN_TTLGT_LT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field GT: Global Time
    inline uint32_t FDCAN2_FDCAN_TTLGT_GT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTCTC: FDCAN TT Cycle Time and Count Register
  #define FDCAN2_FDCAN_TTCTC (* ((const volatile uint32_t *) (0x4000A400 + 312)))

  // Field CT: Cycle Time
    inline uint32_t FDCAN2_FDCAN_TTCTC_CT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CC: Cycle Count
    inline uint32_t FDCAN2_FDCAN_TTCTC_CC (const uint32_t inValue) {return (inValue & 0x3FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTCPT: FDCAN TT Capture Time Register
  #define FDCAN2_FDCAN_TTCPT (* ((const volatile uint32_t *) (0x4000A400 + 316)))

  // Field CT: Cycle Count Value
    inline uint32_t FDCAN2_FDCAN_TTCPT_CT (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SWV: Stop Watch Value
    inline uint32_t FDCAN2_FDCAN_TTCPT_SWV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTCSM: FDCAN TT Cycle Sync Mark Register
  #define FDCAN2_FDCAN_TTCSM (* ((const volatile uint32_t *) (0x4000A400 + 320)))

  // Field CSM: Cycle Sync Mark
    inline uint32_t FDCAN2_FDCAN_TTCSM_CSM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FDCAN_TTTS: FDCAN TT Trigger Select Register
  #define FDCAN2_FDCAN_TTTS (* ((volatile uint32_t *) (0x4000A400 + 768)))

  // Field SWTDEL: Stop watch trigger input selection
    inline uint32_t FDCAN2_FDCAN_TTTS_SWTDEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field EVTSEL: Event trigger input selection
    inline uint32_t FDCAN2_FDCAN_TTTS_EVTSEL (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------
// Peripheral FMC: FMC
//------------------------------------------------------------------------------

//---  Register BCR1: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
  #define FMC_BCR1 (* ((volatile uint32_t *) (0x52004000 + 0)))

  // Field MBKEN: Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    const uint32_t FMC_BCR1_MBKEN = 1U << 0 ;

  // Field MUXEN: Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    const uint32_t FMC_BCR1_MUXEN = 1U << 1 ;

  // Field MTYP: Memory type These bits define the type of external memory attached to the corresponding memory bank:
    inline uint32_t FMC_BCR1_MTYP (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MWID: Memory data bus width Defines the external memory device width, valid for all type of memories.
    inline uint32_t FMC_BCR1_MWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field FACCEN: Flash access enable This bit enables NOR Flash memory access operations.
    const uint32_t FMC_BCR1_FACCEN = 1U << 6 ;

  // Field BURSTEN: Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    const uint32_t FMC_BCR1_BURSTEN = 1U << 8 ;

  // Field WAITPOL: Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    const uint32_t FMC_BCR1_WAITPOL = 1U << 9 ;

  // Field WAITCFG: Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    const uint32_t FMC_BCR1_WAITCFG = 1U << 11 ;

  // Field WREN: Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    const uint32_t FMC_BCR1_WREN = 1U << 12 ;

  // Field WAITEN: Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    const uint32_t FMC_BCR1_WAITEN = 1U << 13 ;

  // Field EXTMOD: Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    const uint32_t FMC_BCR1_EXTMOD = 1U << 14 ;

  // Field ASYNCWAIT: Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    const uint32_t FMC_BCR1_ASYNCWAIT = 1U << 15 ;

  // Field CPSIZE: CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
    inline uint32_t FMC_BCR1_CPSIZE (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field CBURSTRW: Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    const uint32_t FMC_BCR1_CBURSTRW = 1U << 19 ;

  // Field CCLKEN: Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    const uint32_t FMC_BCR1_CCLKEN = 1U << 20 ;

  // Field WFDIS: Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR1_WFDIS = 1U << 21 ;

  // Field BMAP: FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
    inline uint32_t FMC_BCR1_BMAP (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field FMCEN: FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR1_FMCEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register BTR1: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
  #define FMC_BTR1 (* ((volatile uint32_t *) (0x52004000 + 4)))

  // Field ADDSET: Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
    inline uint32_t FMC_BTR1_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
    inline uint32_t FMC_BTR1_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
    inline uint32_t FMC_BTR1_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 126. ...
    inline uint32_t FMC_BTR1_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field CLKDIV: Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
    inline uint32_t FMC_BTR1_CLKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field DATLAT: Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
    inline uint32_t FMC_BTR1_DATLAT (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field ACCMOD: Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BTR1_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register BCR2: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
  #define FMC_BCR2 (* ((volatile uint32_t *) (0x52004000 + 8)))

  // Field MBKEN: Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    const uint32_t FMC_BCR2_MBKEN = 1U << 0 ;

  // Field MUXEN: Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    const uint32_t FMC_BCR2_MUXEN = 1U << 1 ;

  // Field MTYP: Memory type These bits define the type of external memory attached to the corresponding memory bank:
    inline uint32_t FMC_BCR2_MTYP (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MWID: Memory data bus width Defines the external memory device width, valid for all type of memories.
    inline uint32_t FMC_BCR2_MWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field FACCEN: Flash access enable This bit enables NOR Flash memory access operations.
    const uint32_t FMC_BCR2_FACCEN = 1U << 6 ;

  // Field BURSTEN: Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    const uint32_t FMC_BCR2_BURSTEN = 1U << 8 ;

  // Field WAITPOL: Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    const uint32_t FMC_BCR2_WAITPOL = 1U << 9 ;

  // Field WAITCFG: Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    const uint32_t FMC_BCR2_WAITCFG = 1U << 11 ;

  // Field WREN: Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    const uint32_t FMC_BCR2_WREN = 1U << 12 ;

  // Field WAITEN: Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    const uint32_t FMC_BCR2_WAITEN = 1U << 13 ;

  // Field EXTMOD: Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    const uint32_t FMC_BCR2_EXTMOD = 1U << 14 ;

  // Field ASYNCWAIT: Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    const uint32_t FMC_BCR2_ASYNCWAIT = 1U << 15 ;

  // Field CPSIZE: CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
    inline uint32_t FMC_BCR2_CPSIZE (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field CBURSTRW: Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    const uint32_t FMC_BCR2_CBURSTRW = 1U << 19 ;

  // Field CCLKEN: Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    const uint32_t FMC_BCR2_CCLKEN = 1U << 20 ;

  // Field WFDIS: Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR2_WFDIS = 1U << 21 ;

  // Field BMAP: FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
    inline uint32_t FMC_BCR2_BMAP (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field FMCEN: FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR2_FMCEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register BTR2: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
  #define FMC_BTR2 (* ((volatile uint32_t *) (0x52004000 + 12)))

  // Field ADDSET: Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
    inline uint32_t FMC_BTR2_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
    inline uint32_t FMC_BTR2_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
    inline uint32_t FMC_BTR2_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD = 1. ...
    inline uint32_t FMC_BTR2_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field CLKDIV: Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
    inline uint32_t FMC_BTR2_CLKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field DATLAT: Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
    inline uint32_t FMC_BTR2_DATLAT (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field ACCMOD: Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BTR2_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register BCR3: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
  #define FMC_BCR3 (* ((volatile uint32_t *) (0x52004000 + 16)))

  // Field MBKEN: Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    const uint32_t FMC_BCR3_MBKEN = 1U << 0 ;

  // Field MUXEN: Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    const uint32_t FMC_BCR3_MUXEN = 1U << 1 ;

  // Field MTYP: Memory type These bits define the type of external memory attached to the corresponding memory bank:
    inline uint32_t FMC_BCR3_MTYP (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MWID: Memory data bus width Defines the external memory device width, valid for all type of memories.
    inline uint32_t FMC_BCR3_MWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field FACCEN: Flash access enable This bit enables NOR Flash memory access operations.
    const uint32_t FMC_BCR3_FACCEN = 1U << 6 ;

  // Field BURSTEN: Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    const uint32_t FMC_BCR3_BURSTEN = 1U << 8 ;

  // Field WAITPOL: Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    const uint32_t FMC_BCR3_WAITPOL = 1U << 9 ;

  // Field WAITCFG: Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    const uint32_t FMC_BCR3_WAITCFG = 1U << 11 ;

  // Field WREN: Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    const uint32_t FMC_BCR3_WREN = 1U << 12 ;

  // Field WAITEN: Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    const uint32_t FMC_BCR3_WAITEN = 1U << 13 ;

  // Field EXTMOD: Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    const uint32_t FMC_BCR3_EXTMOD = 1U << 14 ;

  // Field ASYNCWAIT: Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    const uint32_t FMC_BCR3_ASYNCWAIT = 1U << 15 ;

  // Field CPSIZE: CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
    inline uint32_t FMC_BCR3_CPSIZE (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field CBURSTRW: Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    const uint32_t FMC_BCR3_CBURSTRW = 1U << 19 ;

  // Field CCLKEN: Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    const uint32_t FMC_BCR3_CCLKEN = 1U << 20 ;

  // Field WFDIS: Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR3_WFDIS = 1U << 21 ;

  // Field BMAP: FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
    inline uint32_t FMC_BCR3_BMAP (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field FMCEN: FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR3_FMCEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register BTR3: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
  #define FMC_BTR3 (* ((volatile uint32_t *) (0x52004000 + 20)))

  // Field ADDSET: Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
    inline uint32_t FMC_BTR3_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
    inline uint32_t FMC_BTR3_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
    inline uint32_t FMC_BTR3_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
    inline uint32_t FMC_BTR3_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field CLKDIV: Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
    inline uint32_t FMC_BTR3_CLKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field DATLAT: Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
    inline uint32_t FMC_BTR3_DATLAT (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field ACCMOD: Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BTR3_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register BCR4: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.
  #define FMC_BCR4 (* ((volatile uint32_t *) (0x52004000 + 24)))

  // Field MBKEN: Memory bank enable bit This bit enables the memory bank. After reset Bank1 is enabled, all others are disabled. Accessing a disabled bank causes an ERROR on AXI bus.
    const uint32_t FMC_BCR4_MBKEN = 1U << 0 ;

  // Field MUXEN: Address/data multiplexing enable bit When this bit is set, the address and data values are multiplexed on the data bus, valid only with NOR and PSRAM memories:
    const uint32_t FMC_BCR4_MUXEN = 1U << 1 ;

  // Field MTYP: Memory type These bits define the type of external memory attached to the corresponding memory bank:
    inline uint32_t FMC_BCR4_MTYP (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MWID: Memory data bus width Defines the external memory device width, valid for all type of memories.
    inline uint32_t FMC_BCR4_MWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field FACCEN: Flash access enable This bit enables NOR Flash memory access operations.
    const uint32_t FMC_BCR4_FACCEN = 1U << 6 ;

  // Field BURSTEN: Burst enable bit This bit enables/disables synchronous accesses during read operations. It is valid only for synchronous memories operating in Burst mode:
    const uint32_t FMC_BCR4_BURSTEN = 1U << 8 ;

  // Field WAITPOL: Wait signal polarity bit This bit defines the polarity of the wait signal from memory used for either in synchronous or asynchronous mode:
    const uint32_t FMC_BCR4_WAITPOL = 1U << 9 ;

  // Field WAITCFG: Wait timing configuration The NWAIT signal indicates whether the data from the memory are valid or if a wait state must be inserted when accessing the memory in synchronous mode. This configuration bit determines if NWAIT is asserted by the memory one clock cycle before the wait state or during the wait state:
    const uint32_t FMC_BCR4_WAITCFG = 1U << 11 ;

  // Field WREN: Write enable bit This bit indicates whether write operations are enabled/disabled in the bank by the FMC:
    const uint32_t FMC_BCR4_WREN = 1U << 12 ;

  // Field WAITEN: Wait enable bit This bit enables/disables wait-state insertion via the NWAIT signal when accessing the memory in synchronous mode.
    const uint32_t FMC_BCR4_WAITEN = 1U << 13 ;

  // Field EXTMOD: Extended mode enable. This bit enables the FMC to program the write timings for asynchronous accesses inside the FMC_BWTR register, thus resulting in different timings for read and write operations. Note: When the extended mode is disabled, the FMC can operate in Mode1 or Mode2 as follows: ** Mode 1 is the default mode when the SRAM/PSRAM memory type is selected (MTYP =0x0 or 0x01) ** Mode 2 is the default mode when the NOR memory type is selected (MTYP = 0x10).
    const uint32_t FMC_BCR4_EXTMOD = 1U << 14 ;

  // Field ASYNCWAIT: Wait signal during asynchronous transfers This bit enables/disables the FMC to use the wait signal even during an asynchronous protocol.
    const uint32_t FMC_BCR4_ASYNCWAIT = 1U << 15 ;

  // Field CPSIZE: CRAM Page Size These are used for Cellular RAM 1.5 which does not allow burst access to cross the address boundaries between pages. When these bits are configured, the FMC controller splits automatically the burst access when the memory page size is reached (refer to memory datasheet for page size). Other configuration: reserved.
    inline uint32_t FMC_BCR4_CPSIZE (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field CBURSTRW: Write burst enable For PSRAM (CRAM) operating in Burst mode, the bit enables synchronous accesses during write operations. The enable bit for synchronous read accesses is the BURSTEN bit in the FMC_BCRx register.
    const uint32_t FMC_BCR4_CBURSTRW = 1U << 19 ;

  // Field CCLKEN: Continuous Clock Enable This bit enables the FMC_CLK clock output to external memory devices. Note: The CCLKEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register. Bank 1 must be configured in synchronous mode to generate the FMC_CLK continuous clock. If CCLKEN bit is set, the FMC_CLK clock ratio is specified by CLKDIV value in the FMC_BTR1 register. CLKDIV in FMC_BWTR1 is dont care. If the synchronous mode is used and CCLKEN bit is set, the synchronous memories connected to other banks than Bank 1 are clocked by the same clock (the CLKDIV value in the FMC_BTR2..4 and FMC_BWTR2..4 registers for other banks has no effect.)
    const uint32_t FMC_BCR4_CCLKEN = 1U << 20 ;

  // Field WFDIS: Write FIFO Disable This bit disables the Write FIFO used by the FMC controller. Note: The WFDIS bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR4_WFDIS = 1U << 21 ;

  // Field BMAP: FMC bank mapping These bits allows different to remap SDRAM bank2 or swap the FMC NOR/PSRAM and SDRAM banks.Refer to Table 10 for Note: The BMAP bits of the FMC_BCR2..4 registers are dont care. It is only enabled through the FMC_BCR1 register.
    inline uint32_t FMC_BCR4_BMAP (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field FMCEN: FMC controller Enable This bit enables/disables the FMC controller. Note: The FMCEN bit of the FMC_BCR2..4 registers is dont care. It is only enabled through the FMC_BCR1 register.
    const uint32_t FMC_BCR4_FMCEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register BTR4: This register contains the control information of each memory bank, used for SRAMs, PSRAM and NOR Flash memories.If the EXTMOD bit is set in the FMC_BCRx register, then this register is partitioned for write and read access, that is, 2 registers are available: one to configure read accesses (this register) and one to configure write accesses (FMC_BWTRx registers).
  #define FMC_BTR4 (* ((volatile uint32_t *) (0x52004000 + 28)))

  // Field ADDSET: Address setup phase duration These bits are written by software to define the duration of the address setup phase (refer to Figure81 to Figure93), used in SRAMs, ROMs and asynchronous NOR Flash: For each access mode address setup phase duration, please refer to the respective figure (refer to Figure81 to Figure93). Note: In synchronous accesses, this value is dont care. In Muxed mode or Mode D, the minimum value for ADDSET is 1.
    inline uint32_t FMC_BTR4_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in mode D or multiplexed accesses: For each access mode address-hold phase duration, please refer to the respective figure (Figure81 to Figure93). Note: In synchronous accesses, this value is not used, the address hold phase is always 1 memory clock period duration.
    inline uint32_t FMC_BTR4_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous accesses: For each memory type and access mode data-phase duration, please refer to the respective figure (Figure81 to Figure93). Example: Mode1, write access, DATAST=1: Data-phase duration= DATAST+1 = 2 KCK_FMC clock cycles. Note: In synchronous accesses, this value is dont care.
    inline uint32_t FMC_BTR4_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write-to-read or read-to write transaction. The programmed bus turnaround delay is inserted between an asynchronous read (in muxed or mode D) or write transaction and any other asynchronous /synchronous read/write from/to a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except in muxed mode and mode D. There is a bus turnaround delay of 1 FMC clock cycle between: Two consecutive asynchronous read transfers to the same static memory bank except for modes muxed and D. An asynchronous read to an asynchronous or synchronous write to any static bank or dynamic bank except in modes muxed and D mode. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank. A synchronous write (burst or single) access and an asynchronous write or read transfer to or from static memory bank (the bank can be the same or a different one in case of a read operation. Two consecutive synchronous read operations (in Burst or Single mode) followed by any synchronous/asynchronous read or write from/to another static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write access (in Burst or Single mode) and a synchronous read from the same or a different bank. The bus turnaround delay allows to match the minimum time between consecutive transactions (tEHEL from NEx high to NEx low) and the maximum time required by the memory to free the data bus after a read access (tEHQZ): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin and (BUSTRUN + 2)KCK_FMC period &#8805; tEHQZmax if EXTMOD = 0 (BUSTRUN + 2)KCK_FMC period &#8805; max (tEHELmin, tEHQZmax) if EXTMOD =1. ...
    inline uint32_t FMC_BTR4_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field CLKDIV: Clock divide ratio (for FMC_CLK signal) These bits define the period of FMC_CLK clock output signal, expressed in number of KCK_FMC cycles: In asynchronous NOR Flash, SRAM or PSRAM accesses, this value is dont care. Note: Refer to Section20.6.5: Synchronous transactions for FMC_CLK divider ratio formula)
    inline uint32_t FMC_BTR4_CLKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field DATLAT: Data latency for synchronous memory For synchronous access with read write burst mode enabled these bits define the number of memory clock cycles
    inline uint32_t FMC_BTR4_DATLAT (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field ACCMOD: Access mode These bits specify the asynchronous access modes as shown in the timing diagrams. They are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BTR4_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register PCR: NAND Flash control registers
  #define FMC_PCR (* ((volatile uint32_t *) (0x52004000 + 128)))

  // Field PWAITEN: Wait feature enable bit. This bit enables the Wait feature for the NAND Flash memory bank:
    const uint32_t FMC_PCR_PWAITEN = 1U << 1 ;

  // Field PBKEN: NAND Flash memory bank enable bit. This bit enables the memory bank. Accessing a disabled memory bank causes an ERROR on AXI bus
    const uint32_t FMC_PCR_PBKEN = 1U << 2 ;

  // Field PWID: Data bus width. These bits define the external memory device width.
    inline uint32_t FMC_PCR_PWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field ECCEN: ECC computation logic enable bit
    const uint32_t FMC_PCR_ECCEN = 1U << 6 ;

  // Field TCLR: CLE to RE delay. These bits set time from CLE low to RE low in number of KCK_FMC clock cycles. The time is give by the following formula: t_clr = (TCLR + SET + 2) TKCK_FMC where TKCK_FMC is the KCK_FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
    inline uint32_t FMC_PCR_TCLR (const uint32_t inValue) {return (inValue & 0xFU) << 9 ; }

  // Field TAR: ALE to RE delay. These bits set time from ALE low to RE low in number of KCK_FMC clock cycles. Time is: t_ar = (TAR + SET + 2) TKCK_FMC where TKCK_FMC is the FMC clock period Note: Set is MEMSET or ATTSET according to the addressed space.
    inline uint32_t FMC_PCR_TAR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field ECCPS: ECC page size. These bits define the page size for the extended ECC:
    inline uint32_t FMC_PCR_ECCPS (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

//------------------------------------------------------------------------------

//---  Register SR: This register contains information about the FIFO status and interrupt. The FMC features a FIFO that is used when writing to memories to transfer up to 16 words of data.This is used to quickly write to the FIFO and free the AXI bus for transactions to peripherals other than the FMC, while the FMC is draining its FIFO into the memory. One of these register bits indicates the status of the FIFO, for ECC purposes.The ECC is calculated while the data are written to the memory. To read the correct ECC, the software must consequently wait until the FIFO is empty.
  #define FMC_SR (* ((volatile uint32_t *) (0x52004000 + 132)))

  // Field IRS: Interrupt rising edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
    const uint32_t FMC_SR_IRS = 1U << 0 ;

  // Field ILS: Interrupt high-level status The flag is set by hardware and reset by software.
    const uint32_t FMC_SR_ILS = 1U << 1 ;

  // Field IFS: Interrupt falling edge status The flag is set by hardware and reset by software. Note: If this bit is written by software to 1 it will be set.
    const uint32_t FMC_SR_IFS = 1U << 2 ;

  // Field IREN: Interrupt rising edge detection enable bit
    const uint32_t FMC_SR_IREN = 1U << 3 ;

  // Field ILEN: Interrupt high-level detection enable bit
    const uint32_t FMC_SR_ILEN = 1U << 4 ;

  // Field IFEN: Interrupt falling edge detection enable bit
    const uint32_t FMC_SR_IFEN = 1U << 5 ;

  // Field FEMPT: FIFO empty. Read-only bit that provides the status of the FIFO
    const uint32_t FMC_SR_FEMPT = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register PMEM: The FMC_PMEM read/write register contains the timing information for NAND Flash memory bank. This information is used to access either the common memory space of the NAND Flash for command, address write access and data read/write access.
  #define FMC_PMEM (* ((volatile uint32_t *) (0x52004000 + 136)))

  // Field MEMSET: Common memory x setup time These bits define the number of KCK_FMC (+1) clock cycles to set up the address before the command assertion (NWE, NOE), for NAND Flash read or write access to common memory space:
    inline uint32_t FMC_PMEM_MEMSET (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MEMWAIT: Common memory wait time These bits define the minimum number of KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to common memory space. The duration of command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
    inline uint32_t FMC_PMEM_MEMWAIT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field MEMHOLD: Common memory hold time These bits define the number of KCK_FMC clock cycles for write accesses and KCK_FMC+1 clock cycles for read accesses during which the address is held (and data for write accesses) after the command is de-asserted (NWE, NOE), for NAND Flash read or write access to common memory space:
    inline uint32_t FMC_PMEM_MEMHOLD (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field MEMHIZ: Common memory x data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept Hi-Z after the start of a NAND Flash write access to common memory space. This is only valid for write transactions:
    inline uint32_t FMC_PMEM_MEMHIZ (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register PATT: The FMC_PATT read/write register contains the timing information for NAND Flash memory bank. It is used for 8-bit accesses to the attribute memory space of the NAND Flash for the last address write access if the timing must differ from that of previous accesses (for Ready/Busy management, refer to Section20.8.5: NAND Flash prewait feature).
  #define FMC_PATT (* ((volatile uint32_t *) (0x52004000 + 140)))

  // Field ATTSET: Attribute memory setup time These bits define the number of KCK_FMC (+1) clock cycles to set up address before the command assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
    inline uint32_t FMC_PATT_ATTSET (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field ATTWAIT: Attribute memory wait time These bits define the minimum number of x KCK_FMC (+1) clock cycles to assert the command (NWE, NOE), for NAND Flash read or write access to attribute memory space. The duration for command assertion is extended if the wait signal (NWAIT) is active (low) at the end of the programmed value of KCK_FMC:
    inline uint32_t FMC_PATT_ATTWAIT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field ATTHOLD: Attribute memory hold time These bits define the number of KCK_FMC clock cycles during which the address is held (and data for write access) after the command de-assertion (NWE, NOE), for NAND Flash read or write access to attribute memory space:
    inline uint32_t FMC_PATT_ATTHOLD (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field ATTHIZ: Attribute memory data bus Hi-Z time These bits define the number of KCK_FMC clock cycles during which the data bus is kept in Hi-Z after the start of a NAND Flash write access to attribute memory space on socket. Only valid for writ transaction:
    inline uint32_t FMC_PATT_ATTHIZ (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register ECCR: This register contain the current error correction code value computed by the ECC computation modules of the FMC NAND controller. When the CPU reads/writes the data from a NAND Flash memory page at the correct address (refer to Section20.8.6: Computation of the error correction code (ECC) in NAND Flash memory), the data read/written from/to the NAND Flash memory are processed automatically by the ECC computation module. When X bytes have been read (according to the ECCPS field in the FMC_PCR registers), the CPU must read the computed ECC value from the FMC_ECC registers. It then verifies if these computed parity data are the same as the parity value recorded in the spare area, to determine whether a page is valid, and, to correct it otherwise. The FMC_ECCR register should be cleared after being read by setting the ECCEN bit to 0. To compute a new data block, the ECCEN bit must be set to 1.
  #define FMC_ECCR (* ((const volatile uint32_t *) (0x52004000 + 148)))

  // Field ECC: ECC result This field contains the value computed by the ECC computation logic. Table167 describes the contents of these bit fields.
    inline uint32_t FMC_ECCR_ECC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BWTR1: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
  #define FMC_BWTR1 (* ((volatile uint32_t *) (0x52004000 + 260)))

  // Field ADDSET: Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
    inline uint32_t FMC_BWTR1_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
    inline uint32_t FMC_BWTR1_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
    inline uint32_t FMC_BWTR1_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
    inline uint32_t FMC_BWTR1_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field ACCMOD: Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BWTR1_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register BWTR2: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
  #define FMC_BWTR2 (* ((volatile uint32_t *) (0x52004000 + 268)))

  // Field ADDSET: Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
    inline uint32_t FMC_BWTR2_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
    inline uint32_t FMC_BWTR2_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
    inline uint32_t FMC_BWTR2_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
    inline uint32_t FMC_BWTR2_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field ACCMOD: Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BWTR2_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register BWTR3: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
  #define FMC_BWTR3 (* ((volatile uint32_t *) (0x52004000 + 276)))

  // Field ADDSET: Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
    inline uint32_t FMC_BWTR3_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
    inline uint32_t FMC_BWTR3_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
    inline uint32_t FMC_BWTR3_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
    inline uint32_t FMC_BWTR3_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field ACCMOD: Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BWTR3_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register BWTR4: This register contains the control information of each memory bank. It is used for SRAMs, PSRAMs and NOR Flash memories. When the EXTMOD bit is set in the FMC_BCRx register, then this register is active for write access.
  #define FMC_BWTR4 (* ((volatile uint32_t *) (0x52004000 + 284)))

  // Field ADDSET: Address setup phase duration. These bits are written by software to define the duration of the address setup phase in KCK_FMC cycles (refer to Figure81 to Figure93), used in asynchronous accesses: ... Note: In synchronous accesses, this value is not used, the address setup phase is always 1 Flash clock period duration. In muxed mode, the minimum ADDSET value is 1.
    inline uint32_t FMC_BWTR4_ADDSET (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ADDHLD: Address-hold phase duration. These bits are written by software to define the duration of the address hold phase (refer to Figure81 to Figure93), used in asynchronous multiplexed accesses: ... Note: In synchronous NOR Flash accesses, this value is not used, the address hold phase is always 1 Flash clock period duration.
    inline uint32_t FMC_BWTR4_ADDHLD (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field DATAST: Data-phase duration. These bits are written by software to define the duration of the data phase (refer to Figure81 to Figure93), used in asynchronous SRAM, PSRAM and NOR Flash memory accesses:
    inline uint32_t FMC_BWTR4_DATAST (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BUSTURN: Bus turnaround phase duration These bits are written by software to add a delay at the end of a write transaction to match the minimum time between consecutive transactions (tEHEL from ENx high to ENx low): (BUSTRUN + 1) KCK_FMC period &#8805; tEHELmin. The programmed bus turnaround delay is inserted between a an asynchronous write transfer and any other asynchronous /synchronous read or write transfer to or from a static bank. If a read operation is performed, the bank can be the same or a different one, whereas it must be different in case of write operation to the bank, except in muxed mode or mode D. In some cases, whatever the programmed BUSTRUN values, the bus turnaround delay is fixed as follows: The bus turnaround delay is not inserted between two consecutive asynchronous write transfers to the same static memory bank except for muxed mode and mode D. There is a bus turnaround delay of 2 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to the same bank A synchronous write transfer ((in Burst or Single mode) and an asynchronous write or read transfer to or from static memory bank. There is a bus turnaround delay of 3 FMC clock cycle between: Two consecutive synchronous write operations (in Burst or Single mode) to different static banks. A synchronous write transfer (in Burst or Single mode) and a synchronous read from the same or a different bank. ...
    inline uint32_t FMC_BWTR4_BUSTURN (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field ACCMOD: Access mode. These bits specify the asynchronous access modes as shown in the next timing diagrams.These bits are taken into account only when the EXTMOD bit in the FMC_BCRx register is 1.
    inline uint32_t FMC_BWTR4_ACCMOD (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register SDCR1: This register contains the control parameters for each SDRAM memory bank
  #define FMC_SDCR1 (* ((volatile uint32_t *) (0x52004000 + 320)))

  // Field NC: Number of column address bits These bits define the number of bits of a column address.
    inline uint32_t FMC_SDCR1_NC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field NR: Number of row address bits These bits define the number of bits of a row address.
    inline uint32_t FMC_SDCR1_NR (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MWID: Memory data bus width. These bits define the memory device width.
    inline uint32_t FMC_SDCR1_MWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field NB: Number of internal banks This bit sets the number of internal banks.
    const uint32_t FMC_SDCR1_NB = 1U << 6 ;

  // Field CAS: CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
    inline uint32_t FMC_SDCR1_CAS (const uint32_t inValue) {return (inValue & 0x3U) << 7 ; }

  // Field WP: Write protection This bit enables write mode access to the SDRAM bank.
    const uint32_t FMC_SDCR1_WP = 1U << 9 ;

  // Field SDCLK: SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
    inline uint32_t FMC_SDCR1_SDCLK (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field RBURST: Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
    const uint32_t FMC_SDCR1_RBURST = 1U << 12 ;

  // Field RPIPE: Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
    inline uint32_t FMC_SDCR1_RPIPE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

//------------------------------------------------------------------------------

//---  Register SDCR2: This register contains the control parameters for each SDRAM memory bank
  #define FMC_SDCR2 (* ((volatile uint32_t *) (0x52004000 + 324)))

  // Field NC: Number of column address bits These bits define the number of bits of a column address.
    inline uint32_t FMC_SDCR2_NC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field NR: Number of row address bits These bits define the number of bits of a row address.
    inline uint32_t FMC_SDCR2_NR (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MWID: Memory data bus width. These bits define the memory device width.
    inline uint32_t FMC_SDCR2_MWID (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field NB: Number of internal banks This bit sets the number of internal banks.
    const uint32_t FMC_SDCR2_NB = 1U << 6 ;

  // Field CAS: CAS Latency This bits sets the SDRAM CAS latency in number of memory clock cycles
    inline uint32_t FMC_SDCR2_CAS (const uint32_t inValue) {return (inValue & 0x3U) << 7 ; }

  // Field WP: Write protection This bit enables write mode access to the SDRAM bank.
    const uint32_t FMC_SDCR2_WP = 1U << 9 ;

  // Field SDCLK: SDRAM clock configuration These bits define the SDRAM clock period for both SDRAM banks and allow disabling the clock before changing the frequency. In this case the SDRAM must be re-initialized. Note: The corresponding bits in the FMC_SDCR2 register is read only.
    inline uint32_t FMC_SDCR2_SDCLK (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field RBURST: Burst read This bit enables burst read mode. The SDRAM controller anticipates the next read commands during the CAS latency and stores data in the Read FIFO. Note: The corresponding bit in the FMC_SDCR2 register is read only.
    const uint32_t FMC_SDCR2_RBURST = 1U << 12 ;

  // Field RPIPE: Read pipe These bits define the delay, in KCK_FMC clock cycles, for reading data after CAS latency. Note: The corresponding bits in the FMC_SDCR2 register is read only.
    inline uint32_t FMC_SDCR2_RPIPE (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

//------------------------------------------------------------------------------

//---  Register SDTR1: This register contains the timing parameters of each SDRAM bank
  #define FMC_SDTR1 (* ((volatile uint32_t *) (0x52004000 + 328)))

  // Field TMRD: Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
    inline uint32_t FMC_SDTR1_TMRD (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TXSR: Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
    inline uint32_t FMC_SDTR1_TXSR (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field TRAS: Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
    inline uint32_t FMC_SDTR1_TRAS (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TRC: Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
    inline uint32_t FMC_SDTR1_TRC (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field TWR: Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
    inline uint32_t FMC_SDTR1_TWR (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TRP: Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
    inline uint32_t FMC_SDTR1_TRP (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field TRCD: Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
    inline uint32_t FMC_SDTR1_TRCD (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register SDTR2: This register contains the timing parameters of each SDRAM bank
  #define FMC_SDTR2 (* ((volatile uint32_t *) (0x52004000 + 332)))

  // Field TMRD: Load Mode Register to Active These bits define the delay between a Load Mode Register command and an Active or Refresh command in number of memory clock cycles. ....
    inline uint32_t FMC_SDTR2_TMRD (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TXSR: Exit Self-refresh delay These bits define the delay from releasing the Self-refresh command to issuing the Activate command in number of memory clock cycles. .... Note: If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TXSR timing corresponding to the slowest SDRAM device.
    inline uint32_t FMC_SDTR2_TXSR (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field TRAS: Self refresh time These bits define the minimum Self-refresh period in number of memory clock cycles. ....
    inline uint32_t FMC_SDTR2_TRAS (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TRC: Row cycle delay These bits define the delay between the Refresh command and the Activate command, as well as the delay between two consecutive Refresh commands. It is expressed in number of memory clock cycles. The TRC timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRC must be programmed with the timings of the slowest device. .... Note: TRC must match the TRC and TRFC (Auto Refresh period) timings defined in the SDRAM device datasheet. Note: The corresponding bits in the FMC_SDTR2 register are dont care.
    inline uint32_t FMC_SDTR2_TRC (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field TWR: Recovery delay These bits define the delay between a Write and a Precharge command in number of memory clock cycles. .... Note: TWR must be programmed to match the write recovery time (tWR) defined in the SDRAM datasheet, and to guarantee that: TWR &#8805; TRAS - TRCD and TWR &#8805;TRC - TRCD - TRP Example: TRAS= 4 cycles, TRCD= 2 cycles. So, TWR &gt;= 2 cycles. TWR must be programmed to 0x1. If two SDRAM devices are used, the FMC_SDTR1 and FMC_SDTR2 must be programmed with the same TWR timing corresponding to the slowest SDRAM device.
    inline uint32_t FMC_SDTR2_TWR (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TRP: Row precharge delay These bits define the delay between a Precharge command and another command in number of memory clock cycles. The TRP timing is only configured in the FMC_SDTR1 register. If two SDRAM devices are used, the TRP must be programmed with the timing of the slowest device. .... Note: The corresponding bits in the FMC_SDTR2 register are dont care.
    inline uint32_t FMC_SDTR2_TRP (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field TRCD: Row to column delay These bits define the delay between the Activate command and a Read/Write command in number of memory clock cycles. ....
    inline uint32_t FMC_SDTR2_TRCD (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register SDCMR: This register contains the command issued when the SDRAM device is accessed. This register is used to initialize the SDRAM device, and to activate the Self-refresh and the Power-down modes. As soon as the MODE field is written, the command will be issued only to one or to both SDRAM banks according to CTB1 and CTB2 command bits. This register is the same for both SDRAM banks.
  #define FMC_SDCMR (* ((volatile uint32_t *) (0x52004000 + 336)))

  // Field MODE: Command mode These bits define the command issued to the SDRAM device. Note: When a command is issued, at least one Command Target Bank bit ( CTB1 or CTB2) must be set otherwise the command will be ignored. Note: If two SDRAM banks are used, the Auto-refresh and PALL command must be issued simultaneously to the two devices with CTB1 and CTB2 bits set otherwise the command will be ignored. Note: If only one SDRAM bank is used and a command is issued with its associated CTB bit set, the other CTB bit of the unused bank must be kept to 0.
    inline uint32_t FMC_SDCMR_MODE (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field CTB2: Command Target Bank 2 This bit indicates whether the command will be issued to SDRAM Bank 2 or not.
    const uint32_t FMC_SDCMR_CTB2 = 1U << 3 ;

  // Field CTB1: Command Target Bank 1 This bit indicates whether the command will be issued to SDRAM Bank 1 or not.
    const uint32_t FMC_SDCMR_CTB1 = 1U << 4 ;

  // Field NRFS: Number of Auto-refresh These bits define the number of consecutive Auto-refresh commands issued when MODE = 011. ....
    inline uint32_t FMC_SDCMR_NRFS (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field MRD: Mode Register definition This 14-bit field defines the SDRAM Mode Register content. The Mode Register is programmed using the Load Mode Register command. The MRD[13:0] bits are also used to program the extended mode register for mobile SDRAM.
    inline uint32_t FMC_SDCMR_MRD (const uint32_t inValue) {return (inValue & 0x3FFFU) << 9 ; }

//------------------------------------------------------------------------------

//---  Register SDRTR: This register sets the refresh rate in number of SDCLK clock cycles between the refresh cycles by configuring the Refresh Timer Count value.Examplewhere 64 ms is the SDRAM refresh period.The refresh rate must be increased by 20 SDRAM clock cycles (as in the above example) to obtain a safe margin if an internal refresh request occurs when a read request has been accepted. It corresponds to a COUNT value of 0000111000000 (448). This 13-bit field is loaded into a timer which is decremented using the SDRAM clock. This timer generates a refresh pulse when zero is reached. The COUNT value must be set at least to 41 SDRAM clock cycles.As soon as the FMC_SDRTR register is programmed, the timer starts counting. If the value programmed in the register is 0, no refresh is carried out. This register must not be reprogrammed after the initialization procedure to avoid modifying the refresh rate.Each time a refresh pulse is generated, this 13-bit COUNT field is reloaded into the counter.If a memory access is in progress, the Auto-refresh request is delayed. However, if the memory access and Auto-refresh requests are generated simultaneously, the Auto-refresh takes precedence. If the memory access occurs during a refresh operation, the request is buffered to be processed when the refresh is complete.This register is common to SDRAM bank 1 and bank 2.
  #define FMC_SDRTR (* ((volatile uint32_t *) (0x52004000 + 340)))

  // Field CRE: Clear Refresh error flag This bit is used to clear the Refresh Error Flag (RE) in the Status Register.
    const uint32_t FMC_SDRTR_CRE = 1U << 0 ;

  // Field COUNT: Refresh Timer Count This 13-bit field defines the refresh rate of the SDRAM device. It is expressed in number of memory clock cycles. It must be set at least to 41 SDRAM clock cycles (0x29). Refresh rate = (COUNT + 1) x SDRAM frequency clock COUNT = (SDRAM refresh period / Number of rows) - 20
    inline uint32_t FMC_SDRTR_COUNT (const uint32_t inValue) {return (inValue & 0x1FFFU) << 1 ; }

  // Field REIE: RES Interrupt Enable
    const uint32_t FMC_SDRTR_REIE = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register SDSR: SDRAM Status register
  #define FMC_SDSR (* ((const volatile uint32_t *) (0x52004000 + 344)))

  // Field RE: Refresh error flag An interrupt is generated if REIE = 1 and RE = 1
    const uint32_t FMC_SDSR_RE = 1U << 0 ;

  // Field MODES1: Status Mode for Bank 1 These bits define the Status Mode of SDRAM Bank 1.
    inline uint32_t FMC_SDSR_MODES1 (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field MODES2: Status Mode for Bank 2 These bits define the Status Mode of SDRAM Bank 2.
    inline uint32_t FMC_SDSR_MODES2 (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

//------------------------------------------------------------------------------
// Peripheral FPU: Floting point unit
//------------------------------------------------------------------------------

//---  Register FPCCR: Floating-point context control register
  #define FPU_FPCCR (* ((volatile uint32_t *) (0xE000EF34 + 0)))

  // Field LSPACT: LSPACT
    const uint32_t FPU_FPCCR_LSPACT = 1U << 0 ;

  // Field USER: USER
    const uint32_t FPU_FPCCR_USER = 1U << 1 ;

  // Field THREAD: THREAD
    const uint32_t FPU_FPCCR_THREAD = 1U << 3 ;

  // Field HFRDY: HFRDY
    const uint32_t FPU_FPCCR_HFRDY = 1U << 4 ;

  // Field MMRDY: MMRDY
    const uint32_t FPU_FPCCR_MMRDY = 1U << 5 ;

  // Field BFRDY: BFRDY
    const uint32_t FPU_FPCCR_BFRDY = 1U << 6 ;

  // Field MONRDY: MONRDY
    const uint32_t FPU_FPCCR_MONRDY = 1U << 8 ;

  // Field LSPEN: LSPEN
    const uint32_t FPU_FPCCR_LSPEN = 1U << 30 ;

  // Field ASPEN: ASPEN
    const uint32_t FPU_FPCCR_ASPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register FPCAR: Floating-point context address register
  #define FPU_FPCAR (* ((volatile uint32_t *) (0xE000EF34 + 4)))

  // Field ADDRESS: Location of unpopulated floating-point
    inline uint32_t FPU_FPCAR_ADDRESS (const uint32_t inValue) {return (inValue & 0x1FFFFFFFU) << 3 ; }

//------------------------------------------------------------------------------

//---  Register FPSCR: Floating-point status control register
  #define FPU_FPSCR (* ((volatile uint32_t *) (0xE000EF34 + 8)))

  // Field IOC: Invalid operation cumulative exception bit
    const uint32_t FPU_FPSCR_IOC = 1U << 0 ;

  // Field DZC: Division by zero cumulative exception bit.
    const uint32_t FPU_FPSCR_DZC = 1U << 1 ;

  // Field OFC: Overflow cumulative exception bit
    const uint32_t FPU_FPSCR_OFC = 1U << 2 ;

  // Field UFC: Underflow cumulative exception bit
    const uint32_t FPU_FPSCR_UFC = 1U << 3 ;

  // Field IXC: Inexact cumulative exception bit
    const uint32_t FPU_FPSCR_IXC = 1U << 4 ;

  // Field IDC: Input denormal cumulative exception bit.
    const uint32_t FPU_FPSCR_IDC = 1U << 7 ;

  // Field RMode: Rounding Mode control field
    inline uint32_t FPU_FPSCR_RMode (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field FZ: Flush-to-zero mode control bit:
    const uint32_t FPU_FPSCR_FZ = 1U << 24 ;

  // Field DN: Default NaN mode control bit
    const uint32_t FPU_FPSCR_DN = 1U << 25 ;

  // Field AHP: Alternative half-precision control bit
    const uint32_t FPU_FPSCR_AHP = 1U << 26 ;

  // Field V: Overflow condition code flag
    const uint32_t FPU_FPSCR_V = 1U << 28 ;

  // Field C: Carry condition code flag
    const uint32_t FPU_FPSCR_C = 1U << 29 ;

  // Field Z: Zero condition code flag
    const uint32_t FPU_FPSCR_Z = 1U << 30 ;

  // Field N: Negative condition code flag
    const uint32_t FPU_FPSCR_N = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral FPU_CPACR: Floating point unit CPACR
//------------------------------------------------------------------------------

//---  Register CPACR: Coprocessor access control register
  #define FPU_CPACR_CPACR (* ((volatile uint32_t *) (0xE000ED88 + 0)))

  // Field CP: CP
    inline uint32_t FPU_CPACR_CPACR_CP (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

//------------------------------------------------------------------------------
// Peripheral Flash: Flash
//------------------------------------------------------------------------------

//---  Register ACR: Access control register
  #define Flash_ACR (* ((volatile uint32_t *) (0x52002000 + 0)))

  // Field LATENCY: Read latency
    inline uint32_t Flash_ACR_LATENCY (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field WRHIGHFREQ: Flash signal delay
    inline uint32_t Flash_ACR_WRHIGHFREQ (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register ACR_: Access control register
  #define Flash_ACR_ (* ((volatile uint32_t *) (0x52002000 + 256)))

  // Field LATENCY: Read latency
    inline uint32_t Flash_ACR__LATENCY (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field WRHIGHFREQ: Flash signal delay
    inline uint32_t Flash_ACR__WRHIGHFREQ (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register KEYR1: FLASH key register for bank 1
  #define Flash_KEYR1 (* ((volatile uint32_t *) (0x52002000 + 4)))

  // Field KEYR1: Bank 1 access configuration unlock key
    inline uint32_t Flash_KEYR1_KEYR1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OPTKEYR: FLASH option key register
  #define Flash_OPTKEYR (* ((volatile uint32_t *) (0x52002000 + 8)))

  // Field OPTKEYR: Unlock key option bytes
    inline uint32_t Flash_OPTKEYR_OPTKEYR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OPTKEYR_: FLASH option key register
  #define Flash_OPTKEYR_ (* ((volatile uint32_t *) (0x52002000 + 264)))

  // Field OPTKEYR: Unlock key option bytes
    inline uint32_t Flash_OPTKEYR__OPTKEYR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CR1: FLASH control register for bank 1
  #define Flash_CR1 (* ((volatile uint32_t *) (0x52002000 + 12)))

  // Field LOCK1: Bank 1 configuration lock bit
    const uint32_t Flash_CR1_LOCK1 = 1U << 0 ;

  // Field PG1: Bank 1 program enable bit
    const uint32_t Flash_CR1_PG1 = 1U << 1 ;

  // Field SER1: Bank 1 sector erase request
    const uint32_t Flash_CR1_SER1 = 1U << 2 ;

  // Field BER1: Bank 1 erase request
    const uint32_t Flash_CR1_BER1 = 1U << 3 ;

  // Field PSIZE1: Bank 1 program size
    inline uint32_t Flash_CR1_PSIZE1 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field FW1: Bank 1 write forcing control bit
    const uint32_t Flash_CR1_FW1 = 1U << 6 ;

  // Field START1: Bank 1 bank or sector erase start control bit
    const uint32_t Flash_CR1_START1 = 1U << 7 ;

  // Field SNB1: Bank 1 sector erase selection number
    inline uint32_t Flash_CR1_SNB1 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field CRC_EN: Bank 1 CRC control bit
    const uint32_t Flash_CR1_CRC_EN = 1U << 15 ;

  // Field EOPIE1: Bank 1 end-of-program interrupt control bit
    const uint32_t Flash_CR1_EOPIE1 = 1U << 16 ;

  // Field WRPERRIE1: Bank 1 write protection error interrupt enable bit
    const uint32_t Flash_CR1_WRPERRIE1 = 1U << 17 ;

  // Field PGSERRIE1: Bank 1 programming sequence error interrupt enable bit
    const uint32_t Flash_CR1_PGSERRIE1 = 1U << 18 ;

  // Field STRBERRIE1: Bank 1 strobe error interrupt enable bit
    const uint32_t Flash_CR1_STRBERRIE1 = 1U << 19 ;

  // Field INCERRIE1: Bank 1 inconsistency error interrupt enable bit
    const uint32_t Flash_CR1_INCERRIE1 = 1U << 21 ;

  // Field OPERRIE1: Bank 1 write/erase error interrupt enable bit
    const uint32_t Flash_CR1_OPERRIE1 = 1U << 22 ;

  // Field RDPERRIE1: Bank 1 read protection error interrupt enable bit
    const uint32_t Flash_CR1_RDPERRIE1 = 1U << 23 ;

  // Field RDSERRIE1: Bank 1 secure error interrupt enable bit
    const uint32_t Flash_CR1_RDSERRIE1 = 1U << 24 ;

  // Field SNECCERRIE1: Bank 1 ECC single correction error interrupt enable bit
    const uint32_t Flash_CR1_SNECCERRIE1 = 1U << 25 ;

  // Field DBECCERRIE1: Bank 1 ECC double detection error interrupt enable bit
    const uint32_t Flash_CR1_DBECCERRIE1 = 1U << 26 ;

  // Field CRCENDIE1: Bank 1 end of CRC calculation interrupt enable bit
    const uint32_t Flash_CR1_CRCENDIE1 = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register SR1: FLASH status register for bank 1
  #define Flash_SR1 (* ((volatile uint32_t *) (0x52002000 + 16)))

  // Field BSY1: Bank 1 ongoing program flag
    const uint32_t Flash_SR1_BSY1 = 1U << 0 ;

  // Field WBNE1: Bank 1 write buffer not empty flag
    const uint32_t Flash_SR1_WBNE1 = 1U << 1 ;

  // Field QW1: Bank 1 wait queue flag
    const uint32_t Flash_SR1_QW1 = 1U << 2 ;

  // Field CRC_BUSY1: Bank 1 CRC busy flag
    const uint32_t Flash_SR1_CRC_BUSY1 = 1U << 3 ;

  // Field EOP1: Bank 1 end-of-program flag
    const uint32_t Flash_SR1_EOP1 = 1U << 16 ;

  // Field WRPERR1: Bank 1 write protection error flag
    const uint32_t Flash_SR1_WRPERR1 = 1U << 17 ;

  // Field PGSERR1: Bank 1 programming sequence error flag
    const uint32_t Flash_SR1_PGSERR1 = 1U << 18 ;

  // Field STRBERR1: Bank 1 strobe error flag
    const uint32_t Flash_SR1_STRBERR1 = 1U << 19 ;

  // Field INCERR1: Bank 1 inconsistency error flag
    const uint32_t Flash_SR1_INCERR1 = 1U << 21 ;

  // Field OPERR1: Bank 1 write/erase error flag
    const uint32_t Flash_SR1_OPERR1 = 1U << 22 ;

  // Field RDPERR1: Bank 1 read protection error flag
    const uint32_t Flash_SR1_RDPERR1 = 1U << 23 ;

  // Field RDSERR1: Bank 1 secure error flag
    const uint32_t Flash_SR1_RDSERR1 = 1U << 24 ;

  // Field SNECCERR11: Bank 1 single correction error flag
    const uint32_t Flash_SR1_SNECCERR11 = 1U << 25 ;

  // Field DBECCERR1: Bank 1 ECC double detection error flag
    const uint32_t Flash_SR1_DBECCERR1 = 1U << 26 ;

  // Field CRCEND1: Bank 1 CRC-complete flag
    const uint32_t Flash_SR1_CRCEND1 = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register CCR1: FLASH clear control register for bank 1
  #define Flash_CCR1 (* ((volatile uint32_t *) (0x52002000 + 20)))

  // Field CLR_EOP1: Bank 1 EOP1 flag clear bit
    const uint32_t Flash_CCR1_CLR_EOP1 = 1U << 16 ;

  // Field CLR_WRPERR1: Bank 1 WRPERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_WRPERR1 = 1U << 17 ;

  // Field CLR_PGSERR1: Bank 1 PGSERR1 flag clear bi
    const uint32_t Flash_CCR1_CLR_PGSERR1 = 1U << 18 ;

  // Field CLR_STRBERR1: Bank 1 STRBERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_STRBERR1 = 1U << 19 ;

  // Field CLR_INCERR1: Bank 1 INCERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_INCERR1 = 1U << 21 ;

  // Field CLR_OPERR1: Bank 1 OPERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_OPERR1 = 1U << 22 ;

  // Field CLR_RDPERR1: Bank 1 RDPERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_RDPERR1 = 1U << 23 ;

  // Field CLR_RDSERR1: Bank 1 RDSERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_RDSERR1 = 1U << 24 ;

  // Field CLR_SNECCERR1: Bank 1 SNECCERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_SNECCERR1 = 1U << 25 ;

  // Field CLR_DBECCERR1: Bank 1 DBECCERR1 flag clear bit
    const uint32_t Flash_CCR1_CLR_DBECCERR1 = 1U << 26 ;

  // Field CLR_CRCEND1: Bank 1 CRCEND1 flag clear bit
    const uint32_t Flash_CCR1_CLR_CRCEND1 = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register OPTCR: FLASH option control register
  #define Flash_OPTCR (* ((volatile uint32_t *) (0x52002000 + 24)))

  // Field OPTLOCK: FLASH_OPTCR lock option configuration bit
    const uint32_t Flash_OPTCR_OPTLOCK = 1U << 0 ;

  // Field OPTSTART: Option byte start change option configuration bit
    const uint32_t Flash_OPTCR_OPTSTART = 1U << 1 ;

  // Field MER: Flash mass erase enable bit
    const uint32_t Flash_OPTCR_MER = 1U << 4 ;

  // Field OPTCHANGEERRIE: Option byte change error interrupt enable bit
    const uint32_t Flash_OPTCR_OPTCHANGEERRIE = 1U << 30 ;

  // Field SWAP_BANK: Bank swapping configuration bit
    const uint32_t Flash_OPTCR_SWAP_BANK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OPTCR_: FLASH option control register
  #define Flash_OPTCR_ (* ((volatile uint32_t *) (0x52002000 + 280)))

  // Field OPTLOCK: FLASH_OPTCR lock option configuration bit
    const uint32_t Flash_OPTCR__OPTLOCK = 1U << 0 ;

  // Field OPTSTART: Option byte start change option configuration bit
    const uint32_t Flash_OPTCR__OPTSTART = 1U << 1 ;

  // Field MER: Flash mass erase enable bit
    const uint32_t Flash_OPTCR__MER = 1U << 4 ;

  // Field OPTCHANGEERRIE: Option byte change error interrupt enable bit
    const uint32_t Flash_OPTCR__OPTCHANGEERRIE = 1U << 30 ;

  // Field SWAP_BANK: Bank swapping configuration bit
    const uint32_t Flash_OPTCR__SWAP_BANK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OPTSR_CUR_: FLASH option status register
  #define Flash_OPTSR_CUR_ (* ((volatile uint32_t *) (0x52002000 + 284)))

  // Field OPT_BUSY: Option byte change ongoing flag
    const uint32_t Flash_OPTSR_CUR__OPT_BUSY = 1U << 0 ;

  // Field BOR_LEV: Brownout level option status bit
    inline uint32_t Flash_OPTSR_CUR__BOR_LEV (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field IWDG1_HW: IWDG1 control option status bit
    const uint32_t Flash_OPTSR_CUR__IWDG1_HW = 1U << 4 ;

  // Field nRST_STOP_D1: D1 DStop entry reset option status bit
    const uint32_t Flash_OPTSR_CUR__nRST_STOP_D1 = 1U << 6 ;

  // Field nRST_STBY_D1: D1 DStandby entry reset option status bit
    const uint32_t Flash_OPTSR_CUR__nRST_STBY_D1 = 1U << 7 ;

  // Field RDP: Readout protection level option status byte
    inline uint32_t Flash_OPTSR_CUR__RDP (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field FZ_IWDG_STOP: IWDG Stop mode freeze option status bit
    const uint32_t Flash_OPTSR_CUR__FZ_IWDG_STOP = 1U << 17 ;

  // Field FZ_IWDG_SDBY: IWDG Standby mode freeze option status bit
    const uint32_t Flash_OPTSR_CUR__FZ_IWDG_SDBY = 1U << 18 ;

  // Field ST_RAM_SIZE: DTCM RAM size option status
    inline uint32_t Flash_OPTSR_CUR__ST_RAM_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

  // Field SECURITY: Security enable option status bit
    const uint32_t Flash_OPTSR_CUR__SECURITY = 1U << 21 ;

  // Field RSS1: User option bit 1
    const uint32_t Flash_OPTSR_CUR__RSS1 = 1U << 26 ;

  // Field PERSO_OK: Device personalization status bit
    const uint32_t Flash_OPTSR_CUR__PERSO_OK = 1U << 28 ;

  // Field IO_HSLV: I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
    const uint32_t Flash_OPTSR_CUR__IO_HSLV = 1U << 29 ;

  // Field OPTCHANGEERR: Option byte change error flag
    const uint32_t Flash_OPTSR_CUR__OPTCHANGEERR = 1U << 30 ;

  // Field SWAP_BANK_OPT: Bank swapping option status bit
    const uint32_t Flash_OPTSR_CUR__SWAP_BANK_OPT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OPTSR_CUR: FLASH option status register
  #define Flash_OPTSR_CUR (* ((volatile uint32_t *) (0x52002000 + 28)))

  // Field OPT_BUSY: Option byte change ongoing flag
    const uint32_t Flash_OPTSR_CUR_OPT_BUSY = 1U << 0 ;

  // Field BOR_LEV: Brownout level option status bit
    inline uint32_t Flash_OPTSR_CUR_BOR_LEV (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field IWDG1_HW: IWDG1 control option status bit
    const uint32_t Flash_OPTSR_CUR_IWDG1_HW = 1U << 4 ;

  // Field nRST_STOP_D1: D1 DStop entry reset option status bit
    const uint32_t Flash_OPTSR_CUR_nRST_STOP_D1 = 1U << 6 ;

  // Field nRST_STBY_D1: D1 DStandby entry reset option status bit
    const uint32_t Flash_OPTSR_CUR_nRST_STBY_D1 = 1U << 7 ;

  // Field RDP: Readout protection level option status byte
    inline uint32_t Flash_OPTSR_CUR_RDP (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field FZ_IWDG_STOP: IWDG Stop mode freeze option status bit
    const uint32_t Flash_OPTSR_CUR_FZ_IWDG_STOP = 1U << 17 ;

  // Field FZ_IWDG_SDBY: IWDG Standby mode freeze option status bit
    const uint32_t Flash_OPTSR_CUR_FZ_IWDG_SDBY = 1U << 18 ;

  // Field ST_RAM_SIZE: DTCM RAM size option status
    inline uint32_t Flash_OPTSR_CUR_ST_RAM_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

  // Field SECURITY: Security enable option status bit
    const uint32_t Flash_OPTSR_CUR_SECURITY = 1U << 21 ;

  // Field RSS1: User option bit 1
    const uint32_t Flash_OPTSR_CUR_RSS1 = 1U << 26 ;

  // Field PERSO_OK: Device personalization status bit
    const uint32_t Flash_OPTSR_CUR_PERSO_OK = 1U << 28 ;

  // Field IO_HSLV: I/O high-speed at low-voltage status bit (PRODUCT_BELOW_25V)
    const uint32_t Flash_OPTSR_CUR_IO_HSLV = 1U << 29 ;

  // Field OPTCHANGEERR: Option byte change error flag
    const uint32_t Flash_OPTSR_CUR_OPTCHANGEERR = 1U << 30 ;

  // Field SWAP_BANK_OPT: Bank swapping option status bit
    const uint32_t Flash_OPTSR_CUR_SWAP_BANK_OPT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OPTSR_PRG: FLASH option status register
  #define Flash_OPTSR_PRG (* ((volatile uint32_t *) (0x52002000 + 32)))

  // Field BOR_LEV: BOR reset level option configuration bits
    inline uint32_t Flash_OPTSR_PRG_BOR_LEV (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field IWDG1_HW: IWDG1 option configuration bit
    const uint32_t Flash_OPTSR_PRG_IWDG1_HW = 1U << 4 ;

  // Field nRST_STOP_D1: Option byte erase after D1 DStop option configuration bit
    const uint32_t Flash_OPTSR_PRG_nRST_STOP_D1 = 1U << 6 ;

  // Field nRST_STBY_D1: Option byte erase after D1 DStandby option configuration bit
    const uint32_t Flash_OPTSR_PRG_nRST_STBY_D1 = 1U << 7 ;

  // Field RDP: Readout protection level option configuration byte
    inline uint32_t Flash_OPTSR_PRG_RDP (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field FZ_IWDG_STOP: IWDG Stop mode freeze option configuration bit
    const uint32_t Flash_OPTSR_PRG_FZ_IWDG_STOP = 1U << 17 ;

  // Field FZ_IWDG_SDBY: IWDG Standby mode freeze option configuration bit
    const uint32_t Flash_OPTSR_PRG_FZ_IWDG_SDBY = 1U << 18 ;

  // Field ST_RAM_SIZE: DTCM size select option configuration bits
    inline uint32_t Flash_OPTSR_PRG_ST_RAM_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

  // Field SECURITY: Security option configuration bit
    const uint32_t Flash_OPTSR_PRG_SECURITY = 1U << 21 ;

  // Field RSS1: User option configuration bit 1
    const uint32_t Flash_OPTSR_PRG_RSS1 = 1U << 26 ;

  // Field RSS2: User option configuration bit 2
    const uint32_t Flash_OPTSR_PRG_RSS2 = 1U << 27 ;

  // Field IO_HSLV: I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
    const uint32_t Flash_OPTSR_PRG_IO_HSLV = 1U << 29 ;

  // Field SWAP_BANK_OPT: Bank swapping option configuration bit
    const uint32_t Flash_OPTSR_PRG_SWAP_BANK_OPT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OPTSR_PRG_: FLASH option status register
  #define Flash_OPTSR_PRG_ (* ((volatile uint32_t *) (0x52002000 + 288)))

  // Field BOR_LEV: BOR reset level option configuration bits
    inline uint32_t Flash_OPTSR_PRG__BOR_LEV (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field IWDG1_HW: IWDG1 option configuration bit
    const uint32_t Flash_OPTSR_PRG__IWDG1_HW = 1U << 4 ;

  // Field nRST_STOP_D1: Option byte erase after D1 DStop option configuration bit
    const uint32_t Flash_OPTSR_PRG__nRST_STOP_D1 = 1U << 6 ;

  // Field nRST_STBY_D1: Option byte erase after D1 DStandby option configuration bit
    const uint32_t Flash_OPTSR_PRG__nRST_STBY_D1 = 1U << 7 ;

  // Field RDP: Readout protection level option configuration byte
    inline uint32_t Flash_OPTSR_PRG__RDP (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field FZ_IWDG_STOP: IWDG Stop mode freeze option configuration bit
    const uint32_t Flash_OPTSR_PRG__FZ_IWDG_STOP = 1U << 17 ;

  // Field FZ_IWDG_SDBY: IWDG Standby mode freeze option configuration bit
    const uint32_t Flash_OPTSR_PRG__FZ_IWDG_SDBY = 1U << 18 ;

  // Field ST_RAM_SIZE: DTCM size select option configuration bits
    inline uint32_t Flash_OPTSR_PRG__ST_RAM_SIZE (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

  // Field SECURITY: Security option configuration bit
    const uint32_t Flash_OPTSR_PRG__SECURITY = 1U << 21 ;

  // Field RSS1: User option configuration bit 1
    const uint32_t Flash_OPTSR_PRG__RSS1 = 1U << 26 ;

  // Field RSS2: User option configuration bit 2
    const uint32_t Flash_OPTSR_PRG__RSS2 = 1U << 27 ;

  // Field IO_HSLV: I/O high-speed at low-voltage (PRODUCT_BELOW_25V)
    const uint32_t Flash_OPTSR_PRG__IO_HSLV = 1U << 29 ;

  // Field SWAP_BANK_OPT: Bank swapping option configuration bit
    const uint32_t Flash_OPTSR_PRG__SWAP_BANK_OPT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OPTCCR_: FLASH option clear control register
  #define Flash_OPTCCR_ (* ((volatile uint32_t *) (0x52002000 + 292)))

  // Field CLR_OPTCHANGEERR: OPTCHANGEERR reset bit
    const uint32_t Flash_OPTCCR__CLR_OPTCHANGEERR = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OPTCCR: FLASH option clear control register
  #define Flash_OPTCCR (* ((volatile uint32_t *) (0x52002000 + 36)))

  // Field CLR_OPTCHANGEERR: OPTCHANGEERR reset bit
    const uint32_t Flash_OPTCCR_CLR_OPTCHANGEERR = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register PRAR_CUR1: FLASH protection address for bank 1
  #define Flash_PRAR_CUR1 (* ((const volatile uint32_t *) (0x52002000 + 40)))

  // Field PROT_AREA_START1: Bank 1 lowest PCROP protected address
    inline uint32_t Flash_PRAR_CUR1_PROT_AREA_START1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field PROT_AREA_END1: Bank 1 highest PCROP protected address
    inline uint32_t Flash_PRAR_CUR1_PROT_AREA_END1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMEP1: Bank 1 PCROP protected erase enable option status bit
    const uint32_t Flash_PRAR_CUR1_DMEP1 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PRAR_PRG1: FLASH protection address for bank 1
  #define Flash_PRAR_PRG1 (* ((volatile uint32_t *) (0x52002000 + 44)))

  // Field PROT_AREA_START1: Bank 1 lowest PCROP protected address configuration
    inline uint32_t Flash_PRAR_PRG1_PROT_AREA_START1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field PROT_AREA_END1: Bank 1 highest PCROP protected address configuration
    inline uint32_t Flash_PRAR_PRG1_PROT_AREA_END1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMEP1: Bank 1 PCROP protected erase enable option configuration bit
    const uint32_t Flash_PRAR_PRG1_DMEP1 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SCAR_CUR1: FLASH secure address for bank 1
  #define Flash_SCAR_CUR1 (* ((volatile uint32_t *) (0x52002000 + 48)))

  // Field SEC_AREA_START1: Bank 1 lowest secure protected address
    inline uint32_t Flash_SCAR_CUR1_SEC_AREA_START1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field SEC_AREA_END1: Bank 1 highest secure protected address
    inline uint32_t Flash_SCAR_CUR1_SEC_AREA_END1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMES1: Bank 1 secure protected erase enable option status bit
    const uint32_t Flash_SCAR_CUR1_DMES1 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SCAR_PRG1: FLASH secure address for bank 1
  #define Flash_SCAR_PRG1 (* ((volatile uint32_t *) (0x52002000 + 52)))

  // Field SEC_AREA_START1: Bank 1 lowest secure protected address configuration
    inline uint32_t Flash_SCAR_PRG1_SEC_AREA_START1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field SEC_AREA_END1: Bank 1 highest secure protected address configuration
    inline uint32_t Flash_SCAR_PRG1_SEC_AREA_END1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMES1: Bank 1 secure protected erase enable option configuration bit
    const uint32_t Flash_SCAR_PRG1_DMES1 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register WPSN_CUR1R: FLASH write sector protection for bank 1
  #define Flash_WPSN_CUR1R (* ((const volatile uint32_t *) (0x52002000 + 56)))

  // Field WRPSn1: Bank 1 sector write protection option status byte
    inline uint32_t Flash_WPSN_CUR1R_WRPSn1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register WPSN_PRG1R: FLASH write sector protection for bank 1
  #define Flash_WPSN_PRG1R (* ((volatile uint32_t *) (0x52002000 + 60)))

  // Field WRPSn1: Bank 1 sector write protection configuration byte
    inline uint32_t Flash_WPSN_PRG1R_WRPSn1 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BOOT_CURR: FLASH register with boot address
  #define Flash_BOOT_CURR (* ((const volatile uint32_t *) (0x52002000 + 64)))

  // Field BOOT_ADD0: Boot address 0
    inline uint32_t Flash_BOOT_CURR_BOOT_ADD0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field BOOT_ADD1: Boot address 1
    inline uint32_t Flash_BOOT_CURR_BOOT_ADD1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register BOOT_PRGR: FLASH register with boot address
  #define Flash_BOOT_PRGR (* ((const volatile uint32_t *) (0x52002000 + 68)))

  // Field BOOT_ADD0: Boot address 0
    inline uint32_t Flash_BOOT_PRGR_BOOT_ADD0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field BOOT_ADD1: Boot address 1
    inline uint32_t Flash_BOOT_PRGR_BOOT_ADD1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CRCCR1: FLASH CRC control register for bank 1
  #define Flash_CRCCR1 (* ((volatile uint32_t *) (0x52002000 + 80)))

  // Field CRC_SECT: Bank 1 CRC sector number
    inline uint32_t Flash_CRCCR1_CRC_SECT (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field ALL_BANK: Bank 1 CRC select bit
    const uint32_t Flash_CRCCR1_ALL_BANK = 1U << 7 ;

  // Field CRC_BY_SECT: Bank 1 CRC sector mode select bit
    const uint32_t Flash_CRCCR1_CRC_BY_SECT = 1U << 8 ;

  // Field ADD_SECT: Bank 1 CRC sector select bit
    const uint32_t Flash_CRCCR1_ADD_SECT = 1U << 9 ;

  // Field CLEAN_SECT: Bank 1 CRC sector list clear bit
    const uint32_t Flash_CRCCR1_CLEAN_SECT = 1U << 10 ;

  // Field START_CRC: Bank 1 CRC start bit
    const uint32_t Flash_CRCCR1_START_CRC = 1U << 16 ;

  // Field CLEAN_CRC: Bank 1 CRC clear bit
    const uint32_t Flash_CRCCR1_CLEAN_CRC = 1U << 17 ;

  // Field CRC_BURST: Bank 1 CRC burst size
    inline uint32_t Flash_CRCCR1_CRC_BURST (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register CRCSADD1R: FLASH CRC start address register for bank 1
  #define Flash_CRCSADD1R (* ((volatile uint32_t *) (0x52002000 + 84)))

  // Field CRC_START_ADDR: CRC start address on bank 1
    inline uint32_t Flash_CRCSADD1R_CRC_START_ADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCEADD1R: FLASH CRC end address register for bank 1
  #define Flash_CRCEADD1R (* ((volatile uint32_t *) (0x52002000 + 88)))

  // Field CRC_END_ADDR: CRC end address on bank 1
    inline uint32_t Flash_CRCEADD1R_CRC_END_ADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCDATAR: FLASH CRC data register
  #define Flash_CRCDATAR (* ((volatile uint32_t *) (0x52002000 + 92)))

  // Field CRC_DATA: CRC result
    inline uint32_t Flash_CRCDATAR_CRC_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ECC_FA1R: FLASH ECC fail address for bank 1
  #define Flash_ECC_FA1R (* ((const volatile uint32_t *) (0x52002000 + 96)))

  // Field FAIL_ECC_ADDR1: Bank 1 ECC error address
    inline uint32_t Flash_ECC_FA1R_FAIL_ECC_ADDR1 (const uint32_t inValue) {return (inValue & 0x7FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register KEYR2: FLASH key register for bank 2
  #define Flash_KEYR2 (* ((const volatile uint32_t *) (0x52002000 + 260)))

  // Field KEYR2: Bank 2 access configuration unlock key
    inline uint32_t Flash_KEYR2_KEYR2 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CR2: FLASH control register for bank 2
  #define Flash_CR2 (* ((volatile uint32_t *) (0x52002000 + 268)))

  // Field LOCK2: Bank 2 configuration lock bit
    const uint32_t Flash_CR2_LOCK2 = 1U << 0 ;

  // Field PG2: Bank 2 program enable bit
    const uint32_t Flash_CR2_PG2 = 1U << 1 ;

  // Field SER2: Bank 2 sector erase request
    const uint32_t Flash_CR2_SER2 = 1U << 2 ;

  // Field BER2: Bank 2 erase request
    const uint32_t Flash_CR2_BER2 = 1U << 3 ;

  // Field PSIZE2: Bank 2 program size
    inline uint32_t Flash_CR2_PSIZE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field FW2: Bank 2 write forcing control bit
    const uint32_t Flash_CR2_FW2 = 1U << 6 ;

  // Field START2: Bank 2 bank or sector erase start control bit
    const uint32_t Flash_CR2_START2 = 1U << 7 ;

  // Field SNB2: Bank 2 sector erase selection number
    inline uint32_t Flash_CR2_SNB2 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field CRC_EN: Bank 2 CRC control bit
    const uint32_t Flash_CR2_CRC_EN = 1U << 15 ;

  // Field EOPIE2: Bank 2 end-of-program interrupt control bit
    const uint32_t Flash_CR2_EOPIE2 = 1U << 16 ;

  // Field WRPERRIE2: Bank 2 write protection error interrupt enable bit
    const uint32_t Flash_CR2_WRPERRIE2 = 1U << 17 ;

  // Field PGSERRIE2: Bank 2 programming sequence error interrupt enable bit
    const uint32_t Flash_CR2_PGSERRIE2 = 1U << 18 ;

  // Field STRBERRIE2: Bank 2 strobe error interrupt enable bit
    const uint32_t Flash_CR2_STRBERRIE2 = 1U << 19 ;

  // Field INCERRIE2: Bank 2 inconsistency error interrupt enable bit
    const uint32_t Flash_CR2_INCERRIE2 = 1U << 21 ;

  // Field OPERRIE2: Bank 2 write/erase error interrupt enable bit
    const uint32_t Flash_CR2_OPERRIE2 = 1U << 22 ;

  // Field RDPERRIE2: Bank 2 read protection error interrupt enable bit
    const uint32_t Flash_CR2_RDPERRIE2 = 1U << 23 ;

  // Field RDSERRIE2: Bank 2 secure error interrupt enable bit
    const uint32_t Flash_CR2_RDSERRIE2 = 1U << 24 ;

  // Field SNECCERRIE2: Bank 2 ECC single correction error interrupt enable bit
    const uint32_t Flash_CR2_SNECCERRIE2 = 1U << 25 ;

  // Field DBECCERRIE2: Bank 2 ECC double detection error interrupt enable bit
    const uint32_t Flash_CR2_DBECCERRIE2 = 1U << 26 ;

  // Field CRCENDIE2: Bank 2 end of CRC calculation interrupt enable bit
    const uint32_t Flash_CR2_CRCENDIE2 = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register SR2: FLASH status register for bank 2
  #define Flash_SR2 (* ((volatile uint32_t *) (0x52002000 + 272)))

  // Field BSY2: Bank 2 ongoing program flag
    const uint32_t Flash_SR2_BSY2 = 1U << 0 ;

  // Field WBNE2: Bank 2 write buffer not empty flag
    const uint32_t Flash_SR2_WBNE2 = 1U << 1 ;

  // Field QW2: Bank 2 wait queue flag
    const uint32_t Flash_SR2_QW2 = 1U << 2 ;

  // Field CRC_BUSY2: Bank 2 CRC busy flag
    const uint32_t Flash_SR2_CRC_BUSY2 = 1U << 3 ;

  // Field EOP2: Bank 2 end-of-program flag
    const uint32_t Flash_SR2_EOP2 = 1U << 16 ;

  // Field WRPERR2: Bank 2 write protection error flag
    const uint32_t Flash_SR2_WRPERR2 = 1U << 17 ;

  // Field PGSERR2: Bank 2 programming sequence error flag
    const uint32_t Flash_SR2_PGSERR2 = 1U << 18 ;

  // Field STRBERR2: Bank 2 strobe error flag
    const uint32_t Flash_SR2_STRBERR2 = 1U << 19 ;

  // Field INCERR2: Bank 2 inconsistency error flag
    const uint32_t Flash_SR2_INCERR2 = 1U << 21 ;

  // Field OPERR2: Bank 2 write/erase error flag
    const uint32_t Flash_SR2_OPERR2 = 1U << 22 ;

  // Field RDPERR2: Bank 2 read protection error flag
    const uint32_t Flash_SR2_RDPERR2 = 1U << 23 ;

  // Field RDSERR2: Bank 2 secure error flag
    const uint32_t Flash_SR2_RDSERR2 = 1U << 24 ;

  // Field SNECCERR2: Bank 2 single correction error flag
    const uint32_t Flash_SR2_SNECCERR2 = 1U << 25 ;

  // Field DBECCERR2: Bank 2 ECC double detection error flag
    const uint32_t Flash_SR2_DBECCERR2 = 1U << 26 ;

  // Field CRCEND2: Bank 2 CRC-complete flag
    const uint32_t Flash_SR2_CRCEND2 = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register CCR2: FLASH clear control register for bank 2
  #define Flash_CCR2 (* ((volatile uint32_t *) (0x52002000 + 276)))

  // Field CLR_EOP2: Bank 1 EOP1 flag clear bit
    const uint32_t Flash_CCR2_CLR_EOP2 = 1U << 16 ;

  // Field CLR_WRPERR2: Bank 2 WRPERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_WRPERR2 = 1U << 17 ;

  // Field CLR_PGSERR2: Bank 2 PGSERR1 flag clear bi
    const uint32_t Flash_CCR2_CLR_PGSERR2 = 1U << 18 ;

  // Field CLR_STRBERR2: Bank 2 STRBERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_STRBERR2 = 1U << 19 ;

  // Field CLR_INCERR2: Bank 2 INCERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_INCERR2 = 1U << 21 ;

  // Field CLR_OPERR2: Bank 2 OPERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_OPERR2 = 1U << 22 ;

  // Field CLR_RDPERR2: Bank 2 RDPERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_RDPERR2 = 1U << 23 ;

  // Field CLR_RDSERR1: Bank 1 RDSERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_RDSERR1 = 1U << 24 ;

  // Field CLR_SNECCERR2: Bank 2 SNECCERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_SNECCERR2 = 1U << 25 ;

  // Field CLR_DBECCERR1: Bank 1 DBECCERR1 flag clear bit
    const uint32_t Flash_CCR2_CLR_DBECCERR1 = 1U << 26 ;

  // Field CLR_CRCEND2: Bank 2 CRCEND1 flag clear bit
    const uint32_t Flash_CCR2_CLR_CRCEND2 = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register PRAR_CUR2: FLASH protection address for bank 1
  #define Flash_PRAR_CUR2 (* ((const volatile uint32_t *) (0x52002000 + 296)))

  // Field PROT_AREA_START2: Bank 2 lowest PCROP protected address
    inline uint32_t Flash_PRAR_CUR2_PROT_AREA_START2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field PROT_AREA_END2: Bank 2 highest PCROP protected address
    inline uint32_t Flash_PRAR_CUR2_PROT_AREA_END2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMEP2: Bank 2 PCROP protected erase enable option status bit
    const uint32_t Flash_PRAR_CUR2_DMEP2 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PRAR_PRG2: FLASH protection address for bank 2
  #define Flash_PRAR_PRG2 (* ((volatile uint32_t *) (0x52002000 + 44)))

  // Field PROT_AREA_START2: Bank 2 lowest PCROP protected address configuration
    inline uint32_t Flash_PRAR_PRG2_PROT_AREA_START2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field PROT_AREA_END2: Bank 2 highest PCROP protected address configuration
    inline uint32_t Flash_PRAR_PRG2_PROT_AREA_END2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMEP2: Bank 2 PCROP protected erase enable option configuration bit
    const uint32_t Flash_PRAR_PRG2_DMEP2 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SCAR_CUR2: FLASH secure address for bank 2
  #define Flash_SCAR_CUR2 (* ((volatile uint32_t *) (0x52002000 + 304)))

  // Field SEC_AREA_START2: Bank 2 lowest secure protected address
    inline uint32_t Flash_SCAR_CUR2_SEC_AREA_START2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field SEC_AREA_END2: Bank 2 highest secure protected address
    inline uint32_t Flash_SCAR_CUR2_SEC_AREA_END2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMES2: Bank 2 secure protected erase enable option status bit
    const uint32_t Flash_SCAR_CUR2_DMES2 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register SCAR_PRG2: FLASH secure address for bank 2
  #define Flash_SCAR_PRG2 (* ((volatile uint32_t *) (0x52002000 + 308)))

  // Field SEC_AREA_START2: Bank 2 lowest secure protected address configuration
    inline uint32_t Flash_SCAR_PRG2_SEC_AREA_START2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field SEC_AREA_END2: Bank 2 highest secure protected address configuration
    inline uint32_t Flash_SCAR_PRG2_SEC_AREA_END2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field DMES2: Bank 2 secure protected erase enable option configuration bit
    const uint32_t Flash_SCAR_PRG2_DMES2 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register WPSN_CUR2R: FLASH write sector protection for bank 2
  #define Flash_WPSN_CUR2R (* ((const volatile uint32_t *) (0x52002000 + 312)))

  // Field WRPSn2: Bank 2 sector write protection option status byte
    inline uint32_t Flash_WPSN_CUR2R_WRPSn2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register WPSN_PRG2R: FLASH write sector protection for bank 2
  #define Flash_WPSN_PRG2R (* ((volatile uint32_t *) (0x52002000 + 316)))

  // Field WRPSn2: Bank 2 sector write protection configuration byte
    inline uint32_t Flash_WPSN_PRG2R_WRPSn2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCCR2: FLASH CRC control register for bank 1
  #define Flash_CRCCR2 (* ((volatile uint32_t *) (0x52002000 + 336)))

  // Field CRC_SECT: Bank 2 CRC sector number
    inline uint32_t Flash_CRCCR2_CRC_SECT (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field ALL_BANK: Bank 2 CRC select bit
    const uint32_t Flash_CRCCR2_ALL_BANK = 1U << 7 ;

  // Field CRC_BY_SECT: Bank 2 CRC sector mode select bit
    const uint32_t Flash_CRCCR2_CRC_BY_SECT = 1U << 8 ;

  // Field ADD_SECT: Bank 2 CRC sector select bit
    const uint32_t Flash_CRCCR2_ADD_SECT = 1U << 9 ;

  // Field CLEAN_SECT: Bank 2 CRC sector list clear bit
    const uint32_t Flash_CRCCR2_CLEAN_SECT = 1U << 10 ;

  // Field START_CRC: Bank 2 CRC start bit
    const uint32_t Flash_CRCCR2_START_CRC = 1U << 16 ;

  // Field CLEAN_CRC: Bank 2 CRC clear bit
    const uint32_t Flash_CRCCR2_CLEAN_CRC = 1U << 17 ;

  // Field CRC_BURST: Bank 2 CRC burst size
    inline uint32_t Flash_CRCCR2_CRC_BURST (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register CRCSADD2R: FLASH CRC start address register for bank 2
  #define Flash_CRCSADD2R (* ((volatile uint32_t *) (0x52002000 + 340)))

  // Field CRC_START_ADDR: CRC start address on bank 2
    inline uint32_t Flash_CRCSADD2R_CRC_START_ADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCEADD2R: FLASH CRC end address register for bank 2
  #define Flash_CRCEADD2R (* ((volatile uint32_t *) (0x52002000 + 344)))

  // Field CRC_END_ADDR: CRC end address on bank 2
    inline uint32_t Flash_CRCEADD2R_CRC_END_ADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ECC_FA2R: FLASH ECC fail address for bank 2
  #define Flash_ECC_FA2R (* ((const volatile uint32_t *) (0x52002000 + 352)))

  // Field FAIL_ECC_ADDR2: Bank 2 ECC error address
    inline uint32_t Flash_ECC_FA2R_FAIL_ECC_ADDR2 (const uint32_t inValue) {return (inValue & 0x7FFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOA: GPIO
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOA_MODER (* ((volatile uint32_t *) (0x58020000 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOA_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOA_OTYPER (* ((volatile uint32_t *) (0x58020000 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOA_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOA_OSPEEDR (* ((volatile uint32_t *) (0x58020000 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOA_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOA_PUPDR (* ((volatile uint32_t *) (0x58020000 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOA_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOA_IDR (* ((const volatile uint32_t *) (0x58020000 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOA_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOA_ODR (* ((volatile uint32_t *) (0x58020000 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOA_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOA_BSRR (* ((volatile uint32_t *) (0x58020000 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOA_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOA_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOA_LCKR (* ((volatile uint32_t *) (0x58020000 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOA_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOA_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOA_AFRL (* ((volatile uint32_t *) (0x58020000 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOA_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOA_AFRH (* ((volatile uint32_t *) (0x58020000 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOA_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOB
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOB_MODER (* ((volatile uint32_t *) (0x58020400 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOB_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOB_OTYPER (* ((volatile uint32_t *) (0x58020400 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOB_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOB_OSPEEDR (* ((volatile uint32_t *) (0x58020400 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOB_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOB_PUPDR (* ((volatile uint32_t *) (0x58020400 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOB_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOB_IDR (* ((const volatile uint32_t *) (0x58020400 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOB_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOB_ODR (* ((volatile uint32_t *) (0x58020400 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOB_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOB_BSRR (* ((volatile uint32_t *) (0x58020400 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOB_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOB_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOB_LCKR (* ((volatile uint32_t *) (0x58020400 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOB_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOB_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOB_AFRL (* ((volatile uint32_t *) (0x58020400 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOB_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOB_AFRH (* ((volatile uint32_t *) (0x58020400 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOB_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOC
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOC_MODER (* ((volatile uint32_t *) (0x58020800 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOC_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOC_OTYPER (* ((volatile uint32_t *) (0x58020800 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOC_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOC_OSPEEDR (* ((volatile uint32_t *) (0x58020800 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOC_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOC_PUPDR (* ((volatile uint32_t *) (0x58020800 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOC_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOC_IDR (* ((const volatile uint32_t *) (0x58020800 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOC_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOC_ODR (* ((volatile uint32_t *) (0x58020800 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOC_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOC_BSRR (* ((volatile uint32_t *) (0x58020800 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOC_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOC_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOC_LCKR (* ((volatile uint32_t *) (0x58020800 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOC_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOC_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOC_AFRL (* ((volatile uint32_t *) (0x58020800 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOC_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOC_AFRH (* ((volatile uint32_t *) (0x58020800 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOC_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOD
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOD_MODER (* ((volatile uint32_t *) (0x58020C00 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOD_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOD_OTYPER (* ((volatile uint32_t *) (0x58020C00 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOD_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOD_OSPEEDR (* ((volatile uint32_t *) (0x58020C00 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOD_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOD_PUPDR (* ((volatile uint32_t *) (0x58020C00 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOD_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOD_IDR (* ((const volatile uint32_t *) (0x58020C00 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOD_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOD_ODR (* ((volatile uint32_t *) (0x58020C00 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOD_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOD_BSRR (* ((volatile uint32_t *) (0x58020C00 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOD_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOD_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOD_LCKR (* ((volatile uint32_t *) (0x58020C00 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOD_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOD_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOD_AFRL (* ((volatile uint32_t *) (0x58020C00 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOD_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOD_AFRH (* ((volatile uint32_t *) (0x58020C00 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOD_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOE
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOE_MODER (* ((volatile uint32_t *) (0x58021000 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOE_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOE_OTYPER (* ((volatile uint32_t *) (0x58021000 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOE_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOE_OSPEEDR (* ((volatile uint32_t *) (0x58021000 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOE_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOE_PUPDR (* ((volatile uint32_t *) (0x58021000 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOE_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOE_IDR (* ((const volatile uint32_t *) (0x58021000 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOE_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOE_ODR (* ((volatile uint32_t *) (0x58021000 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOE_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOE_BSRR (* ((volatile uint32_t *) (0x58021000 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOE_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOE_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOE_LCKR (* ((volatile uint32_t *) (0x58021000 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOE_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOE_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOE_AFRL (* ((volatile uint32_t *) (0x58021000 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOE_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOE_AFRH (* ((volatile uint32_t *) (0x58021000 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOE_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOF
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOF_MODER (* ((volatile uint32_t *) (0x58021400 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOF_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOF_OTYPER (* ((volatile uint32_t *) (0x58021400 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOF_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOF_OSPEEDR (* ((volatile uint32_t *) (0x58021400 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOF_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOF_PUPDR (* ((volatile uint32_t *) (0x58021400 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOF_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOF_IDR (* ((const volatile uint32_t *) (0x58021400 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOF_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOF_ODR (* ((volatile uint32_t *) (0x58021400 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOF_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOF_BSRR (* ((volatile uint32_t *) (0x58021400 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOF_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOF_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOF_LCKR (* ((volatile uint32_t *) (0x58021400 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOF_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOF_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOF_AFRL (* ((volatile uint32_t *) (0x58021400 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOF_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOF_AFRH (* ((volatile uint32_t *) (0x58021400 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOF_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOG
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOG_MODER (* ((volatile uint32_t *) (0x58021800 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOG_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOG_OTYPER (* ((volatile uint32_t *) (0x58021800 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOG_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOG_OSPEEDR (* ((volatile uint32_t *) (0x58021800 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOG_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOG_PUPDR (* ((volatile uint32_t *) (0x58021800 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOG_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOG_IDR (* ((const volatile uint32_t *) (0x58021800 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOG_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOG_ODR (* ((volatile uint32_t *) (0x58021800 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOG_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOG_BSRR (* ((volatile uint32_t *) (0x58021800 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOG_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOG_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOG_LCKR (* ((volatile uint32_t *) (0x58021800 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOG_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOG_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOG_AFRL (* ((volatile uint32_t *) (0x58021800 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOG_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOG_AFRH (* ((volatile uint32_t *) (0x58021800 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOG_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOH
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOH_MODER (* ((volatile uint32_t *) (0x58021C00 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOH_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOH_OTYPER (* ((volatile uint32_t *) (0x58021C00 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOH_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOH_OSPEEDR (* ((volatile uint32_t *) (0x58021C00 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOH_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOH_PUPDR (* ((volatile uint32_t *) (0x58021C00 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOH_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOH_IDR (* ((const volatile uint32_t *) (0x58021C00 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOH_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOH_ODR (* ((volatile uint32_t *) (0x58021C00 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOH_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOH_BSRR (* ((volatile uint32_t *) (0x58021C00 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOH_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOH_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOH_LCKR (* ((volatile uint32_t *) (0x58021C00 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOH_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOH_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOH_AFRL (* ((volatile uint32_t *) (0x58021C00 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOH_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOH_AFRH (* ((volatile uint32_t *) (0x58021C00 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOH_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOI
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOI_MODER (* ((volatile uint32_t *) (0x58022000 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOI_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOI_OTYPER (* ((volatile uint32_t *) (0x58022000 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOI_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOI_OSPEEDR (* ((volatile uint32_t *) (0x58022000 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOI_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOI_PUPDR (* ((volatile uint32_t *) (0x58022000 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOI_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOI_IDR (* ((const volatile uint32_t *) (0x58022000 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOI_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOI_ODR (* ((volatile uint32_t *) (0x58022000 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOI_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOI_BSRR (* ((volatile uint32_t *) (0x58022000 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOI_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOI_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOI_LCKR (* ((volatile uint32_t *) (0x58022000 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOI_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOI_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOI_AFRL (* ((volatile uint32_t *) (0x58022000 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOI_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOI_AFRH (* ((volatile uint32_t *) (0x58022000 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOI_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOJ
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOJ_MODER (* ((volatile uint32_t *) (0x58022400 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOJ_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOJ_OTYPER (* ((volatile uint32_t *) (0x58022400 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOJ_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOJ_OSPEEDR (* ((volatile uint32_t *) (0x58022400 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOJ_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOJ_PUPDR (* ((volatile uint32_t *) (0x58022400 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOJ_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOJ_IDR (* ((const volatile uint32_t *) (0x58022400 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOJ_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOJ_ODR (* ((volatile uint32_t *) (0x58022400 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOJ_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOJ_BSRR (* ((volatile uint32_t *) (0x58022400 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOJ_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOJ_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOJ_LCKR (* ((volatile uint32_t *) (0x58022400 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOJ_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOJ_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOJ_AFRL (* ((volatile uint32_t *) (0x58022400 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOJ_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOJ_AFRH (* ((volatile uint32_t *) (0x58022400 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOJ_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral GPIOK
//------------------------------------------------------------------------------

//---  Register MODER: GPIO port mode register
  #define GPIOK_MODER (* ((volatile uint32_t *) (0x58022800 + 0)))

  // Field MODE0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field MODE1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field MODE2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MODE3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field MODE4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field MODE5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MODE6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field MODE7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field MODE8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field MODE9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MODE10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field MODE11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field MODE12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field MODE13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field MODE14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field MODE15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O mode.
    inline uint32_t GPIOK_MODER_MODE15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register OTYPER: GPIO port output type register
  #define GPIOK_OTYPER (* ((volatile uint32_t *) (0x58022800 + 4)))

  // Field OT0: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT0 = 1U << 0 ;

  // Field OT1: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT1 = 1U << 1 ;

  // Field OT2: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT2 = 1U << 2 ;

  // Field OT3: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT3 = 1U << 3 ;

  // Field OT4: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT4 = 1U << 4 ;

  // Field OT5: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT5 = 1U << 5 ;

  // Field OT6: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT6 = 1U << 6 ;

  // Field OT7: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT7 = 1U << 7 ;

  // Field OT8: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT8 = 1U << 8 ;

  // Field OT9: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT9 = 1U << 9 ;

  // Field OT10: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT10 = 1U << 10 ;

  // Field OT11: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT11 = 1U << 11 ;

  // Field OT12: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT12 = 1U << 12 ;

  // Field OT13: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT13 = 1U << 13 ;

  // Field OT14: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT14 = 1U << 14 ;

  // Field OT15: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output type.
    const uint32_t GPIOK_OTYPER_OT15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OSPEEDR: GPIO port output speed register
  #define GPIOK_OSPEEDR (* ((volatile uint32_t *) (0x58022800 + 8)))

  // Field OSPEED0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OSPEED1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field OSPEED2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field OSPEED3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field OSPEED4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSPEED5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field OSPEED6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field OSPEED7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field OSPEED8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field OSPEED9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field OSPEED10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field OSPEED11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field OSPEED12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field OSPEED13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field OSPEED14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field OSPEED15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O output speed. Note: Refer to the device datasheet for the frequency specifications and the power supply and load conditions for each speed.
    inline uint32_t GPIOK_OSPEEDR_OSPEED15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register PUPDR: GPIO port pull-up/pull-down register
  #define GPIOK_PUPDR (* ((volatile uint32_t *) (0x58022800 + 12)))

  // Field PUPD0: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD0 (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PUPD1: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PUPD2: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PUPD3: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PUPD4: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PUPD5: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PUPD6: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PUPD7: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD7 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field PUPD8: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD8 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field PUPD9: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD9 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field PUPD10: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD10 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PUPD11: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD11 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field PUPD12: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD12 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field PUPD13: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD13 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field PUPD14: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD14 (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field PUPD15: [1:0]: Port x configuration bits (y = 0..15) These bits are written by software to configure the I/O pull-up or pull-down
    inline uint32_t GPIOK_PUPDR_PUPD15 (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

//------------------------------------------------------------------------------

//---  Register IDR: GPIO port input data register
  #define GPIOK_IDR (* ((const volatile uint32_t *) (0x58022800 + 16)))

  // Field ID0: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID0 = 1U << 0 ;

  // Field ID1: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID1 = 1U << 1 ;

  // Field ID2: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID2 = 1U << 2 ;

  // Field ID3: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID3 = 1U << 3 ;

  // Field ID4: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID4 = 1U << 4 ;

  // Field ID5: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID5 = 1U << 5 ;

  // Field ID6: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID6 = 1U << 6 ;

  // Field ID7: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID7 = 1U << 7 ;

  // Field ID8: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID8 = 1U << 8 ;

  // Field ID9: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID9 = 1U << 9 ;

  // Field ID10: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID10 = 1U << 10 ;

  // Field ID11: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID11 = 1U << 11 ;

  // Field ID12: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID12 = 1U << 12 ;

  // Field ID13: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID13 = 1U << 13 ;

  // Field ID14: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID14 = 1U << 14 ;

  // Field ID15: Port input data bit (y = 0..15) These bits are read-only. They contain the input value of the corresponding I/O port.
    const uint32_t GPIOK_IDR_ID15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register ODR: GPIO port output data register
  #define GPIOK_ODR (* ((volatile uint32_t *) (0x58022800 + 20)))

  // Field OD0: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD0 = 1U << 0 ;

  // Field OD1: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD1 = 1U << 1 ;

  // Field OD2: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD2 = 1U << 2 ;

  // Field OD3: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD3 = 1U << 3 ;

  // Field OD4: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD4 = 1U << 4 ;

  // Field OD5: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD5 = 1U << 5 ;

  // Field OD6: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD6 = 1U << 6 ;

  // Field OD7: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD7 = 1U << 7 ;

  // Field OD8: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD8 = 1U << 8 ;

  // Field OD9: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD9 = 1U << 9 ;

  // Field OD10: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD10 = 1U << 10 ;

  // Field OD11: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD11 = 1U << 11 ;

  // Field OD12: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD12 = 1U << 12 ;

  // Field OD13: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD13 = 1U << 13 ;

  // Field OD14: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD14 = 1U << 14 ;

  // Field OD15: Port output data bit These bits can be read and written by software. Note: For atomic bit set/reset, the OD bits can be individually set and/or reset by writing to the GPIOx_BSRR or GPIOx_BRR registers (x = A..F).
    const uint32_t GPIOK_ODR_OD15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register BSRR: GPIO port bit set/reset register
  #define GPIOK_BSRR (* ((volatile uint32_t *) (0x58022800 + 24)))

  // Field BS0: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS0 = 1U << 0 ;

  // Field BS1: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS1 = 1U << 1 ;

  // Field BS2: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS2 = 1U << 2 ;

  // Field BS3: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS3 = 1U << 3 ;

  // Field BS4: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS4 = 1U << 4 ;

  // Field BS5: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS5 = 1U << 5 ;

  // Field BS6: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS6 = 1U << 6 ;

  // Field BS7: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS7 = 1U << 7 ;

  // Field BS8: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS8 = 1U << 8 ;

  // Field BS9: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS9 = 1U << 9 ;

  // Field BS10: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS10 = 1U << 10 ;

  // Field BS11: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS11 = 1U << 11 ;

  // Field BS12: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS12 = 1U << 12 ;

  // Field BS13: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS13 = 1U << 13 ;

  // Field BS14: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS14 = 1U << 14 ;

  // Field BS15: Port x set bit y (y= 0..15) These bits are write-only. A read to these bits returns the value 0x0000.
    const uint32_t GPIOK_BSRR_BS15 = 1U << 15 ;

  // Field BR0: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR0 = 1U << 16 ;

  // Field BR1: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR1 = 1U << 17 ;

  // Field BR2: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR2 = 1U << 18 ;

  // Field BR3: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR3 = 1U << 19 ;

  // Field BR4: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR4 = 1U << 20 ;

  // Field BR5: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR5 = 1U << 21 ;

  // Field BR6: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR6 = 1U << 22 ;

  // Field BR7: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR7 = 1U << 23 ;

  // Field BR8: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR8 = 1U << 24 ;

  // Field BR9: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR9 = 1U << 25 ;

  // Field BR10: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR10 = 1U << 26 ;

  // Field BR11: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR11 = 1U << 27 ;

  // Field BR12: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR12 = 1U << 28 ;

  // Field BR13: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR13 = 1U << 29 ;

  // Field BR14: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR14 = 1U << 30 ;

  // Field BR15: Port x reset bit y (y = 0..15) These bits are write-only. A read to these bits returns the value 0x0000. Note: If both BSx and BRx are set, BSx has priority.
    const uint32_t GPIOK_BSRR_BR15 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register LCKR: This register is used to lock the configuration of the port bits when a correct write sequence is applied to bit 16 (LCKK). The value of bits [15:0] is used to lock the configuration of the GPIO. During the write sequence, the value of LCKR[15:0] must not change. When the LOCK sequence has been applied on a port bit, the value of this port bit can no longer be modified until the next MCU reset or peripheral reset.A specific write sequence is used to write to the GPIOx_LCKR register. Only word access (32-bit long) is allowed during this locking sequence.Each lock bit freezes a specific configuration register (control and alternate function registers).
  #define GPIOK_LCKR (* ((volatile uint32_t *) (0x58022800 + 28)))

  // Field LCK0: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK0 = 1U << 0 ;

  // Field LCK1: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK1 = 1U << 1 ;

  // Field LCK2: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK2 = 1U << 2 ;

  // Field LCK3: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK3 = 1U << 3 ;

  // Field LCK4: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK4 = 1U << 4 ;

  // Field LCK5: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK5 = 1U << 5 ;

  // Field LCK6: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK6 = 1U << 6 ;

  // Field LCK7: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK7 = 1U << 7 ;

  // Field LCK8: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK8 = 1U << 8 ;

  // Field LCK9: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK9 = 1U << 9 ;

  // Field LCK10: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK10 = 1U << 10 ;

  // Field LCK11: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK11 = 1U << 11 ;

  // Field LCK12: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK12 = 1U << 12 ;

  // Field LCK13: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK13 = 1U << 13 ;

  // Field LCK14: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK14 = 1U << 14 ;

  // Field LCK15: Port x lock bit y (y= 0..15) These bits are read/write but can only be written when the LCKK bit is 0.
    const uint32_t GPIOK_LCKR_LCK15 = 1U << 15 ;

  // Field LCKK: Lock key This bit can be read any time. It can only be modified using the lock key write sequence. LOCK key write sequence: WR LCKR[16] = 1 + LCKR[15:0] WR LCKR[16] = 0 + LCKR[15:0] WR LCKR[16] = 1 + LCKR[15:0] RD LCKR RD LCKR[16] = 1 (this read operation is optional but it confirms that the lock is active) Note: During the LOCK key write sequence, the value of LCK[15:0] must not change. Any error in the lock sequence aborts the lock. After the first lock sequence on any bit of the port, any read access on the LCKK bit will return 1 until the next MCU reset or peripheral reset.
    const uint32_t GPIOK_LCKR_LCKK = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AFRL: GPIO alternate function low register
  #define GPIOK_AFRL (* ((volatile uint32_t *) (0x58022800 + 32)))

  // Field AFSEL0: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL1: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL2: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL3: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL4: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL4 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL5: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL5 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL6: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL6 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL7: [3:0]: Alternate function selection for port x pin y (y = 0..7) These bits are written by software to configure alternate function I/Os AFSELy selection:
    inline uint32_t GPIOK_AFRL_AFSEL7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register AFRH: GPIO alternate function high register
  #define GPIOK_AFRH (* ((volatile uint32_t *) (0x58022800 + 36)))

  // Field AFSEL8: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field AFSEL9: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field AFSEL10: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field AFSEL11: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field AFSEL12: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL12 (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field AFSEL13: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL13 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field AFSEL14: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL14 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field AFSEL15: [3:0]: Alternate function selection for port x pin y (y = 8..15) These bits are written by software to configure alternate function I/Os
    inline uint32_t GPIOK_AFRH_AFSEL15 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral HRTIM_Common: High Resolution Timer: Common       functions
//------------------------------------------------------------------------------

//---  Register CR1: Control Register 1
  #define HRTIM_Common_CR1 (* ((volatile uint32_t *) (0x40017780 + 0)))

  // Field AD4USRC: ADC Trigger 4 Update Source
    inline uint32_t HRTIM_Common_CR1_AD4USRC (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field AD3USRC: ADC Trigger 3 Update Source
    inline uint32_t HRTIM_Common_CR1_AD3USRC (const uint32_t inValue) {return (inValue & 0x7U) << 22 ; }

  // Field AD2USRC: ADC Trigger 2 Update Source
    inline uint32_t HRTIM_Common_CR1_AD2USRC (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field AD1USRC: ADC Trigger 1 Update Source
    inline uint32_t HRTIM_Common_CR1_AD1USRC (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field TEUDIS: Timer E Update Disable
    const uint32_t HRTIM_Common_CR1_TEUDIS = 1U << 5 ;

  // Field TDUDIS: Timer D Update Disable
    const uint32_t HRTIM_Common_CR1_TDUDIS = 1U << 4 ;

  // Field TCUDIS: Timer C Update Disable
    const uint32_t HRTIM_Common_CR1_TCUDIS = 1U << 3 ;

  // Field TBUDIS: Timer B Update Disable
    const uint32_t HRTIM_Common_CR1_TBUDIS = 1U << 2 ;

  // Field TAUDIS: Timer A Update Disable
    const uint32_t HRTIM_Common_CR1_TAUDIS = 1U << 1 ;

  // Field MUDIS: Master Update Disable
    const uint32_t HRTIM_Common_CR1_MUDIS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control Register 2
  #define HRTIM_Common_CR2 (* ((volatile uint32_t *) (0x40017780 + 4)))

  // Field TERST: Timer E counter software reset
    const uint32_t HRTIM_Common_CR2_TERST = 1U << 13 ;

  // Field TDRST: Timer D counter software reset
    const uint32_t HRTIM_Common_CR2_TDRST = 1U << 12 ;

  // Field TCRST: Timer C counter software reset
    const uint32_t HRTIM_Common_CR2_TCRST = 1U << 11 ;

  // Field TBRST: Timer B counter software reset
    const uint32_t HRTIM_Common_CR2_TBRST = 1U << 10 ;

  // Field TARST: Timer A counter software reset
    const uint32_t HRTIM_Common_CR2_TARST = 1U << 9 ;

  // Field MRST: Master Counter software reset
    const uint32_t HRTIM_Common_CR2_MRST = 1U << 8 ;

  // Field TESWU: Timer E Software Update
    const uint32_t HRTIM_Common_CR2_TESWU = 1U << 5 ;

  // Field TDSWU: Timer D Software Update
    const uint32_t HRTIM_Common_CR2_TDSWU = 1U << 4 ;

  // Field TCSWU: Timer C Software Update
    const uint32_t HRTIM_Common_CR2_TCSWU = 1U << 3 ;

  // Field TBSWU: Timer B Software Update
    const uint32_t HRTIM_Common_CR2_TBSWU = 1U << 2 ;

  // Field TASWU: Timer A Software update
    const uint32_t HRTIM_Common_CR2_TASWU = 1U << 1 ;

  // Field MSWU: Master Timer Software update
    const uint32_t HRTIM_Common_CR2_MSWU = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt Status Register
  #define HRTIM_Common_ISR (* ((volatile uint32_t *) (0x40017780 + 8)))

  // Field BMPER: Burst mode Period Interrupt Flag
    const uint32_t HRTIM_Common_ISR_BMPER = 1U << 17 ;

  // Field DLLRDY: DLL Ready Interrupt Flag
    const uint32_t HRTIM_Common_ISR_DLLRDY = 1U << 16 ;

  // Field SYSFLT: System Fault Interrupt Flag
    const uint32_t HRTIM_Common_ISR_SYSFLT = 1U << 5 ;

  // Field FLT5: Fault 5 Interrupt Flag
    const uint32_t HRTIM_Common_ISR_FLT5 = 1U << 4 ;

  // Field FLT4: Fault 4 Interrupt Flag
    const uint32_t HRTIM_Common_ISR_FLT4 = 1U << 3 ;

  // Field FLT3: Fault 3 Interrupt Flag
    const uint32_t HRTIM_Common_ISR_FLT3 = 1U << 2 ;

  // Field FLT2: Fault 2 Interrupt Flag
    const uint32_t HRTIM_Common_ISR_FLT2 = 1U << 1 ;

  // Field FLT1: Fault 1 Interrupt Flag
    const uint32_t HRTIM_Common_ISR_FLT1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define HRTIM_Common_ICR (* ((volatile uint32_t *) (0x40017780 + 12)))

  // Field BMPERC: Burst mode period flag Clear
    const uint32_t HRTIM_Common_ICR_BMPERC = 1U << 17 ;

  // Field DLLRDYC: DLL Ready Interrupt flag Clear
    const uint32_t HRTIM_Common_ICR_DLLRDYC = 1U << 16 ;

  // Field SYSFLTC: System Fault Interrupt Flag Clear
    const uint32_t HRTIM_Common_ICR_SYSFLTC = 1U << 5 ;

  // Field FLT5C: Fault 5 Interrupt Flag Clear
    const uint32_t HRTIM_Common_ICR_FLT5C = 1U << 4 ;

  // Field FLT4C: Fault 4 Interrupt Flag Clear
    const uint32_t HRTIM_Common_ICR_FLT4C = 1U << 3 ;

  // Field FLT3C: Fault 3 Interrupt Flag Clear
    const uint32_t HRTIM_Common_ICR_FLT3C = 1U << 2 ;

  // Field FLT2C: Fault 2 Interrupt Flag Clear
    const uint32_t HRTIM_Common_ICR_FLT2C = 1U << 1 ;

  // Field FLT1C: Fault 1 Interrupt Flag Clear
    const uint32_t HRTIM_Common_ICR_FLT1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define HRTIM_Common_IER (* ((volatile uint32_t *) (0x40017780 + 16)))

  // Field BMPERIE: Burst mode period Interrupt Enable
    const uint32_t HRTIM_Common_IER_BMPERIE = 1U << 17 ;

  // Field DLLRDYIE: DLL Ready Interrupt Enable
    const uint32_t HRTIM_Common_IER_DLLRDYIE = 1U << 16 ;

  // Field SYSFLTE: System Fault Interrupt Enable
    const uint32_t HRTIM_Common_IER_SYSFLTE = 1U << 5 ;

  // Field FLT5IE: Fault 5 Interrupt Enable
    const uint32_t HRTIM_Common_IER_FLT5IE = 1U << 4 ;

  // Field FLT4IE: Fault 4 Interrupt Enable
    const uint32_t HRTIM_Common_IER_FLT4IE = 1U << 3 ;

  // Field FLT3IE: Fault 3 Interrupt Enable
    const uint32_t HRTIM_Common_IER_FLT3IE = 1U << 2 ;

  // Field FLT2IE: Fault 2 Interrupt Enable
    const uint32_t HRTIM_Common_IER_FLT2IE = 1U << 1 ;

  // Field FLT1IE: Fault 1 Interrupt Enable
    const uint32_t HRTIM_Common_IER_FLT1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register OENR: Output Enable Register
  #define HRTIM_Common_OENR (* ((volatile uint32_t *) (0x40017780 + 20)))

  // Field TE2OEN: Timer E Output 2 Enable
    const uint32_t HRTIM_Common_OENR_TE2OEN = 1U << 9 ;

  // Field TE1OEN: Timer E Output 1 Enable
    const uint32_t HRTIM_Common_OENR_TE1OEN = 1U << 8 ;

  // Field TD2OEN: Timer D Output 2 Enable
    const uint32_t HRTIM_Common_OENR_TD2OEN = 1U << 7 ;

  // Field TD1OEN: Timer D Output 1 Enable
    const uint32_t HRTIM_Common_OENR_TD1OEN = 1U << 6 ;

  // Field TC2OEN: Timer C Output 2 Enable
    const uint32_t HRTIM_Common_OENR_TC2OEN = 1U << 5 ;

  // Field TC1OEN: Timer C Output 1 Enable
    const uint32_t HRTIM_Common_OENR_TC1OEN = 1U << 4 ;

  // Field TB2OEN: Timer B Output 2 Enable
    const uint32_t HRTIM_Common_OENR_TB2OEN = 1U << 3 ;

  // Field TB1OEN: Timer B Output 1 Enable
    const uint32_t HRTIM_Common_OENR_TB1OEN = 1U << 2 ;

  // Field TA2OEN: Timer A Output 2 Enable
    const uint32_t HRTIM_Common_OENR_TA2OEN = 1U << 1 ;

  // Field TA1OEN: Timer A Output 1 Enable
    const uint32_t HRTIM_Common_OENR_TA1OEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register DISR: DISR
  #define HRTIM_Common_DISR (* ((volatile uint32_t *) (0x40017780 + 24)))

  // Field TE2ODIS: TE2ODIS
    const uint32_t HRTIM_Common_DISR_TE2ODIS = 1U << 9 ;

  // Field TE1ODIS: TE1ODIS
    const uint32_t HRTIM_Common_DISR_TE1ODIS = 1U << 8 ;

  // Field TD2ODIS: TD2ODIS
    const uint32_t HRTIM_Common_DISR_TD2ODIS = 1U << 7 ;

  // Field TD1ODIS: TD1ODIS
    const uint32_t HRTIM_Common_DISR_TD1ODIS = 1U << 6 ;

  // Field TC2ODIS: TC2ODIS
    const uint32_t HRTIM_Common_DISR_TC2ODIS = 1U << 5 ;

  // Field TC1ODIS: TC1ODIS
    const uint32_t HRTIM_Common_DISR_TC1ODIS = 1U << 4 ;

  // Field TB2ODIS: TB2ODIS
    const uint32_t HRTIM_Common_DISR_TB2ODIS = 1U << 3 ;

  // Field TB1ODIS: TB1ODIS
    const uint32_t HRTIM_Common_DISR_TB1ODIS = 1U << 2 ;

  // Field TA2ODIS: TA2ODIS
    const uint32_t HRTIM_Common_DISR_TA2ODIS = 1U << 1 ;

  // Field TA1ODIS: TA1ODIS
    const uint32_t HRTIM_Common_DISR_TA1ODIS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ODSR: Output Disable Status Register
  #define HRTIM_Common_ODSR (* ((const volatile uint32_t *) (0x40017780 + 28)))

  // Field TE2ODS: Timer E Output 2 disable status
    const uint32_t HRTIM_Common_ODSR_TE2ODS = 1U << 9 ;

  // Field TE1ODS: Timer E Output 1 disable status
    const uint32_t HRTIM_Common_ODSR_TE1ODS = 1U << 8 ;

  // Field TD2ODS: Timer D Output 2 disable status
    const uint32_t HRTIM_Common_ODSR_TD2ODS = 1U << 7 ;

  // Field TD1ODS: Timer D Output 1 disable status
    const uint32_t HRTIM_Common_ODSR_TD1ODS = 1U << 6 ;

  // Field TC2ODS: Timer C Output 2 disable status
    const uint32_t HRTIM_Common_ODSR_TC2ODS = 1U << 5 ;

  // Field TC1ODS: Timer C Output 1 disable status
    const uint32_t HRTIM_Common_ODSR_TC1ODS = 1U << 4 ;

  // Field TB2ODS: Timer B Output 2 disable status
    const uint32_t HRTIM_Common_ODSR_TB2ODS = 1U << 3 ;

  // Field TB1ODS: Timer B Output 1 disable status
    const uint32_t HRTIM_Common_ODSR_TB1ODS = 1U << 2 ;

  // Field TA2ODS: Timer A Output 2 disable status
    const uint32_t HRTIM_Common_ODSR_TA2ODS = 1U << 1 ;

  // Field TA1ODS: Timer A Output 1 disable status
    const uint32_t HRTIM_Common_ODSR_TA1ODS = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BMCR: Burst Mode Control Register
  #define HRTIM_Common_BMCR (* ((volatile uint32_t *) (0x40017780 + 32)))

  // Field BMSTAT: Burst Mode Status
    const uint32_t HRTIM_Common_BMCR_BMSTAT = 1U << 31 ;

  // Field TEBM: Timer E Burst Mode
    const uint32_t HRTIM_Common_BMCR_TEBM = 1U << 21 ;

  // Field TDBM: Timer D Burst Mode
    const uint32_t HRTIM_Common_BMCR_TDBM = 1U << 20 ;

  // Field TCBM: Timer C Burst Mode
    const uint32_t HRTIM_Common_BMCR_TCBM = 1U << 19 ;

  // Field TBBM: Timer B Burst Mode
    const uint32_t HRTIM_Common_BMCR_TBBM = 1U << 18 ;

  // Field TABM: Timer A Burst Mode
    const uint32_t HRTIM_Common_BMCR_TABM = 1U << 17 ;

  // Field MTBM: Master Timer Burst Mode
    const uint32_t HRTIM_Common_BMCR_MTBM = 1U << 16 ;

  // Field BMPREN: Burst Mode Preload Enable
    const uint32_t HRTIM_Common_BMCR_BMPREN = 1U << 10 ;

  // Field BMPRSC: Burst Mode Prescaler
    inline uint32_t HRTIM_Common_BMCR_BMPRSC (const uint32_t inValue) {return (inValue & 0xFU) << 6 ; }

  // Field BMCLK: Burst Mode Clock source
    inline uint32_t HRTIM_Common_BMCR_BMCLK (const uint32_t inValue) {return (inValue & 0xFU) << 2 ; }

  // Field BMOM: Burst Mode operating mode
    const uint32_t HRTIM_Common_BMCR_BMOM = 1U << 1 ;

  // Field BME: Burst Mode enable
    const uint32_t HRTIM_Common_BMCR_BME = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BMTRG: BMTRG
  #define HRTIM_Common_BMTRG (* ((volatile uint32_t *) (0x40017780 + 36)))

  // Field OCHPEV: OCHPEV
    const uint32_t HRTIM_Common_BMTRG_OCHPEV = 1U << 31 ;

  // Field TECMP2: TECMP2
    const uint32_t HRTIM_Common_BMTRG_TECMP2 = 1U << 26 ;

  // Field TECMP1: TECMP1
    const uint32_t HRTIM_Common_BMTRG_TECMP1 = 1U << 25 ;

  // Field TEREP: TEREP
    const uint32_t HRTIM_Common_BMTRG_TEREP = 1U << 24 ;

  // Field TERST: TERST
    const uint32_t HRTIM_Common_BMTRG_TERST = 1U << 23 ;

  // Field TDCMP2: TDCMP2
    const uint32_t HRTIM_Common_BMTRG_TDCMP2 = 1U << 22 ;

  // Field TDCMP1: TDCMP1
    const uint32_t HRTIM_Common_BMTRG_TDCMP1 = 1U << 21 ;

  // Field TDREP: TDREP
    const uint32_t HRTIM_Common_BMTRG_TDREP = 1U << 20 ;

  // Field TDRST: TDRST
    const uint32_t HRTIM_Common_BMTRG_TDRST = 1U << 19 ;

  // Field TCCMP2: TCCMP2
    const uint32_t HRTIM_Common_BMTRG_TCCMP2 = 1U << 18 ;

  // Field TCCMP1: TCCMP1
    const uint32_t HRTIM_Common_BMTRG_TCCMP1 = 1U << 17 ;

  // Field TCREP: TCREP
    const uint32_t HRTIM_Common_BMTRG_TCREP = 1U << 16 ;

  // Field TCRST: TCRST
    const uint32_t HRTIM_Common_BMTRG_TCRST = 1U << 15 ;

  // Field TBCMP2: TBCMP2
    const uint32_t HRTIM_Common_BMTRG_TBCMP2 = 1U << 14 ;

  // Field TBCMP1: TBCMP1
    const uint32_t HRTIM_Common_BMTRG_TBCMP1 = 1U << 13 ;

  // Field TBREP: TBREP
    const uint32_t HRTIM_Common_BMTRG_TBREP = 1U << 12 ;

  // Field TBRST: TBRST
    const uint32_t HRTIM_Common_BMTRG_TBRST = 1U << 11 ;

  // Field TACMP2: TACMP2
    const uint32_t HRTIM_Common_BMTRG_TACMP2 = 1U << 10 ;

  // Field TACMP1: TACMP1
    const uint32_t HRTIM_Common_BMTRG_TACMP1 = 1U << 9 ;

  // Field TAREP: TAREP
    const uint32_t HRTIM_Common_BMTRG_TAREP = 1U << 8 ;

  // Field TARST: TARST
    const uint32_t HRTIM_Common_BMTRG_TARST = 1U << 7 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_Common_BMTRG_MSTCMP4 = 1U << 6 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_Common_BMTRG_MSTCMP3 = 1U << 5 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_Common_BMTRG_MSTCMP2 = 1U << 4 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_Common_BMTRG_MSTCMP1 = 1U << 3 ;

  // Field MSTREP: MSTREP
    const uint32_t HRTIM_Common_BMTRG_MSTREP = 1U << 2 ;

  // Field MSTRST: MSTRST
    const uint32_t HRTIM_Common_BMTRG_MSTRST = 1U << 1 ;

  // Field SW: SW
    const uint32_t HRTIM_Common_BMTRG_SW = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BMCMPR6: BMCMPR6
  #define HRTIM_Common_BMCMPR6 (* ((volatile uint32_t *) (0x40017780 + 40)))

  // Field BMCMP: BMCMP
    inline uint32_t HRTIM_Common_BMCMPR6_BMCMP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BMPER: Burst Mode Period Register
  #define HRTIM_Common_BMPER (* ((volatile uint32_t *) (0x40017780 + 44)))

  // Field BMPER: Burst mode Period
    inline uint32_t HRTIM_Common_BMPER_BMPER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EECR1: Timer External Event Control Register 1
  #define HRTIM_Common_EECR1 (* ((volatile uint32_t *) (0x40017780 + 48)))

  // Field EE5FAST: External Event 5 Fast mode
    const uint32_t HRTIM_Common_EECR1_EE5FAST = 1U << 29 ;

  // Field EE5SNS: External Event 5 Sensitivity
    inline uint32_t HRTIM_Common_EECR1_EE5SNS (const uint32_t inValue) {return (inValue & 0x3U) << 27 ; }

  // Field EE5POL: External Event 5 Polarity
    const uint32_t HRTIM_Common_EECR1_EE5POL = 1U << 26 ;

  // Field EE5SRC: External Event 5 Source
    inline uint32_t HRTIM_Common_EECR1_EE5SRC (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field EE4FAST: External Event 4 Fast mode
    const uint32_t HRTIM_Common_EECR1_EE4FAST = 1U << 23 ;

  // Field EE4SNS: External Event 4 Sensitivity
    inline uint32_t HRTIM_Common_EECR1_EE4SNS (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field EE4POL: External Event 4 Polarity
    const uint32_t HRTIM_Common_EECR1_EE4POL = 1U << 20 ;

  // Field EE4SRC: External Event 4 Source
    inline uint32_t HRTIM_Common_EECR1_EE4SRC (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field EE3FAST: External Event 3 Fast mode
    const uint32_t HRTIM_Common_EECR1_EE3FAST = 1U << 17 ;

  // Field EE3SNS: External Event 3 Sensitivity
    inline uint32_t HRTIM_Common_EECR1_EE3SNS (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field EE3POL: External Event 3 Polarity
    const uint32_t HRTIM_Common_EECR1_EE3POL = 1U << 14 ;

  // Field EE3SRC: External Event 3 Source
    inline uint32_t HRTIM_Common_EECR1_EE3SRC (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field EE2FAST: External Event 2 Fast mode
    const uint32_t HRTIM_Common_EECR1_EE2FAST = 1U << 11 ;

  // Field EE2SNS: External Event 2 Sensitivity
    inline uint32_t HRTIM_Common_EECR1_EE2SNS (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field EE2POL: External Event 2 Polarity
    const uint32_t HRTIM_Common_EECR1_EE2POL = 1U << 8 ;

  // Field EE2SRC: External Event 2 Source
    inline uint32_t HRTIM_Common_EECR1_EE2SRC (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field EE1FAST: External Event 1 Fast mode
    const uint32_t HRTIM_Common_EECR1_EE1FAST = 1U << 5 ;

  // Field EE1SNS: External Event 1 Sensitivity
    inline uint32_t HRTIM_Common_EECR1_EE1SNS (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field EE1POL: External Event 1 Polarity
    const uint32_t HRTIM_Common_EECR1_EE1POL = 1U << 2 ;

  // Field EE1SRC: External Event 1 Source
    inline uint32_t HRTIM_Common_EECR1_EE1SRC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EECR2: Timer External Event Control Register 2
  #define HRTIM_Common_EECR2 (* ((volatile uint32_t *) (0x40017780 + 52)))

  // Field EE10SNS: External Event 10 Sensitivity
    inline uint32_t HRTIM_Common_EECR2_EE10SNS (const uint32_t inValue) {return (inValue & 0x3U) << 27 ; }

  // Field EE10POL: External Event 10 Polarity
    const uint32_t HRTIM_Common_EECR2_EE10POL = 1U << 26 ;

  // Field EE10SRC: External Event 10 Source
    inline uint32_t HRTIM_Common_EECR2_EE10SRC (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field EE9SNS: External Event 9 Sensitivity
    inline uint32_t HRTIM_Common_EECR2_EE9SNS (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field EE9POL: External Event 9 Polarity
    const uint32_t HRTIM_Common_EECR2_EE9POL = 1U << 20 ;

  // Field EE9SRC: External Event 9 Source
    inline uint32_t HRTIM_Common_EECR2_EE9SRC (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field EE8SNS: External Event 8 Sensitivity
    inline uint32_t HRTIM_Common_EECR2_EE8SNS (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field EE8POL: External Event 8 Polarity
    const uint32_t HRTIM_Common_EECR2_EE8POL = 1U << 14 ;

  // Field EE8SRC: External Event 8 Source
    inline uint32_t HRTIM_Common_EECR2_EE8SRC (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field EE7SNS: External Event 7 Sensitivity
    inline uint32_t HRTIM_Common_EECR2_EE7SNS (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field EE7POL: External Event 7 Polarity
    const uint32_t HRTIM_Common_EECR2_EE7POL = 1U << 8 ;

  // Field EE7SRC: External Event 7 Source
    inline uint32_t HRTIM_Common_EECR2_EE7SRC (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field EE6SNS: External Event 6 Sensitivity
    inline uint32_t HRTIM_Common_EECR2_EE6SNS (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field EE6POL: External Event 6 Polarity
    const uint32_t HRTIM_Common_EECR2_EE6POL = 1U << 2 ;

  // Field EE6SRC: External Event 6 Source
    inline uint32_t HRTIM_Common_EECR2_EE6SRC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EECR3: Timer External Event Control Register 3
  #define HRTIM_Common_EECR3 (* ((volatile uint32_t *) (0x40017780 + 56)))

  // Field EE10SNS: EE10SNS
    inline uint32_t HRTIM_Common_EECR3_EE10SNS (const uint32_t inValue) {return (inValue & 0x3U) << 27 ; }

  // Field EE10POL: EE10POL
    const uint32_t HRTIM_Common_EECR3_EE10POL = 1U << 26 ;

  // Field EE10SRC: EE10SRC
    inline uint32_t HRTIM_Common_EECR3_EE10SRC (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field EE9SNS: EE9SNS
    inline uint32_t HRTIM_Common_EECR3_EE9SNS (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field EE9POL: EE9POL
    const uint32_t HRTIM_Common_EECR3_EE9POL = 1U << 20 ;

  // Field EE9SRC: EE9SRC
    inline uint32_t HRTIM_Common_EECR3_EE9SRC (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field EE8SNS: EE8SNS
    inline uint32_t HRTIM_Common_EECR3_EE8SNS (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field EE8POL: EE8POL
    const uint32_t HRTIM_Common_EECR3_EE8POL = 1U << 14 ;

  // Field EE8SRC: EE8SRC
    inline uint32_t HRTIM_Common_EECR3_EE8SRC (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field EE7SNS: EE7SNS
    inline uint32_t HRTIM_Common_EECR3_EE7SNS (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field EE7POL: EE7POL
    const uint32_t HRTIM_Common_EECR3_EE7POL = 1U << 8 ;

  // Field EE7SRC: EE7SRC
    inline uint32_t HRTIM_Common_EECR3_EE7SRC (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field EE6SNS: EE6SNS
    inline uint32_t HRTIM_Common_EECR3_EE6SNS (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field EE6POL: EE6POL
    const uint32_t HRTIM_Common_EECR3_EE6POL = 1U << 2 ;

  // Field EE6SRC: EE6SRC
    inline uint32_t HRTIM_Common_EECR3_EE6SRC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ADC1R: ADC Trigger 1 Register
  #define HRTIM_Common_ADC1R (* ((volatile uint32_t *) (0x40017780 + 60)))

  // Field AD1TEPER: ADC trigger 1 on Timer E Period
    const uint32_t HRTIM_Common_ADC1R_AD1TEPER = 1U << 31 ;

  // Field AD1TEC4: ADC trigger 1 on Timer E compare 4
    const uint32_t HRTIM_Common_ADC1R_AD1TEC4 = 1U << 30 ;

  // Field AD1TEC3: ADC trigger 1 on Timer E compare 3
    const uint32_t HRTIM_Common_ADC1R_AD1TEC3 = 1U << 29 ;

  // Field AD1TEC2: ADC trigger 1 on Timer E compare 2
    const uint32_t HRTIM_Common_ADC1R_AD1TEC2 = 1U << 28 ;

  // Field AD1TDPER: ADC trigger 1 on Timer D Period
    const uint32_t HRTIM_Common_ADC1R_AD1TDPER = 1U << 27 ;

  // Field AD1TDC4: ADC trigger 1 on Timer D compare 4
    const uint32_t HRTIM_Common_ADC1R_AD1TDC4 = 1U << 26 ;

  // Field AD1TDC3: ADC trigger 1 on Timer D compare 3
    const uint32_t HRTIM_Common_ADC1R_AD1TDC3 = 1U << 25 ;

  // Field AD1TDC2: ADC trigger 1 on Timer D compare 2
    const uint32_t HRTIM_Common_ADC1R_AD1TDC2 = 1U << 24 ;

  // Field AD1TCPER: ADC trigger 1 on Timer C Period
    const uint32_t HRTIM_Common_ADC1R_AD1TCPER = 1U << 23 ;

  // Field AD1TCC4: ADC trigger 1 on Timer C compare 4
    const uint32_t HRTIM_Common_ADC1R_AD1TCC4 = 1U << 22 ;

  // Field AD1TCC3: ADC trigger 1 on Timer C compare 3
    const uint32_t HRTIM_Common_ADC1R_AD1TCC3 = 1U << 21 ;

  // Field AD1TCC2: ADC trigger 1 on Timer C compare 2
    const uint32_t HRTIM_Common_ADC1R_AD1TCC2 = 1U << 20 ;

  // Field AD1TBRST: ADC trigger 1 on Timer B Reset
    const uint32_t HRTIM_Common_ADC1R_AD1TBRST = 1U << 19 ;

  // Field AD1TBPER: ADC trigger 1 on Timer B Period
    const uint32_t HRTIM_Common_ADC1R_AD1TBPER = 1U << 18 ;

  // Field AD1TBC4: ADC trigger 1 on Timer B compare 4
    const uint32_t HRTIM_Common_ADC1R_AD1TBC4 = 1U << 17 ;

  // Field AD1TBC3: ADC trigger 1 on Timer B compare 3
    const uint32_t HRTIM_Common_ADC1R_AD1TBC3 = 1U << 16 ;

  // Field AD1TBC2: ADC trigger 1 on Timer B compare 2
    const uint32_t HRTIM_Common_ADC1R_AD1TBC2 = 1U << 15 ;

  // Field AD1TARST: ADC trigger 1 on Timer A Reset
    const uint32_t HRTIM_Common_ADC1R_AD1TARST = 1U << 14 ;

  // Field AD1TAPER: ADC trigger 1 on Timer A Period
    const uint32_t HRTIM_Common_ADC1R_AD1TAPER = 1U << 13 ;

  // Field AD1TAC4: ADC trigger 1 on Timer A compare 4
    const uint32_t HRTIM_Common_ADC1R_AD1TAC4 = 1U << 12 ;

  // Field AD1TAC3: ADC trigger 1 on Timer A compare 3
    const uint32_t HRTIM_Common_ADC1R_AD1TAC3 = 1U << 11 ;

  // Field AD1TAC2: ADC trigger 1 on Timer A compare 2
    const uint32_t HRTIM_Common_ADC1R_AD1TAC2 = 1U << 10 ;

  // Field AD1EEV5: ADC trigger 1 on External Event 5
    const uint32_t HRTIM_Common_ADC1R_AD1EEV5 = 1U << 9 ;

  // Field AD1EEV4: ADC trigger 1 on External Event 4
    const uint32_t HRTIM_Common_ADC1R_AD1EEV4 = 1U << 8 ;

  // Field AD1EEV3: ADC trigger 1 on External Event 3
    const uint32_t HRTIM_Common_ADC1R_AD1EEV3 = 1U << 7 ;

  // Field AD1EEV2: ADC trigger 1 on External Event 2
    const uint32_t HRTIM_Common_ADC1R_AD1EEV2 = 1U << 6 ;

  // Field AD1EEV1: ADC trigger 1 on External Event 1
    const uint32_t HRTIM_Common_ADC1R_AD1EEV1 = 1U << 5 ;

  // Field AD1MPER: ADC trigger 1 on Master Period
    const uint32_t HRTIM_Common_ADC1R_AD1MPER = 1U << 4 ;

  // Field AD1MC4: ADC trigger 1 on Master Compare 4
    const uint32_t HRTIM_Common_ADC1R_AD1MC4 = 1U << 3 ;

  // Field AD1MC3: ADC trigger 1 on Master Compare 3
    const uint32_t HRTIM_Common_ADC1R_AD1MC3 = 1U << 2 ;

  // Field AD1MC2: ADC trigger 1 on Master Compare 2
    const uint32_t HRTIM_Common_ADC1R_AD1MC2 = 1U << 1 ;

  // Field AD1MC1: ADC trigger 1 on Master Compare 1
    const uint32_t HRTIM_Common_ADC1R_AD1MC1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ADC2R: ADC Trigger 2 Register
  #define HRTIM_Common_ADC2R (* ((volatile uint32_t *) (0x40017780 + 64)))

  // Field AD2TERST: ADC trigger 2 on Timer E Reset
    const uint32_t HRTIM_Common_ADC2R_AD2TERST = 1U << 31 ;

  // Field AD2TEC4: ADC trigger 2 on Timer E compare 4
    const uint32_t HRTIM_Common_ADC2R_AD2TEC4 = 1U << 30 ;

  // Field AD2TEC3: ADC trigger 2 on Timer E compare 3
    const uint32_t HRTIM_Common_ADC2R_AD2TEC3 = 1U << 29 ;

  // Field AD2TEC2: ADC trigger 2 on Timer E compare 2
    const uint32_t HRTIM_Common_ADC2R_AD2TEC2 = 1U << 28 ;

  // Field AD2TDRST: ADC trigger 2 on Timer D Reset
    const uint32_t HRTIM_Common_ADC2R_AD2TDRST = 1U << 27 ;

  // Field AD2TDPER: ADC trigger 2 on Timer D Period
    const uint32_t HRTIM_Common_ADC2R_AD2TDPER = 1U << 26 ;

  // Field AD2TDC4: ADC trigger 2 on Timer D compare 4
    const uint32_t HRTIM_Common_ADC2R_AD2TDC4 = 1U << 25 ;

  // Field AD2TDC3: ADC trigger 2 on Timer D compare 3
    const uint32_t HRTIM_Common_ADC2R_AD2TDC3 = 1U << 24 ;

  // Field AD2TDC2: ADC trigger 2 on Timer D compare 2
    const uint32_t HRTIM_Common_ADC2R_AD2TDC2 = 1U << 23 ;

  // Field AD2TCRST: ADC trigger 2 on Timer C Reset
    const uint32_t HRTIM_Common_ADC2R_AD2TCRST = 1U << 22 ;

  // Field AD2TCPER: ADC trigger 2 on Timer C Period
    const uint32_t HRTIM_Common_ADC2R_AD2TCPER = 1U << 21 ;

  // Field AD2TCC4: ADC trigger 2 on Timer C compare 4
    const uint32_t HRTIM_Common_ADC2R_AD2TCC4 = 1U << 20 ;

  // Field AD2TCC3: ADC trigger 2 on Timer C compare 3
    const uint32_t HRTIM_Common_ADC2R_AD2TCC3 = 1U << 19 ;

  // Field AD2TCC2: ADC trigger 2 on Timer C compare 2
    const uint32_t HRTIM_Common_ADC2R_AD2TCC2 = 1U << 18 ;

  // Field AD2TBPER: ADC trigger 2 on Timer B Period
    const uint32_t HRTIM_Common_ADC2R_AD2TBPER = 1U << 17 ;

  // Field AD2TBC4: ADC trigger 2 on Timer B compare 4
    const uint32_t HRTIM_Common_ADC2R_AD2TBC4 = 1U << 16 ;

  // Field AD2TBC3: ADC trigger 2 on Timer B compare 3
    const uint32_t HRTIM_Common_ADC2R_AD2TBC3 = 1U << 15 ;

  // Field AD2TBC2: ADC trigger 2 on Timer B compare 2
    const uint32_t HRTIM_Common_ADC2R_AD2TBC2 = 1U << 14 ;

  // Field AD2TAPER: ADC trigger 2 on Timer A Period
    const uint32_t HRTIM_Common_ADC2R_AD2TAPER = 1U << 13 ;

  // Field AD2TAC4: ADC trigger 2 on Timer A compare 4
    const uint32_t HRTIM_Common_ADC2R_AD2TAC4 = 1U << 12 ;

  // Field AD2TAC3: ADC trigger 2 on Timer A compare 3
    const uint32_t HRTIM_Common_ADC2R_AD2TAC3 = 1U << 11 ;

  // Field AD2TAC2: ADC trigger 2 on Timer A compare 2
    const uint32_t HRTIM_Common_ADC2R_AD2TAC2 = 1U << 10 ;

  // Field AD2EEV10: ADC trigger 2 on External Event 10
    const uint32_t HRTIM_Common_ADC2R_AD2EEV10 = 1U << 9 ;

  // Field AD2EEV9: ADC trigger 2 on External Event 9
    const uint32_t HRTIM_Common_ADC2R_AD2EEV9 = 1U << 8 ;

  // Field AD2EEV8: ADC trigger 2 on External Event 8
    const uint32_t HRTIM_Common_ADC2R_AD2EEV8 = 1U << 7 ;

  // Field AD2EEV7: ADC trigger 2 on External Event 7
    const uint32_t HRTIM_Common_ADC2R_AD2EEV7 = 1U << 6 ;

  // Field AD2EEV6: ADC trigger 2 on External Event 6
    const uint32_t HRTIM_Common_ADC2R_AD2EEV6 = 1U << 5 ;

  // Field AD2MPER: ADC trigger 2 on Master Period
    const uint32_t HRTIM_Common_ADC2R_AD2MPER = 1U << 4 ;

  // Field AD2MC4: ADC trigger 2 on Master Compare 4
    const uint32_t HRTIM_Common_ADC2R_AD2MC4 = 1U << 3 ;

  // Field AD2MC3: ADC trigger 2 on Master Compare 3
    const uint32_t HRTIM_Common_ADC2R_AD2MC3 = 1U << 2 ;

  // Field AD2MC2: ADC trigger 2 on Master Compare 2
    const uint32_t HRTIM_Common_ADC2R_AD2MC2 = 1U << 1 ;

  // Field AD2MC1: ADC trigger 2 on Master Compare 1
    const uint32_t HRTIM_Common_ADC2R_AD2MC1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ADC3R: ADC Trigger 3 Register
  #define HRTIM_Common_ADC3R (* ((volatile uint32_t *) (0x40017780 + 68)))

  // Field AD1TEPER: AD1TEPER
    const uint32_t HRTIM_Common_ADC3R_AD1TEPER = 1U << 31 ;

  // Field AD1TEC4: AD1TEC4
    const uint32_t HRTIM_Common_ADC3R_AD1TEC4 = 1U << 30 ;

  // Field AD1TEC3: AD1TEC3
    const uint32_t HRTIM_Common_ADC3R_AD1TEC3 = 1U << 29 ;

  // Field AD1TEC2: AD1TEC2
    const uint32_t HRTIM_Common_ADC3R_AD1TEC2 = 1U << 28 ;

  // Field AD1TDPER: AD1TDPER
    const uint32_t HRTIM_Common_ADC3R_AD1TDPER = 1U << 27 ;

  // Field AD1TDC4: AD1TDC4
    const uint32_t HRTIM_Common_ADC3R_AD1TDC4 = 1U << 26 ;

  // Field AD1TDC3: AD1TDC3
    const uint32_t HRTIM_Common_ADC3R_AD1TDC3 = 1U << 25 ;

  // Field AD1TDC2: AD1TDC2
    const uint32_t HRTIM_Common_ADC3R_AD1TDC2 = 1U << 24 ;

  // Field AD1TCPER: AD1TCPER
    const uint32_t HRTIM_Common_ADC3R_AD1TCPER = 1U << 23 ;

  // Field AD1TCC4: AD1TCC4
    const uint32_t HRTIM_Common_ADC3R_AD1TCC4 = 1U << 22 ;

  // Field AD1TCC3: AD1TCC3
    const uint32_t HRTIM_Common_ADC3R_AD1TCC3 = 1U << 21 ;

  // Field AD1TCC2: AD1TCC2
    const uint32_t HRTIM_Common_ADC3R_AD1TCC2 = 1U << 20 ;

  // Field AD1TBRST: AD1TBRST
    const uint32_t HRTIM_Common_ADC3R_AD1TBRST = 1U << 19 ;

  // Field AD1TBPER: AD1TBPER
    const uint32_t HRTIM_Common_ADC3R_AD1TBPER = 1U << 18 ;

  // Field AD1TBC4: AD1TBC4
    const uint32_t HRTIM_Common_ADC3R_AD1TBC4 = 1U << 17 ;

  // Field AD1TBC3: AD1TBC3
    const uint32_t HRTIM_Common_ADC3R_AD1TBC3 = 1U << 16 ;

  // Field AD1TBC2: AD1TBC2
    const uint32_t HRTIM_Common_ADC3R_AD1TBC2 = 1U << 15 ;

  // Field AD1TARST: AD1TARST
    const uint32_t HRTIM_Common_ADC3R_AD1TARST = 1U << 14 ;

  // Field AD1TAPER: AD1TAPER
    const uint32_t HRTIM_Common_ADC3R_AD1TAPER = 1U << 13 ;

  // Field AD1TAC4: AD1TAC4
    const uint32_t HRTIM_Common_ADC3R_AD1TAC4 = 1U << 12 ;

  // Field AD1TAC3: AD1TAC3
    const uint32_t HRTIM_Common_ADC3R_AD1TAC3 = 1U << 11 ;

  // Field AD1TAC2: AD1TAC2
    const uint32_t HRTIM_Common_ADC3R_AD1TAC2 = 1U << 10 ;

  // Field AD1EEV5: AD1EEV5
    const uint32_t HRTIM_Common_ADC3R_AD1EEV5 = 1U << 9 ;

  // Field AD1EEV4: AD1EEV4
    const uint32_t HRTIM_Common_ADC3R_AD1EEV4 = 1U << 8 ;

  // Field AD1EEV3: AD1EEV3
    const uint32_t HRTIM_Common_ADC3R_AD1EEV3 = 1U << 7 ;

  // Field AD1EEV2: AD1EEV2
    const uint32_t HRTIM_Common_ADC3R_AD1EEV2 = 1U << 6 ;

  // Field AD1EEV1: AD1EEV1
    const uint32_t HRTIM_Common_ADC3R_AD1EEV1 = 1U << 5 ;

  // Field AD1MPER: AD1MPER
    const uint32_t HRTIM_Common_ADC3R_AD1MPER = 1U << 4 ;

  // Field AD1MC4: AD1MC4
    const uint32_t HRTIM_Common_ADC3R_AD1MC4 = 1U << 3 ;

  // Field AD1MC3: AD1MC3
    const uint32_t HRTIM_Common_ADC3R_AD1MC3 = 1U << 2 ;

  // Field AD1MC2: AD1MC2
    const uint32_t HRTIM_Common_ADC3R_AD1MC2 = 1U << 1 ;

  // Field AD1MC1: AD1MC1
    const uint32_t HRTIM_Common_ADC3R_AD1MC1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ADC4R: ADC Trigger 4 Register
  #define HRTIM_Common_ADC4R (* ((volatile uint32_t *) (0x40017780 + 72)))

  // Field AD2TERST: AD2TERST
    const uint32_t HRTIM_Common_ADC4R_AD2TERST = 1U << 31 ;

  // Field AD2TEC4: AD2TEC4
    const uint32_t HRTIM_Common_ADC4R_AD2TEC4 = 1U << 30 ;

  // Field AD2TEC3: AD2TEC3
    const uint32_t HRTIM_Common_ADC4R_AD2TEC3 = 1U << 29 ;

  // Field AD2TEC2: AD2TEC2
    const uint32_t HRTIM_Common_ADC4R_AD2TEC2 = 1U << 28 ;

  // Field AD2TDRST: AD2TDRST
    const uint32_t HRTIM_Common_ADC4R_AD2TDRST = 1U << 27 ;

  // Field AD2TDPER: AD2TDPER
    const uint32_t HRTIM_Common_ADC4R_AD2TDPER = 1U << 26 ;

  // Field AD2TDC4: AD2TDC4
    const uint32_t HRTIM_Common_ADC4R_AD2TDC4 = 1U << 25 ;

  // Field AD2TDC3: AD2TDC3
    const uint32_t HRTIM_Common_ADC4R_AD2TDC3 = 1U << 24 ;

  // Field AD2TDC2: AD2TDC2
    const uint32_t HRTIM_Common_ADC4R_AD2TDC2 = 1U << 23 ;

  // Field AD2TCRST: AD2TCRST
    const uint32_t HRTIM_Common_ADC4R_AD2TCRST = 1U << 22 ;

  // Field AD2TCPER: AD2TCPER
    const uint32_t HRTIM_Common_ADC4R_AD2TCPER = 1U << 21 ;

  // Field AD2TCC4: AD2TCC4
    const uint32_t HRTIM_Common_ADC4R_AD2TCC4 = 1U << 20 ;

  // Field AD2TCC3: AD2TCC3
    const uint32_t HRTIM_Common_ADC4R_AD2TCC3 = 1U << 19 ;

  // Field AD2TCC2: AD2TCC2
    const uint32_t HRTIM_Common_ADC4R_AD2TCC2 = 1U << 18 ;

  // Field AD2TBPER: AD2TBPER
    const uint32_t HRTIM_Common_ADC4R_AD2TBPER = 1U << 17 ;

  // Field AD2TBC4: AD2TBC4
    const uint32_t HRTIM_Common_ADC4R_AD2TBC4 = 1U << 16 ;

  // Field AD2TBC3: AD2TBC3
    const uint32_t HRTIM_Common_ADC4R_AD2TBC3 = 1U << 15 ;

  // Field AD2TBC2: AD2TBC2
    const uint32_t HRTIM_Common_ADC4R_AD2TBC2 = 1U << 14 ;

  // Field AD2TAPER: AD2TAPER
    const uint32_t HRTIM_Common_ADC4R_AD2TAPER = 1U << 13 ;

  // Field AD2TAC4: AD2TAC4
    const uint32_t HRTIM_Common_ADC4R_AD2TAC4 = 1U << 12 ;

  // Field AD2TAC3: AD2TAC3
    const uint32_t HRTIM_Common_ADC4R_AD2TAC3 = 1U << 11 ;

  // Field AD2TAC2: AD2TAC2
    const uint32_t HRTIM_Common_ADC4R_AD2TAC2 = 1U << 10 ;

  // Field AD2EEV10: AD2EEV10
    const uint32_t HRTIM_Common_ADC4R_AD2EEV10 = 1U << 9 ;

  // Field AD2EEV9: AD2EEV9
    const uint32_t HRTIM_Common_ADC4R_AD2EEV9 = 1U << 8 ;

  // Field AD2EEV8: AD2EEV8
    const uint32_t HRTIM_Common_ADC4R_AD2EEV8 = 1U << 7 ;

  // Field AD2EEV7: AD2EEV7
    const uint32_t HRTIM_Common_ADC4R_AD2EEV7 = 1U << 6 ;

  // Field AD2EEV6: AD2EEV6
    const uint32_t HRTIM_Common_ADC4R_AD2EEV6 = 1U << 5 ;

  // Field AD2MPER: AD2MPER
    const uint32_t HRTIM_Common_ADC4R_AD2MPER = 1U << 4 ;

  // Field AD2MC4: AD2MC4
    const uint32_t HRTIM_Common_ADC4R_AD2MC4 = 1U << 3 ;

  // Field AD2MC3: AD2MC3
    const uint32_t HRTIM_Common_ADC4R_AD2MC3 = 1U << 2 ;

  // Field AD2MC2: AD2MC2
    const uint32_t HRTIM_Common_ADC4R_AD2MC2 = 1U << 1 ;

  // Field AD2MC1: AD2MC1
    const uint32_t HRTIM_Common_ADC4R_AD2MC1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register DLLCR: DLL Control Register
  #define HRTIM_Common_DLLCR (* ((volatile uint32_t *) (0x40017780 + 76)))

  // Field CALRTE: DLL Calibration rate
    inline uint32_t HRTIM_Common_DLLCR_CALRTE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CALEN: DLL Calibration Enable
    const uint32_t HRTIM_Common_DLLCR_CALEN = 1U << 1 ;

  // Field CAL: DLL Calibration Start
    const uint32_t HRTIM_Common_DLLCR_CAL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register FLTINR1: HRTIM Fault Input Register 1
  #define HRTIM_Common_FLTINR1 (* ((volatile uint32_t *) (0x40017780 + 80)))

  // Field FLT4LCK: FLT4LCK
    const uint32_t HRTIM_Common_FLTINR1_FLT4LCK = 1U << 31 ;

  // Field FLT4F: FLT4F
    inline uint32_t HRTIM_Common_FLTINR1_FLT4F (const uint32_t inValue) {return (inValue & 0xFU) << 27 ; }

  // Field FLT4SRC: FLT4SRC
    const uint32_t HRTIM_Common_FLTINR1_FLT4SRC = 1U << 26 ;

  // Field FLT4P: FLT4P
    const uint32_t HRTIM_Common_FLTINR1_FLT4P = 1U << 25 ;

  // Field FLT4E: FLT4E
    const uint32_t HRTIM_Common_FLTINR1_FLT4E = 1U << 24 ;

  // Field FLT3LCK: FLT3LCK
    const uint32_t HRTIM_Common_FLTINR1_FLT3LCK = 1U << 23 ;

  // Field FLT3F: FLT3F
    inline uint32_t HRTIM_Common_FLTINR1_FLT3F (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field FLT3SRC: FLT3SRC
    const uint32_t HRTIM_Common_FLTINR1_FLT3SRC = 1U << 18 ;

  // Field FLT3P: FLT3P
    const uint32_t HRTIM_Common_FLTINR1_FLT3P = 1U << 17 ;

  // Field FLT3E: FLT3E
    const uint32_t HRTIM_Common_FLTINR1_FLT3E = 1U << 16 ;

  // Field FLT2LCK: FLT2LCK
    const uint32_t HRTIM_Common_FLTINR1_FLT2LCK = 1U << 15 ;

  // Field FLT2F: FLT2F
    inline uint32_t HRTIM_Common_FLTINR1_FLT2F (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field FLT2SRC: FLT2SRC
    const uint32_t HRTIM_Common_FLTINR1_FLT2SRC = 1U << 10 ;

  // Field FLT2P: FLT2P
    const uint32_t HRTIM_Common_FLTINR1_FLT2P = 1U << 9 ;

  // Field FLT2E: FLT2E
    const uint32_t HRTIM_Common_FLTINR1_FLT2E = 1U << 8 ;

  // Field FLT1LCK: FLT1LCK
    const uint32_t HRTIM_Common_FLTINR1_FLT1LCK = 1U << 7 ;

  // Field FLT1F: FLT1F
    inline uint32_t HRTIM_Common_FLTINR1_FLT1F (const uint32_t inValue) {return (inValue & 0xFU) << 3 ; }

  // Field FLT1SRC: FLT1SRC
    const uint32_t HRTIM_Common_FLTINR1_FLT1SRC = 1U << 2 ;

  // Field FLT1P: FLT1P
    const uint32_t HRTIM_Common_FLTINR1_FLT1P = 1U << 1 ;

  // Field FLT1E: FLT1E
    const uint32_t HRTIM_Common_FLTINR1_FLT1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register FLTINR2: HRTIM Fault Input Register 2
  #define HRTIM_Common_FLTINR2 (* ((volatile uint32_t *) (0x40017780 + 84)))

  // Field FLTSD: FLTSD
    inline uint32_t HRTIM_Common_FLTINR2_FLTSD (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field FLT5LCK: FLT5LCK
    const uint32_t HRTIM_Common_FLTINR2_FLT5LCK = 1U << 7 ;

  // Field FLT5F: FLT5F
    inline uint32_t HRTIM_Common_FLTINR2_FLT5F (const uint32_t inValue) {return (inValue & 0xFU) << 3 ; }

  // Field FLT5SRC: FLT5SRC
    const uint32_t HRTIM_Common_FLTINR2_FLT5SRC = 1U << 2 ;

  // Field FLT5P: FLT5P
    const uint32_t HRTIM_Common_FLTINR2_FLT5P = 1U << 1 ;

  // Field FLT5E: FLT5E
    const uint32_t HRTIM_Common_FLTINR2_FLT5E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BDMUPDR: BDMUPDR
  #define HRTIM_Common_BDMUPDR (* ((volatile uint32_t *) (0x40017780 + 88)))

  // Field MCMP4: MCMP4
    const uint32_t HRTIM_Common_BDMUPDR_MCMP4 = 1U << 9 ;

  // Field MCMP3: MCMP3
    const uint32_t HRTIM_Common_BDMUPDR_MCMP3 = 1U << 8 ;

  // Field MCMP2: MCMP2
    const uint32_t HRTIM_Common_BDMUPDR_MCMP2 = 1U << 7 ;

  // Field MCMP1: MCMP1
    const uint32_t HRTIM_Common_BDMUPDR_MCMP1 = 1U << 6 ;

  // Field MREP: MREP
    const uint32_t HRTIM_Common_BDMUPDR_MREP = 1U << 5 ;

  // Field MPER: MPER
    const uint32_t HRTIM_Common_BDMUPDR_MPER = 1U << 4 ;

  // Field MCNT: MCNT
    const uint32_t HRTIM_Common_BDMUPDR_MCNT = 1U << 3 ;

  // Field MDIER: MDIER
    const uint32_t HRTIM_Common_BDMUPDR_MDIER = 1U << 2 ;

  // Field MICR: MICR
    const uint32_t HRTIM_Common_BDMUPDR_MICR = 1U << 1 ;

  // Field MCR: MCR
    const uint32_t HRTIM_Common_BDMUPDR_MCR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BDTxUPR: Burst DMA Timerx update Register
  #define HRTIM_Common_BDTxUPR (* ((volatile uint32_t *) (0x40017780 + 92)))

  // Field TIMxFLTR: HRTIM_FLTxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxFLTR = 1U << 20 ;

  // Field TIMxOUTR: HRTIM_OUTxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxOUTR = 1U << 19 ;

  // Field TIMxCHPR: HRTIM_CHPxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCHPR = 1U << 18 ;

  // Field TIMxRSTR: HRTIM_RSTxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxRSTR = 1U << 17 ;

  // Field TIMxEEFR2: HRTIM_EEFxR2 register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxEEFR2 = 1U << 16 ;

  // Field TIMxEEFR1: HRTIM_EEFxR1 register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxEEFR1 = 1U << 15 ;

  // Field TIMxRST2R: HRTIM_RST2xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxRST2R = 1U << 14 ;

  // Field TIMxSET2R: HRTIM_SET2xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxSET2R = 1U << 13 ;

  // Field TIMxRST1R: HRTIM_RST1xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxRST1R = 1U << 12 ;

  // Field TIMxSET1R: HRTIM_SET1xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxSET1R = 1U << 11 ;

  // Field TIMx_DTxR: HRTIM_DTxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMx_DTxR = 1U << 10 ;

  // Field TIMxCMP4: HRTIM_CMP4xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCMP4 = 1U << 9 ;

  // Field TIMxCMP3: HRTIM_CMP3xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCMP3 = 1U << 8 ;

  // Field TIMxCMP2: HRTIM_CMP2xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCMP2 = 1U << 7 ;

  // Field TIMxCMP1: HRTIM_CMP1xR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCMP1 = 1U << 6 ;

  // Field TIMxREP: HRTIM_REPxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxREP = 1U << 5 ;

  // Field TIMxPER: HRTIM_PERxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxPER = 1U << 4 ;

  // Field TIMxCNT: HRTIM_CNTxR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCNT = 1U << 3 ;

  // Field TIMxDIER: HRTIM_TIMxDIER register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxDIER = 1U << 2 ;

  // Field TIMxICR: HRTIM_TIMxICR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxICR = 1U << 1 ;

  // Field TIMxCR: HRTIM_TIMxCR register update enable
    const uint32_t HRTIM_Common_BDTxUPR_TIMxCR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BDMADR: Burst DMA Data Register
  #define HRTIM_Common_BDMADR (* ((volatile uint32_t *) (0x40017780 + 96)))

  // Field BDMADR: Burst DMA Data register
    inline uint32_t HRTIM_Common_BDMADR_BDMADR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral HRTIM_Master: High Resolution Timer: Master       Timers
//------------------------------------------------------------------------------

//---  Register MCR: Master Timer Control Register
  #define HRTIM_Master_MCR (* ((volatile uint32_t *) (0x40017400 + 0)))

  // Field BRSTDMA: Burst DMA Update
    inline uint32_t HRTIM_Master_MCR_BRSTDMA (const uint32_t inValue) {return (inValue & 0x3U) << 30 ; }

  // Field MREPU: Master Timer Repetition update
    const uint32_t HRTIM_Master_MCR_MREPU = 1U << 29 ;

  // Field PREEN: Preload enable
    const uint32_t HRTIM_Master_MCR_PREEN = 1U << 27 ;

  // Field DACSYNC: AC Synchronization
    inline uint32_t HRTIM_Master_MCR_DACSYNC (const uint32_t inValue) {return (inValue & 0x3U) << 25 ; }

  // Field TECEN: Timer E counter enable
    const uint32_t HRTIM_Master_MCR_TECEN = 1U << 21 ;

  // Field TDCEN: Timer D counter enable
    const uint32_t HRTIM_Master_MCR_TDCEN = 1U << 20 ;

  // Field TCCEN: Timer C counter enable
    const uint32_t HRTIM_Master_MCR_TCCEN = 1U << 19 ;

  // Field TBCEN: Timer B counter enable
    const uint32_t HRTIM_Master_MCR_TBCEN = 1U << 18 ;

  // Field TACEN: Timer A counter enable
    const uint32_t HRTIM_Master_MCR_TACEN = 1U << 17 ;

  // Field MCEN: Master Counter enable
    const uint32_t HRTIM_Master_MCR_MCEN = 1U << 16 ;

  // Field SYNC_SRC: Synchronization source
    inline uint32_t HRTIM_Master_MCR_SYNC_SRC (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field SYNC_OUT: Synchronization output
    inline uint32_t HRTIM_Master_MCR_SYNC_OUT (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field SYNCSTRTM: Synchronization Starts Master
    const uint32_t HRTIM_Master_MCR_SYNCSTRTM = 1U << 11 ;

  // Field SYNCRSTM: Synchronization Resets Master
    const uint32_t HRTIM_Master_MCR_SYNCRSTM = 1U << 10 ;

  // Field SYNC_IN: ynchronization input
    inline uint32_t HRTIM_Master_MCR_SYNC_IN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field HALF: Half mode enable
    const uint32_t HRTIM_Master_MCR_HALF = 1U << 5 ;

  // Field RETRIG: Master Re-triggerable mode
    const uint32_t HRTIM_Master_MCR_RETRIG = 1U << 4 ;

  // Field CONT: Master Continuous mode
    const uint32_t HRTIM_Master_MCR_CONT = 1U << 3 ;

  // Field CK_PSC: HRTIM Master Clock prescaler
    inline uint32_t HRTIM_Master_MCR_CK_PSC (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MISR: Master Timer Interrupt Status Register
  #define HRTIM_Master_MISR (* ((const volatile uint32_t *) (0x40017400 + 4)))

  // Field MUPD: Master Update Interrupt Flag
    const uint32_t HRTIM_Master_MISR_MUPD = 1U << 6 ;

  // Field SYNC: Sync Input Interrupt Flag
    const uint32_t HRTIM_Master_MISR_SYNC = 1U << 5 ;

  // Field MREP: Master Repetition Interrupt Flag
    const uint32_t HRTIM_Master_MISR_MREP = 1U << 4 ;

  // Field MCMP4: Master Compare 4 Interrupt Flag
    const uint32_t HRTIM_Master_MISR_MCMP4 = 1U << 3 ;

  // Field MCMP3: Master Compare 3 Interrupt Flag
    const uint32_t HRTIM_Master_MISR_MCMP3 = 1U << 2 ;

  // Field MCMP2: Master Compare 2 Interrupt Flag
    const uint32_t HRTIM_Master_MISR_MCMP2 = 1U << 1 ;

  // Field MCMP1: Master Compare 1 Interrupt Flag
    const uint32_t HRTIM_Master_MISR_MCMP1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MICR: Master Timer Interrupt Clear Register
  #define HRTIM_Master_MICR (* ((volatile uint32_t *) (0x40017400 + 8)))

  // Field MUPDC: Master update Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_MUPDC = 1U << 6 ;

  // Field SYNCC: Sync Input Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_SYNCC = 1U << 5 ;

  // Field MREPC: Repetition Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_MREPC = 1U << 4 ;

  // Field MCMP4C: Master Compare 4 Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_MCMP4C = 1U << 3 ;

  // Field MCMP3C: Master Compare 3 Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_MCMP3C = 1U << 2 ;

  // Field MCMP2C: Master Compare 2 Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_MCMP2C = 1U << 1 ;

  // Field MCMP1C: Master Compare 1 Interrupt flag clear
    const uint32_t HRTIM_Master_MICR_MCMP1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MDIER4: MDIER4
  #define HRTIM_Master_MDIER4 (* ((volatile uint32_t *) (0x40017400 + 12)))

  // Field MUPDDE: MUPDDE
    const uint32_t HRTIM_Master_MDIER4_MUPDDE = 1U << 22 ;

  // Field SYNCDE: SYNCDE
    const uint32_t HRTIM_Master_MDIER4_SYNCDE = 1U << 21 ;

  // Field MREPDE: MREPDE
    const uint32_t HRTIM_Master_MDIER4_MREPDE = 1U << 20 ;

  // Field MCMP4DE: MCMP4DE
    const uint32_t HRTIM_Master_MDIER4_MCMP4DE = 1U << 19 ;

  // Field MCMP3DE: MCMP3DE
    const uint32_t HRTIM_Master_MDIER4_MCMP3DE = 1U << 18 ;

  // Field MCMP2DE: MCMP2DE
    const uint32_t HRTIM_Master_MDIER4_MCMP2DE = 1U << 17 ;

  // Field MCMP1DE: MCMP1DE
    const uint32_t HRTIM_Master_MDIER4_MCMP1DE = 1U << 16 ;

  // Field MUPDIE: MUPDIE
    const uint32_t HRTIM_Master_MDIER4_MUPDIE = 1U << 6 ;

  // Field SYNCIE: SYNCIE
    const uint32_t HRTIM_Master_MDIER4_SYNCIE = 1U << 5 ;

  // Field MREPIE: MREPIE
    const uint32_t HRTIM_Master_MDIER4_MREPIE = 1U << 4 ;

  // Field MCMP4IE: MCMP4IE
    const uint32_t HRTIM_Master_MDIER4_MCMP4IE = 1U << 3 ;

  // Field MCMP3IE: MCMP3IE
    const uint32_t HRTIM_Master_MDIER4_MCMP3IE = 1U << 2 ;

  // Field MCMP2IE: MCMP2IE
    const uint32_t HRTIM_Master_MDIER4_MCMP2IE = 1U << 1 ;

  // Field MCMP1IE: MCMP1IE
    const uint32_t HRTIM_Master_MDIER4_MCMP1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register MCNTR: Master Timer Counter Register
  #define HRTIM_Master_MCNTR (* ((volatile uint32_t *) (0x40017400 + 16)))

  // Field MCNT: Counter value
    inline uint32_t HRTIM_Master_MCNTR_MCNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MPER: Master Timer Period Register
  #define HRTIM_Master_MPER (* ((volatile uint32_t *) (0x40017400 + 20)))

  // Field MPER: Master Timer Period value
    inline uint32_t HRTIM_Master_MPER_MPER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MREP: Master Timer Repetition Register
  #define HRTIM_Master_MREP (* ((volatile uint32_t *) (0x40017400 + 24)))

  // Field MREP: Master Timer Repetition counter value
    inline uint32_t HRTIM_Master_MREP_MREP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MCMP1R: Master Timer Compare 1 Register
  #define HRTIM_Master_MCMP1R (* ((volatile uint32_t *) (0x40017400 + 28)))

  // Field MCMP1: Master Timer Compare 1 value
    inline uint32_t HRTIM_Master_MCMP1R_MCMP1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MCMP2R: Master Timer Compare 2 Register
  #define HRTIM_Master_MCMP2R (* ((volatile uint32_t *) (0x40017400 + 36)))

  // Field MCMP2: Master Timer Compare 2 value
    inline uint32_t HRTIM_Master_MCMP2R_MCMP2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MCMP3R: Master Timer Compare 3 Register
  #define HRTIM_Master_MCMP3R (* ((volatile uint32_t *) (0x40017400 + 40)))

  // Field MCMP3: Master Timer Compare 3 value
    inline uint32_t HRTIM_Master_MCMP3R_MCMP3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MCMP4R: Master Timer Compare 4 Register
  #define HRTIM_Master_MCMP4R (* ((volatile uint32_t *) (0x40017400 + 44)))

  // Field MCMP4: Master Timer Compare 4 value
    inline uint32_t HRTIM_Master_MCMP4R_MCMP4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral HRTIM_TIMA: High Resolution Timer: TIMA
//------------------------------------------------------------------------------

//---  Register TIMACR: Timerx Control Register
  #define HRTIM_TIMA_TIMACR (* ((volatile uint32_t *) (0x40017480 + 0)))

  // Field UPDGAT: Update Gating
    inline uint32_t HRTIM_TIMA_TIMACR_UPDGAT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field PREEN: Preload enable
    const uint32_t HRTIM_TIMA_TIMACR_PREEN = 1U << 27 ;

  // Field DACSYNC: AC Synchronization
    inline uint32_t HRTIM_TIMA_TIMACR_DACSYNC (const uint32_t inValue) {return (inValue & 0x3U) << 25 ; }

  // Field MSTU: Master Timer update
    const uint32_t HRTIM_TIMA_TIMACR_MSTU = 1U << 24 ;

  // Field TEU: TEU
    const uint32_t HRTIM_TIMA_TIMACR_TEU = 1U << 23 ;

  // Field TDU: TDU
    const uint32_t HRTIM_TIMA_TIMACR_TDU = 1U << 22 ;

  // Field TCU: TCU
    const uint32_t HRTIM_TIMA_TIMACR_TCU = 1U << 21 ;

  // Field TBU: TBU
    const uint32_t HRTIM_TIMA_TIMACR_TBU = 1U << 20 ;

  // Field TxRSTU: Timerx reset update
    const uint32_t HRTIM_TIMA_TIMACR_TxRSTU = 1U << 18 ;

  // Field TxREPU: Timer x Repetition update
    const uint32_t HRTIM_TIMA_TIMACR_TxREPU = 1U << 17 ;

  // Field DELCMP4: Delayed CMP4 mode
    inline uint32_t HRTIM_TIMA_TIMACR_DELCMP4 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field DELCMP2: Delayed CMP2 mode
    inline uint32_t HRTIM_TIMA_TIMACR_DELCMP2 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field SYNCSTRTx: Synchronization Starts Timer x
    const uint32_t HRTIM_TIMA_TIMACR_SYNCSTRTx = 1U << 11 ;

  // Field SYNCRSTx: Synchronization Resets Timer x
    const uint32_t HRTIM_TIMA_TIMACR_SYNCRSTx = 1U << 10 ;

  // Field PSHPLL: Push-Pull mode enable
    const uint32_t HRTIM_TIMA_TIMACR_PSHPLL = 1U << 6 ;

  // Field HALF: Half mode enable
    const uint32_t HRTIM_TIMA_TIMACR_HALF = 1U << 5 ;

  // Field RETRIG: Re-triggerable mode
    const uint32_t HRTIM_TIMA_TIMACR_RETRIG = 1U << 4 ;

  // Field CONT: Continuous mode
    const uint32_t HRTIM_TIMA_TIMACR_CONT = 1U << 3 ;

  // Field CK_PSCx: HRTIM Timer x Clock prescaler
    inline uint32_t HRTIM_TIMA_TIMACR_CK_PSCx (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMAISR: Timerx Interrupt Status Register
  #define HRTIM_TIMA_TIMAISR (* ((const volatile uint32_t *) (0x40017480 + 4)))

  // Field O2STAT: Output 2 State
    const uint32_t HRTIM_TIMA_TIMAISR_O2STAT = 1U << 19 ;

  // Field O1STAT: Output 1 State
    const uint32_t HRTIM_TIMA_TIMAISR_O1STAT = 1U << 18 ;

  // Field IPPSTAT: Idle Push Pull Status
    const uint32_t HRTIM_TIMA_TIMAISR_IPPSTAT = 1U << 17 ;

  // Field CPPSTAT: Current Push Pull Status
    const uint32_t HRTIM_TIMA_TIMAISR_CPPSTAT = 1U << 16 ;

  // Field DLYPRT: Delayed Protection Flag
    const uint32_t HRTIM_TIMA_TIMAISR_DLYPRT = 1U << 14 ;

  // Field RST: Reset Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_RST = 1U << 13 ;

  // Field RSTx2: Output 2 Reset Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_RSTx2 = 1U << 12 ;

  // Field SETx2: Output 2 Set Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_SETx2 = 1U << 11 ;

  // Field RSTx1: Output 1 Reset Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_RSTx1 = 1U << 10 ;

  // Field SETx1: Output 1 Set Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_SETx1 = 1U << 9 ;

  // Field CPT2: Capture2 Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_CPT2 = 1U << 8 ;

  // Field CPT1: Capture1 Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_CPT1 = 1U << 7 ;

  // Field UPD: Update Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_UPD = 1U << 6 ;

  // Field REP: Repetition Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_REP = 1U << 4 ;

  // Field CMP4: Compare 4 Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_CMP4 = 1U << 3 ;

  // Field CMP3: Compare 3 Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_CMP3 = 1U << 2 ;

  // Field CMP2: Compare 2 Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_CMP2 = 1U << 1 ;

  // Field CMP1: Compare 1 Interrupt Flag
    const uint32_t HRTIM_TIMA_TIMAISR_CMP1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMAICR: Timerx Interrupt Clear Register
  #define HRTIM_TIMA_TIMAICR (* ((volatile uint32_t *) (0x40017480 + 8)))

  // Field DLYPRTC: Delayed Protection Flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_DLYPRTC = 1U << 14 ;

  // Field RSTC: Reset Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_RSTC = 1U << 13 ;

  // Field RSTx2C: Output 2 Reset flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_RSTx2C = 1U << 12 ;

  // Field SET2xC: Output 2 Set flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_SET2xC = 1U << 11 ;

  // Field RSTx1C: Output 1 Reset flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_RSTx1C = 1U << 10 ;

  // Field SET1xC: Output 1 Set flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_SET1xC = 1U << 9 ;

  // Field CPT2C: Capture2 Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_CPT2C = 1U << 8 ;

  // Field CPT1C: Capture1 Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_CPT1C = 1U << 7 ;

  // Field UPDC: Update Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_UPDC = 1U << 6 ;

  // Field REPC: Repetition Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_REPC = 1U << 4 ;

  // Field CMP4C: Compare 4 Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_CMP4C = 1U << 3 ;

  // Field CMP3C: Compare 3 Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_CMP3C = 1U << 2 ;

  // Field CMP2C: Compare 2 Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_CMP2C = 1U << 1 ;

  // Field CMP1C: Compare 1 Interrupt flag Clear
    const uint32_t HRTIM_TIMA_TIMAICR_CMP1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMADIER5: TIMxDIER5
  #define HRTIM_TIMA_TIMADIER5 (* ((volatile uint32_t *) (0x40017480 + 12)))

  // Field DLYPRTDE: DLYPRTDE
    const uint32_t HRTIM_TIMA_TIMADIER5_DLYPRTDE = 1U << 30 ;

  // Field RSTDE: RSTDE
    const uint32_t HRTIM_TIMA_TIMADIER5_RSTDE = 1U << 29 ;

  // Field RSTx2DE: RSTx2DE
    const uint32_t HRTIM_TIMA_TIMADIER5_RSTx2DE = 1U << 28 ;

  // Field SETx2DE: SETx2DE
    const uint32_t HRTIM_TIMA_TIMADIER5_SETx2DE = 1U << 27 ;

  // Field RSTx1DE: RSTx1DE
    const uint32_t HRTIM_TIMA_TIMADIER5_RSTx1DE = 1U << 26 ;

  // Field SET1xDE: SET1xDE
    const uint32_t HRTIM_TIMA_TIMADIER5_SET1xDE = 1U << 25 ;

  // Field CPT2DE: CPT2DE
    const uint32_t HRTIM_TIMA_TIMADIER5_CPT2DE = 1U << 24 ;

  // Field CPT1DE: CPT1DE
    const uint32_t HRTIM_TIMA_TIMADIER5_CPT1DE = 1U << 23 ;

  // Field UPDDE: UPDDE
    const uint32_t HRTIM_TIMA_TIMADIER5_UPDDE = 1U << 22 ;

  // Field REPDE: REPDE
    const uint32_t HRTIM_TIMA_TIMADIER5_REPDE = 1U << 20 ;

  // Field CMP4DE: CMP4DE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP4DE = 1U << 19 ;

  // Field CMP3DE: CMP3DE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP3DE = 1U << 18 ;

  // Field CMP2DE: CMP2DE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP2DE = 1U << 17 ;

  // Field CMP1DE: CMP1DE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP1DE = 1U << 16 ;

  // Field DLYPRTIE: DLYPRTIE
    const uint32_t HRTIM_TIMA_TIMADIER5_DLYPRTIE = 1U << 14 ;

  // Field RSTIE: RSTIE
    const uint32_t HRTIM_TIMA_TIMADIER5_RSTIE = 1U << 13 ;

  // Field RSTx2IE: RSTx2IE
    const uint32_t HRTIM_TIMA_TIMADIER5_RSTx2IE = 1U << 12 ;

  // Field SETx2IE: SETx2IE
    const uint32_t HRTIM_TIMA_TIMADIER5_SETx2IE = 1U << 11 ;

  // Field RSTx1IE: RSTx1IE
    const uint32_t HRTIM_TIMA_TIMADIER5_RSTx1IE = 1U << 10 ;

  // Field SET1xIE: SET1xIE
    const uint32_t HRTIM_TIMA_TIMADIER5_SET1xIE = 1U << 9 ;

  // Field CPT2IE: CPT2IE
    const uint32_t HRTIM_TIMA_TIMADIER5_CPT2IE = 1U << 8 ;

  // Field CPT1IE: CPT1IE
    const uint32_t HRTIM_TIMA_TIMADIER5_CPT1IE = 1U << 7 ;

  // Field UPDIE: UPDIE
    const uint32_t HRTIM_TIMA_TIMADIER5_UPDIE = 1U << 6 ;

  // Field REPIE: REPIE
    const uint32_t HRTIM_TIMA_TIMADIER5_REPIE = 1U << 4 ;

  // Field CMP4IE: CMP4IE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP4IE = 1U << 3 ;

  // Field CMP3IE: CMP3IE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP3IE = 1U << 2 ;

  // Field CMP2IE: CMP2IE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP2IE = 1U << 1 ;

  // Field CMP1IE: CMP1IE
    const uint32_t HRTIM_TIMA_TIMADIER5_CMP1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNTAR: Timerx Counter Register
  #define HRTIM_TIMA_CNTAR (* ((volatile uint32_t *) (0x40017480 + 16)))

  // Field CNTx: Timerx Counter value
    inline uint32_t HRTIM_TIMA_CNTAR_CNTx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERAR: Timerx Period Register
  #define HRTIM_TIMA_PERAR (* ((volatile uint32_t *) (0x40017480 + 20)))

  // Field PERx: Timerx Period value
    inline uint32_t HRTIM_TIMA_PERAR_PERx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register REPAR: Timerx Repetition Register
  #define HRTIM_TIMA_REPAR (* ((volatile uint32_t *) (0x40017480 + 24)))

  // Field REPx: Timerx Repetition counter value
    inline uint32_t HRTIM_TIMA_REPAR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1AR: Timerx Compare 1 Register
  #define HRTIM_TIMA_CMP1AR (* ((volatile uint32_t *) (0x40017480 + 28)))

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMA_CMP1AR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1CAR: Timerx Compare 1 Compound Register
  #define HRTIM_TIMA_CMP1CAR (* ((volatile uint32_t *) (0x40017480 + 32)))

  // Field REPx: Timerx Repetition value (aliased from HRTIM_REPx register)
    inline uint32_t HRTIM_TIMA_CMP1CAR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMA_CMP1CAR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP2AR: Timerx Compare 2 Register
  #define HRTIM_TIMA_CMP2AR (* ((volatile uint32_t *) (0x40017480 + 36)))

  // Field CMP2x: Timerx Compare 2 value
    inline uint32_t HRTIM_TIMA_CMP2AR_CMP2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP3AR: Timerx Compare 3 Register
  #define HRTIM_TIMA_CMP3AR (* ((volatile uint32_t *) (0x40017480 + 40)))

  // Field CMP3x: Timerx Compare 3 value
    inline uint32_t HRTIM_TIMA_CMP3AR_CMP3x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP4AR: Timerx Compare 4 Register
  #define HRTIM_TIMA_CMP4AR (* ((volatile uint32_t *) (0x40017480 + 44)))

  // Field CMP4x: Timerx Compare 4 value
    inline uint32_t HRTIM_TIMA_CMP4AR_CMP4x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1AR: Timerx Capture 1 Register
  #define HRTIM_TIMA_CPT1AR (* ((const volatile uint32_t *) (0x40017480 + 48)))

  // Field CPT1x: Timerx Capture 1 value
    inline uint32_t HRTIM_TIMA_CPT1AR_CPT1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT2AR: Timerx Capture 2 Register
  #define HRTIM_TIMA_CPT2AR (* ((const volatile uint32_t *) (0x40017480 + 52)))

  // Field CPT2x: Timerx Capture 2 value
    inline uint32_t HRTIM_TIMA_CPT2AR_CPT2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTAR: Timerx Deadtime Register
  #define HRTIM_TIMA_DTAR (* ((volatile uint32_t *) (0x40017480 + 56)))

  // Field DTFLKx: Deadtime Falling Lock
    const uint32_t HRTIM_TIMA_DTAR_DTFLKx = 1U << 31 ;

  // Field DTFSLKx: Deadtime Falling Sign Lock
    const uint32_t HRTIM_TIMA_DTAR_DTFSLKx = 1U << 30 ;

  // Field SDTFx: Sign Deadtime Falling value
    const uint32_t HRTIM_TIMA_DTAR_SDTFx = 1U << 25 ;

  // Field DTFx: Deadtime Falling value
    inline uint32_t HRTIM_TIMA_DTAR_DTFx (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field DTRLKx: Deadtime Rising Lock
    const uint32_t HRTIM_TIMA_DTAR_DTRLKx = 1U << 15 ;

  // Field DTRSLKx: Deadtime Rising Sign Lock
    const uint32_t HRTIM_TIMA_DTAR_DTRSLKx = 1U << 14 ;

  // Field DTPRSC: Deadtime Prescaler
    inline uint32_t HRTIM_TIMA_DTAR_DTPRSC (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field SDTRx: Sign Deadtime Rising value
    const uint32_t HRTIM_TIMA_DTAR_SDTRx = 1U << 9 ;

  // Field DTRx: Deadtime Rising value
    inline uint32_t HRTIM_TIMA_DTAR_DTRx (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SETA1R: Timerx Output1 Set Register
  #define HRTIM_TIMA_SETA1R (* ((volatile uint32_t *) (0x40017480 + 60)))

  // Field UPDATE: Registers update (transfer preload to active)
    const uint32_t HRTIM_TIMA_SETA1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMA_SETA1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: Timer Event 9
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: Timer Event 8
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: Timer Event 7
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: Timer Event 6
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: Timer Event 5
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: Timer Event 4
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: Timer Event 3
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: Timer Event 2
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: Timer Event 1
    const uint32_t HRTIM_TIMA_SETA1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: Master Compare 4
    const uint32_t HRTIM_TIMA_SETA1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: Master Compare 3
    const uint32_t HRTIM_TIMA_SETA1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: Master Compare 2
    const uint32_t HRTIM_TIMA_SETA1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: Master Compare 1
    const uint32_t HRTIM_TIMA_SETA1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: Master Period
    const uint32_t HRTIM_TIMA_SETA1R_MSTPER = 1U << 7 ;

  // Field CMP4: Timer A compare 4
    const uint32_t HRTIM_TIMA_SETA1R_CMP4 = 1U << 6 ;

  // Field CMP3: Timer A compare 3
    const uint32_t HRTIM_TIMA_SETA1R_CMP3 = 1U << 5 ;

  // Field CMP2: Timer A compare 2
    const uint32_t HRTIM_TIMA_SETA1R_CMP2 = 1U << 4 ;

  // Field CMP1: Timer A compare 1
    const uint32_t HRTIM_TIMA_SETA1R_CMP1 = 1U << 3 ;

  // Field PER: Timer A Period
    const uint32_t HRTIM_TIMA_SETA1R_PER = 1U << 2 ;

  // Field RESYNC: Timer A resynchronizaton
    const uint32_t HRTIM_TIMA_SETA1R_RESYNC = 1U << 1 ;

  // Field SST: Software Set trigger
    const uint32_t HRTIM_TIMA_SETA1R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTA1R: Timerx Output1 Reset Register
  #define HRTIM_TIMA_RSTA1R (* ((volatile uint32_t *) (0x40017480 + 64)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMA_RSTA1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMA_RSTA1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMA_RSTA1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMA_RSTA1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMA_RSTA1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMA_RSTA1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMA_RSTA1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMA_RSTA1R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMA_RSTA1R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMA_RSTA1R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMA_RSTA1R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMA_RSTA1R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMA_RSTA1R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMA_RSTA1R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMA_RSTA1R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SETA2R: Timerx Output2 Set Register
  #define HRTIM_TIMA_SETA2R (* ((volatile uint32_t *) (0x40017480 + 68)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMA_SETA2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMA_SETA2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMA_SETA2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMA_SETA2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMA_SETA2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMA_SETA2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMA_SETA2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMA_SETA2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMA_SETA2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMA_SETA2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMA_SETA2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMA_SETA2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMA_SETA2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMA_SETA2R_RESYNC = 1U << 1 ;

  // Field SST: SST
    const uint32_t HRTIM_TIMA_SETA2R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTA2R: Timerx Output2 Reset Register
  #define HRTIM_TIMA_RSTA2R (* ((volatile uint32_t *) (0x40017480 + 72)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMA_RSTA2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMA_RSTA2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMA_RSTA2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMA_RSTA2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMA_RSTA2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMA_RSTA2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMA_RSTA2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMA_RSTA2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMA_RSTA2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMA_RSTA2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMA_RSTA2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMA_RSTA2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMA_RSTA2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMA_RSTA2R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMA_RSTA2R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFAR1: Timerx External Event Filtering Register 1
  #define HRTIM_TIMA_EEFAR1 (* ((volatile uint32_t *) (0x40017480 + 76)))

  // Field EE5FLTR: External Event 5 filter
    inline uint32_t HRTIM_TIMA_EEFAR1_EE5FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE5LTCH: External Event 5 latch
    const uint32_t HRTIM_TIMA_EEFAR1_EE5LTCH = 1U << 24 ;

  // Field EE4FLTR: External Event 4 filter
    inline uint32_t HRTIM_TIMA_EEFAR1_EE4FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE4LTCH: External Event 4 latch
    const uint32_t HRTIM_TIMA_EEFAR1_EE4LTCH = 1U << 18 ;

  // Field EE3FLTR: External Event 3 filter
    inline uint32_t HRTIM_TIMA_EEFAR1_EE3FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE3LTCH: External Event 3 latch
    const uint32_t HRTIM_TIMA_EEFAR1_EE3LTCH = 1U << 12 ;

  // Field EE2FLTR: External Event 2 filter
    inline uint32_t HRTIM_TIMA_EEFAR1_EE2FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE2LTCH: External Event 2 latch
    const uint32_t HRTIM_TIMA_EEFAR1_EE2LTCH = 1U << 6 ;

  // Field EE1FLTR: External Event 1 filter
    inline uint32_t HRTIM_TIMA_EEFAR1_EE1FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE1LTCH: External Event 1 latch
    const uint32_t HRTIM_TIMA_EEFAR1_EE1LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFAR2: Timerx External Event Filtering Register 2
  #define HRTIM_TIMA_EEFAR2 (* ((volatile uint32_t *) (0x40017480 + 80)))

  // Field EE10FLTR: External Event 10 filter
    inline uint32_t HRTIM_TIMA_EEFAR2_EE10FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE10LTCH: External Event 10 latch
    const uint32_t HRTIM_TIMA_EEFAR2_EE10LTCH = 1U << 24 ;

  // Field EE9FLTR: External Event 9 filter
    inline uint32_t HRTIM_TIMA_EEFAR2_EE9FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE9LTCH: External Event 9 latch
    const uint32_t HRTIM_TIMA_EEFAR2_EE9LTCH = 1U << 18 ;

  // Field EE8FLTR: External Event 8 filter
    inline uint32_t HRTIM_TIMA_EEFAR2_EE8FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE8LTCH: External Event 8 latch
    const uint32_t HRTIM_TIMA_EEFAR2_EE8LTCH = 1U << 12 ;

  // Field EE7FLTR: External Event 7 filter
    inline uint32_t HRTIM_TIMA_EEFAR2_EE7FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE7LTCH: External Event 7 latch
    const uint32_t HRTIM_TIMA_EEFAR2_EE7LTCH = 1U << 6 ;

  // Field EE6FLTR: External Event 6 filter
    inline uint32_t HRTIM_TIMA_EEFAR2_EE6FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE6LTCH: External Event 6 latch
    const uint32_t HRTIM_TIMA_EEFAR2_EE6LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTAR: TimerA Reset Register
  #define HRTIM_TIMA_RSTAR (* ((volatile uint32_t *) (0x40017480 + 84)))

  // Field TIMECMP4: Timer E Compare 4
    const uint32_t HRTIM_TIMA_RSTAR_TIMECMP4 = 1U << 30 ;

  // Field TIMECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMA_RSTAR_TIMECMP2 = 1U << 29 ;

  // Field TIMECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMA_RSTAR_TIMECMP1 = 1U << 28 ;

  // Field TIMDCMP4: Timer D Compare 4
    const uint32_t HRTIM_TIMA_RSTAR_TIMDCMP4 = 1U << 27 ;

  // Field TIMDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMA_RSTAR_TIMDCMP2 = 1U << 26 ;

  // Field TIMDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMA_RSTAR_TIMDCMP1 = 1U << 25 ;

  // Field TIMCCMP4: Timer C Compare 4
    const uint32_t HRTIM_TIMA_RSTAR_TIMCCMP4 = 1U << 24 ;

  // Field TIMCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMA_RSTAR_TIMCCMP2 = 1U << 23 ;

  // Field TIMCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMA_RSTAR_TIMCCMP1 = 1U << 22 ;

  // Field TIMBCMP4: Timer B Compare 4
    const uint32_t HRTIM_TIMA_RSTAR_TIMBCMP4 = 1U << 21 ;

  // Field TIMBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMA_RSTAR_TIMBCMP2 = 1U << 20 ;

  // Field TIMBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMA_RSTAR_TIMBCMP1 = 1U << 19 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT10 = 1U << 18 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT9 = 1U << 17 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT8 = 1U << 16 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT7 = 1U << 15 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT6 = 1U << 14 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT5 = 1U << 13 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT4 = 1U << 12 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT3 = 1U << 11 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT2 = 1U << 10 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMA_RSTAR_EXTEVNT1 = 1U << 9 ;

  // Field MSTCMP4: Master compare 4
    const uint32_t HRTIM_TIMA_RSTAR_MSTCMP4 = 1U << 8 ;

  // Field MSTCMP3: Master compare 3
    const uint32_t HRTIM_TIMA_RSTAR_MSTCMP3 = 1U << 7 ;

  // Field MSTCMP2: Master compare 2
    const uint32_t HRTIM_TIMA_RSTAR_MSTCMP2 = 1U << 6 ;

  // Field MSTCMP1: Master compare 1
    const uint32_t HRTIM_TIMA_RSTAR_MSTCMP1 = 1U << 5 ;

  // Field MSTPER: Master timer Period
    const uint32_t HRTIM_TIMA_RSTAR_MSTPER = 1U << 4 ;

  // Field CMP4: Timer A compare 4 reset
    const uint32_t HRTIM_TIMA_RSTAR_CMP4 = 1U << 3 ;

  // Field CMP2: Timer A compare 2 reset
    const uint32_t HRTIM_TIMA_RSTAR_CMP2 = 1U << 2 ;

  // Field UPDT: Timer A Update reset
    const uint32_t HRTIM_TIMA_RSTAR_UPDT = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CHPAR: Timerx Chopper Register
  #define HRTIM_TIMA_CHPAR (* ((volatile uint32_t *) (0x40017480 + 88)))

  // Field STRTPW: STRTPW
    inline uint32_t HRTIM_TIMA_CHPAR_STRTPW (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field CHPDTY: Timerx chopper duty cycle value
    inline uint32_t HRTIM_TIMA_CHPAR_CHPDTY (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CHPFRQ: Timerx carrier frequency value
    inline uint32_t HRTIM_TIMA_CHPAR_CHPFRQ (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1ACR: Timerx Capture 2 Control Register
  #define HRTIM_TIMA_CPT1ACR (* ((volatile uint32_t *) (0x40017480 + 92)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMA_CPT1ACR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMA_CPT1ACR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMA_CPT1ACR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMA_CPT1ACR_TE1SET = 1U << 28 ;

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMA_CPT1ACR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMA_CPT1ACR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIMA_CPT1ACR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIMA_CPT1ACR_TD1SET = 1U << 24 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMA_CPT1ACR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMA_CPT1ACR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIMA_CPT1ACR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIMA_CPT1ACR_TC1SET = 1U << 20 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMA_CPT1ACR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMA_CPT1ACR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIMA_CPT1ACR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIMA_CPT1ACR_TB1SET = 1U << 16 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMA_CPT1ACR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CPT2ACR: CPT2xCR
  #define HRTIM_TIMA_CPT2ACR (* ((volatile uint32_t *) (0x40017480 + 96)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMA_CPT2ACR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMA_CPT2ACR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMA_CPT2ACR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMA_CPT2ACR_TE1SET = 1U << 28 ;

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMA_CPT2ACR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMA_CPT2ACR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIMA_CPT2ACR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIMA_CPT2ACR_TD1SET = 1U << 24 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMA_CPT2ACR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMA_CPT2ACR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIMA_CPT2ACR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIMA_CPT2ACR_TC1SET = 1U << 20 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMA_CPT2ACR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMA_CPT2ACR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIMA_CPT2ACR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIMA_CPT2ACR_TB1SET = 1U << 16 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMA_CPT2ACR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register OUTAR: Timerx Output Register
  #define HRTIM_TIMA_OUTAR (* ((volatile uint32_t *) (0x40017480 + 100)))

  // Field DIDL2: Output 2 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMA_OUTAR_DIDL2 = 1U << 23 ;

  // Field CHP2: Output 2 Chopper enable
    const uint32_t HRTIM_TIMA_OUTAR_CHP2 = 1U << 22 ;

  // Field FAULT2: Output 2 Fault state
    inline uint32_t HRTIM_TIMA_OUTAR_FAULT2 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field IDLES2: Output 2 Idle State
    const uint32_t HRTIM_TIMA_OUTAR_IDLES2 = 1U << 19 ;

  // Field IDLEM2: Output 2 Idle mode
    const uint32_t HRTIM_TIMA_OUTAR_IDLEM2 = 1U << 18 ;

  // Field POL2: Output 2 polarity
    const uint32_t HRTIM_TIMA_OUTAR_POL2 = 1U << 17 ;

  // Field DLYPRT: Delayed Protection
    inline uint32_t HRTIM_TIMA_OUTAR_DLYPRT (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field DLYPRTEN: Delayed Protection Enable
    const uint32_t HRTIM_TIMA_OUTAR_DLYPRTEN = 1U << 9 ;

  // Field DTEN: Deadtime enable
    const uint32_t HRTIM_TIMA_OUTAR_DTEN = 1U << 8 ;

  // Field DIDL1: Output 1 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMA_OUTAR_DIDL1 = 1U << 7 ;

  // Field CHP1: Output 1 Chopper enable
    const uint32_t HRTIM_TIMA_OUTAR_CHP1 = 1U << 6 ;

  // Field FAULT1: Output 1 Fault state
    inline uint32_t HRTIM_TIMA_OUTAR_FAULT1 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IDLES1: Output 1 Idle State
    const uint32_t HRTIM_TIMA_OUTAR_IDLES1 = 1U << 3 ;

  // Field IDLEM1: Output 1 Idle mode
    const uint32_t HRTIM_TIMA_OUTAR_IDLEM1 = 1U << 2 ;

  // Field POL1: Output 1 polarity
    const uint32_t HRTIM_TIMA_OUTAR_POL1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FLTAR: Timerx Fault Register
  #define HRTIM_TIMA_FLTAR (* ((volatile uint32_t *) (0x40017480 + 104)))

  // Field FLTLCK: Fault sources Lock
    const uint32_t HRTIM_TIMA_FLTAR_FLTLCK = 1U << 31 ;

  // Field FLT5EN: Fault 5 enable
    const uint32_t HRTIM_TIMA_FLTAR_FLT5EN = 1U << 4 ;

  // Field FLT4EN: Fault 4 enable
    const uint32_t HRTIM_TIMA_FLTAR_FLT4EN = 1U << 3 ;

  // Field FLT3EN: Fault 3 enable
    const uint32_t HRTIM_TIMA_FLTAR_FLT3EN = 1U << 2 ;

  // Field FLT2EN: Fault 2 enable
    const uint32_t HRTIM_TIMA_FLTAR_FLT2EN = 1U << 1 ;

  // Field FLT1EN: Fault 1 enable
    const uint32_t HRTIM_TIMA_FLTAR_FLT1EN = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral HRTIM_TIMB: High Resolution Timer: TIMB
//------------------------------------------------------------------------------

//---  Register TIMBCR: Timerx Control Register
  #define HRTIM_TIMB_TIMBCR (* ((volatile uint32_t *) (0x40017500 + 0)))

  // Field UPDGAT: Update Gating
    inline uint32_t HRTIM_TIMB_TIMBCR_UPDGAT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field PREEN: Preload enable
    const uint32_t HRTIM_TIMB_TIMBCR_PREEN = 1U << 27 ;

  // Field DACSYNC: AC Synchronization
    inline uint32_t HRTIM_TIMB_TIMBCR_DACSYNC (const uint32_t inValue) {return (inValue & 0x3U) << 25 ; }

  // Field MSTU: Master Timer update
    const uint32_t HRTIM_TIMB_TIMBCR_MSTU = 1U << 24 ;

  // Field TEU: TEU
    const uint32_t HRTIM_TIMB_TIMBCR_TEU = 1U << 23 ;

  // Field TDU: TDU
    const uint32_t HRTIM_TIMB_TIMBCR_TDU = 1U << 22 ;

  // Field TCU: TCU
    const uint32_t HRTIM_TIMB_TIMBCR_TCU = 1U << 21 ;

  // Field TBU: TBU
    const uint32_t HRTIM_TIMB_TIMBCR_TBU = 1U << 20 ;

  // Field TxRSTU: Timerx reset update
    const uint32_t HRTIM_TIMB_TIMBCR_TxRSTU = 1U << 18 ;

  // Field TxREPU: Timer x Repetition update
    const uint32_t HRTIM_TIMB_TIMBCR_TxREPU = 1U << 17 ;

  // Field DELCMP4: Delayed CMP4 mode
    inline uint32_t HRTIM_TIMB_TIMBCR_DELCMP4 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field DELCMP2: Delayed CMP2 mode
    inline uint32_t HRTIM_TIMB_TIMBCR_DELCMP2 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field SYNCSTRTx: Synchronization Starts Timer x
    const uint32_t HRTIM_TIMB_TIMBCR_SYNCSTRTx = 1U << 11 ;

  // Field SYNCRSTx: Synchronization Resets Timer x
    const uint32_t HRTIM_TIMB_TIMBCR_SYNCRSTx = 1U << 10 ;

  // Field PSHPLL: Push-Pull mode enable
    const uint32_t HRTIM_TIMB_TIMBCR_PSHPLL = 1U << 6 ;

  // Field HALF: Half mode enable
    const uint32_t HRTIM_TIMB_TIMBCR_HALF = 1U << 5 ;

  // Field RETRIG: Re-triggerable mode
    const uint32_t HRTIM_TIMB_TIMBCR_RETRIG = 1U << 4 ;

  // Field CONT: Continuous mode
    const uint32_t HRTIM_TIMB_TIMBCR_CONT = 1U << 3 ;

  // Field CK_PSCx: HRTIM Timer x Clock prescaler
    inline uint32_t HRTIM_TIMB_TIMBCR_CK_PSCx (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMBISR: Timerx Interrupt Status Register
  #define HRTIM_TIMB_TIMBISR (* ((const volatile uint32_t *) (0x40017500 + 4)))

  // Field O2STAT: Output 2 State
    const uint32_t HRTIM_TIMB_TIMBISR_O2STAT = 1U << 19 ;

  // Field O1STAT: Output 1 State
    const uint32_t HRTIM_TIMB_TIMBISR_O1STAT = 1U << 18 ;

  // Field IPPSTAT: Idle Push Pull Status
    const uint32_t HRTIM_TIMB_TIMBISR_IPPSTAT = 1U << 17 ;

  // Field CPPSTAT: Current Push Pull Status
    const uint32_t HRTIM_TIMB_TIMBISR_CPPSTAT = 1U << 16 ;

  // Field DLYPRT: Delayed Protection Flag
    const uint32_t HRTIM_TIMB_TIMBISR_DLYPRT = 1U << 14 ;

  // Field RST: Reset Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_RST = 1U << 13 ;

  // Field RSTx2: Output 2 Reset Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_RSTx2 = 1U << 12 ;

  // Field SETx2: Output 2 Set Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_SETx2 = 1U << 11 ;

  // Field RSTx1: Output 1 Reset Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_RSTx1 = 1U << 10 ;

  // Field SETx1: Output 1 Set Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_SETx1 = 1U << 9 ;

  // Field CPT2: Capture2 Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_CPT2 = 1U << 8 ;

  // Field CPT1: Capture1 Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_CPT1 = 1U << 7 ;

  // Field UPD: Update Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_UPD = 1U << 6 ;

  // Field REP: Repetition Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_REP = 1U << 4 ;

  // Field CMP4: Compare 4 Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_CMP4 = 1U << 3 ;

  // Field CMP3: Compare 3 Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_CMP3 = 1U << 2 ;

  // Field CMP2: Compare 2 Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_CMP2 = 1U << 1 ;

  // Field CMP1: Compare 1 Interrupt Flag
    const uint32_t HRTIM_TIMB_TIMBISR_CMP1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMBICR: Timerx Interrupt Clear Register
  #define HRTIM_TIMB_TIMBICR (* ((volatile uint32_t *) (0x40017500 + 8)))

  // Field DLYPRTC: Delayed Protection Flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_DLYPRTC = 1U << 14 ;

  // Field RSTC: Reset Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_RSTC = 1U << 13 ;

  // Field RSTx2C: Output 2 Reset flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_RSTx2C = 1U << 12 ;

  // Field SET2xC: Output 2 Set flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_SET2xC = 1U << 11 ;

  // Field RSTx1C: Output 1 Reset flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_RSTx1C = 1U << 10 ;

  // Field SET1xC: Output 1 Set flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_SET1xC = 1U << 9 ;

  // Field CPT2C: Capture2 Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_CPT2C = 1U << 8 ;

  // Field CPT1C: Capture1 Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_CPT1C = 1U << 7 ;

  // Field UPDC: Update Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_UPDC = 1U << 6 ;

  // Field REPC: Repetition Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_REPC = 1U << 4 ;

  // Field CMP4C: Compare 4 Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_CMP4C = 1U << 3 ;

  // Field CMP3C: Compare 3 Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_CMP3C = 1U << 2 ;

  // Field CMP2C: Compare 2 Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_CMP2C = 1U << 1 ;

  // Field CMP1C: Compare 1 Interrupt flag Clear
    const uint32_t HRTIM_TIMB_TIMBICR_CMP1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMBDIER5: TIMxDIER5
  #define HRTIM_TIMB_TIMBDIER5 (* ((volatile uint32_t *) (0x40017500 + 12)))

  // Field DLYPRTDE: DLYPRTDE
    const uint32_t HRTIM_TIMB_TIMBDIER5_DLYPRTDE = 1U << 30 ;

  // Field RSTDE: RSTDE
    const uint32_t HRTIM_TIMB_TIMBDIER5_RSTDE = 1U << 29 ;

  // Field RSTx2DE: RSTx2DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_RSTx2DE = 1U << 28 ;

  // Field SETx2DE: SETx2DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_SETx2DE = 1U << 27 ;

  // Field RSTx1DE: RSTx1DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_RSTx1DE = 1U << 26 ;

  // Field SET1xDE: SET1xDE
    const uint32_t HRTIM_TIMB_TIMBDIER5_SET1xDE = 1U << 25 ;

  // Field CPT2DE: CPT2DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CPT2DE = 1U << 24 ;

  // Field CPT1DE: CPT1DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CPT1DE = 1U << 23 ;

  // Field UPDDE: UPDDE
    const uint32_t HRTIM_TIMB_TIMBDIER5_UPDDE = 1U << 22 ;

  // Field REPDE: REPDE
    const uint32_t HRTIM_TIMB_TIMBDIER5_REPDE = 1U << 20 ;

  // Field CMP4DE: CMP4DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP4DE = 1U << 19 ;

  // Field CMP3DE: CMP3DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP3DE = 1U << 18 ;

  // Field CMP2DE: CMP2DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP2DE = 1U << 17 ;

  // Field CMP1DE: CMP1DE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP1DE = 1U << 16 ;

  // Field DLYPRTIE: DLYPRTIE
    const uint32_t HRTIM_TIMB_TIMBDIER5_DLYPRTIE = 1U << 14 ;

  // Field RSTIE: RSTIE
    const uint32_t HRTIM_TIMB_TIMBDIER5_RSTIE = 1U << 13 ;

  // Field RSTx2IE: RSTx2IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_RSTx2IE = 1U << 12 ;

  // Field SETx2IE: SETx2IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_SETx2IE = 1U << 11 ;

  // Field RSTx1IE: RSTx1IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_RSTx1IE = 1U << 10 ;

  // Field SET1xIE: SET1xIE
    const uint32_t HRTIM_TIMB_TIMBDIER5_SET1xIE = 1U << 9 ;

  // Field CPT2IE: CPT2IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CPT2IE = 1U << 8 ;

  // Field CPT1IE: CPT1IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CPT1IE = 1U << 7 ;

  // Field UPDIE: UPDIE
    const uint32_t HRTIM_TIMB_TIMBDIER5_UPDIE = 1U << 6 ;

  // Field REPIE: REPIE
    const uint32_t HRTIM_TIMB_TIMBDIER5_REPIE = 1U << 4 ;

  // Field CMP4IE: CMP4IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP4IE = 1U << 3 ;

  // Field CMP3IE: CMP3IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP3IE = 1U << 2 ;

  // Field CMP2IE: CMP2IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP2IE = 1U << 1 ;

  // Field CMP1IE: CMP1IE
    const uint32_t HRTIM_TIMB_TIMBDIER5_CMP1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNTR: Timerx Counter Register
  #define HRTIM_TIMB_CNTR (* ((volatile uint32_t *) (0x40017500 + 16)))

  // Field CNTx: Timerx Counter value
    inline uint32_t HRTIM_TIMB_CNTR_CNTx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERBR: Timerx Period Register
  #define HRTIM_TIMB_PERBR (* ((volatile uint32_t *) (0x40017500 + 20)))

  // Field PERx: Timerx Period value
    inline uint32_t HRTIM_TIMB_PERBR_PERx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register REPBR: Timerx Repetition Register
  #define HRTIM_TIMB_REPBR (* ((volatile uint32_t *) (0x40017500 + 24)))

  // Field REPx: Timerx Repetition counter value
    inline uint32_t HRTIM_TIMB_REPBR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1BR: Timerx Compare 1 Register
  #define HRTIM_TIMB_CMP1BR (* ((volatile uint32_t *) (0x40017500 + 28)))

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMB_CMP1BR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1CBR: Timerx Compare 1 Compound Register
  #define HRTIM_TIMB_CMP1CBR (* ((volatile uint32_t *) (0x40017500 + 32)))

  // Field REPx: Timerx Repetition value (aliased from HRTIM_REPx register)
    inline uint32_t HRTIM_TIMB_CMP1CBR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMB_CMP1CBR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP2BR: Timerx Compare 2 Register
  #define HRTIM_TIMB_CMP2BR (* ((volatile uint32_t *) (0x40017500 + 36)))

  // Field CMP2x: Timerx Compare 2 value
    inline uint32_t HRTIM_TIMB_CMP2BR_CMP2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP3BR: Timerx Compare 3 Register
  #define HRTIM_TIMB_CMP3BR (* ((volatile uint32_t *) (0x40017500 + 40)))

  // Field CMP3x: Timerx Compare 3 value
    inline uint32_t HRTIM_TIMB_CMP3BR_CMP3x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP4BR: Timerx Compare 4 Register
  #define HRTIM_TIMB_CMP4BR (* ((volatile uint32_t *) (0x40017500 + 44)))

  // Field CMP4x: Timerx Compare 4 value
    inline uint32_t HRTIM_TIMB_CMP4BR_CMP4x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1BR: Timerx Capture 1 Register
  #define HRTIM_TIMB_CPT1BR (* ((const volatile uint32_t *) (0x40017500 + 48)))

  // Field CPT1x: Timerx Capture 1 value
    inline uint32_t HRTIM_TIMB_CPT1BR_CPT1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT2BR: Timerx Capture 2 Register
  #define HRTIM_TIMB_CPT2BR (* ((const volatile uint32_t *) (0x40017500 + 52)))

  // Field CPT2x: Timerx Capture 2 value
    inline uint32_t HRTIM_TIMB_CPT2BR_CPT2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTBR: Timerx Deadtime Register
  #define HRTIM_TIMB_DTBR (* ((volatile uint32_t *) (0x40017500 + 56)))

  // Field DTFLKx: Deadtime Falling Lock
    const uint32_t HRTIM_TIMB_DTBR_DTFLKx = 1U << 31 ;

  // Field DTFSLKx: Deadtime Falling Sign Lock
    const uint32_t HRTIM_TIMB_DTBR_DTFSLKx = 1U << 30 ;

  // Field SDTFx: Sign Deadtime Falling value
    const uint32_t HRTIM_TIMB_DTBR_SDTFx = 1U << 25 ;

  // Field DTFx: Deadtime Falling value
    inline uint32_t HRTIM_TIMB_DTBR_DTFx (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field DTRLKx: Deadtime Rising Lock
    const uint32_t HRTIM_TIMB_DTBR_DTRLKx = 1U << 15 ;

  // Field DTRSLKx: Deadtime Rising Sign Lock
    const uint32_t HRTIM_TIMB_DTBR_DTRSLKx = 1U << 14 ;

  // Field DTPRSC: Deadtime Prescaler
    inline uint32_t HRTIM_TIMB_DTBR_DTPRSC (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field SDTRx: Sign Deadtime Rising value
    const uint32_t HRTIM_TIMB_DTBR_SDTRx = 1U << 9 ;

  // Field DTRx: Deadtime Rising value
    inline uint32_t HRTIM_TIMB_DTBR_DTRx (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SETB1R: Timerx Output1 Set Register
  #define HRTIM_TIMB_SETB1R (* ((volatile uint32_t *) (0x40017500 + 60)))

  // Field UPDATE: Registers update (transfer preload to active)
    const uint32_t HRTIM_TIMB_SETB1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMB_SETB1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: Timer Event 9
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: Timer Event 8
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: Timer Event 7
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: Timer Event 6
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: Timer Event 5
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: Timer Event 4
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: Timer Event 3
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: Timer Event 2
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: Timer Event 1
    const uint32_t HRTIM_TIMB_SETB1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: Master Compare 4
    const uint32_t HRTIM_TIMB_SETB1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: Master Compare 3
    const uint32_t HRTIM_TIMB_SETB1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: Master Compare 2
    const uint32_t HRTIM_TIMB_SETB1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: Master Compare 1
    const uint32_t HRTIM_TIMB_SETB1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: Master Period
    const uint32_t HRTIM_TIMB_SETB1R_MSTPER = 1U << 7 ;

  // Field CMP4: Timer A compare 4
    const uint32_t HRTIM_TIMB_SETB1R_CMP4 = 1U << 6 ;

  // Field CMP3: Timer A compare 3
    const uint32_t HRTIM_TIMB_SETB1R_CMP3 = 1U << 5 ;

  // Field CMP2: Timer A compare 2
    const uint32_t HRTIM_TIMB_SETB1R_CMP2 = 1U << 4 ;

  // Field CMP1: Timer A compare 1
    const uint32_t HRTIM_TIMB_SETB1R_CMP1 = 1U << 3 ;

  // Field PER: Timer A Period
    const uint32_t HRTIM_TIMB_SETB1R_PER = 1U << 2 ;

  // Field RESYNC: Timer A resynchronizaton
    const uint32_t HRTIM_TIMB_SETB1R_RESYNC = 1U << 1 ;

  // Field SST: Software Set trigger
    const uint32_t HRTIM_TIMB_SETB1R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTB1R: Timerx Output1 Reset Register
  #define HRTIM_TIMB_RSTB1R (* ((volatile uint32_t *) (0x40017500 + 64)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMB_RSTB1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMB_RSTB1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMB_RSTB1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMB_RSTB1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMB_RSTB1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMB_RSTB1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMB_RSTB1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMB_RSTB1R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMB_RSTB1R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMB_RSTB1R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMB_RSTB1R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMB_RSTB1R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMB_RSTB1R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMB_RSTB1R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMB_RSTB1R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SETB2R: Timerx Output2 Set Register
  #define HRTIM_TIMB_SETB2R (* ((volatile uint32_t *) (0x40017500 + 68)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMB_SETB2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMB_SETB2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMB_SETB2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMB_SETB2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMB_SETB2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMB_SETB2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMB_SETB2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMB_SETB2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMB_SETB2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMB_SETB2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMB_SETB2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMB_SETB2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMB_SETB2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMB_SETB2R_RESYNC = 1U << 1 ;

  // Field SST: SST
    const uint32_t HRTIM_TIMB_SETB2R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTB2R: Timerx Output2 Reset Register
  #define HRTIM_TIMB_RSTB2R (* ((volatile uint32_t *) (0x40017500 + 72)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMB_RSTB2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMB_RSTB2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMB_RSTB2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMB_RSTB2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMB_RSTB2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMB_RSTB2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMB_RSTB2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMB_RSTB2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMB_RSTB2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMB_RSTB2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMB_RSTB2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMB_RSTB2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMB_RSTB2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMB_RSTB2R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMB_RSTB2R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFBR1: Timerx External Event Filtering Register 1
  #define HRTIM_TIMB_EEFBR1 (* ((volatile uint32_t *) (0x40017500 + 76)))

  // Field EE5FLTR: External Event 5 filter
    inline uint32_t HRTIM_TIMB_EEFBR1_EE5FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE5LTCH: External Event 5 latch
    const uint32_t HRTIM_TIMB_EEFBR1_EE5LTCH = 1U << 24 ;

  // Field EE4FLTR: External Event 4 filter
    inline uint32_t HRTIM_TIMB_EEFBR1_EE4FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE4LTCH: External Event 4 latch
    const uint32_t HRTIM_TIMB_EEFBR1_EE4LTCH = 1U << 18 ;

  // Field EE3FLTR: External Event 3 filter
    inline uint32_t HRTIM_TIMB_EEFBR1_EE3FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE3LTCH: External Event 3 latch
    const uint32_t HRTIM_TIMB_EEFBR1_EE3LTCH = 1U << 12 ;

  // Field EE2FLTR: External Event 2 filter
    inline uint32_t HRTIM_TIMB_EEFBR1_EE2FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE2LTCH: External Event 2 latch
    const uint32_t HRTIM_TIMB_EEFBR1_EE2LTCH = 1U << 6 ;

  // Field EE1FLTR: External Event 1 filter
    inline uint32_t HRTIM_TIMB_EEFBR1_EE1FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE1LTCH: External Event 1 latch
    const uint32_t HRTIM_TIMB_EEFBR1_EE1LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFBR2: Timerx External Event Filtering Register 2
  #define HRTIM_TIMB_EEFBR2 (* ((volatile uint32_t *) (0x40017500 + 80)))

  // Field EE10FLTR: External Event 10 filter
    inline uint32_t HRTIM_TIMB_EEFBR2_EE10FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE10LTCH: External Event 10 latch
    const uint32_t HRTIM_TIMB_EEFBR2_EE10LTCH = 1U << 24 ;

  // Field EE9FLTR: External Event 9 filter
    inline uint32_t HRTIM_TIMB_EEFBR2_EE9FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE9LTCH: External Event 9 latch
    const uint32_t HRTIM_TIMB_EEFBR2_EE9LTCH = 1U << 18 ;

  // Field EE8FLTR: External Event 8 filter
    inline uint32_t HRTIM_TIMB_EEFBR2_EE8FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE8LTCH: External Event 8 latch
    const uint32_t HRTIM_TIMB_EEFBR2_EE8LTCH = 1U << 12 ;

  // Field EE7FLTR: External Event 7 filter
    inline uint32_t HRTIM_TIMB_EEFBR2_EE7FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE7LTCH: External Event 7 latch
    const uint32_t HRTIM_TIMB_EEFBR2_EE7LTCH = 1U << 6 ;

  // Field EE6FLTR: External Event 6 filter
    inline uint32_t HRTIM_TIMB_EEFBR2_EE6FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE6LTCH: External Event 6 latch
    const uint32_t HRTIM_TIMB_EEFBR2_EE6LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTBR: TimerA Reset Register
  #define HRTIM_TIMB_RSTBR (* ((volatile uint32_t *) (0x40017500 + 84)))

  // Field TIMECMP4: Timer E Compare 4
    const uint32_t HRTIM_TIMB_RSTBR_TIMECMP4 = 1U << 30 ;

  // Field TIMECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMB_RSTBR_TIMECMP2 = 1U << 29 ;

  // Field TIMECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMB_RSTBR_TIMECMP1 = 1U << 28 ;

  // Field TIMDCMP4: Timer D Compare 4
    const uint32_t HRTIM_TIMB_RSTBR_TIMDCMP4 = 1U << 27 ;

  // Field TIMDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMB_RSTBR_TIMDCMP2 = 1U << 26 ;

  // Field TIMDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMB_RSTBR_TIMDCMP1 = 1U << 25 ;

  // Field TIMCCMP4: Timer C Compare 4
    const uint32_t HRTIM_TIMB_RSTBR_TIMCCMP4 = 1U << 24 ;

  // Field TIMCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMB_RSTBR_TIMCCMP2 = 1U << 23 ;

  // Field TIMCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMB_RSTBR_TIMCCMP1 = 1U << 22 ;

  // Field TIMACMP4: Timer A Compare 4
    const uint32_t HRTIM_TIMB_RSTBR_TIMACMP4 = 1U << 21 ;

  // Field TIMACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMB_RSTBR_TIMACMP2 = 1U << 20 ;

  // Field TIMACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMB_RSTBR_TIMACMP1 = 1U << 19 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT10 = 1U << 18 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT9 = 1U << 17 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT8 = 1U << 16 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT7 = 1U << 15 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT6 = 1U << 14 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT5 = 1U << 13 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT4 = 1U << 12 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT3 = 1U << 11 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT2 = 1U << 10 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMB_RSTBR_EXTEVNT1 = 1U << 9 ;

  // Field MSTCMP4: Master compare 4
    const uint32_t HRTIM_TIMB_RSTBR_MSTCMP4 = 1U << 8 ;

  // Field MSTCMP3: Master compare 3
    const uint32_t HRTIM_TIMB_RSTBR_MSTCMP3 = 1U << 7 ;

  // Field MSTCMP2: Master compare 2
    const uint32_t HRTIM_TIMB_RSTBR_MSTCMP2 = 1U << 6 ;

  // Field MSTCMP1: Master compare 1
    const uint32_t HRTIM_TIMB_RSTBR_MSTCMP1 = 1U << 5 ;

  // Field MSTPER: Master timer Period
    const uint32_t HRTIM_TIMB_RSTBR_MSTPER = 1U << 4 ;

  // Field CMP4: Timer A compare 4 reset
    const uint32_t HRTIM_TIMB_RSTBR_CMP4 = 1U << 3 ;

  // Field CMP2: Timer A compare 2 reset
    const uint32_t HRTIM_TIMB_RSTBR_CMP2 = 1U << 2 ;

  // Field UPDT: Timer A Update reset
    const uint32_t HRTIM_TIMB_RSTBR_UPDT = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CHPBR: Timerx Chopper Register
  #define HRTIM_TIMB_CHPBR (* ((volatile uint32_t *) (0x40017500 + 88)))

  // Field STRTPW: STRTPW
    inline uint32_t HRTIM_TIMB_CHPBR_STRTPW (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field CHPDTY: Timerx chopper duty cycle value
    inline uint32_t HRTIM_TIMB_CHPBR_CHPDTY (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CHPFRQ: Timerx carrier frequency value
    inline uint32_t HRTIM_TIMB_CHPBR_CHPFRQ (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1BCR: Timerx Capture 2 Control Register
  #define HRTIM_TIMB_CPT1BCR (* ((volatile uint32_t *) (0x40017500 + 92)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMB_CPT1BCR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMB_CPT1BCR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMB_CPT1BCR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMB_CPT1BCR_TE1SET = 1U << 28 ;

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMB_CPT1BCR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMB_CPT1BCR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIMB_CPT1BCR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIMB_CPT1BCR_TD1SET = 1U << 24 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMB_CPT1BCR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMB_CPT1BCR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIMB_CPT1BCR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIMB_CPT1BCR_TC1SET = 1U << 20 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMB_CPT1BCR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMB_CPT1BCR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIMB_CPT1BCR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIMB_CPT1BCR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMB_CPT1BCR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CPT2BCR: CPT2xCR
  #define HRTIM_TIMB_CPT2BCR (* ((volatile uint32_t *) (0x40017500 + 96)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMB_CPT2BCR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMB_CPT2BCR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMB_CPT2BCR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMB_CPT2BCR_TE1SET = 1U << 28 ;

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMB_CPT2BCR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMB_CPT2BCR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIMB_CPT2BCR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIMB_CPT2BCR_TD1SET = 1U << 24 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMB_CPT2BCR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMB_CPT2BCR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIMB_CPT2BCR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIMB_CPT2BCR_TC1SET = 1U << 20 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMB_CPT2BCR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMB_CPT2BCR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIMB_CPT2BCR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIMB_CPT2BCR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMB_CPT2BCR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register OUTBR: Timerx Output Register
  #define HRTIM_TIMB_OUTBR (* ((volatile uint32_t *) (0x40017500 + 100)))

  // Field DIDL2: Output 2 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMB_OUTBR_DIDL2 = 1U << 23 ;

  // Field CHP2: Output 2 Chopper enable
    const uint32_t HRTIM_TIMB_OUTBR_CHP2 = 1U << 22 ;

  // Field FAULT2: Output 2 Fault state
    inline uint32_t HRTIM_TIMB_OUTBR_FAULT2 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field IDLES2: Output 2 Idle State
    const uint32_t HRTIM_TIMB_OUTBR_IDLES2 = 1U << 19 ;

  // Field IDLEM2: Output 2 Idle mode
    const uint32_t HRTIM_TIMB_OUTBR_IDLEM2 = 1U << 18 ;

  // Field POL2: Output 2 polarity
    const uint32_t HRTIM_TIMB_OUTBR_POL2 = 1U << 17 ;

  // Field DLYPRT: Delayed Protection
    inline uint32_t HRTIM_TIMB_OUTBR_DLYPRT (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field DLYPRTEN: Delayed Protection Enable
    const uint32_t HRTIM_TIMB_OUTBR_DLYPRTEN = 1U << 9 ;

  // Field DTEN: Deadtime enable
    const uint32_t HRTIM_TIMB_OUTBR_DTEN = 1U << 8 ;

  // Field DIDL1: Output 1 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMB_OUTBR_DIDL1 = 1U << 7 ;

  // Field CHP1: Output 1 Chopper enable
    const uint32_t HRTIM_TIMB_OUTBR_CHP1 = 1U << 6 ;

  // Field FAULT1: Output 1 Fault state
    inline uint32_t HRTIM_TIMB_OUTBR_FAULT1 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IDLES1: Output 1 Idle State
    const uint32_t HRTIM_TIMB_OUTBR_IDLES1 = 1U << 3 ;

  // Field IDLEM1: Output 1 Idle mode
    const uint32_t HRTIM_TIMB_OUTBR_IDLEM1 = 1U << 2 ;

  // Field POL1: Output 1 polarity
    const uint32_t HRTIM_TIMB_OUTBR_POL1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FLTBR: Timerx Fault Register
  #define HRTIM_TIMB_FLTBR (* ((volatile uint32_t *) (0x40017500 + 104)))

  // Field FLTLCK: Fault sources Lock
    const uint32_t HRTIM_TIMB_FLTBR_FLTLCK = 1U << 31 ;

  // Field FLT5EN: Fault 5 enable
    const uint32_t HRTIM_TIMB_FLTBR_FLT5EN = 1U << 4 ;

  // Field FLT4EN: Fault 4 enable
    const uint32_t HRTIM_TIMB_FLTBR_FLT4EN = 1U << 3 ;

  // Field FLT3EN: Fault 3 enable
    const uint32_t HRTIM_TIMB_FLTBR_FLT3EN = 1U << 2 ;

  // Field FLT2EN: Fault 2 enable
    const uint32_t HRTIM_TIMB_FLTBR_FLT2EN = 1U << 1 ;

  // Field FLT1EN: Fault 1 enable
    const uint32_t HRTIM_TIMB_FLTBR_FLT1EN = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral HRTIM_TIMC: High Resolution Timer: TIMC
//------------------------------------------------------------------------------

//---  Register TIMCCR: Timerx Control Register
  #define HRTIM_TIMC_TIMCCR (* ((volatile uint32_t *) (0x40017580 + 0)))

  // Field UPDGAT: Update Gating
    inline uint32_t HRTIM_TIMC_TIMCCR_UPDGAT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field PREEN: Preload enable
    const uint32_t HRTIM_TIMC_TIMCCR_PREEN = 1U << 27 ;

  // Field DACSYNC: AC Synchronization
    inline uint32_t HRTIM_TIMC_TIMCCR_DACSYNC (const uint32_t inValue) {return (inValue & 0x3U) << 25 ; }

  // Field MSTU: Master Timer update
    const uint32_t HRTIM_TIMC_TIMCCR_MSTU = 1U << 24 ;

  // Field TEU: TEU
    const uint32_t HRTIM_TIMC_TIMCCR_TEU = 1U << 23 ;

  // Field TDU: TDU
    const uint32_t HRTIM_TIMC_TIMCCR_TDU = 1U << 22 ;

  // Field TCU: TCU
    const uint32_t HRTIM_TIMC_TIMCCR_TCU = 1U << 21 ;

  // Field TBU: TBU
    const uint32_t HRTIM_TIMC_TIMCCR_TBU = 1U << 20 ;

  // Field TxRSTU: Timerx reset update
    const uint32_t HRTIM_TIMC_TIMCCR_TxRSTU = 1U << 18 ;

  // Field TxREPU: Timer x Repetition update
    const uint32_t HRTIM_TIMC_TIMCCR_TxREPU = 1U << 17 ;

  // Field DELCMP4: Delayed CMP4 mode
    inline uint32_t HRTIM_TIMC_TIMCCR_DELCMP4 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field DELCMP2: Delayed CMP2 mode
    inline uint32_t HRTIM_TIMC_TIMCCR_DELCMP2 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field SYNCSTRTx: Synchronization Starts Timer x
    const uint32_t HRTIM_TIMC_TIMCCR_SYNCSTRTx = 1U << 11 ;

  // Field SYNCRSTx: Synchronization Resets Timer x
    const uint32_t HRTIM_TIMC_TIMCCR_SYNCRSTx = 1U << 10 ;

  // Field PSHPLL: Push-Pull mode enable
    const uint32_t HRTIM_TIMC_TIMCCR_PSHPLL = 1U << 6 ;

  // Field HALF: Half mode enable
    const uint32_t HRTIM_TIMC_TIMCCR_HALF = 1U << 5 ;

  // Field RETRIG: Re-triggerable mode
    const uint32_t HRTIM_TIMC_TIMCCR_RETRIG = 1U << 4 ;

  // Field CONT: Continuous mode
    const uint32_t HRTIM_TIMC_TIMCCR_CONT = 1U << 3 ;

  // Field CK_PSCx: HRTIM Timer x Clock prescaler
    inline uint32_t HRTIM_TIMC_TIMCCR_CK_PSCx (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMCISR: Timerx Interrupt Status Register
  #define HRTIM_TIMC_TIMCISR (* ((const volatile uint32_t *) (0x40017580 + 4)))

  // Field O2STAT: Output 2 State
    const uint32_t HRTIM_TIMC_TIMCISR_O2STAT = 1U << 19 ;

  // Field O1STAT: Output 1 State
    const uint32_t HRTIM_TIMC_TIMCISR_O1STAT = 1U << 18 ;

  // Field IPPSTAT: Idle Push Pull Status
    const uint32_t HRTIM_TIMC_TIMCISR_IPPSTAT = 1U << 17 ;

  // Field CPPSTAT: Current Push Pull Status
    const uint32_t HRTIM_TIMC_TIMCISR_CPPSTAT = 1U << 16 ;

  // Field DLYPRT: Delayed Protection Flag
    const uint32_t HRTIM_TIMC_TIMCISR_DLYPRT = 1U << 14 ;

  // Field RST: Reset Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_RST = 1U << 13 ;

  // Field RSTx2: Output 2 Reset Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_RSTx2 = 1U << 12 ;

  // Field SETx2: Output 2 Set Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_SETx2 = 1U << 11 ;

  // Field RSTx1: Output 1 Reset Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_RSTx1 = 1U << 10 ;

  // Field SETx1: Output 1 Set Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_SETx1 = 1U << 9 ;

  // Field CPT2: Capture2 Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_CPT2 = 1U << 8 ;

  // Field CPT1: Capture1 Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_CPT1 = 1U << 7 ;

  // Field UPD: Update Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_UPD = 1U << 6 ;

  // Field REP: Repetition Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_REP = 1U << 4 ;

  // Field CMP4: Compare 4 Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_CMP4 = 1U << 3 ;

  // Field CMP3: Compare 3 Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_CMP3 = 1U << 2 ;

  // Field CMP2: Compare 2 Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_CMP2 = 1U << 1 ;

  // Field CMP1: Compare 1 Interrupt Flag
    const uint32_t HRTIM_TIMC_TIMCISR_CMP1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMCICR: Timerx Interrupt Clear Register
  #define HRTIM_TIMC_TIMCICR (* ((volatile uint32_t *) (0x40017580 + 8)))

  // Field DLYPRTC: Delayed Protection Flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_DLYPRTC = 1U << 14 ;

  // Field RSTC: Reset Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_RSTC = 1U << 13 ;

  // Field RSTx2C: Output 2 Reset flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_RSTx2C = 1U << 12 ;

  // Field SET2xC: Output 2 Set flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_SET2xC = 1U << 11 ;

  // Field RSTx1C: Output 1 Reset flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_RSTx1C = 1U << 10 ;

  // Field SET1xC: Output 1 Set flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_SET1xC = 1U << 9 ;

  // Field CPT2C: Capture2 Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_CPT2C = 1U << 8 ;

  // Field CPT1C: Capture1 Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_CPT1C = 1U << 7 ;

  // Field UPDC: Update Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_UPDC = 1U << 6 ;

  // Field REPC: Repetition Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_REPC = 1U << 4 ;

  // Field CMP4C: Compare 4 Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_CMP4C = 1U << 3 ;

  // Field CMP3C: Compare 3 Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_CMP3C = 1U << 2 ;

  // Field CMP2C: Compare 2 Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_CMP2C = 1U << 1 ;

  // Field CMP1C: Compare 1 Interrupt flag Clear
    const uint32_t HRTIM_TIMC_TIMCICR_CMP1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMCDIER5: TIMxDIER5
  #define HRTIM_TIMC_TIMCDIER5 (* ((volatile uint32_t *) (0x40017580 + 12)))

  // Field DLYPRTDE: DLYPRTDE
    const uint32_t HRTIM_TIMC_TIMCDIER5_DLYPRTDE = 1U << 30 ;

  // Field RSTDE: RSTDE
    const uint32_t HRTIM_TIMC_TIMCDIER5_RSTDE = 1U << 29 ;

  // Field RSTx2DE: RSTx2DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_RSTx2DE = 1U << 28 ;

  // Field SETx2DE: SETx2DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_SETx2DE = 1U << 27 ;

  // Field RSTx1DE: RSTx1DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_RSTx1DE = 1U << 26 ;

  // Field SET1xDE: SET1xDE
    const uint32_t HRTIM_TIMC_TIMCDIER5_SET1xDE = 1U << 25 ;

  // Field CPT2DE: CPT2DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CPT2DE = 1U << 24 ;

  // Field CPT1DE: CPT1DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CPT1DE = 1U << 23 ;

  // Field UPDDE: UPDDE
    const uint32_t HRTIM_TIMC_TIMCDIER5_UPDDE = 1U << 22 ;

  // Field REPDE: REPDE
    const uint32_t HRTIM_TIMC_TIMCDIER5_REPDE = 1U << 20 ;

  // Field CMP4DE: CMP4DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP4DE = 1U << 19 ;

  // Field CMP3DE: CMP3DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP3DE = 1U << 18 ;

  // Field CMP2DE: CMP2DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP2DE = 1U << 17 ;

  // Field CMP1DE: CMP1DE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP1DE = 1U << 16 ;

  // Field DLYPRTIE: DLYPRTIE
    const uint32_t HRTIM_TIMC_TIMCDIER5_DLYPRTIE = 1U << 14 ;

  // Field RSTIE: RSTIE
    const uint32_t HRTIM_TIMC_TIMCDIER5_RSTIE = 1U << 13 ;

  // Field RSTx2IE: RSTx2IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_RSTx2IE = 1U << 12 ;

  // Field SETx2IE: SETx2IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_SETx2IE = 1U << 11 ;

  // Field RSTx1IE: RSTx1IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_RSTx1IE = 1U << 10 ;

  // Field SET1xIE: SET1xIE
    const uint32_t HRTIM_TIMC_TIMCDIER5_SET1xIE = 1U << 9 ;

  // Field CPT2IE: CPT2IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CPT2IE = 1U << 8 ;

  // Field CPT1IE: CPT1IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CPT1IE = 1U << 7 ;

  // Field UPDIE: UPDIE
    const uint32_t HRTIM_TIMC_TIMCDIER5_UPDIE = 1U << 6 ;

  // Field REPIE: REPIE
    const uint32_t HRTIM_TIMC_TIMCDIER5_REPIE = 1U << 4 ;

  // Field CMP4IE: CMP4IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP4IE = 1U << 3 ;

  // Field CMP3IE: CMP3IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP3IE = 1U << 2 ;

  // Field CMP2IE: CMP2IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP2IE = 1U << 1 ;

  // Field CMP1IE: CMP1IE
    const uint32_t HRTIM_TIMC_TIMCDIER5_CMP1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNTCR: Timerx Counter Register
  #define HRTIM_TIMC_CNTCR (* ((volatile uint32_t *) (0x40017580 + 16)))

  // Field CNTx: Timerx Counter value
    inline uint32_t HRTIM_TIMC_CNTCR_CNTx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERCR: Timerx Period Register
  #define HRTIM_TIMC_PERCR (* ((volatile uint32_t *) (0x40017580 + 20)))

  // Field PERx: Timerx Period value
    inline uint32_t HRTIM_TIMC_PERCR_PERx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register REPCR: Timerx Repetition Register
  #define HRTIM_TIMC_REPCR (* ((volatile uint32_t *) (0x40017580 + 24)))

  // Field REPx: Timerx Repetition counter value
    inline uint32_t HRTIM_TIMC_REPCR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1CR: Timerx Compare 1 Register
  #define HRTIM_TIMC_CMP1CR (* ((volatile uint32_t *) (0x40017580 + 28)))

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMC_CMP1CR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1CCR: Timerx Compare 1 Compound Register
  #define HRTIM_TIMC_CMP1CCR (* ((volatile uint32_t *) (0x40017580 + 32)))

  // Field REPx: Timerx Repetition value (aliased from HRTIM_REPx register)
    inline uint32_t HRTIM_TIMC_CMP1CCR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMC_CMP1CCR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP2CR: Timerx Compare 2 Register
  #define HRTIM_TIMC_CMP2CR (* ((volatile uint32_t *) (0x40017580 + 36)))

  // Field CMP2x: Timerx Compare 2 value
    inline uint32_t HRTIM_TIMC_CMP2CR_CMP2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP3CR: Timerx Compare 3 Register
  #define HRTIM_TIMC_CMP3CR (* ((volatile uint32_t *) (0x40017580 + 40)))

  // Field CMP3x: Timerx Compare 3 value
    inline uint32_t HRTIM_TIMC_CMP3CR_CMP3x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP4CR: Timerx Compare 4 Register
  #define HRTIM_TIMC_CMP4CR (* ((volatile uint32_t *) (0x40017580 + 44)))

  // Field CMP4x: Timerx Compare 4 value
    inline uint32_t HRTIM_TIMC_CMP4CR_CMP4x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1CR: Timerx Capture 1 Register
  #define HRTIM_TIMC_CPT1CR (* ((const volatile uint32_t *) (0x40017580 + 48)))

  // Field CPT1x: Timerx Capture 1 value
    inline uint32_t HRTIM_TIMC_CPT1CR_CPT1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT2CR: Timerx Capture 2 Register
  #define HRTIM_TIMC_CPT2CR (* ((const volatile uint32_t *) (0x40017580 + 52)))

  // Field CPT2x: Timerx Capture 2 value
    inline uint32_t HRTIM_TIMC_CPT2CR_CPT2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTCR: Timerx Deadtime Register
  #define HRTIM_TIMC_DTCR (* ((volatile uint32_t *) (0x40017580 + 56)))

  // Field DTFLKx: Deadtime Falling Lock
    const uint32_t HRTIM_TIMC_DTCR_DTFLKx = 1U << 31 ;

  // Field DTFSLKx: Deadtime Falling Sign Lock
    const uint32_t HRTIM_TIMC_DTCR_DTFSLKx = 1U << 30 ;

  // Field SDTFx: Sign Deadtime Falling value
    const uint32_t HRTIM_TIMC_DTCR_SDTFx = 1U << 25 ;

  // Field DTFx: Deadtime Falling value
    inline uint32_t HRTIM_TIMC_DTCR_DTFx (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field DTRLKx: Deadtime Rising Lock
    const uint32_t HRTIM_TIMC_DTCR_DTRLKx = 1U << 15 ;

  // Field DTRSLKx: Deadtime Rising Sign Lock
    const uint32_t HRTIM_TIMC_DTCR_DTRSLKx = 1U << 14 ;

  // Field DTPRSC: Deadtime Prescaler
    inline uint32_t HRTIM_TIMC_DTCR_DTPRSC (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field SDTRx: Sign Deadtime Rising value
    const uint32_t HRTIM_TIMC_DTCR_SDTRx = 1U << 9 ;

  // Field DTRx: Deadtime Rising value
    inline uint32_t HRTIM_TIMC_DTCR_DTRx (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SETC1R: Timerx Output1 Set Register
  #define HRTIM_TIMC_SETC1R (* ((volatile uint32_t *) (0x40017580 + 60)))

  // Field UPDATE: Registers update (transfer preload to active)
    const uint32_t HRTIM_TIMC_SETC1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMC_SETC1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: Timer Event 9
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: Timer Event 8
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: Timer Event 7
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: Timer Event 6
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: Timer Event 5
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: Timer Event 4
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: Timer Event 3
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: Timer Event 2
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: Timer Event 1
    const uint32_t HRTIM_TIMC_SETC1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: Master Compare 4
    const uint32_t HRTIM_TIMC_SETC1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: Master Compare 3
    const uint32_t HRTIM_TIMC_SETC1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: Master Compare 2
    const uint32_t HRTIM_TIMC_SETC1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: Master Compare 1
    const uint32_t HRTIM_TIMC_SETC1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: Master Period
    const uint32_t HRTIM_TIMC_SETC1R_MSTPER = 1U << 7 ;

  // Field CMP4: Timer A compare 4
    const uint32_t HRTIM_TIMC_SETC1R_CMP4 = 1U << 6 ;

  // Field CMP3: Timer A compare 3
    const uint32_t HRTIM_TIMC_SETC1R_CMP3 = 1U << 5 ;

  // Field CMP2: Timer A compare 2
    const uint32_t HRTIM_TIMC_SETC1R_CMP2 = 1U << 4 ;

  // Field CMP1: Timer A compare 1
    const uint32_t HRTIM_TIMC_SETC1R_CMP1 = 1U << 3 ;

  // Field PER: Timer A Period
    const uint32_t HRTIM_TIMC_SETC1R_PER = 1U << 2 ;

  // Field RESYNC: Timer A resynchronizaton
    const uint32_t HRTIM_TIMC_SETC1R_RESYNC = 1U << 1 ;

  // Field SST: Software Set trigger
    const uint32_t HRTIM_TIMC_SETC1R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTC1R: Timerx Output1 Reset Register
  #define HRTIM_TIMC_RSTC1R (* ((volatile uint32_t *) (0x40017580 + 64)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMC_RSTC1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMC_RSTC1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMC_RSTC1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMC_RSTC1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMC_RSTC1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMC_RSTC1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMC_RSTC1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMC_RSTC1R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMC_RSTC1R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMC_RSTC1R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMC_RSTC1R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMC_RSTC1R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMC_RSTC1R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMC_RSTC1R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMC_RSTC1R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SETC2R: Timerx Output2 Set Register
  #define HRTIM_TIMC_SETC2R (* ((volatile uint32_t *) (0x40017580 + 68)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMC_SETC2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMC_SETC2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMC_SETC2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMC_SETC2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMC_SETC2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMC_SETC2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMC_SETC2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMC_SETC2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMC_SETC2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMC_SETC2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMC_SETC2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMC_SETC2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMC_SETC2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMC_SETC2R_RESYNC = 1U << 1 ;

  // Field SST: SST
    const uint32_t HRTIM_TIMC_SETC2R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTC2R: Timerx Output2 Reset Register
  #define HRTIM_TIMC_RSTC2R (* ((volatile uint32_t *) (0x40017580 + 72)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMC_RSTC2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMC_RSTC2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMC_RSTC2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMC_RSTC2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMC_RSTC2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMC_RSTC2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMC_RSTC2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMC_RSTC2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMC_RSTC2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMC_RSTC2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMC_RSTC2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMC_RSTC2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMC_RSTC2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMC_RSTC2R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMC_RSTC2R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFCR1: Timerx External Event Filtering Register 1
  #define HRTIM_TIMC_EEFCR1 (* ((volatile uint32_t *) (0x40017580 + 76)))

  // Field EE5FLTR: External Event 5 filter
    inline uint32_t HRTIM_TIMC_EEFCR1_EE5FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE5LTCH: External Event 5 latch
    const uint32_t HRTIM_TIMC_EEFCR1_EE5LTCH = 1U << 24 ;

  // Field EE4FLTR: External Event 4 filter
    inline uint32_t HRTIM_TIMC_EEFCR1_EE4FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE4LTCH: External Event 4 latch
    const uint32_t HRTIM_TIMC_EEFCR1_EE4LTCH = 1U << 18 ;

  // Field EE3FLTR: External Event 3 filter
    inline uint32_t HRTIM_TIMC_EEFCR1_EE3FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE3LTCH: External Event 3 latch
    const uint32_t HRTIM_TIMC_EEFCR1_EE3LTCH = 1U << 12 ;

  // Field EE2FLTR: External Event 2 filter
    inline uint32_t HRTIM_TIMC_EEFCR1_EE2FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE2LTCH: External Event 2 latch
    const uint32_t HRTIM_TIMC_EEFCR1_EE2LTCH = 1U << 6 ;

  // Field EE1FLTR: External Event 1 filter
    inline uint32_t HRTIM_TIMC_EEFCR1_EE1FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE1LTCH: External Event 1 latch
    const uint32_t HRTIM_TIMC_EEFCR1_EE1LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFCR2: Timerx External Event Filtering Register 2
  #define HRTIM_TIMC_EEFCR2 (* ((volatile uint32_t *) (0x40017580 + 80)))

  // Field EE10FLTR: External Event 10 filter
    inline uint32_t HRTIM_TIMC_EEFCR2_EE10FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE10LTCH: External Event 10 latch
    const uint32_t HRTIM_TIMC_EEFCR2_EE10LTCH = 1U << 24 ;

  // Field EE9FLTR: External Event 9 filter
    inline uint32_t HRTIM_TIMC_EEFCR2_EE9FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE9LTCH: External Event 9 latch
    const uint32_t HRTIM_TIMC_EEFCR2_EE9LTCH = 1U << 18 ;

  // Field EE8FLTR: External Event 8 filter
    inline uint32_t HRTIM_TIMC_EEFCR2_EE8FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE8LTCH: External Event 8 latch
    const uint32_t HRTIM_TIMC_EEFCR2_EE8LTCH = 1U << 12 ;

  // Field EE7FLTR: External Event 7 filter
    inline uint32_t HRTIM_TIMC_EEFCR2_EE7FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE7LTCH: External Event 7 latch
    const uint32_t HRTIM_TIMC_EEFCR2_EE7LTCH = 1U << 6 ;

  // Field EE6FLTR: External Event 6 filter
    inline uint32_t HRTIM_TIMC_EEFCR2_EE6FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE6LTCH: External Event 6 latch
    const uint32_t HRTIM_TIMC_EEFCR2_EE6LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTCR: TimerA Reset Register
  #define HRTIM_TIMC_RSTCR (* ((volatile uint32_t *) (0x40017580 + 84)))

  // Field TIMECMP4: Timer E Compare 4
    const uint32_t HRTIM_TIMC_RSTCR_TIMECMP4 = 1U << 30 ;

  // Field TIMECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMC_RSTCR_TIMECMP2 = 1U << 29 ;

  // Field TIMECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMC_RSTCR_TIMECMP1 = 1U << 28 ;

  // Field TIMDCMP4: Timer D Compare 4
    const uint32_t HRTIM_TIMC_RSTCR_TIMDCMP4 = 1U << 27 ;

  // Field TIMDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMC_RSTCR_TIMDCMP2 = 1U << 26 ;

  // Field TIMDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMC_RSTCR_TIMDCMP1 = 1U << 25 ;

  // Field TIMBCMP4: Timer B Compare 4
    const uint32_t HRTIM_TIMC_RSTCR_TIMBCMP4 = 1U << 24 ;

  // Field TIMBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMC_RSTCR_TIMBCMP2 = 1U << 23 ;

  // Field TIMBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMC_RSTCR_TIMBCMP1 = 1U << 22 ;

  // Field TIMACMP4: Timer A Compare 4
    const uint32_t HRTIM_TIMC_RSTCR_TIMACMP4 = 1U << 21 ;

  // Field TIMACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMC_RSTCR_TIMACMP2 = 1U << 20 ;

  // Field TIMACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMC_RSTCR_TIMACMP1 = 1U << 19 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT10 = 1U << 18 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT9 = 1U << 17 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT8 = 1U << 16 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT7 = 1U << 15 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT6 = 1U << 14 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT5 = 1U << 13 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT4 = 1U << 12 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT3 = 1U << 11 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT2 = 1U << 10 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMC_RSTCR_EXTEVNT1 = 1U << 9 ;

  // Field MSTCMP4: Master compare 4
    const uint32_t HRTIM_TIMC_RSTCR_MSTCMP4 = 1U << 8 ;

  // Field MSTCMP3: Master compare 3
    const uint32_t HRTIM_TIMC_RSTCR_MSTCMP3 = 1U << 7 ;

  // Field MSTCMP2: Master compare 2
    const uint32_t HRTIM_TIMC_RSTCR_MSTCMP2 = 1U << 6 ;

  // Field MSTCMP1: Master compare 1
    const uint32_t HRTIM_TIMC_RSTCR_MSTCMP1 = 1U << 5 ;

  // Field MSTPER: Master timer Period
    const uint32_t HRTIM_TIMC_RSTCR_MSTPER = 1U << 4 ;

  // Field CMP4: Timer A compare 4 reset
    const uint32_t HRTIM_TIMC_RSTCR_CMP4 = 1U << 3 ;

  // Field CMP2: Timer A compare 2 reset
    const uint32_t HRTIM_TIMC_RSTCR_CMP2 = 1U << 2 ;

  // Field UPDT: Timer A Update reset
    const uint32_t HRTIM_TIMC_RSTCR_UPDT = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CHPCR: Timerx Chopper Register
  #define HRTIM_TIMC_CHPCR (* ((volatile uint32_t *) (0x40017580 + 88)))

  // Field STRTPW: STRTPW
    inline uint32_t HRTIM_TIMC_CHPCR_STRTPW (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field CHPDTY: Timerx chopper duty cycle value
    inline uint32_t HRTIM_TIMC_CHPCR_CHPDTY (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CHPFRQ: Timerx carrier frequency value
    inline uint32_t HRTIM_TIMC_CHPCR_CHPFRQ (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1CCR: Timerx Capture 2 Control Register
  #define HRTIM_TIMC_CPT1CCR (* ((volatile uint32_t *) (0x40017580 + 92)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMC_CPT1CCR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMC_CPT1CCR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMC_CPT1CCR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMC_CPT1CCR_TE1SET = 1U << 28 ;

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMC_CPT1CCR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMC_CPT1CCR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIMC_CPT1CCR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIMC_CPT1CCR_TD1SET = 1U << 24 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMC_CPT1CCR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMC_CPT1CCR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIMC_CPT1CCR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIMC_CPT1CCR_TB1SET = 1U << 16 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMC_CPT1CCR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMC_CPT1CCR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIMC_CPT1CCR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIMC_CPT1CCR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMC_CPT1CCR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CPT2CCR: CPT2xCR
  #define HRTIM_TIMC_CPT2CCR (* ((volatile uint32_t *) (0x40017580 + 96)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMC_CPT2CCR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMC_CPT2CCR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMC_CPT2CCR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMC_CPT2CCR_TE1SET = 1U << 28 ;

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIMC_CPT2CCR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIMC_CPT2CCR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIMC_CPT2CCR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIMC_CPT2CCR_TD1SET = 1U << 24 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMC_CPT2CCR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMC_CPT2CCR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIMC_CPT2CCR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIMC_CPT2CCR_TB1SET = 1U << 16 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMC_CPT2CCR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMC_CPT2CCR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIMC_CPT2CCR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIMC_CPT2CCR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMC_CPT2CCR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register OUTCR: Timerx Output Register
  #define HRTIM_TIMC_OUTCR (* ((volatile uint32_t *) (0x40017580 + 100)))

  // Field DIDL2: Output 2 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMC_OUTCR_DIDL2 = 1U << 23 ;

  // Field CHP2: Output 2 Chopper enable
    const uint32_t HRTIM_TIMC_OUTCR_CHP2 = 1U << 22 ;

  // Field FAULT2: Output 2 Fault state
    inline uint32_t HRTIM_TIMC_OUTCR_FAULT2 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field IDLES2: Output 2 Idle State
    const uint32_t HRTIM_TIMC_OUTCR_IDLES2 = 1U << 19 ;

  // Field IDLEM2: Output 2 Idle mode
    const uint32_t HRTIM_TIMC_OUTCR_IDLEM2 = 1U << 18 ;

  // Field POL2: Output 2 polarity
    const uint32_t HRTIM_TIMC_OUTCR_POL2 = 1U << 17 ;

  // Field DLYPRT: Delayed Protection
    inline uint32_t HRTIM_TIMC_OUTCR_DLYPRT (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field DLYPRTEN: Delayed Protection Enable
    const uint32_t HRTIM_TIMC_OUTCR_DLYPRTEN = 1U << 9 ;

  // Field DTEN: Deadtime enable
    const uint32_t HRTIM_TIMC_OUTCR_DTEN = 1U << 8 ;

  // Field DIDL1: Output 1 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMC_OUTCR_DIDL1 = 1U << 7 ;

  // Field CHP1: Output 1 Chopper enable
    const uint32_t HRTIM_TIMC_OUTCR_CHP1 = 1U << 6 ;

  // Field FAULT1: Output 1 Fault state
    inline uint32_t HRTIM_TIMC_OUTCR_FAULT1 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IDLES1: Output 1 Idle State
    const uint32_t HRTIM_TIMC_OUTCR_IDLES1 = 1U << 3 ;

  // Field IDLEM1: Output 1 Idle mode
    const uint32_t HRTIM_TIMC_OUTCR_IDLEM1 = 1U << 2 ;

  // Field POL1: Output 1 polarity
    const uint32_t HRTIM_TIMC_OUTCR_POL1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FLTCR: Timerx Fault Register
  #define HRTIM_TIMC_FLTCR (* ((volatile uint32_t *) (0x40017580 + 104)))

  // Field FLTLCK: Fault sources Lock
    const uint32_t HRTIM_TIMC_FLTCR_FLTLCK = 1U << 31 ;

  // Field FLT5EN: Fault 5 enable
    const uint32_t HRTIM_TIMC_FLTCR_FLT5EN = 1U << 4 ;

  // Field FLT4EN: Fault 4 enable
    const uint32_t HRTIM_TIMC_FLTCR_FLT4EN = 1U << 3 ;

  // Field FLT3EN: Fault 3 enable
    const uint32_t HRTIM_TIMC_FLTCR_FLT3EN = 1U << 2 ;

  // Field FLT2EN: Fault 2 enable
    const uint32_t HRTIM_TIMC_FLTCR_FLT2EN = 1U << 1 ;

  // Field FLT1EN: Fault 1 enable
    const uint32_t HRTIM_TIMC_FLTCR_FLT1EN = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral HRTIM_TIMD: High Resolution Timer: TIMD
//------------------------------------------------------------------------------

//---  Register TIMDCR: Timerx Control Register
  #define HRTIM_TIMD_TIMDCR (* ((volatile uint32_t *) (0x40017600 + 0)))

  // Field UPDGAT: Update Gating
    inline uint32_t HRTIM_TIMD_TIMDCR_UPDGAT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field PREEN: Preload enable
    const uint32_t HRTIM_TIMD_TIMDCR_PREEN = 1U << 27 ;

  // Field DACSYNC: AC Synchronization
    inline uint32_t HRTIM_TIMD_TIMDCR_DACSYNC (const uint32_t inValue) {return (inValue & 0x3U) << 25 ; }

  // Field MSTU: Master Timer update
    const uint32_t HRTIM_TIMD_TIMDCR_MSTU = 1U << 24 ;

  // Field TEU: TEU
    const uint32_t HRTIM_TIMD_TIMDCR_TEU = 1U << 23 ;

  // Field TDU: TDU
    const uint32_t HRTIM_TIMD_TIMDCR_TDU = 1U << 22 ;

  // Field TCU: TCU
    const uint32_t HRTIM_TIMD_TIMDCR_TCU = 1U << 21 ;

  // Field TBU: TBU
    const uint32_t HRTIM_TIMD_TIMDCR_TBU = 1U << 20 ;

  // Field TxRSTU: Timerx reset update
    const uint32_t HRTIM_TIMD_TIMDCR_TxRSTU = 1U << 18 ;

  // Field TxREPU: Timer x Repetition update
    const uint32_t HRTIM_TIMD_TIMDCR_TxREPU = 1U << 17 ;

  // Field DELCMP4: Delayed CMP4 mode
    inline uint32_t HRTIM_TIMD_TIMDCR_DELCMP4 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field DELCMP2: Delayed CMP2 mode
    inline uint32_t HRTIM_TIMD_TIMDCR_DELCMP2 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field SYNCSTRTx: Synchronization Starts Timer x
    const uint32_t HRTIM_TIMD_TIMDCR_SYNCSTRTx = 1U << 11 ;

  // Field SYNCRSTx: Synchronization Resets Timer x
    const uint32_t HRTIM_TIMD_TIMDCR_SYNCRSTx = 1U << 10 ;

  // Field PSHPLL: Push-Pull mode enable
    const uint32_t HRTIM_TIMD_TIMDCR_PSHPLL = 1U << 6 ;

  // Field HALF: Half mode enable
    const uint32_t HRTIM_TIMD_TIMDCR_HALF = 1U << 5 ;

  // Field RETRIG: Re-triggerable mode
    const uint32_t HRTIM_TIMD_TIMDCR_RETRIG = 1U << 4 ;

  // Field CONT: Continuous mode
    const uint32_t HRTIM_TIMD_TIMDCR_CONT = 1U << 3 ;

  // Field CK_PSCx: HRTIM Timer x Clock prescaler
    inline uint32_t HRTIM_TIMD_TIMDCR_CK_PSCx (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMDISR: Timerx Interrupt Status Register
  #define HRTIM_TIMD_TIMDISR (* ((const volatile uint32_t *) (0x40017600 + 4)))

  // Field O2STAT: Output 2 State
    const uint32_t HRTIM_TIMD_TIMDISR_O2STAT = 1U << 19 ;

  // Field O1STAT: Output 1 State
    const uint32_t HRTIM_TIMD_TIMDISR_O1STAT = 1U << 18 ;

  // Field IPPSTAT: Idle Push Pull Status
    const uint32_t HRTIM_TIMD_TIMDISR_IPPSTAT = 1U << 17 ;

  // Field CPPSTAT: Current Push Pull Status
    const uint32_t HRTIM_TIMD_TIMDISR_CPPSTAT = 1U << 16 ;

  // Field DLYPRT: Delayed Protection Flag
    const uint32_t HRTIM_TIMD_TIMDISR_DLYPRT = 1U << 14 ;

  // Field RST: Reset Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_RST = 1U << 13 ;

  // Field RSTx2: Output 2 Reset Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_RSTx2 = 1U << 12 ;

  // Field SETx2: Output 2 Set Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_SETx2 = 1U << 11 ;

  // Field RSTx1: Output 1 Reset Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_RSTx1 = 1U << 10 ;

  // Field SETx1: Output 1 Set Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_SETx1 = 1U << 9 ;

  // Field CPT2: Capture2 Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_CPT2 = 1U << 8 ;

  // Field CPT1: Capture1 Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_CPT1 = 1U << 7 ;

  // Field UPD: Update Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_UPD = 1U << 6 ;

  // Field REP: Repetition Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_REP = 1U << 4 ;

  // Field CMP4: Compare 4 Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_CMP4 = 1U << 3 ;

  // Field CMP3: Compare 3 Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_CMP3 = 1U << 2 ;

  // Field CMP2: Compare 2 Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_CMP2 = 1U << 1 ;

  // Field CMP1: Compare 1 Interrupt Flag
    const uint32_t HRTIM_TIMD_TIMDISR_CMP1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMDICR: Timerx Interrupt Clear Register
  #define HRTIM_TIMD_TIMDICR (* ((volatile uint32_t *) (0x40017600 + 8)))

  // Field DLYPRTC: Delayed Protection Flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_DLYPRTC = 1U << 14 ;

  // Field RSTC: Reset Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_RSTC = 1U << 13 ;

  // Field RSTx2C: Output 2 Reset flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_RSTx2C = 1U << 12 ;

  // Field SET2xC: Output 2 Set flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_SET2xC = 1U << 11 ;

  // Field RSTx1C: Output 1 Reset flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_RSTx1C = 1U << 10 ;

  // Field SET1xC: Output 1 Set flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_SET1xC = 1U << 9 ;

  // Field CPT2C: Capture2 Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_CPT2C = 1U << 8 ;

  // Field CPT1C: Capture1 Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_CPT1C = 1U << 7 ;

  // Field UPDC: Update Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_UPDC = 1U << 6 ;

  // Field REPC: Repetition Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_REPC = 1U << 4 ;

  // Field CMP4C: Compare 4 Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_CMP4C = 1U << 3 ;

  // Field CMP3C: Compare 3 Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_CMP3C = 1U << 2 ;

  // Field CMP2C: Compare 2 Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_CMP2C = 1U << 1 ;

  // Field CMP1C: Compare 1 Interrupt flag Clear
    const uint32_t HRTIM_TIMD_TIMDICR_CMP1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMDDIER5: TIMxDIER5
  #define HRTIM_TIMD_TIMDDIER5 (* ((volatile uint32_t *) (0x40017600 + 12)))

  // Field DLYPRTDE: DLYPRTDE
    const uint32_t HRTIM_TIMD_TIMDDIER5_DLYPRTDE = 1U << 30 ;

  // Field RSTDE: RSTDE
    const uint32_t HRTIM_TIMD_TIMDDIER5_RSTDE = 1U << 29 ;

  // Field RSTx2DE: RSTx2DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_RSTx2DE = 1U << 28 ;

  // Field SETx2DE: SETx2DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_SETx2DE = 1U << 27 ;

  // Field RSTx1DE: RSTx1DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_RSTx1DE = 1U << 26 ;

  // Field SET1xDE: SET1xDE
    const uint32_t HRTIM_TIMD_TIMDDIER5_SET1xDE = 1U << 25 ;

  // Field CPT2DE: CPT2DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CPT2DE = 1U << 24 ;

  // Field CPT1DE: CPT1DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CPT1DE = 1U << 23 ;

  // Field UPDDE: UPDDE
    const uint32_t HRTIM_TIMD_TIMDDIER5_UPDDE = 1U << 22 ;

  // Field REPDE: REPDE
    const uint32_t HRTIM_TIMD_TIMDDIER5_REPDE = 1U << 20 ;

  // Field CMP4DE: CMP4DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP4DE = 1U << 19 ;

  // Field CMP3DE: CMP3DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP3DE = 1U << 18 ;

  // Field CMP2DE: CMP2DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP2DE = 1U << 17 ;

  // Field CMP1DE: CMP1DE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP1DE = 1U << 16 ;

  // Field DLYPRTIE: DLYPRTIE
    const uint32_t HRTIM_TIMD_TIMDDIER5_DLYPRTIE = 1U << 14 ;

  // Field RSTIE: RSTIE
    const uint32_t HRTIM_TIMD_TIMDDIER5_RSTIE = 1U << 13 ;

  // Field RSTx2IE: RSTx2IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_RSTx2IE = 1U << 12 ;

  // Field SETx2IE: SETx2IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_SETx2IE = 1U << 11 ;

  // Field RSTx1IE: RSTx1IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_RSTx1IE = 1U << 10 ;

  // Field SET1xIE: SET1xIE
    const uint32_t HRTIM_TIMD_TIMDDIER5_SET1xIE = 1U << 9 ;

  // Field CPT2IE: CPT2IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CPT2IE = 1U << 8 ;

  // Field CPT1IE: CPT1IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CPT1IE = 1U << 7 ;

  // Field UPDIE: UPDIE
    const uint32_t HRTIM_TIMD_TIMDDIER5_UPDIE = 1U << 6 ;

  // Field REPIE: REPIE
    const uint32_t HRTIM_TIMD_TIMDDIER5_REPIE = 1U << 4 ;

  // Field CMP4IE: CMP4IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP4IE = 1U << 3 ;

  // Field CMP3IE: CMP3IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP3IE = 1U << 2 ;

  // Field CMP2IE: CMP2IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP2IE = 1U << 1 ;

  // Field CMP1IE: CMP1IE
    const uint32_t HRTIM_TIMD_TIMDDIER5_CMP1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNTDR: Timerx Counter Register
  #define HRTIM_TIMD_CNTDR (* ((volatile uint32_t *) (0x40017600 + 16)))

  // Field CNTx: Timerx Counter value
    inline uint32_t HRTIM_TIMD_CNTDR_CNTx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERDR: Timerx Period Register
  #define HRTIM_TIMD_PERDR (* ((volatile uint32_t *) (0x40017600 + 20)))

  // Field PERx: Timerx Period value
    inline uint32_t HRTIM_TIMD_PERDR_PERx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register REPDR: Timerx Repetition Register
  #define HRTIM_TIMD_REPDR (* ((volatile uint32_t *) (0x40017600 + 24)))

  // Field REPx: Timerx Repetition counter value
    inline uint32_t HRTIM_TIMD_REPDR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1DR: Timerx Compare 1 Register
  #define HRTIM_TIMD_CMP1DR (* ((volatile uint32_t *) (0x40017600 + 28)))

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMD_CMP1DR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1CDR: Timerx Compare 1 Compound Register
  #define HRTIM_TIMD_CMP1CDR (* ((volatile uint32_t *) (0x40017600 + 32)))

  // Field REPx: Timerx Repetition value (aliased from HRTIM_REPx register)
    inline uint32_t HRTIM_TIMD_CMP1CDR_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIMD_CMP1CDR_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP2DR: Timerx Compare 2 Register
  #define HRTIM_TIMD_CMP2DR (* ((volatile uint32_t *) (0x40017600 + 36)))

  // Field CMP2x: Timerx Compare 2 value
    inline uint32_t HRTIM_TIMD_CMP2DR_CMP2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP3DR: Timerx Compare 3 Register
  #define HRTIM_TIMD_CMP3DR (* ((volatile uint32_t *) (0x40017600 + 40)))

  // Field CMP3x: Timerx Compare 3 value
    inline uint32_t HRTIM_TIMD_CMP3DR_CMP3x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP4DR: Timerx Compare 4 Register
  #define HRTIM_TIMD_CMP4DR (* ((volatile uint32_t *) (0x40017600 + 44)))

  // Field CMP4x: Timerx Compare 4 value
    inline uint32_t HRTIM_TIMD_CMP4DR_CMP4x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1DR: Timerx Capture 1 Register
  #define HRTIM_TIMD_CPT1DR (* ((const volatile uint32_t *) (0x40017600 + 48)))

  // Field CPT1x: Timerx Capture 1 value
    inline uint32_t HRTIM_TIMD_CPT1DR_CPT1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT2DR: Timerx Capture 2 Register
  #define HRTIM_TIMD_CPT2DR (* ((const volatile uint32_t *) (0x40017600 + 52)))

  // Field CPT2x: Timerx Capture 2 value
    inline uint32_t HRTIM_TIMD_CPT2DR_CPT2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTDR: Timerx Deadtime Register
  #define HRTIM_TIMD_DTDR (* ((volatile uint32_t *) (0x40017600 + 56)))

  // Field DTFLKx: Deadtime Falling Lock
    const uint32_t HRTIM_TIMD_DTDR_DTFLKx = 1U << 31 ;

  // Field DTFSLKx: Deadtime Falling Sign Lock
    const uint32_t HRTIM_TIMD_DTDR_DTFSLKx = 1U << 30 ;

  // Field SDTFx: Sign Deadtime Falling value
    const uint32_t HRTIM_TIMD_DTDR_SDTFx = 1U << 25 ;

  // Field DTFx: Deadtime Falling value
    inline uint32_t HRTIM_TIMD_DTDR_DTFx (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field DTRLKx: Deadtime Rising Lock
    const uint32_t HRTIM_TIMD_DTDR_DTRLKx = 1U << 15 ;

  // Field DTRSLKx: Deadtime Rising Sign Lock
    const uint32_t HRTIM_TIMD_DTDR_DTRSLKx = 1U << 14 ;

  // Field DTPRSC: Deadtime Prescaler
    inline uint32_t HRTIM_TIMD_DTDR_DTPRSC (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field SDTRx: Sign Deadtime Rising value
    const uint32_t HRTIM_TIMD_DTDR_SDTRx = 1U << 9 ;

  // Field DTRx: Deadtime Rising value
    inline uint32_t HRTIM_TIMD_DTDR_DTRx (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SETD1R: Timerx Output1 Set Register
  #define HRTIM_TIMD_SETD1R (* ((volatile uint32_t *) (0x40017600 + 60)))

  // Field UPDATE: Registers update (transfer preload to active)
    const uint32_t HRTIM_TIMD_SETD1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMD_SETD1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: Timer Event 9
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: Timer Event 8
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: Timer Event 7
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: Timer Event 6
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: Timer Event 5
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: Timer Event 4
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: Timer Event 3
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: Timer Event 2
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: Timer Event 1
    const uint32_t HRTIM_TIMD_SETD1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: Master Compare 4
    const uint32_t HRTIM_TIMD_SETD1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: Master Compare 3
    const uint32_t HRTIM_TIMD_SETD1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: Master Compare 2
    const uint32_t HRTIM_TIMD_SETD1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: Master Compare 1
    const uint32_t HRTIM_TIMD_SETD1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: Master Period
    const uint32_t HRTIM_TIMD_SETD1R_MSTPER = 1U << 7 ;

  // Field CMP4: Timer A compare 4
    const uint32_t HRTIM_TIMD_SETD1R_CMP4 = 1U << 6 ;

  // Field CMP3: Timer A compare 3
    const uint32_t HRTIM_TIMD_SETD1R_CMP3 = 1U << 5 ;

  // Field CMP2: Timer A compare 2
    const uint32_t HRTIM_TIMD_SETD1R_CMP2 = 1U << 4 ;

  // Field CMP1: Timer A compare 1
    const uint32_t HRTIM_TIMD_SETD1R_CMP1 = 1U << 3 ;

  // Field PER: Timer A Period
    const uint32_t HRTIM_TIMD_SETD1R_PER = 1U << 2 ;

  // Field RESYNC: Timer A resynchronizaton
    const uint32_t HRTIM_TIMD_SETD1R_RESYNC = 1U << 1 ;

  // Field SST: Software Set trigger
    const uint32_t HRTIM_TIMD_SETD1R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTD1R: Timerx Output1 Reset Register
  #define HRTIM_TIMD_RSTD1R (* ((volatile uint32_t *) (0x40017600 + 64)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMD_RSTD1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMD_RSTD1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMD_RSTD1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMD_RSTD1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMD_RSTD1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMD_RSTD1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMD_RSTD1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMD_RSTD1R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMD_RSTD1R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMD_RSTD1R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMD_RSTD1R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMD_RSTD1R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMD_RSTD1R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMD_RSTD1R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMD_RSTD1R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SETD2R: Timerx Output2 Set Register
  #define HRTIM_TIMD_SETD2R (* ((volatile uint32_t *) (0x40017600 + 68)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMD_SETD2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMD_SETD2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMD_SETD2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMD_SETD2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMD_SETD2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMD_SETD2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMD_SETD2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMD_SETD2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMD_SETD2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMD_SETD2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMD_SETD2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMD_SETD2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMD_SETD2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMD_SETD2R_RESYNC = 1U << 1 ;

  // Field SST: SST
    const uint32_t HRTIM_TIMD_SETD2R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTD2R: Timerx Output2 Reset Register
  #define HRTIM_TIMD_RSTD2R (* ((volatile uint32_t *) (0x40017600 + 72)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIMD_RSTD2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIMD_RSTD2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIMD_RSTD2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIMD_RSTD2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIMD_RSTD2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIMD_RSTD2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIMD_RSTD2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIMD_RSTD2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIMD_RSTD2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIMD_RSTD2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIMD_RSTD2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIMD_RSTD2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIMD_RSTD2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIMD_RSTD2R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIMD_RSTD2R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFDR1: Timerx External Event Filtering Register 1
  #define HRTIM_TIMD_EEFDR1 (* ((volatile uint32_t *) (0x40017600 + 76)))

  // Field EE5FLTR: External Event 5 filter
    inline uint32_t HRTIM_TIMD_EEFDR1_EE5FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE5LTCH: External Event 5 latch
    const uint32_t HRTIM_TIMD_EEFDR1_EE5LTCH = 1U << 24 ;

  // Field EE4FLTR: External Event 4 filter
    inline uint32_t HRTIM_TIMD_EEFDR1_EE4FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE4LTCH: External Event 4 latch
    const uint32_t HRTIM_TIMD_EEFDR1_EE4LTCH = 1U << 18 ;

  // Field EE3FLTR: External Event 3 filter
    inline uint32_t HRTIM_TIMD_EEFDR1_EE3FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE3LTCH: External Event 3 latch
    const uint32_t HRTIM_TIMD_EEFDR1_EE3LTCH = 1U << 12 ;

  // Field EE2FLTR: External Event 2 filter
    inline uint32_t HRTIM_TIMD_EEFDR1_EE2FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE2LTCH: External Event 2 latch
    const uint32_t HRTIM_TIMD_EEFDR1_EE2LTCH = 1U << 6 ;

  // Field EE1FLTR: External Event 1 filter
    inline uint32_t HRTIM_TIMD_EEFDR1_EE1FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE1LTCH: External Event 1 latch
    const uint32_t HRTIM_TIMD_EEFDR1_EE1LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFDR2: Timerx External Event Filtering Register 2
  #define HRTIM_TIMD_EEFDR2 (* ((volatile uint32_t *) (0x40017600 + 80)))

  // Field EE10FLTR: External Event 10 filter
    inline uint32_t HRTIM_TIMD_EEFDR2_EE10FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE10LTCH: External Event 10 latch
    const uint32_t HRTIM_TIMD_EEFDR2_EE10LTCH = 1U << 24 ;

  // Field EE9FLTR: External Event 9 filter
    inline uint32_t HRTIM_TIMD_EEFDR2_EE9FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE9LTCH: External Event 9 latch
    const uint32_t HRTIM_TIMD_EEFDR2_EE9LTCH = 1U << 18 ;

  // Field EE8FLTR: External Event 8 filter
    inline uint32_t HRTIM_TIMD_EEFDR2_EE8FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE8LTCH: External Event 8 latch
    const uint32_t HRTIM_TIMD_EEFDR2_EE8LTCH = 1U << 12 ;

  // Field EE7FLTR: External Event 7 filter
    inline uint32_t HRTIM_TIMD_EEFDR2_EE7FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE7LTCH: External Event 7 latch
    const uint32_t HRTIM_TIMD_EEFDR2_EE7LTCH = 1U << 6 ;

  // Field EE6FLTR: External Event 6 filter
    inline uint32_t HRTIM_TIMD_EEFDR2_EE6FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE6LTCH: External Event 6 latch
    const uint32_t HRTIM_TIMD_EEFDR2_EE6LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTDR: TimerA Reset Register
  #define HRTIM_TIMD_RSTDR (* ((volatile uint32_t *) (0x40017600 + 84)))

  // Field TIMECMP4: Timer E Compare 4
    const uint32_t HRTIM_TIMD_RSTDR_TIMECMP4 = 1U << 30 ;

  // Field TIMECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMD_RSTDR_TIMECMP2 = 1U << 29 ;

  // Field TIMECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMD_RSTDR_TIMECMP1 = 1U << 28 ;

  // Field TIMCCMP4: Timer C Compare 4
    const uint32_t HRTIM_TIMD_RSTDR_TIMCCMP4 = 1U << 27 ;

  // Field TIMCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMD_RSTDR_TIMCCMP2 = 1U << 26 ;

  // Field TIMCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMD_RSTDR_TIMCCMP1 = 1U << 25 ;

  // Field TIMBCMP4: Timer B Compare 4
    const uint32_t HRTIM_TIMD_RSTDR_TIMBCMP4 = 1U << 24 ;

  // Field TIMBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMD_RSTDR_TIMBCMP2 = 1U << 23 ;

  // Field TIMBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMD_RSTDR_TIMBCMP1 = 1U << 22 ;

  // Field TIMACMP4: Timer A Compare 4
    const uint32_t HRTIM_TIMD_RSTDR_TIMACMP4 = 1U << 21 ;

  // Field TIMACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMD_RSTDR_TIMACMP2 = 1U << 20 ;

  // Field TIMACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMD_RSTDR_TIMACMP1 = 1U << 19 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT10 = 1U << 18 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT9 = 1U << 17 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT8 = 1U << 16 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT7 = 1U << 15 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT6 = 1U << 14 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT5 = 1U << 13 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT4 = 1U << 12 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT3 = 1U << 11 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT2 = 1U << 10 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIMD_RSTDR_EXTEVNT1 = 1U << 9 ;

  // Field MSTCMP4: Master compare 4
    const uint32_t HRTIM_TIMD_RSTDR_MSTCMP4 = 1U << 8 ;

  // Field MSTCMP3: Master compare 3
    const uint32_t HRTIM_TIMD_RSTDR_MSTCMP3 = 1U << 7 ;

  // Field MSTCMP2: Master compare 2
    const uint32_t HRTIM_TIMD_RSTDR_MSTCMP2 = 1U << 6 ;

  // Field MSTCMP1: Master compare 1
    const uint32_t HRTIM_TIMD_RSTDR_MSTCMP1 = 1U << 5 ;

  // Field MSTPER: Master timer Period
    const uint32_t HRTIM_TIMD_RSTDR_MSTPER = 1U << 4 ;

  // Field CMP4: Timer A compare 4 reset
    const uint32_t HRTIM_TIMD_RSTDR_CMP4 = 1U << 3 ;

  // Field CMP2: Timer A compare 2 reset
    const uint32_t HRTIM_TIMD_RSTDR_CMP2 = 1U << 2 ;

  // Field UPDT: Timer A Update reset
    const uint32_t HRTIM_TIMD_RSTDR_UPDT = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CHPDR: Timerx Chopper Register
  #define HRTIM_TIMD_CHPDR (* ((volatile uint32_t *) (0x40017600 + 88)))

  // Field STRTPW: STRTPW
    inline uint32_t HRTIM_TIMD_CHPDR_STRTPW (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field CHPDTY: Timerx chopper duty cycle value
    inline uint32_t HRTIM_TIMD_CHPDR_CHPDTY (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CHPFRQ: Timerx carrier frequency value
    inline uint32_t HRTIM_TIMD_CHPDR_CHPFRQ (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1DCR: Timerx Capture 2 Control Register
  #define HRTIM_TIMD_CPT1DCR (* ((volatile uint32_t *) (0x40017600 + 92)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMD_CPT1DCR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMD_CPT1DCR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMD_CPT1DCR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMD_CPT1DCR_TE1SET = 1U << 28 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMD_CPT1DCR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMD_CPT1DCR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIMD_CPT1DCR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIMD_CPT1DCR_TC1SET = 1U << 20 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMD_CPT1DCR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMD_CPT1DCR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIMD_CPT1DCR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIMD_CPT1DCR_TB1SET = 1U << 16 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMD_CPT1DCR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMD_CPT1DCR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIMD_CPT1DCR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIMD_CPT1DCR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMD_CPT1DCR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CPT2DCR: CPT2xCR
  #define HRTIM_TIMD_CPT2DCR (* ((volatile uint32_t *) (0x40017600 + 96)))

  // Field TECMP2: Timer E Compare 2
    const uint32_t HRTIM_TIMD_CPT2DCR_TECMP2 = 1U << 31 ;

  // Field TECMP1: Timer E Compare 1
    const uint32_t HRTIM_TIMD_CPT2DCR_TECMP1 = 1U << 30 ;

  // Field TE1RST: Timer E output 1 Reset
    const uint32_t HRTIM_TIMD_CPT2DCR_TE1RST = 1U << 29 ;

  // Field TE1SET: Timer E output 1 Set
    const uint32_t HRTIM_TIMD_CPT2DCR_TE1SET = 1U << 28 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIMD_CPT2DCR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIMD_CPT2DCR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIMD_CPT2DCR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIMD_CPT2DCR_TC1SET = 1U << 20 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIMD_CPT2DCR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIMD_CPT2DCR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIMD_CPT2DCR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIMD_CPT2DCR_TB1SET = 1U << 16 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIMD_CPT2DCR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIMD_CPT2DCR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIMD_CPT2DCR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIMD_CPT2DCR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIMD_CPT2DCR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register OUTDR: Timerx Output Register
  #define HRTIM_TIMD_OUTDR (* ((volatile uint32_t *) (0x40017600 + 100)))

  // Field DIDL2: Output 2 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMD_OUTDR_DIDL2 = 1U << 23 ;

  // Field CHP2: Output 2 Chopper enable
    const uint32_t HRTIM_TIMD_OUTDR_CHP2 = 1U << 22 ;

  // Field FAULT2: Output 2 Fault state
    inline uint32_t HRTIM_TIMD_OUTDR_FAULT2 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field IDLES2: Output 2 Idle State
    const uint32_t HRTIM_TIMD_OUTDR_IDLES2 = 1U << 19 ;

  // Field IDLEM2: Output 2 Idle mode
    const uint32_t HRTIM_TIMD_OUTDR_IDLEM2 = 1U << 18 ;

  // Field POL2: Output 2 polarity
    const uint32_t HRTIM_TIMD_OUTDR_POL2 = 1U << 17 ;

  // Field DLYPRT: Delayed Protection
    inline uint32_t HRTIM_TIMD_OUTDR_DLYPRT (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field DLYPRTEN: Delayed Protection Enable
    const uint32_t HRTIM_TIMD_OUTDR_DLYPRTEN = 1U << 9 ;

  // Field DTEN: Deadtime enable
    const uint32_t HRTIM_TIMD_OUTDR_DTEN = 1U << 8 ;

  // Field DIDL1: Output 1 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIMD_OUTDR_DIDL1 = 1U << 7 ;

  // Field CHP1: Output 1 Chopper enable
    const uint32_t HRTIM_TIMD_OUTDR_CHP1 = 1U << 6 ;

  // Field FAULT1: Output 1 Fault state
    inline uint32_t HRTIM_TIMD_OUTDR_FAULT1 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IDLES1: Output 1 Idle State
    const uint32_t HRTIM_TIMD_OUTDR_IDLES1 = 1U << 3 ;

  // Field IDLEM1: Output 1 Idle mode
    const uint32_t HRTIM_TIMD_OUTDR_IDLEM1 = 1U << 2 ;

  // Field POL1: Output 1 polarity
    const uint32_t HRTIM_TIMD_OUTDR_POL1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FLTDR: Timerx Fault Register
  #define HRTIM_TIMD_FLTDR (* ((volatile uint32_t *) (0x40017600 + 104)))

  // Field FLTLCK: Fault sources Lock
    const uint32_t HRTIM_TIMD_FLTDR_FLTLCK = 1U << 31 ;

  // Field FLT5EN: Fault 5 enable
    const uint32_t HRTIM_TIMD_FLTDR_FLT5EN = 1U << 4 ;

  // Field FLT4EN: Fault 4 enable
    const uint32_t HRTIM_TIMD_FLTDR_FLT4EN = 1U << 3 ;

  // Field FLT3EN: Fault 3 enable
    const uint32_t HRTIM_TIMD_FLTDR_FLT3EN = 1U << 2 ;

  // Field FLT2EN: Fault 2 enable
    const uint32_t HRTIM_TIMD_FLTDR_FLT2EN = 1U << 1 ;

  // Field FLT1EN: Fault 1 enable
    const uint32_t HRTIM_TIMD_FLTDR_FLT1EN = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral HRTIM_TIME: High Resolution Timer: TIME
//------------------------------------------------------------------------------

//---  Register TIMECR: Timerx Control Register
  #define HRTIM_TIME_TIMECR (* ((volatile uint32_t *) (0x40017680 + 0)))

  // Field UPDGAT: Update Gating
    inline uint32_t HRTIM_TIME_TIMECR_UPDGAT (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field PREEN: Preload enable
    const uint32_t HRTIM_TIME_TIMECR_PREEN = 1U << 27 ;

  // Field DACSYNC: AC Synchronization
    inline uint32_t HRTIM_TIME_TIMECR_DACSYNC (const uint32_t inValue) {return (inValue & 0x3U) << 25 ; }

  // Field MSTU: Master Timer update
    const uint32_t HRTIM_TIME_TIMECR_MSTU = 1U << 24 ;

  // Field TEU: TEU
    const uint32_t HRTIM_TIME_TIMECR_TEU = 1U << 23 ;

  // Field TDU: TDU
    const uint32_t HRTIM_TIME_TIMECR_TDU = 1U << 22 ;

  // Field TCU: TCU
    const uint32_t HRTIM_TIME_TIMECR_TCU = 1U << 21 ;

  // Field TBU: TBU
    const uint32_t HRTIM_TIME_TIMECR_TBU = 1U << 20 ;

  // Field TxRSTU: Timerx reset update
    const uint32_t HRTIM_TIME_TIMECR_TxRSTU = 1U << 18 ;

  // Field TxREPU: Timer x Repetition update
    const uint32_t HRTIM_TIME_TIMECR_TxREPU = 1U << 17 ;

  // Field DELCMP4: Delayed CMP4 mode
    inline uint32_t HRTIM_TIME_TIMECR_DELCMP4 (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field DELCMP2: Delayed CMP2 mode
    inline uint32_t HRTIM_TIME_TIMECR_DELCMP2 (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field SYNCSTRTx: Synchronization Starts Timer x
    const uint32_t HRTIM_TIME_TIMECR_SYNCSTRTx = 1U << 11 ;

  // Field SYNCRSTx: Synchronization Resets Timer x
    const uint32_t HRTIM_TIME_TIMECR_SYNCRSTx = 1U << 10 ;

  // Field PSHPLL: Push-Pull mode enable
    const uint32_t HRTIM_TIME_TIMECR_PSHPLL = 1U << 6 ;

  // Field HALF: Half mode enable
    const uint32_t HRTIM_TIME_TIMECR_HALF = 1U << 5 ;

  // Field RETRIG: Re-triggerable mode
    const uint32_t HRTIM_TIME_TIMECR_RETRIG = 1U << 4 ;

  // Field CONT: Continuous mode
    const uint32_t HRTIM_TIME_TIMECR_CONT = 1U << 3 ;

  // Field CK_PSCx: HRTIM Timer x Clock prescaler
    inline uint32_t HRTIM_TIME_TIMECR_CK_PSCx (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIMEISR: Timerx Interrupt Status Register
  #define HRTIM_TIME_TIMEISR (* ((const volatile uint32_t *) (0x40017680 + 4)))

  // Field O2STAT: Output 2 State
    const uint32_t HRTIM_TIME_TIMEISR_O2STAT = 1U << 19 ;

  // Field O1STAT: Output 1 State
    const uint32_t HRTIM_TIME_TIMEISR_O1STAT = 1U << 18 ;

  // Field IPPSTAT: Idle Push Pull Status
    const uint32_t HRTIM_TIME_TIMEISR_IPPSTAT = 1U << 17 ;

  // Field CPPSTAT: Current Push Pull Status
    const uint32_t HRTIM_TIME_TIMEISR_CPPSTAT = 1U << 16 ;

  // Field DLYPRT: Delayed Protection Flag
    const uint32_t HRTIM_TIME_TIMEISR_DLYPRT = 1U << 14 ;

  // Field RST: Reset Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_RST = 1U << 13 ;

  // Field RSTx2: Output 2 Reset Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_RSTx2 = 1U << 12 ;

  // Field SETx2: Output 2 Set Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_SETx2 = 1U << 11 ;

  // Field RSTx1: Output 1 Reset Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_RSTx1 = 1U << 10 ;

  // Field SETx1: Output 1 Set Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_SETx1 = 1U << 9 ;

  // Field CPT2: Capture2 Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_CPT2 = 1U << 8 ;

  // Field CPT1: Capture1 Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_CPT1 = 1U << 7 ;

  // Field UPD: Update Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_UPD = 1U << 6 ;

  // Field REP: Repetition Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_REP = 1U << 4 ;

  // Field CMP4: Compare 4 Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_CMP4 = 1U << 3 ;

  // Field CMP3: Compare 3 Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_CMP3 = 1U << 2 ;

  // Field CMP2: Compare 2 Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_CMP2 = 1U << 1 ;

  // Field CMP1: Compare 1 Interrupt Flag
    const uint32_t HRTIM_TIME_TIMEISR_CMP1 = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMEICR: Timerx Interrupt Clear Register
  #define HRTIM_TIME_TIMEICR (* ((volatile uint32_t *) (0x40017680 + 8)))

  // Field DLYPRTC: Delayed Protection Flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_DLYPRTC = 1U << 14 ;

  // Field RSTC: Reset Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_RSTC = 1U << 13 ;

  // Field RSTx2C: Output 2 Reset flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_RSTx2C = 1U << 12 ;

  // Field SET2xC: Output 2 Set flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_SET2xC = 1U << 11 ;

  // Field RSTx1C: Output 1 Reset flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_RSTx1C = 1U << 10 ;

  // Field SET1xC: Output 1 Set flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_SET1xC = 1U << 9 ;

  // Field CPT2C: Capture2 Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_CPT2C = 1U << 8 ;

  // Field CPT1C: Capture1 Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_CPT1C = 1U << 7 ;

  // Field UPDC: Update Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_UPDC = 1U << 6 ;

  // Field REPC: Repetition Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_REPC = 1U << 4 ;

  // Field CMP4C: Compare 4 Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_CMP4C = 1U << 3 ;

  // Field CMP3C: Compare 3 Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_CMP3C = 1U << 2 ;

  // Field CMP2C: Compare 2 Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_CMP2C = 1U << 1 ;

  // Field CMP1C: Compare 1 Interrupt flag Clear
    const uint32_t HRTIM_TIME_TIMEICR_CMP1C = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register TIMEDIER5: TIMxDIER5
  #define HRTIM_TIME_TIMEDIER5 (* ((volatile uint32_t *) (0x40017680 + 12)))

  // Field DLYPRTDE: DLYPRTDE
    const uint32_t HRTIM_TIME_TIMEDIER5_DLYPRTDE = 1U << 30 ;

  // Field RSTDE: RSTDE
    const uint32_t HRTIM_TIME_TIMEDIER5_RSTDE = 1U << 29 ;

  // Field RSTx2DE: RSTx2DE
    const uint32_t HRTIM_TIME_TIMEDIER5_RSTx2DE = 1U << 28 ;

  // Field SETx2DE: SETx2DE
    const uint32_t HRTIM_TIME_TIMEDIER5_SETx2DE = 1U << 27 ;

  // Field RSTx1DE: RSTx1DE
    const uint32_t HRTIM_TIME_TIMEDIER5_RSTx1DE = 1U << 26 ;

  // Field SET1xDE: SET1xDE
    const uint32_t HRTIM_TIME_TIMEDIER5_SET1xDE = 1U << 25 ;

  // Field CPT2DE: CPT2DE
    const uint32_t HRTIM_TIME_TIMEDIER5_CPT2DE = 1U << 24 ;

  // Field CPT1DE: CPT1DE
    const uint32_t HRTIM_TIME_TIMEDIER5_CPT1DE = 1U << 23 ;

  // Field UPDDE: UPDDE
    const uint32_t HRTIM_TIME_TIMEDIER5_UPDDE = 1U << 22 ;

  // Field REPDE: REPDE
    const uint32_t HRTIM_TIME_TIMEDIER5_REPDE = 1U << 20 ;

  // Field CMP4DE: CMP4DE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP4DE = 1U << 19 ;

  // Field CMP3DE: CMP3DE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP3DE = 1U << 18 ;

  // Field CMP2DE: CMP2DE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP2DE = 1U << 17 ;

  // Field CMP1DE: CMP1DE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP1DE = 1U << 16 ;

  // Field DLYPRTIE: DLYPRTIE
    const uint32_t HRTIM_TIME_TIMEDIER5_DLYPRTIE = 1U << 14 ;

  // Field RSTIE: RSTIE
    const uint32_t HRTIM_TIME_TIMEDIER5_RSTIE = 1U << 13 ;

  // Field RSTx2IE: RSTx2IE
    const uint32_t HRTIM_TIME_TIMEDIER5_RSTx2IE = 1U << 12 ;

  // Field SETx2IE: SETx2IE
    const uint32_t HRTIM_TIME_TIMEDIER5_SETx2IE = 1U << 11 ;

  // Field RSTx1IE: RSTx1IE
    const uint32_t HRTIM_TIME_TIMEDIER5_RSTx1IE = 1U << 10 ;

  // Field SET1xIE: SET1xIE
    const uint32_t HRTIM_TIME_TIMEDIER5_SET1xIE = 1U << 9 ;

  // Field CPT2IE: CPT2IE
    const uint32_t HRTIM_TIME_TIMEDIER5_CPT2IE = 1U << 8 ;

  // Field CPT1IE: CPT1IE
    const uint32_t HRTIM_TIME_TIMEDIER5_CPT1IE = 1U << 7 ;

  // Field UPDIE: UPDIE
    const uint32_t HRTIM_TIME_TIMEDIER5_UPDIE = 1U << 6 ;

  // Field REPIE: REPIE
    const uint32_t HRTIM_TIME_TIMEDIER5_REPIE = 1U << 4 ;

  // Field CMP4IE: CMP4IE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP4IE = 1U << 3 ;

  // Field CMP3IE: CMP3IE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP3IE = 1U << 2 ;

  // Field CMP2IE: CMP2IE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP2IE = 1U << 1 ;

  // Field CMP1IE: CMP1IE
    const uint32_t HRTIM_TIME_TIMEDIER5_CMP1IE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNTER: Timerx Counter Register
  #define HRTIM_TIME_CNTER (* ((volatile uint32_t *) (0x40017680 + 16)))

  // Field CNTx: Timerx Counter value
    inline uint32_t HRTIM_TIME_CNTER_CNTx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PERER: Timerx Period Register
  #define HRTIM_TIME_PERER (* ((volatile uint32_t *) (0x40017680 + 20)))

  // Field PERx: Timerx Period value
    inline uint32_t HRTIM_TIME_PERER_PERx (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register REPER: Timerx Repetition Register
  #define HRTIM_TIME_REPER (* ((volatile uint32_t *) (0x40017680 + 24)))

  // Field REPx: Timerx Repetition counter value
    inline uint32_t HRTIM_TIME_REPER_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1ER: Timerx Compare 1 Register
  #define HRTIM_TIME_CMP1ER (* ((volatile uint32_t *) (0x40017680 + 28)))

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIME_CMP1ER_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP1CER: Timerx Compare 1 Compound Register
  #define HRTIM_TIME_CMP1CER (* ((volatile uint32_t *) (0x40017680 + 32)))

  // Field REPx: Timerx Repetition value (aliased from HRTIM_REPx register)
    inline uint32_t HRTIM_TIME_CMP1CER_REPx (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CMP1x: Timerx Compare 1 value
    inline uint32_t HRTIM_TIME_CMP1CER_CMP1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP2ER: Timerx Compare 2 Register
  #define HRTIM_TIME_CMP2ER (* ((volatile uint32_t *) (0x40017680 + 36)))

  // Field CMP2x: Timerx Compare 2 value
    inline uint32_t HRTIM_TIME_CMP2ER_CMP2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP3ER: Timerx Compare 3 Register
  #define HRTIM_TIME_CMP3ER (* ((volatile uint32_t *) (0x40017680 + 40)))

  // Field CMP3x: Timerx Compare 3 value
    inline uint32_t HRTIM_TIME_CMP3ER_CMP3x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMP4ER: Timerx Compare 4 Register
  #define HRTIM_TIME_CMP4ER (* ((volatile uint32_t *) (0x40017680 + 44)))

  // Field CMP4x: Timerx Compare 4 value
    inline uint32_t HRTIM_TIME_CMP4ER_CMP4x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1ER: Timerx Capture 1 Register
  #define HRTIM_TIME_CPT1ER (* ((const volatile uint32_t *) (0x40017680 + 48)))

  // Field CPT1x: Timerx Capture 1 value
    inline uint32_t HRTIM_TIME_CPT1ER_CPT1x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT2ER: Timerx Capture 2 Register
  #define HRTIM_TIME_CPT2ER (* ((const volatile uint32_t *) (0x40017680 + 52)))

  // Field CPT2x: Timerx Capture 2 value
    inline uint32_t HRTIM_TIME_CPT2ER_CPT2x (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTER: Timerx Deadtime Register
  #define HRTIM_TIME_DTER (* ((volatile uint32_t *) (0x40017680 + 56)))

  // Field DTFLKx: Deadtime Falling Lock
    const uint32_t HRTIM_TIME_DTER_DTFLKx = 1U << 31 ;

  // Field DTFSLKx: Deadtime Falling Sign Lock
    const uint32_t HRTIM_TIME_DTER_DTFSLKx = 1U << 30 ;

  // Field SDTFx: Sign Deadtime Falling value
    const uint32_t HRTIM_TIME_DTER_SDTFx = 1U << 25 ;

  // Field DTFx: Deadtime Falling value
    inline uint32_t HRTIM_TIME_DTER_DTFx (const uint32_t inValue) {return (inValue & 0x1FFU) << 16 ; }

  // Field DTRLKx: Deadtime Rising Lock
    const uint32_t HRTIM_TIME_DTER_DTRLKx = 1U << 15 ;

  // Field DTRSLKx: Deadtime Rising Sign Lock
    const uint32_t HRTIM_TIME_DTER_DTRSLKx = 1U << 14 ;

  // Field DTPRSC: Deadtime Prescaler
    inline uint32_t HRTIM_TIME_DTER_DTPRSC (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field SDTRx: Sign Deadtime Rising value
    const uint32_t HRTIM_TIME_DTER_SDTRx = 1U << 9 ;

  // Field DTRx: Deadtime Rising value
    inline uint32_t HRTIM_TIME_DTER_DTRx (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SETE1R: Timerx Output1 Set Register
  #define HRTIM_TIME_SETE1R (* ((volatile uint32_t *) (0x40017680 + 60)))

  // Field UPDATE: Registers update (transfer preload to active)
    const uint32_t HRTIM_TIME_SETE1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIME_SETE1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: Timer Event 9
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: Timer Event 8
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: Timer Event 7
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: Timer Event 6
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: Timer Event 5
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: Timer Event 4
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: Timer Event 3
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: Timer Event 2
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: Timer Event 1
    const uint32_t HRTIM_TIME_SETE1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: Master Compare 4
    const uint32_t HRTIM_TIME_SETE1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: Master Compare 3
    const uint32_t HRTIM_TIME_SETE1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: Master Compare 2
    const uint32_t HRTIM_TIME_SETE1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: Master Compare 1
    const uint32_t HRTIM_TIME_SETE1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: Master Period
    const uint32_t HRTIM_TIME_SETE1R_MSTPER = 1U << 7 ;

  // Field CMP4: Timer A compare 4
    const uint32_t HRTIM_TIME_SETE1R_CMP4 = 1U << 6 ;

  // Field CMP3: Timer A compare 3
    const uint32_t HRTIM_TIME_SETE1R_CMP3 = 1U << 5 ;

  // Field CMP2: Timer A compare 2
    const uint32_t HRTIM_TIME_SETE1R_CMP2 = 1U << 4 ;

  // Field CMP1: Timer A compare 1
    const uint32_t HRTIM_TIME_SETE1R_CMP1 = 1U << 3 ;

  // Field PER: Timer A Period
    const uint32_t HRTIM_TIME_SETE1R_PER = 1U << 2 ;

  // Field RESYNC: Timer A resynchronizaton
    const uint32_t HRTIM_TIME_SETE1R_RESYNC = 1U << 1 ;

  // Field SST: Software Set trigger
    const uint32_t HRTIM_TIME_SETE1R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTE1R: Timerx Output1 Reset Register
  #define HRTIM_TIME_RSTE1R (* ((volatile uint32_t *) (0x40017680 + 64)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIME_RSTE1R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIME_RSTE1R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIME_RSTE1R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIME_RSTE1R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIME_RSTE1R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIME_RSTE1R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIME_RSTE1R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIME_RSTE1R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIME_RSTE1R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIME_RSTE1R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIME_RSTE1R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIME_RSTE1R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIME_RSTE1R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIME_RSTE1R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIME_RSTE1R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SETE2R: Timerx Output2 Set Register
  #define HRTIM_TIME_SETE2R (* ((volatile uint32_t *) (0x40017680 + 68)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIME_SETE2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIME_SETE2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIME_SETE2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIME_SETE2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIME_SETE2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIME_SETE2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIME_SETE2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIME_SETE2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIME_SETE2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIME_SETE2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIME_SETE2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIME_SETE2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIME_SETE2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIME_SETE2R_RESYNC = 1U << 1 ;

  // Field SST: SST
    const uint32_t HRTIM_TIME_SETE2R_SST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTE2R: Timerx Output2 Reset Register
  #define HRTIM_TIME_RSTE2R (* ((volatile uint32_t *) (0x40017680 + 72)))

  // Field UPDATE: UPDATE
    const uint32_t HRTIM_TIME_RSTE2R_UPDATE = 1U << 31 ;

  // Field EXTEVNT10: EXTEVNT10
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT10 = 1U << 30 ;

  // Field EXTEVNT9: EXTEVNT9
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT9 = 1U << 29 ;

  // Field EXTEVNT8: EXTEVNT8
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT8 = 1U << 28 ;

  // Field EXTEVNT7: EXTEVNT7
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT7 = 1U << 27 ;

  // Field EXTEVNT6: EXTEVNT6
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT6 = 1U << 26 ;

  // Field EXTEVNT5: EXTEVNT5
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT5 = 1U << 25 ;

  // Field EXTEVNT4: EXTEVNT4
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT4 = 1U << 24 ;

  // Field EXTEVNT3: EXTEVNT3
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT3 = 1U << 23 ;

  // Field EXTEVNT2: EXTEVNT2
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT2 = 1U << 22 ;

  // Field EXTEVNT1: EXTEVNT1
    const uint32_t HRTIM_TIME_RSTE2R_EXTEVNT1 = 1U << 21 ;

  // Field TIMEVNT9: TIMEVNT9
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT9 = 1U << 20 ;

  // Field TIMEVNT8: TIMEVNT8
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT8 = 1U << 19 ;

  // Field TIMEVNT7: TIMEVNT7
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT7 = 1U << 18 ;

  // Field TIMEVNT6: TIMEVNT6
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT6 = 1U << 17 ;

  // Field TIMEVNT5: TIMEVNT5
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT5 = 1U << 16 ;

  // Field TIMEVNT4: TIMEVNT4
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT4 = 1U << 15 ;

  // Field TIMEVNT3: TIMEVNT3
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT3 = 1U << 14 ;

  // Field TIMEVNT2: TIMEVNT2
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT2 = 1U << 13 ;

  // Field TIMEVNT1: TIMEVNT1
    const uint32_t HRTIM_TIME_RSTE2R_TIMEVNT1 = 1U << 12 ;

  // Field MSTCMP4: MSTCMP4
    const uint32_t HRTIM_TIME_RSTE2R_MSTCMP4 = 1U << 11 ;

  // Field MSTCMP3: MSTCMP3
    const uint32_t HRTIM_TIME_RSTE2R_MSTCMP3 = 1U << 10 ;

  // Field MSTCMP2: MSTCMP2
    const uint32_t HRTIM_TIME_RSTE2R_MSTCMP2 = 1U << 9 ;

  // Field MSTCMP1: MSTCMP1
    const uint32_t HRTIM_TIME_RSTE2R_MSTCMP1 = 1U << 8 ;

  // Field MSTPER: MSTPER
    const uint32_t HRTIM_TIME_RSTE2R_MSTPER = 1U << 7 ;

  // Field CMP4: CMP4
    const uint32_t HRTIM_TIME_RSTE2R_CMP4 = 1U << 6 ;

  // Field CMP3: CMP3
    const uint32_t HRTIM_TIME_RSTE2R_CMP3 = 1U << 5 ;

  // Field CMP2: CMP2
    const uint32_t HRTIM_TIME_RSTE2R_CMP2 = 1U << 4 ;

  // Field CMP1: CMP1
    const uint32_t HRTIM_TIME_RSTE2R_CMP1 = 1U << 3 ;

  // Field PER: PER
    const uint32_t HRTIM_TIME_RSTE2R_PER = 1U << 2 ;

  // Field RESYNC: RESYNC
    const uint32_t HRTIM_TIME_RSTE2R_RESYNC = 1U << 1 ;

  // Field SRT: SRT
    const uint32_t HRTIM_TIME_RSTE2R_SRT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFER1: Timerx External Event Filtering Register 1
  #define HRTIM_TIME_EEFER1 (* ((volatile uint32_t *) (0x40017680 + 76)))

  // Field EE5FLTR: External Event 5 filter
    inline uint32_t HRTIM_TIME_EEFER1_EE5FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE5LTCH: External Event 5 latch
    const uint32_t HRTIM_TIME_EEFER1_EE5LTCH = 1U << 24 ;

  // Field EE4FLTR: External Event 4 filter
    inline uint32_t HRTIM_TIME_EEFER1_EE4FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE4LTCH: External Event 4 latch
    const uint32_t HRTIM_TIME_EEFER1_EE4LTCH = 1U << 18 ;

  // Field EE3FLTR: External Event 3 filter
    inline uint32_t HRTIM_TIME_EEFER1_EE3FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE3LTCH: External Event 3 latch
    const uint32_t HRTIM_TIME_EEFER1_EE3LTCH = 1U << 12 ;

  // Field EE2FLTR: External Event 2 filter
    inline uint32_t HRTIM_TIME_EEFER1_EE2FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE2LTCH: External Event 2 latch
    const uint32_t HRTIM_TIME_EEFER1_EE2LTCH = 1U << 6 ;

  // Field EE1FLTR: External Event 1 filter
    inline uint32_t HRTIM_TIME_EEFER1_EE1FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE1LTCH: External Event 1 latch
    const uint32_t HRTIM_TIME_EEFER1_EE1LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EEFER2: Timerx External Event Filtering Register 2
  #define HRTIM_TIME_EEFER2 (* ((volatile uint32_t *) (0x40017680 + 80)))

  // Field EE10FLTR: External Event 10 filter
    inline uint32_t HRTIM_TIME_EEFER2_EE10FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field EE10LTCH: External Event 10 latch
    const uint32_t HRTIM_TIME_EEFER2_EE10LTCH = 1U << 24 ;

  // Field EE9FLTR: External Event 9 filter
    inline uint32_t HRTIM_TIME_EEFER2_EE9FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 19 ; }

  // Field EE9LTCH: External Event 9 latch
    const uint32_t HRTIM_TIME_EEFER2_EE9LTCH = 1U << 18 ;

  // Field EE8FLTR: External Event 8 filter
    inline uint32_t HRTIM_TIME_EEFER2_EE8FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field EE8LTCH: External Event 8 latch
    const uint32_t HRTIM_TIME_EEFER2_EE8LTCH = 1U << 12 ;

  // Field EE7FLTR: External Event 7 filter
    inline uint32_t HRTIM_TIME_EEFER2_EE7FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field EE7LTCH: External Event 7 latch
    const uint32_t HRTIM_TIME_EEFER2_EE7LTCH = 1U << 6 ;

  // Field EE6FLTR: External Event 6 filter
    inline uint32_t HRTIM_TIME_EEFER2_EE6FLTR (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field EE6LTCH: External Event 6 latch
    const uint32_t HRTIM_TIME_EEFER2_EE6LTCH = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RSTER: TimerA Reset Register
  #define HRTIM_TIME_RSTER (* ((volatile uint32_t *) (0x40017680 + 84)))

  // Field TIMDCMP4: Timer D Compare 4
    const uint32_t HRTIM_TIME_RSTER_TIMDCMP4 = 1U << 30 ;

  // Field TIMDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIME_RSTER_TIMDCMP2 = 1U << 29 ;

  // Field TIMDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIME_RSTER_TIMDCMP1 = 1U << 28 ;

  // Field TIMCCMP4: Timer C Compare 4
    const uint32_t HRTIM_TIME_RSTER_TIMCCMP4 = 1U << 27 ;

  // Field TIMCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIME_RSTER_TIMCCMP2 = 1U << 26 ;

  // Field TIMCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIME_RSTER_TIMCCMP1 = 1U << 25 ;

  // Field TIMBCMP4: Timer B Compare 4
    const uint32_t HRTIM_TIME_RSTER_TIMBCMP4 = 1U << 24 ;

  // Field TIMBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIME_RSTER_TIMBCMP2 = 1U << 23 ;

  // Field TIMBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIME_RSTER_TIMBCMP1 = 1U << 22 ;

  // Field TIMACMP4: Timer A Compare 4
    const uint32_t HRTIM_TIME_RSTER_TIMACMP4 = 1U << 21 ;

  // Field TIMACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIME_RSTER_TIMACMP2 = 1U << 20 ;

  // Field TIMACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIME_RSTER_TIMACMP1 = 1U << 19 ;

  // Field EXTEVNT10: External Event 10
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT10 = 1U << 18 ;

  // Field EXTEVNT9: External Event 9
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT9 = 1U << 17 ;

  // Field EXTEVNT8: External Event 8
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT8 = 1U << 16 ;

  // Field EXTEVNT7: External Event 7
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT7 = 1U << 15 ;

  // Field EXTEVNT6: External Event 6
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT6 = 1U << 14 ;

  // Field EXTEVNT5: External Event 5
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT5 = 1U << 13 ;

  // Field EXTEVNT4: External Event 4
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT4 = 1U << 12 ;

  // Field EXTEVNT3: External Event 3
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT3 = 1U << 11 ;

  // Field EXTEVNT2: External Event 2
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT2 = 1U << 10 ;

  // Field EXTEVNT1: External Event 1
    const uint32_t HRTIM_TIME_RSTER_EXTEVNT1 = 1U << 9 ;

  // Field MSTCMP4: Master compare 4
    const uint32_t HRTIM_TIME_RSTER_MSTCMP4 = 1U << 8 ;

  // Field MSTCMP3: Master compare 3
    const uint32_t HRTIM_TIME_RSTER_MSTCMP3 = 1U << 7 ;

  // Field MSTCMP2: Master compare 2
    const uint32_t HRTIM_TIME_RSTER_MSTCMP2 = 1U << 6 ;

  // Field MSTCMP1: Master compare 1
    const uint32_t HRTIM_TIME_RSTER_MSTCMP1 = 1U << 5 ;

  // Field MSTPER: Master timer Period
    const uint32_t HRTIM_TIME_RSTER_MSTPER = 1U << 4 ;

  // Field CMP4: Timer A compare 4 reset
    const uint32_t HRTIM_TIME_RSTER_CMP4 = 1U << 3 ;

  // Field CMP2: Timer A compare 2 reset
    const uint32_t HRTIM_TIME_RSTER_CMP2 = 1U << 2 ;

  // Field UPDT: Timer A Update reset
    const uint32_t HRTIM_TIME_RSTER_UPDT = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register CHPER: Timerx Chopper Register
  #define HRTIM_TIME_CHPER (* ((volatile uint32_t *) (0x40017680 + 88)))

  // Field STRTPW: STRTPW
    inline uint32_t HRTIM_TIME_CHPER_STRTPW (const uint32_t inValue) {return (inValue & 0xFU) << 7 ; }

  // Field CHPDTY: Timerx chopper duty cycle value
    inline uint32_t HRTIM_TIME_CHPER_CHPDTY (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CHPFRQ: Timerx carrier frequency value
    inline uint32_t HRTIM_TIME_CHPER_CHPFRQ (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPT1ECR: Timerx Capture 2 Control Register
  #define HRTIM_TIME_CPT1ECR (* ((volatile uint32_t *) (0x40017680 + 92)))

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIME_CPT1ECR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIME_CPT1ECR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIME_CPT1ECR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIME_CPT1ECR_TD1SET = 1U << 24 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIME_CPT1ECR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIME_CPT1ECR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIME_CPT1ECR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIME_CPT1ECR_TC1SET = 1U << 20 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIME_CPT1ECR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIME_CPT1ECR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIME_CPT1ECR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIME_CPT1ECR_TB1SET = 1U << 16 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIME_CPT1ECR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIME_CPT1ECR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIME_CPT1ECR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIME_CPT1ECR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIME_CPT1ECR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIME_CPT1ECR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIME_CPT1ECR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CPT2ECR: CPT2xCR
  #define HRTIM_TIME_CPT2ECR (* ((volatile uint32_t *) (0x40017680 + 96)))

  // Field TDCMP2: Timer D Compare 2
    const uint32_t HRTIM_TIME_CPT2ECR_TDCMP2 = 1U << 27 ;

  // Field TDCMP1: Timer D Compare 1
    const uint32_t HRTIM_TIME_CPT2ECR_TDCMP1 = 1U << 26 ;

  // Field TD1RST: Timer D output 1 Reset
    const uint32_t HRTIM_TIME_CPT2ECR_TD1RST = 1U << 25 ;

  // Field TD1SET: Timer D output 1 Set
    const uint32_t HRTIM_TIME_CPT2ECR_TD1SET = 1U << 24 ;

  // Field TCCMP2: Timer C Compare 2
    const uint32_t HRTIM_TIME_CPT2ECR_TCCMP2 = 1U << 23 ;

  // Field TCCMP1: Timer C Compare 1
    const uint32_t HRTIM_TIME_CPT2ECR_TCCMP1 = 1U << 22 ;

  // Field TC1RST: Timer C output 1 Reset
    const uint32_t HRTIM_TIME_CPT2ECR_TC1RST = 1U << 21 ;

  // Field TC1SET: Timer C output 1 Set
    const uint32_t HRTIM_TIME_CPT2ECR_TC1SET = 1U << 20 ;

  // Field TBCMP2: Timer B Compare 2
    const uint32_t HRTIM_TIME_CPT2ECR_TBCMP2 = 1U << 19 ;

  // Field TBCMP1: Timer B Compare 1
    const uint32_t HRTIM_TIME_CPT2ECR_TBCMP1 = 1U << 18 ;

  // Field TB1RST: Timer B output 1 Reset
    const uint32_t HRTIM_TIME_CPT2ECR_TB1RST = 1U << 17 ;

  // Field TB1SET: Timer B output 1 Set
    const uint32_t HRTIM_TIME_CPT2ECR_TB1SET = 1U << 16 ;

  // Field TACMP2: Timer A Compare 2
    const uint32_t HRTIM_TIME_CPT2ECR_TACMP2 = 1U << 15 ;

  // Field TACMP1: Timer A Compare 1
    const uint32_t HRTIM_TIME_CPT2ECR_TACMP1 = 1U << 14 ;

  // Field TA1RST: Timer A output 1 Reset
    const uint32_t HRTIM_TIME_CPT2ECR_TA1RST = 1U << 13 ;

  // Field TA1SET: Timer A output 1 Set
    const uint32_t HRTIM_TIME_CPT2ECR_TA1SET = 1U << 12 ;

  // Field EXEV10CPT: External Event 10 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV10CPT = 1U << 11 ;

  // Field EXEV9CPT: External Event 9 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV9CPT = 1U << 10 ;

  // Field EXEV8CPT: External Event 8 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV8CPT = 1U << 9 ;

  // Field EXEV7CPT: External Event 7 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV7CPT = 1U << 8 ;

  // Field EXEV6CPT: External Event 6 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV6CPT = 1U << 7 ;

  // Field EXEV5CPT: External Event 5 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV5CPT = 1U << 6 ;

  // Field EXEV4CPT: External Event 4 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV4CPT = 1U << 5 ;

  // Field EXEV3CPT: External Event 3 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV3CPT = 1U << 4 ;

  // Field EXEV2CPT: External Event 2 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV2CPT = 1U << 3 ;

  // Field EXEV1CPT: External Event 1 Capture
    const uint32_t HRTIM_TIME_CPT2ECR_EXEV1CPT = 1U << 2 ;

  // Field UDPCPT: Update Capture
    const uint32_t HRTIM_TIME_CPT2ECR_UDPCPT = 1U << 1 ;

  // Field SWCPT: Software Capture
    const uint32_t HRTIM_TIME_CPT2ECR_SWCPT = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register OUTER: Timerx Output Register
  #define HRTIM_TIME_OUTER (* ((volatile uint32_t *) (0x40017680 + 100)))

  // Field DIDL2: Output 2 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIME_OUTER_DIDL2 = 1U << 23 ;

  // Field CHP2: Output 2 Chopper enable
    const uint32_t HRTIM_TIME_OUTER_CHP2 = 1U << 22 ;

  // Field FAULT2: Output 2 Fault state
    inline uint32_t HRTIM_TIME_OUTER_FAULT2 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field IDLES2: Output 2 Idle State
    const uint32_t HRTIM_TIME_OUTER_IDLES2 = 1U << 19 ;

  // Field IDLEM2: Output 2 Idle mode
    const uint32_t HRTIM_TIME_OUTER_IDLEM2 = 1U << 18 ;

  // Field POL2: Output 2 polarity
    const uint32_t HRTIM_TIME_OUTER_POL2 = 1U << 17 ;

  // Field DLYPRT: Delayed Protection
    inline uint32_t HRTIM_TIME_OUTER_DLYPRT (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field DLYPRTEN: Delayed Protection Enable
    const uint32_t HRTIM_TIME_OUTER_DLYPRTEN = 1U << 9 ;

  // Field DTEN: Deadtime enable
    const uint32_t HRTIM_TIME_OUTER_DTEN = 1U << 8 ;

  // Field DIDL1: Output 1 Deadtime upon burst mode Idle entry
    const uint32_t HRTIM_TIME_OUTER_DIDL1 = 1U << 7 ;

  // Field CHP1: Output 1 Chopper enable
    const uint32_t HRTIM_TIME_OUTER_CHP1 = 1U << 6 ;

  // Field FAULT1: Output 1 Fault state
    inline uint32_t HRTIM_TIME_OUTER_FAULT1 (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field IDLES1: Output 1 Idle State
    const uint32_t HRTIM_TIME_OUTER_IDLES1 = 1U << 3 ;

  // Field IDLEM1: Output 1 Idle mode
    const uint32_t HRTIM_TIME_OUTER_IDLEM1 = 1U << 2 ;

  // Field POL1: Output 1 polarity
    const uint32_t HRTIM_TIME_OUTER_POL1 = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register FLTER: Timerx Fault Register
  #define HRTIM_TIME_FLTER (* ((volatile uint32_t *) (0x40017680 + 104)))

  // Field FLTLCK: Fault sources Lock
    const uint32_t HRTIM_TIME_FLTER_FLTLCK = 1U << 31 ;

  // Field FLT5EN: Fault 5 enable
    const uint32_t HRTIM_TIME_FLTER_FLT5EN = 1U << 4 ;

  // Field FLT4EN: Fault 4 enable
    const uint32_t HRTIM_TIME_FLTER_FLT4EN = 1U << 3 ;

  // Field FLT3EN: Fault 3 enable
    const uint32_t HRTIM_TIME_FLTER_FLT3EN = 1U << 2 ;

  // Field FLT2EN: Fault 2 enable
    const uint32_t HRTIM_TIME_FLTER_FLT2EN = 1U << 1 ;

  // Field FLT1EN: Fault 1 enable
    const uint32_t HRTIM_TIME_FLTER_FLT1EN = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral HSEM: HSEM
//------------------------------------------------------------------------------

//---  Register HSEM_R0: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R0 (* ((volatile uint32_t *) (0x58026400 + 0)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R0_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R0_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R0_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R1: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R1 (* ((volatile uint32_t *) (0x58026400 + 4)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R1_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R1_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R1_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R2: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R2 (* ((volatile uint32_t *) (0x58026400 + 8)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R2_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R2_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R2_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R3: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R3 (* ((volatile uint32_t *) (0x58026400 + 12)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R3_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R3_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R3_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R4: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R4 (* ((volatile uint32_t *) (0x58026400 + 16)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R4_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R4_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R4_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R5: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R5 (* ((volatile uint32_t *) (0x58026400 + 20)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R5_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R5_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R5_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R6: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R6 (* ((volatile uint32_t *) (0x58026400 + 24)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R6_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R6_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R6_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R7: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R7 (* ((volatile uint32_t *) (0x58026400 + 28)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R7_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R7_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R7_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R8: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R8 (* ((volatile uint32_t *) (0x58026400 + 32)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R8_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R8_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R8_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R9: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R9 (* ((volatile uint32_t *) (0x58026400 + 36)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R9_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R9_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R9_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R10: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R10 (* ((volatile uint32_t *) (0x58026400 + 40)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R10_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R10_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R10_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R11: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R11 (* ((volatile uint32_t *) (0x58026400 + 44)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R11_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R11_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R11_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R12: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R12 (* ((volatile uint32_t *) (0x58026400 + 48)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R12_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R12_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R12_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R13: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R13 (* ((volatile uint32_t *) (0x58026400 + 52)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R13_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R13_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R13_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R14: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R14 (* ((volatile uint32_t *) (0x58026400 + 56)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R14_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R14_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R14_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R15: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R15 (* ((volatile uint32_t *) (0x58026400 + 60)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R15_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R15_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R15_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R16: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R16 (* ((volatile uint32_t *) (0x58026400 + 64)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R16_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R16_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R16_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R17: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R17 (* ((volatile uint32_t *) (0x58026400 + 68)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R17_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R17_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R17_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R18: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R18 (* ((volatile uint32_t *) (0x58026400 + 72)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R18_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R18_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R18_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R19: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R19 (* ((volatile uint32_t *) (0x58026400 + 76)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R19_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R19_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R19_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R20: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R20 (* ((volatile uint32_t *) (0x58026400 + 80)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R20_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R20_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R20_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R21: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R21 (* ((volatile uint32_t *) (0x58026400 + 84)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R21_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R21_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R21_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R22: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R22 (* ((volatile uint32_t *) (0x58026400 + 88)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R22_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R22_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R22_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R23: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R23 (* ((volatile uint32_t *) (0x58026400 + 92)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R23_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R23_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R23_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R24: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R24 (* ((volatile uint32_t *) (0x58026400 + 96)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R24_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R24_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R24_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R25: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R25 (* ((volatile uint32_t *) (0x58026400 + 100)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R25_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R25_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R25_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R26: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R26 (* ((volatile uint32_t *) (0x58026400 + 104)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R26_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R26_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R26_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R27: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R27 (* ((volatile uint32_t *) (0x58026400 + 108)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R27_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R27_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R27_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R28: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R28 (* ((volatile uint32_t *) (0x58026400 + 112)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R28_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R28_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R28_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R29: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R29 (* ((volatile uint32_t *) (0x58026400 + 116)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R29_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R29_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R29_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R30: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R30 (* ((volatile uint32_t *) (0x58026400 + 120)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R30_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R30_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R30_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_R31: HSEM register HSEM_R0 HSEM_R31
  #define HSEM_HSEM_R31 (* ((volatile uint32_t *) (0x58026400 + 124)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_R31_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_R31_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_R31_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR0: HSEM Read lock register
  #define HSEM_HSEM_RLR0 (* ((const volatile uint32_t *) (0x58026400 + 128)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR0_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR0_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR0_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR1: HSEM Read lock register
  #define HSEM_HSEM_RLR1 (* ((const volatile uint32_t *) (0x58026400 + 132)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR1_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR1_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR1_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR2: HSEM Read lock register
  #define HSEM_HSEM_RLR2 (* ((const volatile uint32_t *) (0x58026400 + 136)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR2_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR2_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR2_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR3: HSEM Read lock register
  #define HSEM_HSEM_RLR3 (* ((const volatile uint32_t *) (0x58026400 + 140)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR3_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR3_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR3_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR4: HSEM Read lock register
  #define HSEM_HSEM_RLR4 (* ((const volatile uint32_t *) (0x58026400 + 144)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR4_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR4_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR4_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR5: HSEM Read lock register
  #define HSEM_HSEM_RLR5 (* ((const volatile uint32_t *) (0x58026400 + 148)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR5_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR5_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR5_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR6: HSEM Read lock register
  #define HSEM_HSEM_RLR6 (* ((const volatile uint32_t *) (0x58026400 + 152)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR6_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR6_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR6_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR7: HSEM Read lock register
  #define HSEM_HSEM_RLR7 (* ((const volatile uint32_t *) (0x58026400 + 156)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR7_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR7_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR7_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR8: HSEM Read lock register
  #define HSEM_HSEM_RLR8 (* ((const volatile uint32_t *) (0x58026400 + 160)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR8_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR8_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR8_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR9: HSEM Read lock register
  #define HSEM_HSEM_RLR9 (* ((const volatile uint32_t *) (0x58026400 + 164)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR9_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR9_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR9_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR10: HSEM Read lock register
  #define HSEM_HSEM_RLR10 (* ((const volatile uint32_t *) (0x58026400 + 168)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR10_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR10_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR10_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR11: HSEM Read lock register
  #define HSEM_HSEM_RLR11 (* ((const volatile uint32_t *) (0x58026400 + 172)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR11_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR11_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR11_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR12: HSEM Read lock register
  #define HSEM_HSEM_RLR12 (* ((const volatile uint32_t *) (0x58026400 + 176)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR12_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR12_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR12_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR13: HSEM Read lock register
  #define HSEM_HSEM_RLR13 (* ((const volatile uint32_t *) (0x58026400 + 180)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR13_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR13_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR13_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR14: HSEM Read lock register
  #define HSEM_HSEM_RLR14 (* ((const volatile uint32_t *) (0x58026400 + 184)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR14_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR14_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR14_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR15: HSEM Read lock register
  #define HSEM_HSEM_RLR15 (* ((const volatile uint32_t *) (0x58026400 + 188)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR15_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR15_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR15_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR16: HSEM Read lock register
  #define HSEM_HSEM_RLR16 (* ((const volatile uint32_t *) (0x58026400 + 192)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR16_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR16_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR16_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR17: HSEM Read lock register
  #define HSEM_HSEM_RLR17 (* ((const volatile uint32_t *) (0x58026400 + 196)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR17_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR17_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR17_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR18: HSEM Read lock register
  #define HSEM_HSEM_RLR18 (* ((const volatile uint32_t *) (0x58026400 + 200)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR18_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR18_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR18_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR19: HSEM Read lock register
  #define HSEM_HSEM_RLR19 (* ((const volatile uint32_t *) (0x58026400 + 204)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR19_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR19_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR19_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR20: HSEM Read lock register
  #define HSEM_HSEM_RLR20 (* ((const volatile uint32_t *) (0x58026400 + 208)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR20_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR20_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR20_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR21: HSEM Read lock register
  #define HSEM_HSEM_RLR21 (* ((const volatile uint32_t *) (0x58026400 + 212)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR21_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR21_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR21_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR22: HSEM Read lock register
  #define HSEM_HSEM_RLR22 (* ((const volatile uint32_t *) (0x58026400 + 216)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR22_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR22_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR22_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR23: HSEM Read lock register
  #define HSEM_HSEM_RLR23 (* ((const volatile uint32_t *) (0x58026400 + 220)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR23_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR23_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR23_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR24: HSEM Read lock register
  #define HSEM_HSEM_RLR24 (* ((const volatile uint32_t *) (0x58026400 + 224)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR24_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR24_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR24_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR25: HSEM Read lock register
  #define HSEM_HSEM_RLR25 (* ((const volatile uint32_t *) (0x58026400 + 228)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR25_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR25_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR25_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR26: HSEM Read lock register
  #define HSEM_HSEM_RLR26 (* ((const volatile uint32_t *) (0x58026400 + 232)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR26_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR26_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR26_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR27: HSEM Read lock register
  #define HSEM_HSEM_RLR27 (* ((const volatile uint32_t *) (0x58026400 + 236)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR27_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR27_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR27_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR28: HSEM Read lock register
  #define HSEM_HSEM_RLR28 (* ((const volatile uint32_t *) (0x58026400 + 240)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR28_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR28_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR28_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR29: HSEM Read lock register
  #define HSEM_HSEM_RLR29 (* ((const volatile uint32_t *) (0x58026400 + 244)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR29_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR29_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR29_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR30: HSEM Read lock register
  #define HSEM_HSEM_RLR30 (* ((const volatile uint32_t *) (0x58026400 + 248)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR30_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR30_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR30_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_RLR31: HSEM Read lock register
  #define HSEM_HSEM_RLR31 (* ((const volatile uint32_t *) (0x58026400 + 252)))

  // Field PROCID: Semaphore ProcessID
    inline uint32_t HSEM_HSEM_RLR31_PROCID (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field MASTERID: Semaphore MasterID
    inline uint32_t HSEM_HSEM_RLR31_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field LOCK: Lock indication
    const uint32_t HSEM_HSEM_RLR31_LOCK = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_IER: HSEM Interrupt enable register
  #define HSEM_HSEM_IER (* ((volatile uint32_t *) (0x58026400 + 256)))

  // Field ISEM0: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM0 = 1U << 0 ;

  // Field ISEM1: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM1 = 1U << 1 ;

  // Field ISEM2: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM2 = 1U << 2 ;

  // Field ISEM3: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM3 = 1U << 3 ;

  // Field ISEM4: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM4 = 1U << 4 ;

  // Field ISEM5: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM5 = 1U << 5 ;

  // Field ISEM6: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM6 = 1U << 6 ;

  // Field ISEM7: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM7 = 1U << 7 ;

  // Field ISEM8: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM8 = 1U << 8 ;

  // Field ISEM9: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM9 = 1U << 9 ;

  // Field ISEM10: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM10 = 1U << 10 ;

  // Field ISEM11: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM11 = 1U << 11 ;

  // Field ISEM12: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM12 = 1U << 12 ;

  // Field ISEM13: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM13 = 1U << 13 ;

  // Field ISEM14: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM14 = 1U << 14 ;

  // Field ISEM15: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM15 = 1U << 15 ;

  // Field ISEM16: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM16 = 1U << 16 ;

  // Field ISEM17: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM17 = 1U << 17 ;

  // Field ISEM18: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM18 = 1U << 18 ;

  // Field ISEM19: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM19 = 1U << 19 ;

  // Field ISEM20: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM20 = 1U << 20 ;

  // Field ISEM21: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM21 = 1U << 21 ;

  // Field ISEM22: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM22 = 1U << 22 ;

  // Field ISEM23: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM23 = 1U << 23 ;

  // Field ISEM24: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM24 = 1U << 24 ;

  // Field ISEM25: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM25 = 1U << 25 ;

  // Field ISEM26: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM26 = 1U << 26 ;

  // Field ISEM27: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM27 = 1U << 27 ;

  // Field ISEM28: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM28 = 1U << 28 ;

  // Field ISEM29: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM29 = 1U << 29 ;

  // Field ISEM30: Interrupt semaphore n enable bit
    const uint32_t HSEM_HSEM_IER_ISEM30 = 1U << 30 ;

  // Field ISEM31: Interrupt(N) semaphore n enable bit.
    const uint32_t HSEM_HSEM_IER_ISEM31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_ICR: HSEM Interrupt clear register
  #define HSEM_HSEM_ICR (* ((const volatile uint32_t *) (0x58026400 + 260)))

  // Field ISEM0: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM0 = 1U << 0 ;

  // Field ISEM1: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM1 = 1U << 1 ;

  // Field ISEM2: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM2 = 1U << 2 ;

  // Field ISEM3: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM3 = 1U << 3 ;

  // Field ISEM4: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM4 = 1U << 4 ;

  // Field ISEM5: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM5 = 1U << 5 ;

  // Field ISEM6: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM6 = 1U << 6 ;

  // Field ISEM7: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM7 = 1U << 7 ;

  // Field ISEM8: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM8 = 1U << 8 ;

  // Field ISEM9: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM9 = 1U << 9 ;

  // Field ISEM10: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM10 = 1U << 10 ;

  // Field ISEM11: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM11 = 1U << 11 ;

  // Field ISEM12: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM12 = 1U << 12 ;

  // Field ISEM13: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM13 = 1U << 13 ;

  // Field ISEM14: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM14 = 1U << 14 ;

  // Field ISEM15: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM15 = 1U << 15 ;

  // Field ISEM16: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM16 = 1U << 16 ;

  // Field ISEM17: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM17 = 1U << 17 ;

  // Field ISEM18: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM18 = 1U << 18 ;

  // Field ISEM19: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM19 = 1U << 19 ;

  // Field ISEM20: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM20 = 1U << 20 ;

  // Field ISEM21: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM21 = 1U << 21 ;

  // Field ISEM22: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM22 = 1U << 22 ;

  // Field ISEM23: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM23 = 1U << 23 ;

  // Field ISEM24: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM24 = 1U << 24 ;

  // Field ISEM25: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM25 = 1U << 25 ;

  // Field ISEM26: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM26 = 1U << 26 ;

  // Field ISEM27: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM27 = 1U << 27 ;

  // Field ISEM28: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM28 = 1U << 28 ;

  // Field ISEM29: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM29 = 1U << 29 ;

  // Field ISEM30: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM30 = 1U << 30 ;

  // Field ISEM31: Interrupt(N) semaphore n clear bit
    const uint32_t HSEM_HSEM_ICR_ISEM31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_ISR: HSEM Interrupt status register
  #define HSEM_HSEM_ISR (* ((const volatile uint32_t *) (0x58026400 + 264)))

  // Field ISEM0: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM0 = 1U << 0 ;

  // Field ISEM1: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM1 = 1U << 1 ;

  // Field ISEM2: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM2 = 1U << 2 ;

  // Field ISEM3: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM3 = 1U << 3 ;

  // Field ISEM4: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM4 = 1U << 4 ;

  // Field ISEM5: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM5 = 1U << 5 ;

  // Field ISEM6: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM6 = 1U << 6 ;

  // Field ISEM7: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM7 = 1U << 7 ;

  // Field ISEM8: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM8 = 1U << 8 ;

  // Field ISEM9: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM9 = 1U << 9 ;

  // Field ISEM10: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM10 = 1U << 10 ;

  // Field ISEM11: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM11 = 1U << 11 ;

  // Field ISEM12: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM12 = 1U << 12 ;

  // Field ISEM13: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM13 = 1U << 13 ;

  // Field ISEM14: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM14 = 1U << 14 ;

  // Field ISEM15: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM15 = 1U << 15 ;

  // Field ISEM16: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM16 = 1U << 16 ;

  // Field ISEM17: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM17 = 1U << 17 ;

  // Field ISEM18: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM18 = 1U << 18 ;

  // Field ISEM19: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM19 = 1U << 19 ;

  // Field ISEM20: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM20 = 1U << 20 ;

  // Field ISEM21: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM21 = 1U << 21 ;

  // Field ISEM22: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM22 = 1U << 22 ;

  // Field ISEM23: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM23 = 1U << 23 ;

  // Field ISEM24: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM24 = 1U << 24 ;

  // Field ISEM25: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM25 = 1U << 25 ;

  // Field ISEM26: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM26 = 1U << 26 ;

  // Field ISEM27: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM27 = 1U << 27 ;

  // Field ISEM28: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM28 = 1U << 28 ;

  // Field ISEM29: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM29 = 1U << 29 ;

  // Field ISEM30: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM30 = 1U << 30 ;

  // Field ISEM31: Interrupt(N) semaphore n status bit before enable (mask)
    const uint32_t HSEM_HSEM_ISR_ISEM31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_MISR: HSEM Masked interrupt status register
  #define HSEM_HSEM_MISR (* ((const volatile uint32_t *) (0x58026400 + 268)))

  // Field ISEM0: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM0 = 1U << 0 ;

  // Field ISEM1: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM1 = 1U << 1 ;

  // Field ISEM2: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM2 = 1U << 2 ;

  // Field ISEM3: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM3 = 1U << 3 ;

  // Field ISEM4: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM4 = 1U << 4 ;

  // Field ISEM5: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM5 = 1U << 5 ;

  // Field ISEM6: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM6 = 1U << 6 ;

  // Field ISEM7: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM7 = 1U << 7 ;

  // Field ISEM8: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM8 = 1U << 8 ;

  // Field ISEM9: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM9 = 1U << 9 ;

  // Field ISEM10: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM10 = 1U << 10 ;

  // Field ISEM11: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM11 = 1U << 11 ;

  // Field ISEM12: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM12 = 1U << 12 ;

  // Field ISEM13: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM13 = 1U << 13 ;

  // Field ISEM14: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM14 = 1U << 14 ;

  // Field ISEM15: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM15 = 1U << 15 ;

  // Field ISEM16: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM16 = 1U << 16 ;

  // Field ISEM17: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM17 = 1U << 17 ;

  // Field ISEM18: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM18 = 1U << 18 ;

  // Field ISEM19: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM19 = 1U << 19 ;

  // Field ISEM20: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM20 = 1U << 20 ;

  // Field ISEM21: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM21 = 1U << 21 ;

  // Field ISEM22: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM22 = 1U << 22 ;

  // Field ISEM23: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM23 = 1U << 23 ;

  // Field ISEM24: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM24 = 1U << 24 ;

  // Field ISEM25: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM25 = 1U << 25 ;

  // Field ISEM26: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM26 = 1U << 26 ;

  // Field ISEM27: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM27 = 1U << 27 ;

  // Field ISEM28: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM28 = 1U << 28 ;

  // Field ISEM29: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM29 = 1U << 29 ;

  // Field ISEM30: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM30 = 1U << 30 ;

  // Field ISEM31: masked interrupt(N) semaphore n status bit after enable (mask)
    const uint32_t HSEM_HSEM_MISR_ISEM31 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register HSEM_CR: HSEM Clear register
  #define HSEM_HSEM_CR (* ((volatile uint32_t *) (0x58026400 + 320)))

  // Field MASTERID: MasterID of semaphores to be cleared
    inline uint32_t HSEM_HSEM_CR_MASTERID (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field KEY: Semaphore clear Key
    inline uint32_t HSEM_HSEM_CR_KEY (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register HSEM_KEYR: HSEM Interrupt clear register
  #define HSEM_HSEM_KEYR (* ((volatile uint32_t *) (0x58026400 + 324)))

  // Field KEY: Semaphore Clear Key
    inline uint32_t HSEM_HSEM_KEYR_KEY (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral I2C1: I2C
//------------------------------------------------------------------------------

//---  Register CR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C1_CR1 (* ((volatile uint32_t *) (0x40005400 + 0)))

  // Field PE: Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    const uint32_t I2C1_CR1_PE = 1U << 0 ;

  // Field TXIE: TX Interrupt enable
    const uint32_t I2C1_CR1_TXIE = 1U << 1 ;

  // Field RXIE: RX Interrupt enable
    const uint32_t I2C1_CR1_RXIE = 1U << 2 ;

  // Field ADDRIE: Address match Interrupt enable (slave only)
    const uint32_t I2C1_CR1_ADDRIE = 1U << 3 ;

  // Field NACKIE: Not acknowledge received Interrupt enable
    const uint32_t I2C1_CR1_NACKIE = 1U << 4 ;

  // Field STOPIE: STOP detection Interrupt enable
    const uint32_t I2C1_CR1_STOPIE = 1U << 5 ;

  // Field TCIE: Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    const uint32_t I2C1_CR1_TCIE = 1U << 6 ;

  // Field ERRIE: Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    const uint32_t I2C1_CR1_ERRIE = 1U << 7 ;

  // Field DNF: Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
    inline uint32_t I2C1_CR1_DNF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ANFOFF: Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C1_CR1_ANFOFF = 1U << 12 ;

  // Field TXDMAEN: DMA transmission requests enable
    const uint32_t I2C1_CR1_TXDMAEN = 1U << 14 ;

  // Field RXDMAEN: DMA reception requests enable
    const uint32_t I2C1_CR1_RXDMAEN = 1U << 15 ;

  // Field SBC: Slave byte control This bit is used to enable hardware byte control in slave mode.
    const uint32_t I2C1_CR1_SBC = 1U << 16 ;

  // Field NOSTRETCH: Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C1_CR1_NOSTRETCH = 1U << 17 ;

  // Field WUPEN: Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    const uint32_t I2C1_CR1_WUPEN = 1U << 18 ;

  // Field GCEN: General call enable
    const uint32_t I2C1_CR1_GCEN = 1U << 19 ;

  // Field SMBHEN: SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_CR1_SMBHEN = 1U << 20 ;

  // Field SMBDEN: SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_CR1_SMBDEN = 1U << 21 ;

  // Field ALERTEN: SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_CR1_ALERTEN = 1U << 22 ;

  // Field PECEN: PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_CR1_PECEN = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register CR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C1_CR2 (* ((volatile uint32_t *) (0x40005400 + 4)))

  // Field SADD0: Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD0 = 1U << 0 ;

  // Field SADD1: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD1 = 1U << 1 ;

  // Field SADD2: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD2 = 1U << 2 ;

  // Field SADD3: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD3 = 1U << 3 ;

  // Field SADD4: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD4 = 1U << 4 ;

  // Field SADD5: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD5 = 1U << 5 ;

  // Field SADD6: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD6 = 1U << 6 ;

  // Field SADD7: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD7 = 1U << 7 ;

  // Field SADD8: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD8 = 1U << 8 ;

  // Field SADD9: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_SADD9 = 1U << 9 ;

  // Field RD_WRN: Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_RD_WRN = 1U << 10 ;

  // Field ADD10: 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_ADD10 = 1U << 11 ;

  // Field HEAD10R: 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C1_CR2_HEAD10R = 1U << 12 ;

  // Field START: Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    const uint32_t I2C1_CR2_START = 1U << 13 ;

  // Field STOP: Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    const uint32_t I2C1_CR2_STOP = 1U << 14 ;

  // Field NACK: NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    const uint32_t I2C1_CR2_NACK = 1U << 15 ;

  // Field NBYTES: Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
    inline uint32_t I2C1_CR2_NBYTES (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field RELOAD: NBYTES reload mode This bit is set and cleared by software.
    const uint32_t I2C1_CR2_RELOAD = 1U << 24 ;

  // Field AUTOEND: Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    const uint32_t I2C1_CR2_AUTOEND = 1U << 25 ;

  // Field PECBYTE: Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_CR2_PECBYTE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register OAR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C1_OAR1 (* ((volatile uint32_t *) (0x40005400 + 8)))

  // Field OA1: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
    inline uint32_t I2C1_OAR1_OA1 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field OA1MODE: Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    const uint32_t I2C1_OAR1_OA1MODE = 1U << 10 ;

  // Field OA1EN: Own Address 1 enable
    const uint32_t I2C1_OAR1_OA1EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OAR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C1_OAR2 (* ((volatile uint32_t *) (0x40005400 + 12)))

  // Field OA2: Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
    inline uint32_t I2C1_OAR2_OA2 (const uint32_t inValue) {return (inValue & 0x7FU) << 1 ; }

  // Field OA2MSK: Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
    inline uint32_t I2C1_OAR2_OA2MSK (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field OA2EN: Own Address 2 enable
    const uint32_t I2C1_OAR2_OA2EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register TIMINGR: Access: No wait states
  #define I2C1_TIMINGR (* ((volatile uint32_t *) (0x40005400 + 16)))

  // Field SCLL: SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
    inline uint32_t I2C1_TIMINGR_SCLL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SCLH: SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
    inline uint32_t I2C1_TIMINGR_SCLH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field SDADEL: Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
    inline uint32_t I2C1_TIMINGR_SDADEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field SCLDEL: Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
    inline uint32_t I2C1_TIMINGR_SCLDEL (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field PRESC: Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
    inline uint32_t I2C1_TIMINGR_PRESC (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register TIMEOUTR: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C1_TIMEOUTR (* ((volatile uint32_t *) (0x40005400 + 20)))

  // Field TIMEOUTA: Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
    inline uint32_t I2C1_TIMEOUTR_TIMEOUTA (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field TIDLE: Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    const uint32_t I2C1_TIMEOUTR_TIDLE = 1U << 12 ;

  // Field TIMOUTEN: Clock timeout enable
    const uint32_t I2C1_TIMEOUTR_TIMOUTEN = 1U << 15 ;

  // Field TIMEOUTB: Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
    inline uint32_t I2C1_TIMEOUTR_TIMEOUTB (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field TEXTEN: Extended clock timeout enable
    const uint32_t I2C1_TIMEOUTR_TEXTEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register ISR: Access: No wait states
  #define I2C1_ISR (* ((volatile uint32_t *) (0x40005400 + 24)))

  // Field TXE: Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
    const uint32_t I2C1_ISR_TXE = 1U << 0 ;

  // Field TXIS: Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_TXIS = 1U << 1 ;

  // Field RXNE: Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_RXNE = 1U << 2 ;

  // Field ADDR: Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_ADDR = 1U << 3 ;

  // Field NACKF: Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_NACKF = 1U << 4 ;

  // Field STOPF: Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_STOPF = 1U << 5 ;

  // Field TC: Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_TC = 1U << 6 ;

  // Field TCR: Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
    const uint32_t I2C1_ISR_TCR = 1U << 7 ;

  // Field BERR: Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_BERR = 1U << 8 ;

  // Field ARLO: Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_ARLO = 1U << 9 ;

  // Field OVR: Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C1_ISR_OVR = 1U << 10 ;

  // Field PECERR: PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_ISR_PECERR = 1U << 11 ;

  // Field TIMEOUT: Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_ISR_TIMEOUT = 1U << 12 ;

  // Field ALERT: SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_ISR_ALERT = 1U << 13 ;

  // Field BUSY: Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
    const uint32_t I2C1_ISR_BUSY = 1U << 15 ;

  // Field DIR: Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
    const uint32_t I2C1_ISR_DIR = 1U << 16 ;

  // Field ADDCODE: Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
    inline uint32_t I2C1_ISR_ADDCODE (const uint32_t inValue) {return (inValue & 0x7FU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register ICR: Access: No wait states
  #define I2C1_ICR (* ((volatile uint32_t *) (0x40005400 + 28)))

  // Field ADDRCF: Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    const uint32_t I2C1_ICR_ADDRCF = 1U << 3 ;

  // Field NACKCF: Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    const uint32_t I2C1_ICR_NACKCF = 1U << 4 ;

  // Field STOPCF: Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    const uint32_t I2C1_ICR_STOPCF = 1U << 5 ;

  // Field BERRCF: Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    const uint32_t I2C1_ICR_BERRCF = 1U << 8 ;

  // Field ARLOCF: Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    const uint32_t I2C1_ICR_ARLOCF = 1U << 9 ;

  // Field OVRCF: Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    const uint32_t I2C1_ICR_OVRCF = 1U << 10 ;

  // Field PECCF: PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_ICR_PECCF = 1U << 11 ;

  // Field TIMOUTCF: Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_ICR_TIMOUTCF = 1U << 12 ;

  // Field ALERTCF: Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C1_ICR_ALERTCF = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register PECR: Access: No wait states
  #define I2C1_PECR (* ((const volatile uint32_t *) (0x40005400 + 32)))

  // Field PEC: Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
    inline uint32_t I2C1_PECR_PEC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Access: No wait states
  #define I2C1_RXDR (* ((const volatile uint32_t *) (0x40005400 + 36)))

  // Field RXDATA: 8-bit receive data Data byte received from the I2C bus.
    inline uint32_t I2C1_RXDR_RXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXDR: Access: No wait states
  #define I2C1_TXDR (* ((volatile uint32_t *) (0x40005400 + 40)))

  // Field TXDATA: 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
    inline uint32_t I2C1_TXDR_TXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral I2C2
//------------------------------------------------------------------------------

//---  Register CR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C2_CR1 (* ((volatile uint32_t *) (0x40005800 + 0)))

  // Field PE: Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    const uint32_t I2C2_CR1_PE = 1U << 0 ;

  // Field TXIE: TX Interrupt enable
    const uint32_t I2C2_CR1_TXIE = 1U << 1 ;

  // Field RXIE: RX Interrupt enable
    const uint32_t I2C2_CR1_RXIE = 1U << 2 ;

  // Field ADDRIE: Address match Interrupt enable (slave only)
    const uint32_t I2C2_CR1_ADDRIE = 1U << 3 ;

  // Field NACKIE: Not acknowledge received Interrupt enable
    const uint32_t I2C2_CR1_NACKIE = 1U << 4 ;

  // Field STOPIE: STOP detection Interrupt enable
    const uint32_t I2C2_CR1_STOPIE = 1U << 5 ;

  // Field TCIE: Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    const uint32_t I2C2_CR1_TCIE = 1U << 6 ;

  // Field ERRIE: Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    const uint32_t I2C2_CR1_ERRIE = 1U << 7 ;

  // Field DNF: Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
    inline uint32_t I2C2_CR1_DNF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ANFOFF: Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C2_CR1_ANFOFF = 1U << 12 ;

  // Field TXDMAEN: DMA transmission requests enable
    const uint32_t I2C2_CR1_TXDMAEN = 1U << 14 ;

  // Field RXDMAEN: DMA reception requests enable
    const uint32_t I2C2_CR1_RXDMAEN = 1U << 15 ;

  // Field SBC: Slave byte control This bit is used to enable hardware byte control in slave mode.
    const uint32_t I2C2_CR1_SBC = 1U << 16 ;

  // Field NOSTRETCH: Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C2_CR1_NOSTRETCH = 1U << 17 ;

  // Field WUPEN: Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    const uint32_t I2C2_CR1_WUPEN = 1U << 18 ;

  // Field GCEN: General call enable
    const uint32_t I2C2_CR1_GCEN = 1U << 19 ;

  // Field SMBHEN: SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_CR1_SMBHEN = 1U << 20 ;

  // Field SMBDEN: SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_CR1_SMBDEN = 1U << 21 ;

  // Field ALERTEN: SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_CR1_ALERTEN = 1U << 22 ;

  // Field PECEN: PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_CR1_PECEN = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register CR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C2_CR2 (* ((volatile uint32_t *) (0x40005800 + 4)))

  // Field SADD0: Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD0 = 1U << 0 ;

  // Field SADD1: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD1 = 1U << 1 ;

  // Field SADD2: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD2 = 1U << 2 ;

  // Field SADD3: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD3 = 1U << 3 ;

  // Field SADD4: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD4 = 1U << 4 ;

  // Field SADD5: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD5 = 1U << 5 ;

  // Field SADD6: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD6 = 1U << 6 ;

  // Field SADD7: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD7 = 1U << 7 ;

  // Field SADD8: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD8 = 1U << 8 ;

  // Field SADD9: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_SADD9 = 1U << 9 ;

  // Field RD_WRN: Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_RD_WRN = 1U << 10 ;

  // Field ADD10: 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_ADD10 = 1U << 11 ;

  // Field HEAD10R: 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C2_CR2_HEAD10R = 1U << 12 ;

  // Field START: Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    const uint32_t I2C2_CR2_START = 1U << 13 ;

  // Field STOP: Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    const uint32_t I2C2_CR2_STOP = 1U << 14 ;

  // Field NACK: NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    const uint32_t I2C2_CR2_NACK = 1U << 15 ;

  // Field NBYTES: Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
    inline uint32_t I2C2_CR2_NBYTES (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field RELOAD: NBYTES reload mode This bit is set and cleared by software.
    const uint32_t I2C2_CR2_RELOAD = 1U << 24 ;

  // Field AUTOEND: Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    const uint32_t I2C2_CR2_AUTOEND = 1U << 25 ;

  // Field PECBYTE: Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_CR2_PECBYTE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register OAR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C2_OAR1 (* ((volatile uint32_t *) (0x40005800 + 8)))

  // Field OA1: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
    inline uint32_t I2C2_OAR1_OA1 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field OA1MODE: Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    const uint32_t I2C2_OAR1_OA1MODE = 1U << 10 ;

  // Field OA1EN: Own Address 1 enable
    const uint32_t I2C2_OAR1_OA1EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OAR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C2_OAR2 (* ((volatile uint32_t *) (0x40005800 + 12)))

  // Field OA2: Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
    inline uint32_t I2C2_OAR2_OA2 (const uint32_t inValue) {return (inValue & 0x7FU) << 1 ; }

  // Field OA2MSK: Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
    inline uint32_t I2C2_OAR2_OA2MSK (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field OA2EN: Own Address 2 enable
    const uint32_t I2C2_OAR2_OA2EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register TIMINGR: Access: No wait states
  #define I2C2_TIMINGR (* ((volatile uint32_t *) (0x40005800 + 16)))

  // Field SCLL: SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
    inline uint32_t I2C2_TIMINGR_SCLL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SCLH: SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
    inline uint32_t I2C2_TIMINGR_SCLH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field SDADEL: Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
    inline uint32_t I2C2_TIMINGR_SDADEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field SCLDEL: Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
    inline uint32_t I2C2_TIMINGR_SCLDEL (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field PRESC: Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
    inline uint32_t I2C2_TIMINGR_PRESC (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register TIMEOUTR: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C2_TIMEOUTR (* ((volatile uint32_t *) (0x40005800 + 20)))

  // Field TIMEOUTA: Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
    inline uint32_t I2C2_TIMEOUTR_TIMEOUTA (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field TIDLE: Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    const uint32_t I2C2_TIMEOUTR_TIDLE = 1U << 12 ;

  // Field TIMOUTEN: Clock timeout enable
    const uint32_t I2C2_TIMEOUTR_TIMOUTEN = 1U << 15 ;

  // Field TIMEOUTB: Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
    inline uint32_t I2C2_TIMEOUTR_TIMEOUTB (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field TEXTEN: Extended clock timeout enable
    const uint32_t I2C2_TIMEOUTR_TEXTEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register ISR: Access: No wait states
  #define I2C2_ISR (* ((volatile uint32_t *) (0x40005800 + 24)))

  // Field TXE: Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
    const uint32_t I2C2_ISR_TXE = 1U << 0 ;

  // Field TXIS: Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_TXIS = 1U << 1 ;

  // Field RXNE: Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_RXNE = 1U << 2 ;

  // Field ADDR: Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_ADDR = 1U << 3 ;

  // Field NACKF: Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_NACKF = 1U << 4 ;

  // Field STOPF: Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_STOPF = 1U << 5 ;

  // Field TC: Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_TC = 1U << 6 ;

  // Field TCR: Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
    const uint32_t I2C2_ISR_TCR = 1U << 7 ;

  // Field BERR: Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_BERR = 1U << 8 ;

  // Field ARLO: Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_ARLO = 1U << 9 ;

  // Field OVR: Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C2_ISR_OVR = 1U << 10 ;

  // Field PECERR: PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_ISR_PECERR = 1U << 11 ;

  // Field TIMEOUT: Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_ISR_TIMEOUT = 1U << 12 ;

  // Field ALERT: SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_ISR_ALERT = 1U << 13 ;

  // Field BUSY: Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
    const uint32_t I2C2_ISR_BUSY = 1U << 15 ;

  // Field DIR: Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
    const uint32_t I2C2_ISR_DIR = 1U << 16 ;

  // Field ADDCODE: Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
    inline uint32_t I2C2_ISR_ADDCODE (const uint32_t inValue) {return (inValue & 0x7FU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register ICR: Access: No wait states
  #define I2C2_ICR (* ((volatile uint32_t *) (0x40005800 + 28)))

  // Field ADDRCF: Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    const uint32_t I2C2_ICR_ADDRCF = 1U << 3 ;

  // Field NACKCF: Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    const uint32_t I2C2_ICR_NACKCF = 1U << 4 ;

  // Field STOPCF: Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    const uint32_t I2C2_ICR_STOPCF = 1U << 5 ;

  // Field BERRCF: Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    const uint32_t I2C2_ICR_BERRCF = 1U << 8 ;

  // Field ARLOCF: Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    const uint32_t I2C2_ICR_ARLOCF = 1U << 9 ;

  // Field OVRCF: Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    const uint32_t I2C2_ICR_OVRCF = 1U << 10 ;

  // Field PECCF: PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_ICR_PECCF = 1U << 11 ;

  // Field TIMOUTCF: Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_ICR_TIMOUTCF = 1U << 12 ;

  // Field ALERTCF: Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C2_ICR_ALERTCF = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register PECR: Access: No wait states
  #define I2C2_PECR (* ((const volatile uint32_t *) (0x40005800 + 32)))

  // Field PEC: Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
    inline uint32_t I2C2_PECR_PEC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Access: No wait states
  #define I2C2_RXDR (* ((const volatile uint32_t *) (0x40005800 + 36)))

  // Field RXDATA: 8-bit receive data Data byte received from the I2C bus.
    inline uint32_t I2C2_RXDR_RXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXDR: Access: No wait states
  #define I2C2_TXDR (* ((volatile uint32_t *) (0x40005800 + 40)))

  // Field TXDATA: 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
    inline uint32_t I2C2_TXDR_TXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral I2C3
//------------------------------------------------------------------------------

//---  Register CR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C3_CR1 (* ((volatile uint32_t *) (0x40005C00 + 0)))

  // Field PE: Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    const uint32_t I2C3_CR1_PE = 1U << 0 ;

  // Field TXIE: TX Interrupt enable
    const uint32_t I2C3_CR1_TXIE = 1U << 1 ;

  // Field RXIE: RX Interrupt enable
    const uint32_t I2C3_CR1_RXIE = 1U << 2 ;

  // Field ADDRIE: Address match Interrupt enable (slave only)
    const uint32_t I2C3_CR1_ADDRIE = 1U << 3 ;

  // Field NACKIE: Not acknowledge received Interrupt enable
    const uint32_t I2C3_CR1_NACKIE = 1U << 4 ;

  // Field STOPIE: STOP detection Interrupt enable
    const uint32_t I2C3_CR1_STOPIE = 1U << 5 ;

  // Field TCIE: Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    const uint32_t I2C3_CR1_TCIE = 1U << 6 ;

  // Field ERRIE: Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    const uint32_t I2C3_CR1_ERRIE = 1U << 7 ;

  // Field DNF: Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
    inline uint32_t I2C3_CR1_DNF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ANFOFF: Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C3_CR1_ANFOFF = 1U << 12 ;

  // Field TXDMAEN: DMA transmission requests enable
    const uint32_t I2C3_CR1_TXDMAEN = 1U << 14 ;

  // Field RXDMAEN: DMA reception requests enable
    const uint32_t I2C3_CR1_RXDMAEN = 1U << 15 ;

  // Field SBC: Slave byte control This bit is used to enable hardware byte control in slave mode.
    const uint32_t I2C3_CR1_SBC = 1U << 16 ;

  // Field NOSTRETCH: Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C3_CR1_NOSTRETCH = 1U << 17 ;

  // Field WUPEN: Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    const uint32_t I2C3_CR1_WUPEN = 1U << 18 ;

  // Field GCEN: General call enable
    const uint32_t I2C3_CR1_GCEN = 1U << 19 ;

  // Field SMBHEN: SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_CR1_SMBHEN = 1U << 20 ;

  // Field SMBDEN: SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_CR1_SMBDEN = 1U << 21 ;

  // Field ALERTEN: SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_CR1_ALERTEN = 1U << 22 ;

  // Field PECEN: PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_CR1_PECEN = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register CR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C3_CR2 (* ((volatile uint32_t *) (0x40005C00 + 4)))

  // Field SADD0: Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD0 = 1U << 0 ;

  // Field SADD1: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD1 = 1U << 1 ;

  // Field SADD2: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD2 = 1U << 2 ;

  // Field SADD3: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD3 = 1U << 3 ;

  // Field SADD4: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD4 = 1U << 4 ;

  // Field SADD5: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD5 = 1U << 5 ;

  // Field SADD6: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD6 = 1U << 6 ;

  // Field SADD7: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD7 = 1U << 7 ;

  // Field SADD8: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD8 = 1U << 8 ;

  // Field SADD9: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_SADD9 = 1U << 9 ;

  // Field RD_WRN: Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_RD_WRN = 1U << 10 ;

  // Field ADD10: 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_ADD10 = 1U << 11 ;

  // Field HEAD10R: 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C3_CR2_HEAD10R = 1U << 12 ;

  // Field START: Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    const uint32_t I2C3_CR2_START = 1U << 13 ;

  // Field STOP: Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    const uint32_t I2C3_CR2_STOP = 1U << 14 ;

  // Field NACK: NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    const uint32_t I2C3_CR2_NACK = 1U << 15 ;

  // Field NBYTES: Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
    inline uint32_t I2C3_CR2_NBYTES (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field RELOAD: NBYTES reload mode This bit is set and cleared by software.
    const uint32_t I2C3_CR2_RELOAD = 1U << 24 ;

  // Field AUTOEND: Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    const uint32_t I2C3_CR2_AUTOEND = 1U << 25 ;

  // Field PECBYTE: Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_CR2_PECBYTE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register OAR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C3_OAR1 (* ((volatile uint32_t *) (0x40005C00 + 8)))

  // Field OA1: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
    inline uint32_t I2C3_OAR1_OA1 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field OA1MODE: Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    const uint32_t I2C3_OAR1_OA1MODE = 1U << 10 ;

  // Field OA1EN: Own Address 1 enable
    const uint32_t I2C3_OAR1_OA1EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OAR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C3_OAR2 (* ((volatile uint32_t *) (0x40005C00 + 12)))

  // Field OA2: Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
    inline uint32_t I2C3_OAR2_OA2 (const uint32_t inValue) {return (inValue & 0x7FU) << 1 ; }

  // Field OA2MSK: Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
    inline uint32_t I2C3_OAR2_OA2MSK (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field OA2EN: Own Address 2 enable
    const uint32_t I2C3_OAR2_OA2EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register TIMINGR: Access: No wait states
  #define I2C3_TIMINGR (* ((volatile uint32_t *) (0x40005C00 + 16)))

  // Field SCLL: SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
    inline uint32_t I2C3_TIMINGR_SCLL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SCLH: SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
    inline uint32_t I2C3_TIMINGR_SCLH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field SDADEL: Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
    inline uint32_t I2C3_TIMINGR_SDADEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field SCLDEL: Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
    inline uint32_t I2C3_TIMINGR_SCLDEL (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field PRESC: Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
    inline uint32_t I2C3_TIMINGR_PRESC (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register TIMEOUTR: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C3_TIMEOUTR (* ((volatile uint32_t *) (0x40005C00 + 20)))

  // Field TIMEOUTA: Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
    inline uint32_t I2C3_TIMEOUTR_TIMEOUTA (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field TIDLE: Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    const uint32_t I2C3_TIMEOUTR_TIDLE = 1U << 12 ;

  // Field TIMOUTEN: Clock timeout enable
    const uint32_t I2C3_TIMEOUTR_TIMOUTEN = 1U << 15 ;

  // Field TIMEOUTB: Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
    inline uint32_t I2C3_TIMEOUTR_TIMEOUTB (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field TEXTEN: Extended clock timeout enable
    const uint32_t I2C3_TIMEOUTR_TEXTEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register ISR: Access: No wait states
  #define I2C3_ISR (* ((volatile uint32_t *) (0x40005C00 + 24)))

  // Field TXE: Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
    const uint32_t I2C3_ISR_TXE = 1U << 0 ;

  // Field TXIS: Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_TXIS = 1U << 1 ;

  // Field RXNE: Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_RXNE = 1U << 2 ;

  // Field ADDR: Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_ADDR = 1U << 3 ;

  // Field NACKF: Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_NACKF = 1U << 4 ;

  // Field STOPF: Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_STOPF = 1U << 5 ;

  // Field TC: Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_TC = 1U << 6 ;

  // Field TCR: Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
    const uint32_t I2C3_ISR_TCR = 1U << 7 ;

  // Field BERR: Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_BERR = 1U << 8 ;

  // Field ARLO: Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_ARLO = 1U << 9 ;

  // Field OVR: Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C3_ISR_OVR = 1U << 10 ;

  // Field PECERR: PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_ISR_PECERR = 1U << 11 ;

  // Field TIMEOUT: Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_ISR_TIMEOUT = 1U << 12 ;

  // Field ALERT: SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_ISR_ALERT = 1U << 13 ;

  // Field BUSY: Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
    const uint32_t I2C3_ISR_BUSY = 1U << 15 ;

  // Field DIR: Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
    const uint32_t I2C3_ISR_DIR = 1U << 16 ;

  // Field ADDCODE: Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
    inline uint32_t I2C3_ISR_ADDCODE (const uint32_t inValue) {return (inValue & 0x7FU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register ICR: Access: No wait states
  #define I2C3_ICR (* ((volatile uint32_t *) (0x40005C00 + 28)))

  // Field ADDRCF: Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    const uint32_t I2C3_ICR_ADDRCF = 1U << 3 ;

  // Field NACKCF: Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    const uint32_t I2C3_ICR_NACKCF = 1U << 4 ;

  // Field STOPCF: Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    const uint32_t I2C3_ICR_STOPCF = 1U << 5 ;

  // Field BERRCF: Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    const uint32_t I2C3_ICR_BERRCF = 1U << 8 ;

  // Field ARLOCF: Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    const uint32_t I2C3_ICR_ARLOCF = 1U << 9 ;

  // Field OVRCF: Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    const uint32_t I2C3_ICR_OVRCF = 1U << 10 ;

  // Field PECCF: PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_ICR_PECCF = 1U << 11 ;

  // Field TIMOUTCF: Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_ICR_TIMOUTCF = 1U << 12 ;

  // Field ALERTCF: Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C3_ICR_ALERTCF = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register PECR: Access: No wait states
  #define I2C3_PECR (* ((const volatile uint32_t *) (0x40005C00 + 32)))

  // Field PEC: Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
    inline uint32_t I2C3_PECR_PEC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Access: No wait states
  #define I2C3_RXDR (* ((const volatile uint32_t *) (0x40005C00 + 36)))

  // Field RXDATA: 8-bit receive data Data byte received from the I2C bus.
    inline uint32_t I2C3_RXDR_RXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXDR: Access: No wait states
  #define I2C3_TXDR (* ((volatile uint32_t *) (0x40005C00 + 40)))

  // Field TXDATA: 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
    inline uint32_t I2C3_TXDR_TXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral I2C4
//------------------------------------------------------------------------------

//---  Register CR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C4_CR1 (* ((volatile uint32_t *) (0x58001C00 + 0)))

  // Field PE: Peripheral enable Note: When PE=0, the I2C SCL and SDA lines are released. Internal state machines and status bits are put back to their reset value. When cleared, PE must be kept low for at least 3 APB clock cycles.
    const uint32_t I2C4_CR1_PE = 1U << 0 ;

  // Field TXIE: TX Interrupt enable
    const uint32_t I2C4_CR1_TXIE = 1U << 1 ;

  // Field RXIE: RX Interrupt enable
    const uint32_t I2C4_CR1_RXIE = 1U << 2 ;

  // Field ADDRIE: Address match Interrupt enable (slave only)
    const uint32_t I2C4_CR1_ADDRIE = 1U << 3 ;

  // Field NACKIE: Not acknowledge received Interrupt enable
    const uint32_t I2C4_CR1_NACKIE = 1U << 4 ;

  // Field STOPIE: STOP detection Interrupt enable
    const uint32_t I2C4_CR1_STOPIE = 1U << 5 ;

  // Field TCIE: Transfer Complete interrupt enable Note: Any of these events will generate an interrupt: Transfer Complete (TC) Transfer Complete Reload (TCR)
    const uint32_t I2C4_CR1_TCIE = 1U << 6 ;

  // Field ERRIE: Error interrupts enable Note: Any of these errors generate an interrupt: Arbitration Loss (ARLO) Bus Error detection (BERR) Overrun/Underrun (OVR) Timeout detection (TIMEOUT) PEC error detection (PECERR) Alert pin event detection (ALERT)
    const uint32_t I2C4_CR1_ERRIE = 1U << 7 ;

  // Field DNF: Digital noise filter These bits are used to configure the digital noise filter on SDA and SCL input. The digital filter will filter spikes with a length of up to DNF[3:0] * tI2CCLK ... Note: If the analog filter is also enabled, the digital filter is added to the analog filter. This filter can only be programmed when the I2C is disabled (PE = 0).
    inline uint32_t I2C4_CR1_DNF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ANFOFF: Analog noise filter OFF Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C4_CR1_ANFOFF = 1U << 12 ;

  // Field TXDMAEN: DMA transmission requests enable
    const uint32_t I2C4_CR1_TXDMAEN = 1U << 14 ;

  // Field RXDMAEN: DMA reception requests enable
    const uint32_t I2C4_CR1_RXDMAEN = 1U << 15 ;

  // Field SBC: Slave byte control This bit is used to enable hardware byte control in slave mode.
    const uint32_t I2C4_CR1_SBC = 1U << 16 ;

  // Field NOSTRETCH: Clock stretching disable This bit is used to disable clock stretching in slave mode. It must be kept cleared in master mode. Note: This bit can only be programmed when the I2C is disabled (PE = 0).
    const uint32_t I2C4_CR1_NOSTRETCH = 1U << 17 ;

  // Field WUPEN: Wakeup from Stop mode enable Note: If the Wakeup from Stop mode feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation. Note: WUPEN can be set only when DNF = 0000
    const uint32_t I2C4_CR1_WUPEN = 1U << 18 ;

  // Field GCEN: General call enable
    const uint32_t I2C4_CR1_GCEN = 1U << 19 ;

  // Field SMBHEN: SMBus Host address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_CR1_SMBHEN = 1U << 20 ;

  // Field SMBDEN: SMBus Device Default address enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_CR1_SMBDEN = 1U << 21 ;

  // Field ALERTEN: SMBus alert enable Device mode (SMBHEN=0): Host mode (SMBHEN=1): Note: When ALERTEN=0, the SMBA pin can be used as a standard GPIO. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_CR1_ALERTEN = 1U << 22 ;

  // Field PECEN: PEC enable Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_CR1_PECEN = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register CR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C4_CR2 (* ((volatile uint32_t *) (0x58001C00 + 4)))

  // Field SADD0: Slave address bit 0 (master mode) In 7-bit addressing mode (ADD10 = 0): This bit is dont care In 10-bit addressing mode (ADD10 = 1): This bit should be written with bit 0 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD0 = 1U << 0 ;

  // Field SADD1: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD1 = 1U << 1 ;

  // Field SADD2: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD2 = 1U << 2 ;

  // Field SADD3: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD3 = 1U << 3 ;

  // Field SADD4: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD4 = 1U << 4 ;

  // Field SADD5: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD5 = 1U << 5 ;

  // Field SADD6: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD6 = 1U << 6 ;

  // Field SADD7: Slave address bit 7:1 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits should be written with the 7-bit slave address to be sent In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 7:1 of the slave address to be sent. Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD7 = 1U << 7 ;

  // Field SADD8: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD8 = 1U << 8 ;

  // Field SADD9: Slave address bit 9:8 (master mode) In 7-bit addressing mode (ADD10 = 0): These bits are dont care In 10-bit addressing mode (ADD10 = 1): These bits should be written with bits 9:8 of the slave address to be sent Note: Changing these bits when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_SADD9 = 1U << 9 ;

  // Field RD_WRN: Transfer direction (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_RD_WRN = 1U << 10 ;

  // Field ADD10: 10-bit addressing mode (master mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_ADD10 = 1U << 11 ;

  // Field HEAD10R: 10-bit address header only read direction (master receiver mode) Note: Changing this bit when the START bit is set is not allowed.
    const uint32_t I2C4_CR2_HEAD10R = 1U << 12 ;

  // Field START: Start generation This bit is set by software, and cleared by hardware after the Start followed by the address sequence is sent, by an arbitration loss, by a timeout error detection, or when PE = 0. It can also be cleared by software by writing 1 to the ADDRCF bit in the I2C_ICR register. If the I2C is already in master mode with AUTOEND = 0, setting this bit generates a Repeated Start condition when RELOAD=0, after the end of the NBYTES transfer. Otherwise setting this bit will generate a START condition once the bus is free. Note: Writing 0 to this bit has no effect. The START bit can be set even if the bus is BUSY or I2C is in slave mode. This bit has no effect when RELOAD is set.
    const uint32_t I2C4_CR2_START = 1U << 13 ;

  // Field STOP: Stop generation (master mode) The bit is set by software, cleared by hardware when a Stop condition is detected, or when PE = 0. In Master Mode: Note: Writing 0 to this bit has no effect.
    const uint32_t I2C4_CR2_STOP = 1U << 14 ;

  // Field NACK: NACK generation (slave mode) The bit is set by software, cleared by hardware when the NACK is sent, or when a STOP condition or an Address matched is received, or when PE=0. Note: Writing 0 to this bit has no effect. This bit is used in slave mode only: in master receiver mode, NACK is automatically generated after last byte preceding STOP or RESTART condition, whatever the NACK bit value. When an overrun occurs in slave receiver NOSTRETCH mode, a NACK is automatically generated whatever the NACK bit value. When hardware PEC checking is enabled (PECBYTE=1), the PEC acknowledge value does not depend on the NACK value.
    const uint32_t I2C4_CR2_NACK = 1U << 15 ;

  // Field NBYTES: Number of bytes The number of bytes to be transmitted/received is programmed there. This field is dont care in slave mode with SBC=0. Note: Changing these bits when the START bit is set is not allowed.
    inline uint32_t I2C4_CR2_NBYTES (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field RELOAD: NBYTES reload mode This bit is set and cleared by software.
    const uint32_t I2C4_CR2_RELOAD = 1U << 24 ;

  // Field AUTOEND: Automatic end mode (master mode) This bit is set and cleared by software. Note: This bit has no effect in slave mode or when the RELOAD bit is set.
    const uint32_t I2C4_CR2_AUTOEND = 1U << 25 ;

  // Field PECBYTE: Packet error checking byte This bit is set by software, and cleared by hardware when the PEC is transferred, or when a STOP condition or an Address matched is received, also when PE=0. Note: Writing 0 to this bit has no effect. This bit has no effect when RELOAD is set. This bit has no effect is slave mode when SBC=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_CR2_PECBYTE = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register OAR1: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C4_OAR1 (* ((volatile uint32_t *) (0x58001C00 + 8)))

  // Field OA1: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bits 9:8 of address Note: These bits can be written only when OA1EN=0. OA1[7:1]: Interface address Bits 7:1 of address Note: These bits can be written only when OA1EN=0. OA1[0]: Interface address 7-bit addressing mode: dont care 10-bit addressing mode: bit 0 of address Note: This bit can be written only when OA1EN=0.
    inline uint32_t I2C4_OAR1_OA1 (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field OA1MODE: Own Address 1 10-bit mode Note: This bit can be written only when OA1EN=0.
    const uint32_t I2C4_OAR1_OA1MODE = 1U << 10 ;

  // Field OA1EN: Own Address 1 enable
    const uint32_t I2C4_OAR1_OA1EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register OAR2: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C4_OAR2 (* ((volatile uint32_t *) (0x58001C00 + 12)))

  // Field OA2: Interface address bits 7:1 of address Note: These bits can be written only when OA2EN=0.
    inline uint32_t I2C4_OAR2_OA2 (const uint32_t inValue) {return (inValue & 0x7FU) << 1 ; }

  // Field OA2MSK: Own Address 2 masks Note: These bits can be written only when OA2EN=0. As soon as OA2MSK is not equal to 0, the reserved I2C addresses (0b0000xxx and 0b1111xxx) are not acknowledged even if the comparison matches.
    inline uint32_t I2C4_OAR2_OA2MSK (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field OA2EN: Own Address 2 enable
    const uint32_t I2C4_OAR2_OA2EN = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register TIMINGR: Access: No wait states
  #define I2C4_TIMINGR (* ((volatile uint32_t *) (0x58001C00 + 16)))

  // Field SCLL: SCL low period (master mode) This field is used to generate the SCL low period in master mode. tSCLL = (SCLL+1) x tPRESC Note: SCLL is also used to generate tBUF and tSU:STA timings.
    inline uint32_t I2C4_TIMINGR_SCLL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field SCLH: SCL high period (master mode) This field is used to generate the SCL high period in master mode. tSCLH = (SCLH+1) x tPRESC Note: SCLH is also used to generate tSU:STO and tHD:STA timing.
    inline uint32_t I2C4_TIMINGR_SCLH (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field SDADEL: Data hold time This field is used to generate the delay tSDADEL between SCL falling edge and SDA edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSDADEL. tSDADEL= SDADEL x tPRESC Note: SDADEL is used to generate tHD:DAT timing.
    inline uint32_t I2C4_TIMINGR_SDADEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field SCLDEL: Data setup time This field is used to generate a delay tSCLDEL between SDA edge and SCL rising edge. In master mode and in slave mode with NOSTRETCH = 0, the SCL line is stretched low during tSCLDEL. tSCLDEL = (SCLDEL+1) x tPRESC Note: tSCLDEL is used to generate tSU:DAT timing.
    inline uint32_t I2C4_TIMINGR_SCLDEL (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field PRESC: Timing prescaler This field is used to prescale I2CCLK in order to generate the clock period tPRESC used for data setup and hold counters (refer to I2C timings on page9) and for SCL high and low level counters (refer to I2C master initialization on page24). tPRESC = (PRESC+1) x tI2CCLK
    inline uint32_t I2C4_TIMINGR_PRESC (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

//------------------------------------------------------------------------------

//---  Register TIMEOUTR: Access: No wait states, except if a write access occurs while a write access to this register is ongoing. In this case, wait states are inserted in the second write access until the previous one is completed. The latency of the second write access can be up to 2 x PCLK1 + 6 x I2CCLK.
  #define I2C4_TIMEOUTR (* ((volatile uint32_t *) (0x58001C00 + 20)))

  // Field TIMEOUTA: Bus Timeout A This field is used to configure: The SCL low timeout condition tTIMEOUT when TIDLE=0 tTIMEOUT= (TIMEOUTA+1) x 2048 x tI2CCLK The bus idle condition (both SCL and SDA high) when TIDLE=1 tIDLE= (TIMEOUTA+1) x 4 x tI2CCLK Note: These bits can be written only when TIMOUTEN=0.
    inline uint32_t I2C4_TIMEOUTR_TIMEOUTA (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field TIDLE: Idle clock timeout detection Note: This bit can be written only when TIMOUTEN=0.
    const uint32_t I2C4_TIMEOUTR_TIDLE = 1U << 12 ;

  // Field TIMOUTEN: Clock timeout enable
    const uint32_t I2C4_TIMEOUTR_TIMOUTEN = 1U << 15 ;

  // Field TIMEOUTB: Bus timeout B This field is used to configure the cumulative clock extension timeout: In master mode, the master cumulative clock low extend time (tLOW:MEXT) is detected In slave mode, the slave cumulative clock low extend time (tLOW:SEXT) is detected tLOW:EXT= (TIMEOUTB+1) x 2048 x tI2CCLK Note: These bits can be written only when TEXTEN=0.
    inline uint32_t I2C4_TIMEOUTR_TIMEOUTB (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field TEXTEN: Extended clock timeout enable
    const uint32_t I2C4_TIMEOUTR_TEXTEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register ISR: Access: No wait states
  #define I2C4_ISR (* ((volatile uint32_t *) (0x58001C00 + 24)))

  // Field TXE: Transmit data register empty (transmitters) This bit is set by hardware when the I2C_TXDR register is empty. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software in order to flush the transmit data register I2C_TXDR. Note: This bit is set by hardware when PE=0.
    const uint32_t I2C4_ISR_TXE = 1U << 0 ;

  // Field TXIS: Transmit interrupt status (transmitters) This bit is set by hardware when the I2C_TXDR register is empty and the data to be transmitted must be written in the I2C_TXDR register. It is cleared when the next data to be sent is written in the I2C_TXDR register. This bit can be written to 1 by software when NOSTRETCH=1 only, in order to generate a TXIS event (interrupt if TXIE=1 or DMA request if TXDMAEN=1). Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_TXIS = 1U << 1 ;

  // Field RXNE: Receive data register not empty (receivers) This bit is set by hardware when the received data is copied into the I2C_RXDR register, and is ready to be read. It is cleared when I2C_RXDR is read. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_RXNE = 1U << 2 ;

  // Field ADDR: Address matched (slave mode) This bit is set by hardware as soon as the received slave address matched with one of the enabled slave addresses. It is cleared by software by setting ADDRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_ADDR = 1U << 3 ;

  // Field NACKF: Not Acknowledge received flag This flag is set by hardware when a NACK is received after a byte transmission. It is cleared by software by setting the NACKCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_NACKF = 1U << 4 ;

  // Field STOPF: Stop detection flag This flag is set by hardware when a Stop condition is detected on the bus and the peripheral is involved in this transfer: either as a master, provided that the STOP condition is generated by the peripheral. or as a slave, provided that the peripheral has been addressed previously during this transfer. It is cleared by software by setting the STOPCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_STOPF = 1U << 5 ;

  // Field TC: Transfer Complete (master mode) This flag is set by hardware when RELOAD=0, AUTOEND=0 and NBYTES data have been transferred. It is cleared by software when START bit or STOP bit is set. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_TC = 1U << 6 ;

  // Field TCR: Transfer Complete Reload This flag is set by hardware when RELOAD=1 and NBYTES data have been transferred. It is cleared by software when NBYTES is written to a non-zero value. Note: This bit is cleared by hardware when PE=0. This flag is only for master mode, or for slave mode when the SBC bit is set.
    const uint32_t I2C4_ISR_TCR = 1U << 7 ;

  // Field BERR: Bus error This flag is set by hardware when a misplaced Start or Stop condition is detected whereas the peripheral is involved in the transfer. The flag is not set during the address phase in slave mode. It is cleared by software by setting BERRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_BERR = 1U << 8 ;

  // Field ARLO: Arbitration lost This flag is set by hardware in case of arbitration loss. It is cleared by software by setting the ARLOCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_ARLO = 1U << 9 ;

  // Field OVR: Overrun/Underrun (slave mode) This flag is set by hardware in slave mode with NOSTRETCH=1, when an overrun/underrun error occurs. It is cleared by software by setting the OVRCF bit. Note: This bit is cleared by hardware when PE=0.
    const uint32_t I2C4_ISR_OVR = 1U << 10 ;

  // Field PECERR: PEC Error in reception This flag is set by hardware when the received PEC does not match with the PEC register content. A NACK is automatically sent after the wrong PEC reception. It is cleared by software by setting the PECCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_ISR_PECERR = 1U << 11 ;

  // Field TIMEOUT: Timeout or tLOW detection flag This flag is set by hardware when a timeout or extended clock timeout occurred. It is cleared by software by setting the TIMEOUTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_ISR_TIMEOUT = 1U << 12 ;

  // Field ALERT: SMBus alert This flag is set by hardware when SMBHEN=1 (SMBus host configuration), ALERTEN=1 and a SMBALERT event (falling edge) is detected on SMBA pin. It is cleared by software by setting the ALERTCF bit. Note: This bit is cleared by hardware when PE=0. If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_ISR_ALERT = 1U << 13 ;

  // Field BUSY: Bus busy This flag indicates that a communication is in progress on the bus. It is set by hardware when a START condition is detected. It is cleared by hardware when a Stop condition is detected, or when PE=0.
    const uint32_t I2C4_ISR_BUSY = 1U << 15 ;

  // Field DIR: Transfer direction (Slave mode) This flag is updated when an address match event occurs (ADDR=1).
    const uint32_t I2C4_ISR_DIR = 1U << 16 ;

  // Field ADDCODE: Address match code (Slave mode) These bits are updated with the received address when an address match event occurs (ADDR = 1). In the case of a 10-bit address, ADDCODE provides the 10-bit header followed by the 2 MSBs of the address.
    inline uint32_t I2C4_ISR_ADDCODE (const uint32_t inValue) {return (inValue & 0x7FU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register ICR: Access: No wait states
  #define I2C4_ICR (* ((volatile uint32_t *) (0x58001C00 + 28)))

  // Field ADDRCF: Address matched flag clear Writing 1 to this bit clears the ADDR flag in the I2C_ISR register. Writing 1 to this bit also clears the START bit in the I2C_CR2 register.
    const uint32_t I2C4_ICR_ADDRCF = 1U << 3 ;

  // Field NACKCF: Not Acknowledge flag clear Writing 1 to this bit clears the ACKF flag in I2C_ISR register.
    const uint32_t I2C4_ICR_NACKCF = 1U << 4 ;

  // Field STOPCF: Stop detection flag clear Writing 1 to this bit clears the STOPF flag in the I2C_ISR register.
    const uint32_t I2C4_ICR_STOPCF = 1U << 5 ;

  // Field BERRCF: Bus error flag clear Writing 1 to this bit clears the BERRF flag in the I2C_ISR register.
    const uint32_t I2C4_ICR_BERRCF = 1U << 8 ;

  // Field ARLOCF: Arbitration Lost flag clear Writing 1 to this bit clears the ARLO flag in the I2C_ISR register.
    const uint32_t I2C4_ICR_ARLOCF = 1U << 9 ;

  // Field OVRCF: Overrun/Underrun flag clear Writing 1 to this bit clears the OVR flag in the I2C_ISR register.
    const uint32_t I2C4_ICR_OVRCF = 1U << 10 ;

  // Field PECCF: PEC Error flag clear Writing 1 to this bit clears the PECERR flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_ICR_PECCF = 1U << 11 ;

  // Field TIMOUTCF: Timeout detection flag clear Writing 1 to this bit clears the TIMEOUT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_ICR_TIMOUTCF = 1U << 12 ;

  // Field ALERTCF: Alert flag clear Writing 1 to this bit clears the ALERT flag in the I2C_ISR register. Note: If the SMBus feature is not supported, this bit is reserved and forced by hardware to 0. Please refer to Section25.3: I2C implementation.
    const uint32_t I2C4_ICR_ALERTCF = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register PECR: Access: No wait states
  #define I2C4_PECR (* ((const volatile uint32_t *) (0x58001C00 + 32)))

  // Field PEC: Packet error checking register This field contains the internal PEC when PECEN=1. The PEC is cleared by hardware when PE=0.
    inline uint32_t I2C4_PECR_PEC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Access: No wait states
  #define I2C4_RXDR (* ((const volatile uint32_t *) (0x58001C00 + 36)))

  // Field RXDATA: 8-bit receive data Data byte received from the I2C bus.
    inline uint32_t I2C4_RXDR_RXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXDR: Access: No wait states
  #define I2C4_TXDR (* ((volatile uint32_t *) (0x58001C00 + 40)))

  // Field TXDATA: 8-bit transmit data Data byte to be transmitted to the I2C bus. Note: These bits can be written only when TXE=1.
    inline uint32_t I2C4_TXDR_TXDATA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral IWDG: IWDG
//------------------------------------------------------------------------------

//---  Register KR: Key register
  #define IWDG_KR (* ((volatile uint32_t *) (0x58004800 + 0)))

  // Field KEY: Key value (write only, read 0x0000) These bits must be written by software at regular intervals with the key value 0xAAAA, otherwise the watchdog generates a reset when the counter reaches 0. Writing the key value 0x5555 to enable access to the IWDG_PR, IWDG_RLR and IWDG_WINR registers (see Section23.3.6: Register access protection) Writing the key value CCCCh starts the watchdog (except if the hardware watchdog option is selected)
    inline uint32_t IWDG_KR_KEY (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PR: Prescaler register
  #define IWDG_PR (* ((volatile uint32_t *) (0x58004800 + 4)))

  // Field PR: Prescaler divider These bits are write access protected see Section23.3.6: Register access protection. They are written by software to select the prescaler divider feeding the counter clock. PVU bit of IWDG_SR must be reset in order to be able to change the prescaler divider. Note: Reading this register returns the prescaler value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the PVU bit in the IWDG_SR register is reset.
    inline uint32_t IWDG_PR_PR (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RLR: Reload register
  #define IWDG_RLR (* ((volatile uint32_t *) (0x58004800 + 8)))

  // Field RL: Watchdog counter reload value These bits are write access protected see Section23.3.6. They are written by software to define the value to be loaded in the watchdog counter each time the value 0xAAAA is written in the IWDG_KR register. The watchdog counter counts down from this value. The timeout period is a function of this value and the clock prescaler. Refer to the datasheet for the timeout information. The RVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be up to date/valid if a write operation to this register is ongoing on this register. For this reason the value read from this register is valid only when the RVU bit in the IWDG_SR register is reset.
    inline uint32_t IWDG_RLR_RL (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SR: Status register
  #define IWDG_SR (* ((const volatile uint32_t *) (0x58004800 + 12)))

  // Field PVU: Watchdog prescaler value update This bit is set by hardware to indicate that an update of the prescaler value is ongoing. It is reset by hardware when the prescaler update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Prescaler value can be updated only when PVU bit is reset.
    const uint32_t IWDG_SR_PVU = 1U << 0 ;

  // Field RVU: Watchdog counter reload value update This bit is set by hardware to indicate that an update of the reload value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Reload value can be updated only when RVU bit is reset.
    const uint32_t IWDG_SR_RVU = 1U << 1 ;

  // Field WVU: Watchdog counter window value update This bit is set by hardware to indicate that an update of the window value is ongoing. It is reset by hardware when the reload value update operation is completed in the VDD voltage domain (takes up to 5 RC 40 kHz cycles). Window value can be updated only when WVU bit is reset. This bit is generated only if generic window = 1
    const uint32_t IWDG_SR_WVU = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register WINR: Window register
  #define IWDG_WINR (* ((volatile uint32_t *) (0x58004800 + 16)))

  // Field WIN: Watchdog counter window value These bits are write access protected see Section23.3.6. These bits contain the high limit of the window value to be compared to the downcounter. To prevent a reset, the downcounter must be reloaded when its value is lower than the window register value and greater than 0x0 The WVU bit in the IWDG_SR register must be reset in order to be able to change the reload value. Note: Reading this register returns the reload value from the VDD voltage domain. This value may not be valid if a write operation to this register is ongoing. For this reason the value read from this register is valid only when the WVU bit in the IWDG_SR register is reset.
    inline uint32_t IWDG_WINR_WIN (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral JPEG: JPEG
//------------------------------------------------------------------------------

//---  Register CONFR0: JPEG codec control register
  #define JPEG_CONFR0 (* ((volatile uint32_t *) (0x52003000 + 0)))

  // Field START: Start This bit start or stop the encoding or decoding process. Read this register always return 0.
    const uint32_t JPEG_CONFR0_START = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CONFR1: JPEG codec configuration register 1
  #define JPEG_CONFR1 (* ((volatile uint32_t *) (0x52003000 + 4)))

  // Field NF: Number of color components This field defines the number of color components minus 1.
    inline uint32_t JPEG_CONFR1_NF (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DE: Decoding Enable This bit selects the coding or decoding process
    const uint32_t JPEG_CONFR1_DE = 1U << 3 ;

  // Field COLORSPACE: Color Space This filed defines the number of quantization tables minus 1 to insert in the output stream.
    inline uint32_t JPEG_CONFR1_COLORSPACE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field NS: Number of components for Scan This field defines the number of components minus 1 for scan header marker segment.
    inline uint32_t JPEG_CONFR1_NS (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field HDR: Header Processing This bit enable the header processing (generation/parsing).
    const uint32_t JPEG_CONFR1_HDR = 1U << 8 ;

  // Field YSIZE: Y Size This field defines the number of lines in source image.
    inline uint32_t JPEG_CONFR1_YSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CONFR2: JPEG codec configuration register 2
  #define JPEG_CONFR2 (* ((volatile uint32_t *) (0x52003000 + 8)))

  // Field NMCU: Number of MCU For encoding: this field defines the number of MCU units minus 1 to encode. For decoding: this field indicates the number of complete MCU units minus 1 to be decoded (this field is updated after the JPEG header parsing). If the decoded image size has not a X or Y size multiple of 8 or 16 (depending on the sub-sampling process), the resulting incomplete or empty MCU must be added to this value to get the total number of MCU generated.
    inline uint32_t JPEG_CONFR2_NMCU (const uint32_t inValue) {return (inValue & 0x3FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CONFR3: JPEG codec configuration register 3
  #define JPEG_CONFR3 (* ((volatile uint32_t *) (0x52003000 + 12)))

  // Field XSIZE: X size This field defines the number of pixels per line.
    inline uint32_t JPEG_CONFR3_XSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register CONFRN1: JPEG codec configuration register 4-7
  #define JPEG_CONFRN1 (* ((volatile uint32_t *) (0x52003000 + 16)))

  // Field HD: Huffman DC Selects the Huffman table for encoding the DC coefficients.
    const uint32_t JPEG_CONFRN1_HD = 1U << 0 ;

  // Field HA: Huffman AC Selects the Huffman table for encoding the AC coefficients.
    const uint32_t JPEG_CONFRN1_HA = 1U << 1 ;

  // Field QT: Quantization Table Selects quantization table associated with a color component.
    inline uint32_t JPEG_CONFRN1_QT (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field NB: Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
    inline uint32_t JPEG_CONFRN1_NB (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field VSF: Vertical Sampling Factor Vertical sampling factor for component i.
    inline uint32_t JPEG_CONFRN1_VSF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field HSF: Horizontal Sampling Factor Horizontal sampling factor for component i.
    inline uint32_t JPEG_CONFRN1_HSF (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register CONFRN2: JPEG codec configuration register 4-7
  #define JPEG_CONFRN2 (* ((volatile uint32_t *) (0x52003000 + 20)))

  // Field HD: Huffman DC Selects the Huffman table for encoding the DC coefficients.
    const uint32_t JPEG_CONFRN2_HD = 1U << 0 ;

  // Field HA: Huffman AC Selects the Huffman table for encoding the AC coefficients.
    const uint32_t JPEG_CONFRN2_HA = 1U << 1 ;

  // Field QT: Quantization Table Selects quantization table associated with a color component.
    inline uint32_t JPEG_CONFRN2_QT (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field NB: Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
    inline uint32_t JPEG_CONFRN2_NB (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field VSF: Vertical Sampling Factor Vertical sampling factor for component i.
    inline uint32_t JPEG_CONFRN2_VSF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field HSF: Horizontal Sampling Factor Horizontal sampling factor for component i.
    inline uint32_t JPEG_CONFRN2_HSF (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register CONFRN3: JPEG codec configuration register 4-7
  #define JPEG_CONFRN3 (* ((volatile uint32_t *) (0x52003000 + 24)))

  // Field HD: Huffman DC Selects the Huffman table for encoding the DC coefficients.
    const uint32_t JPEG_CONFRN3_HD = 1U << 0 ;

  // Field HA: Huffman AC Selects the Huffman table for encoding the AC coefficients.
    const uint32_t JPEG_CONFRN3_HA = 1U << 1 ;

  // Field QT: Quantization Table Selects quantization table associated with a color component.
    inline uint32_t JPEG_CONFRN3_QT (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field NB: Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
    inline uint32_t JPEG_CONFRN3_NB (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field VSF: Vertical Sampling Factor Vertical sampling factor for component i.
    inline uint32_t JPEG_CONFRN3_VSF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field HSF: Horizontal Sampling Factor Horizontal sampling factor for component i.
    inline uint32_t JPEG_CONFRN3_HSF (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register CONFRN4: JPEG codec configuration register 4-7
  #define JPEG_CONFRN4 (* ((volatile uint32_t *) (0x52003000 + 28)))

  // Field HD: Huffman DC Selects the Huffman table for encoding the DC coefficients.
    const uint32_t JPEG_CONFRN4_HD = 1U << 0 ;

  // Field HA: Huffman AC Selects the Huffman table for encoding the AC coefficients.
    const uint32_t JPEG_CONFRN4_HA = 1U << 1 ;

  // Field QT: Quantization Table Selects quantization table associated with a color component.
    inline uint32_t JPEG_CONFRN4_QT (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field NB: Number of Block Number of data units minus 1 that belong to a particular color in the MCU.
    inline uint32_t JPEG_CONFRN4_NB (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field VSF: Vertical Sampling Factor Vertical sampling factor for component i.
    inline uint32_t JPEG_CONFRN4_VSF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field HSF: Horizontal Sampling Factor Horizontal sampling factor for component i.
    inline uint32_t JPEG_CONFRN4_HSF (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

//------------------------------------------------------------------------------

//---  Register CR: JPEG control register
  #define JPEG_CR (* ((volatile uint32_t *) (0x52003000 + 48)))

  // Field JCEN: JPEG Core Enable Enable the JPEG codec Core.
    const uint32_t JPEG_CR_JCEN = 1U << 0 ;

  // Field IFTIE: Input FIFO Threshold Interrupt Enable This bit enables the interrupt generation when input FIFO reach the threshold.
    const uint32_t JPEG_CR_IFTIE = 1U << 1 ;

  // Field IFNFIE: Input FIFO Not Full Interrupt Enable This bit enables the interrupt generation when input FIFO is not empty.
    const uint32_t JPEG_CR_IFNFIE = 1U << 2 ;

  // Field OFTIE: Output FIFO Threshold Interrupt Enable This bit enables the interrupt generation when output FIFO reach the threshold.
    const uint32_t JPEG_CR_OFTIE = 1U << 3 ;

  // Field OFNEIE: Output FIFO Not Empty Interrupt Enable This bit enables the interrupt generation when output FIFO is not empty.
    const uint32_t JPEG_CR_OFNEIE = 1U << 4 ;

  // Field EOCIE: End of Conversion Interrupt Enable This bit enables the interrupt generation on the end of conversion.
    const uint32_t JPEG_CR_EOCIE = 1U << 5 ;

  // Field HPDIE: Header Parsing Done Interrupt Enable This bit enables the interrupt generation on the Header Parsing Operation.
    const uint32_t JPEG_CR_HPDIE = 1U << 6 ;

  // Field IDMAEN: Input DMA Enable Enable the DMA request generation for the input FIFO.
    const uint32_t JPEG_CR_IDMAEN = 1U << 11 ;

  // Field ODMAEN: Output DMA Enable Enable the DMA request generation for the output FIFO.
    const uint32_t JPEG_CR_ODMAEN = 1U << 12 ;

  // Field IFF: Input FIFO Flush This bit flush the input FIFO. This bit is always read as 0.
    const uint32_t JPEG_CR_IFF = 1U << 13 ;

  // Field OFF: Output FIFO Flush This bit flush the output FIFO. This bit is always read as 0.
    const uint32_t JPEG_CR_OFF = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register SR: JPEG status register
  #define JPEG_SR (* ((const volatile uint32_t *) (0x52003000 + 52)))

  // Field IFTF: Input FIFO Threshold Flag This bit is set when the input FIFO is not full and is bellow its threshold.
    const uint32_t JPEG_SR_IFTF = 1U << 1 ;

  // Field IFNFF: Input FIFO Not Full Flag This bit is set when the input FIFO is not full (a data can be written).
    const uint32_t JPEG_SR_IFNFF = 1U << 2 ;

  // Field OFTF: Output FIFO Threshold Flag This bit is set when the output FIFO is not empty and has reach its threshold.
    const uint32_t JPEG_SR_OFTF = 1U << 3 ;

  // Field OFNEF: Output FIFO Not Empty Flag This bit is set when the output FIFO is not empty (a data is available).
    const uint32_t JPEG_SR_OFNEF = 1U << 4 ;

  // Field EOCF: End of Conversion Flag This bit is set when the JPEG codec core has finished the encoding or the decoding process and than last data has been sent to the output FIFO.
    const uint32_t JPEG_SR_EOCF = 1U << 5 ;

  // Field HPDF: Header Parsing Done Flag This bit is set in decode mode when the JPEG codec has finished the parsing of the headers and the internal registers have been updated.
    const uint32_t JPEG_SR_HPDF = 1U << 6 ;

  // Field COF: Codec Operation Flag This bit is set when when a JPEG codec operation is on going (encoding or decoding).
    const uint32_t JPEG_SR_COF = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CFR: JPEG clear flag register
  #define JPEG_CFR (* ((volatile uint32_t *) (0x52003000 + 56)))

  // Field CEOCF: Clear End of Conversion Flag Writing 1 clears the End of Conversion Flag of the JPEG Status Register.
    const uint32_t JPEG_CFR_CEOCF = 1U << 5 ;

  // Field CHPDF: Clear Header Parsing Done Flag Writing 1 clears the Header Parsing Done Flag of the JPEG Status Register.
    const uint32_t JPEG_CFR_CHPDF = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register DIR: JPEG data input register
  #define JPEG_DIR (* ((volatile uint32_t *) (0x52003000 + 64)))

  // Field DATAIN: Data Input FIFO Input FIFO data register.
    inline uint32_t JPEG_DIR_DATAIN (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOR: JPEG data output register
  #define JPEG_DOR (* ((const volatile uint32_t *) (0x52003000 + 68)))

  // Field DATAOUT: Data Output FIFO Output FIFO data register.
    inline uint32_t JPEG_DOR_DATAOUT (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral LPTIM1: Low power timer
//------------------------------------------------------------------------------

//---  Register ISR: Interrupt and Status Register
  #define LPTIM1_ISR (* ((const volatile uint32_t *) (0x40002400 + 0)))

  // Field DOWN: Counter direction change up to down
    const uint32_t LPTIM1_ISR_DOWN = 1U << 6 ;

  // Field UP: Counter direction change down to up
    const uint32_t LPTIM1_ISR_UP = 1U << 5 ;

  // Field ARROK: Autoreload register update OK
    const uint32_t LPTIM1_ISR_ARROK = 1U << 4 ;

  // Field CMPOK: Compare register update OK
    const uint32_t LPTIM1_ISR_CMPOK = 1U << 3 ;

  // Field EXTTRIG: External trigger edge event
    const uint32_t LPTIM1_ISR_EXTTRIG = 1U << 2 ;

  // Field ARRM: Autoreload match
    const uint32_t LPTIM1_ISR_ARRM = 1U << 1 ;

  // Field CMPM: Compare match
    const uint32_t LPTIM1_ISR_CMPM = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define LPTIM1_ICR (* ((volatile uint32_t *) (0x40002400 + 4)))

  // Field DOWNCF: Direction change to down Clear Flag
    const uint32_t LPTIM1_ICR_DOWNCF = 1U << 6 ;

  // Field UPCF: Direction change to UP Clear Flag
    const uint32_t LPTIM1_ICR_UPCF = 1U << 5 ;

  // Field ARROKCF: Autoreload register update OK Clear Flag
    const uint32_t LPTIM1_ICR_ARROKCF = 1U << 4 ;

  // Field CMPOKCF: Compare register update OK Clear Flag
    const uint32_t LPTIM1_ICR_CMPOKCF = 1U << 3 ;

  // Field EXTTRIGCF: External trigger valid edge Clear Flag
    const uint32_t LPTIM1_ICR_EXTTRIGCF = 1U << 2 ;

  // Field ARRMCF: Autoreload match Clear Flag
    const uint32_t LPTIM1_ICR_ARRMCF = 1U << 1 ;

  // Field CMPMCF: compare match Clear Flag
    const uint32_t LPTIM1_ICR_CMPMCF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define LPTIM1_IER (* ((volatile uint32_t *) (0x40002400 + 8)))

  // Field DOWNIE: Direction change to down Interrupt Enable
    const uint32_t LPTIM1_IER_DOWNIE = 1U << 6 ;

  // Field UPIE: Direction change to UP Interrupt Enable
    const uint32_t LPTIM1_IER_UPIE = 1U << 5 ;

  // Field ARROKIE: Autoreload register update OK Interrupt Enable
    const uint32_t LPTIM1_IER_ARROKIE = 1U << 4 ;

  // Field CMPOKIE: Compare register update OK Interrupt Enable
    const uint32_t LPTIM1_IER_CMPOKIE = 1U << 3 ;

  // Field EXTTRIGIE: External trigger valid edge Interrupt Enable
    const uint32_t LPTIM1_IER_EXTTRIGIE = 1U << 2 ;

  // Field ARRMIE: Autoreload match Interrupt Enable
    const uint32_t LPTIM1_IER_ARRMIE = 1U << 1 ;

  // Field CMPMIE: Compare match Interrupt Enable
    const uint32_t LPTIM1_IER_CMPMIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: Configuration Register
  #define LPTIM1_CFGR (* ((volatile uint32_t *) (0x40002400 + 12)))

  // Field ENC: Encoder mode enable
    const uint32_t LPTIM1_CFGR_ENC = 1U << 24 ;

  // Field COUNTMODE: counter mode enabled
    const uint32_t LPTIM1_CFGR_COUNTMODE = 1U << 23 ;

  // Field PRELOAD: Registers update mode
    const uint32_t LPTIM1_CFGR_PRELOAD = 1U << 22 ;

  // Field WAVPOL: Waveform shape polarity
    const uint32_t LPTIM1_CFGR_WAVPOL = 1U << 21 ;

  // Field WAVE: Waveform shape
    const uint32_t LPTIM1_CFGR_WAVE = 1U << 20 ;

  // Field TIMOUT: Timeout enable
    const uint32_t LPTIM1_CFGR_TIMOUT = 1U << 19 ;

  // Field TRIGEN: Trigger enable and polarity
    inline uint32_t LPTIM1_CFGR_TRIGEN (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field TRIGSEL: Trigger selector
    inline uint32_t LPTIM1_CFGR_TRIGSEL (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field PRESC: Clock prescaler
    inline uint32_t LPTIM1_CFGR_PRESC (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field TRGFLT: Configurable digital filter for trigger
    inline uint32_t LPTIM1_CFGR_TRGFLT (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field CKFLT: Configurable digital filter for external clock
    inline uint32_t LPTIM1_CFGR_CKFLT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field CKPOL: Clock Polarity
    inline uint32_t LPTIM1_CFGR_CKPOL (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field CKSEL: Clock selector
    const uint32_t LPTIM1_CFGR_CKSEL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: Control Register
  #define LPTIM1_CR (* ((volatile uint32_t *) (0x40002400 + 16)))

  // Field ENABLE: LPTIM Enable
    const uint32_t LPTIM1_CR_ENABLE = 1U << 0 ;

  // Field SNGSTRT: LPTIM start in single mode
    const uint32_t LPTIM1_CR_SNGSTRT = 1U << 1 ;

  // Field CNTSTRT: Timer start in continuous mode
    const uint32_t LPTIM1_CR_CNTSTRT = 1U << 2 ;

  // Field COUNTRST: Counter reset
    const uint32_t LPTIM1_CR_COUNTRST = 1U << 3 ;

  // Field RSTARE: Reset after read enable
    const uint32_t LPTIM1_CR_RSTARE = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CMP: Compare Register
  #define LPTIM1_CMP (* ((volatile uint32_t *) (0x40002400 + 20)))

  // Field CMP: Compare value
    inline uint32_t LPTIM1_CMP_CMP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: Autoreload Register
  #define LPTIM1_ARR (* ((volatile uint32_t *) (0x40002400 + 24)))

  // Field ARR: Auto reload value
    inline uint32_t LPTIM1_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CNT: Counter Register
  #define LPTIM1_CNT (* ((const volatile uint32_t *) (0x40002400 + 28)))

  // Field CNT: Counter value
    inline uint32_t LPTIM1_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: LPTIM configuration register 2
  #define LPTIM1_CFGR2 (* ((volatile uint32_t *) (0x40002400 + 36)))

  // Field IN1SEL: LPTIM Input 1 selection
    inline uint32_t LPTIM1_CFGR2_IN1SEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field IN2SEL: LPTIM Input 2 selection
    inline uint32_t LPTIM1_CFGR2_IN2SEL (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------
// Peripheral LPTIM2
//------------------------------------------------------------------------------

//---  Register ISR: Interrupt and Status Register
  #define LPTIM2_ISR (* ((const volatile uint32_t *) (0x58002400 + 0)))

  // Field DOWN: Counter direction change up to down
    const uint32_t LPTIM2_ISR_DOWN = 1U << 6 ;

  // Field UP: Counter direction change down to up
    const uint32_t LPTIM2_ISR_UP = 1U << 5 ;

  // Field ARROK: Autoreload register update OK
    const uint32_t LPTIM2_ISR_ARROK = 1U << 4 ;

  // Field CMPOK: Compare register update OK
    const uint32_t LPTIM2_ISR_CMPOK = 1U << 3 ;

  // Field EXTTRIG: External trigger edge event
    const uint32_t LPTIM2_ISR_EXTTRIG = 1U << 2 ;

  // Field ARRM: Autoreload match
    const uint32_t LPTIM2_ISR_ARRM = 1U << 1 ;

  // Field CMPM: Compare match
    const uint32_t LPTIM2_ISR_CMPM = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define LPTIM2_ICR (* ((volatile uint32_t *) (0x58002400 + 4)))

  // Field DOWNCF: Direction change to down Clear Flag
    const uint32_t LPTIM2_ICR_DOWNCF = 1U << 6 ;

  // Field UPCF: Direction change to UP Clear Flag
    const uint32_t LPTIM2_ICR_UPCF = 1U << 5 ;

  // Field ARROKCF: Autoreload register update OK Clear Flag
    const uint32_t LPTIM2_ICR_ARROKCF = 1U << 4 ;

  // Field CMPOKCF: Compare register update OK Clear Flag
    const uint32_t LPTIM2_ICR_CMPOKCF = 1U << 3 ;

  // Field EXTTRIGCF: External trigger valid edge Clear Flag
    const uint32_t LPTIM2_ICR_EXTTRIGCF = 1U << 2 ;

  // Field ARRMCF: Autoreload match Clear Flag
    const uint32_t LPTIM2_ICR_ARRMCF = 1U << 1 ;

  // Field CMPMCF: compare match Clear Flag
    const uint32_t LPTIM2_ICR_CMPMCF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define LPTIM2_IER (* ((volatile uint32_t *) (0x58002400 + 8)))

  // Field DOWNIE: Direction change to down Interrupt Enable
    const uint32_t LPTIM2_IER_DOWNIE = 1U << 6 ;

  // Field UPIE: Direction change to UP Interrupt Enable
    const uint32_t LPTIM2_IER_UPIE = 1U << 5 ;

  // Field ARROKIE: Autoreload register update OK Interrupt Enable
    const uint32_t LPTIM2_IER_ARROKIE = 1U << 4 ;

  // Field CMPOKIE: Compare register update OK Interrupt Enable
    const uint32_t LPTIM2_IER_CMPOKIE = 1U << 3 ;

  // Field EXTTRIGIE: External trigger valid edge Interrupt Enable
    const uint32_t LPTIM2_IER_EXTTRIGIE = 1U << 2 ;

  // Field ARRMIE: Autoreload match Interrupt Enable
    const uint32_t LPTIM2_IER_ARRMIE = 1U << 1 ;

  // Field CMPMIE: Compare match Interrupt Enable
    const uint32_t LPTIM2_IER_CMPMIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: Configuration Register
  #define LPTIM2_CFGR (* ((volatile uint32_t *) (0x58002400 + 12)))

  // Field ENC: Encoder mode enable
    const uint32_t LPTIM2_CFGR_ENC = 1U << 24 ;

  // Field COUNTMODE: counter mode enabled
    const uint32_t LPTIM2_CFGR_COUNTMODE = 1U << 23 ;

  // Field PRELOAD: Registers update mode
    const uint32_t LPTIM2_CFGR_PRELOAD = 1U << 22 ;

  // Field WAVPOL: Waveform shape polarity
    const uint32_t LPTIM2_CFGR_WAVPOL = 1U << 21 ;

  // Field WAVE: Waveform shape
    const uint32_t LPTIM2_CFGR_WAVE = 1U << 20 ;

  // Field TIMOUT: Timeout enable
    const uint32_t LPTIM2_CFGR_TIMOUT = 1U << 19 ;

  // Field TRIGEN: Trigger enable and polarity
    inline uint32_t LPTIM2_CFGR_TRIGEN (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field TRIGSEL: Trigger selector
    inline uint32_t LPTIM2_CFGR_TRIGSEL (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field PRESC: Clock prescaler
    inline uint32_t LPTIM2_CFGR_PRESC (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field TRGFLT: Configurable digital filter for trigger
    inline uint32_t LPTIM2_CFGR_TRGFLT (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field CKFLT: Configurable digital filter for external clock
    inline uint32_t LPTIM2_CFGR_CKFLT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field CKPOL: Clock Polarity
    inline uint32_t LPTIM2_CFGR_CKPOL (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field CKSEL: Clock selector
    const uint32_t LPTIM2_CFGR_CKSEL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: Control Register
  #define LPTIM2_CR (* ((volatile uint32_t *) (0x58002400 + 16)))

  // Field ENABLE: LPTIM Enable
    const uint32_t LPTIM2_CR_ENABLE = 1U << 0 ;

  // Field SNGSTRT: LPTIM start in single mode
    const uint32_t LPTIM2_CR_SNGSTRT = 1U << 1 ;

  // Field CNTSTRT: Timer start in continuous mode
    const uint32_t LPTIM2_CR_CNTSTRT = 1U << 2 ;

  // Field COUNTRST: Counter reset
    const uint32_t LPTIM2_CR_COUNTRST = 1U << 3 ;

  // Field RSTARE: Reset after read enable
    const uint32_t LPTIM2_CR_RSTARE = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CMP: Compare Register
  #define LPTIM2_CMP (* ((volatile uint32_t *) (0x58002400 + 20)))

  // Field CMP: Compare value
    inline uint32_t LPTIM2_CMP_CMP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: Autoreload Register
  #define LPTIM2_ARR (* ((volatile uint32_t *) (0x58002400 + 24)))

  // Field ARR: Auto reload value
    inline uint32_t LPTIM2_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CNT: Counter Register
  #define LPTIM2_CNT (* ((const volatile uint32_t *) (0x58002400 + 28)))

  // Field CNT: Counter value
    inline uint32_t LPTIM2_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: LPTIM configuration register 2
  #define LPTIM2_CFGR2 (* ((volatile uint32_t *) (0x58002400 + 36)))

  // Field IN1SEL: LPTIM Input 1 selection
    inline uint32_t LPTIM2_CFGR2_IN1SEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field IN2SEL: LPTIM Input 2 selection
    inline uint32_t LPTIM2_CFGR2_IN2SEL (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

//------------------------------------------------------------------------------
// Peripheral LPTIM3: Low power timer
//------------------------------------------------------------------------------

//---  Register ISR: Interrupt and Status Register
  #define LPTIM3_ISR (* ((const volatile uint32_t *) (0x58002800 + 0)))

  // Field DOWN: Counter direction change up to down
    const uint32_t LPTIM3_ISR_DOWN = 1U << 6 ;

  // Field UP: Counter direction change down to up
    const uint32_t LPTIM3_ISR_UP = 1U << 5 ;

  // Field ARROK: Autoreload register update OK
    const uint32_t LPTIM3_ISR_ARROK = 1U << 4 ;

  // Field CMPOK: Compare register update OK
    const uint32_t LPTIM3_ISR_CMPOK = 1U << 3 ;

  // Field EXTTRIG: External trigger edge event
    const uint32_t LPTIM3_ISR_EXTTRIG = 1U << 2 ;

  // Field ARRM: Autoreload match
    const uint32_t LPTIM3_ISR_ARRM = 1U << 1 ;

  // Field CMPM: Compare match
    const uint32_t LPTIM3_ISR_CMPM = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define LPTIM3_ICR (* ((volatile uint32_t *) (0x58002800 + 4)))

  // Field DOWNCF: Direction change to down Clear Flag
    const uint32_t LPTIM3_ICR_DOWNCF = 1U << 6 ;

  // Field UPCF: Direction change to UP Clear Flag
    const uint32_t LPTIM3_ICR_UPCF = 1U << 5 ;

  // Field ARROKCF: Autoreload register update OK Clear Flag
    const uint32_t LPTIM3_ICR_ARROKCF = 1U << 4 ;

  // Field CMPOKCF: Compare register update OK Clear Flag
    const uint32_t LPTIM3_ICR_CMPOKCF = 1U << 3 ;

  // Field EXTTRIGCF: External trigger valid edge Clear Flag
    const uint32_t LPTIM3_ICR_EXTTRIGCF = 1U << 2 ;

  // Field ARRMCF: Autoreload match Clear Flag
    const uint32_t LPTIM3_ICR_ARRMCF = 1U << 1 ;

  // Field CMPMCF: compare match Clear Flag
    const uint32_t LPTIM3_ICR_CMPMCF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define LPTIM3_IER (* ((volatile uint32_t *) (0x58002800 + 8)))

  // Field DOWNIE: Direction change to down Interrupt Enable
    const uint32_t LPTIM3_IER_DOWNIE = 1U << 6 ;

  // Field UPIE: Direction change to UP Interrupt Enable
    const uint32_t LPTIM3_IER_UPIE = 1U << 5 ;

  // Field ARROKIE: Autoreload register update OK Interrupt Enable
    const uint32_t LPTIM3_IER_ARROKIE = 1U << 4 ;

  // Field CMPOKIE: Compare register update OK Interrupt Enable
    const uint32_t LPTIM3_IER_CMPOKIE = 1U << 3 ;

  // Field EXTTRIGIE: External trigger valid edge Interrupt Enable
    const uint32_t LPTIM3_IER_EXTTRIGIE = 1U << 2 ;

  // Field ARRMIE: Autoreload match Interrupt Enable
    const uint32_t LPTIM3_IER_ARRMIE = 1U << 1 ;

  // Field CMPMIE: Compare match Interrupt Enable
    const uint32_t LPTIM3_IER_CMPMIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: Configuration Register
  #define LPTIM3_CFGR (* ((volatile uint32_t *) (0x58002800 + 12)))

  // Field ENC: Encoder mode enable
    const uint32_t LPTIM3_CFGR_ENC = 1U << 24 ;

  // Field COUNTMODE: counter mode enabled
    const uint32_t LPTIM3_CFGR_COUNTMODE = 1U << 23 ;

  // Field PRELOAD: Registers update mode
    const uint32_t LPTIM3_CFGR_PRELOAD = 1U << 22 ;

  // Field WAVPOL: Waveform shape polarity
    const uint32_t LPTIM3_CFGR_WAVPOL = 1U << 21 ;

  // Field WAVE: Waveform shape
    const uint32_t LPTIM3_CFGR_WAVE = 1U << 20 ;

  // Field TIMOUT: Timeout enable
    const uint32_t LPTIM3_CFGR_TIMOUT = 1U << 19 ;

  // Field TRIGEN: Trigger enable and polarity
    inline uint32_t LPTIM3_CFGR_TRIGEN (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field TRIGSEL: Trigger selector
    inline uint32_t LPTIM3_CFGR_TRIGSEL (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field PRESC: Clock prescaler
    inline uint32_t LPTIM3_CFGR_PRESC (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field TRGFLT: Configurable digital filter for trigger
    inline uint32_t LPTIM3_CFGR_TRGFLT (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field CKFLT: Configurable digital filter for external clock
    inline uint32_t LPTIM3_CFGR_CKFLT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field CKPOL: Clock Polarity
    inline uint32_t LPTIM3_CFGR_CKPOL (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field CKSEL: Clock selector
    const uint32_t LPTIM3_CFGR_CKSEL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: Control Register
  #define LPTIM3_CR (* ((volatile uint32_t *) (0x58002800 + 16)))

  // Field ENABLE: LPTIM Enable
    const uint32_t LPTIM3_CR_ENABLE = 1U << 0 ;

  // Field SNGSTRT: LPTIM start in single mode
    const uint32_t LPTIM3_CR_SNGSTRT = 1U << 1 ;

  // Field CNTSTRT: Timer start in continuous mode
    const uint32_t LPTIM3_CR_CNTSTRT = 1U << 2 ;

  // Field COUNTRST: Counter reset
    const uint32_t LPTIM3_CR_COUNTRST = 1U << 3 ;

  // Field RSTARE: Reset after read enable
    const uint32_t LPTIM3_CR_RSTARE = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CMP: Compare Register
  #define LPTIM3_CMP (* ((volatile uint32_t *) (0x58002800 + 20)))

  // Field CMP: Compare value
    inline uint32_t LPTIM3_CMP_CMP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: Autoreload Register
  #define LPTIM3_ARR (* ((volatile uint32_t *) (0x58002800 + 24)))

  // Field ARR: Auto reload value
    inline uint32_t LPTIM3_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CNT: Counter Register
  #define LPTIM3_CNT (* ((const volatile uint32_t *) (0x58002800 + 28)))

  // Field CNT: Counter value
    inline uint32_t LPTIM3_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: LPTIM configuration register 2
  #define LPTIM3_CFGR2 (* ((volatile uint32_t *) (0x58002800 + 36)))

  // Field IN1SEL: LPTIM Input 1 selection
    inline uint32_t LPTIM3_CFGR2_IN1SEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral LPTIM4
//------------------------------------------------------------------------------

//---  Register ISR: Interrupt and Status Register
  #define LPTIM4_ISR (* ((const volatile uint32_t *) (0x58002C00 + 0)))

  // Field DOWN: Counter direction change up to down
    const uint32_t LPTIM4_ISR_DOWN = 1U << 6 ;

  // Field UP: Counter direction change down to up
    const uint32_t LPTIM4_ISR_UP = 1U << 5 ;

  // Field ARROK: Autoreload register update OK
    const uint32_t LPTIM4_ISR_ARROK = 1U << 4 ;

  // Field CMPOK: Compare register update OK
    const uint32_t LPTIM4_ISR_CMPOK = 1U << 3 ;

  // Field EXTTRIG: External trigger edge event
    const uint32_t LPTIM4_ISR_EXTTRIG = 1U << 2 ;

  // Field ARRM: Autoreload match
    const uint32_t LPTIM4_ISR_ARRM = 1U << 1 ;

  // Field CMPM: Compare match
    const uint32_t LPTIM4_ISR_CMPM = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define LPTIM4_ICR (* ((volatile uint32_t *) (0x58002C00 + 4)))

  // Field DOWNCF: Direction change to down Clear Flag
    const uint32_t LPTIM4_ICR_DOWNCF = 1U << 6 ;

  // Field UPCF: Direction change to UP Clear Flag
    const uint32_t LPTIM4_ICR_UPCF = 1U << 5 ;

  // Field ARROKCF: Autoreload register update OK Clear Flag
    const uint32_t LPTIM4_ICR_ARROKCF = 1U << 4 ;

  // Field CMPOKCF: Compare register update OK Clear Flag
    const uint32_t LPTIM4_ICR_CMPOKCF = 1U << 3 ;

  // Field EXTTRIGCF: External trigger valid edge Clear Flag
    const uint32_t LPTIM4_ICR_EXTTRIGCF = 1U << 2 ;

  // Field ARRMCF: Autoreload match Clear Flag
    const uint32_t LPTIM4_ICR_ARRMCF = 1U << 1 ;

  // Field CMPMCF: compare match Clear Flag
    const uint32_t LPTIM4_ICR_CMPMCF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define LPTIM4_IER (* ((volatile uint32_t *) (0x58002C00 + 8)))

  // Field DOWNIE: Direction change to down Interrupt Enable
    const uint32_t LPTIM4_IER_DOWNIE = 1U << 6 ;

  // Field UPIE: Direction change to UP Interrupt Enable
    const uint32_t LPTIM4_IER_UPIE = 1U << 5 ;

  // Field ARROKIE: Autoreload register update OK Interrupt Enable
    const uint32_t LPTIM4_IER_ARROKIE = 1U << 4 ;

  // Field CMPOKIE: Compare register update OK Interrupt Enable
    const uint32_t LPTIM4_IER_CMPOKIE = 1U << 3 ;

  // Field EXTTRIGIE: External trigger valid edge Interrupt Enable
    const uint32_t LPTIM4_IER_EXTTRIGIE = 1U << 2 ;

  // Field ARRMIE: Autoreload match Interrupt Enable
    const uint32_t LPTIM4_IER_ARRMIE = 1U << 1 ;

  // Field CMPMIE: Compare match Interrupt Enable
    const uint32_t LPTIM4_IER_CMPMIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: Configuration Register
  #define LPTIM4_CFGR (* ((volatile uint32_t *) (0x58002C00 + 12)))

  // Field ENC: Encoder mode enable
    const uint32_t LPTIM4_CFGR_ENC = 1U << 24 ;

  // Field COUNTMODE: counter mode enabled
    const uint32_t LPTIM4_CFGR_COUNTMODE = 1U << 23 ;

  // Field PRELOAD: Registers update mode
    const uint32_t LPTIM4_CFGR_PRELOAD = 1U << 22 ;

  // Field WAVPOL: Waveform shape polarity
    const uint32_t LPTIM4_CFGR_WAVPOL = 1U << 21 ;

  // Field WAVE: Waveform shape
    const uint32_t LPTIM4_CFGR_WAVE = 1U << 20 ;

  // Field TIMOUT: Timeout enable
    const uint32_t LPTIM4_CFGR_TIMOUT = 1U << 19 ;

  // Field TRIGEN: Trigger enable and polarity
    inline uint32_t LPTIM4_CFGR_TRIGEN (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field TRIGSEL: Trigger selector
    inline uint32_t LPTIM4_CFGR_TRIGSEL (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field PRESC: Clock prescaler
    inline uint32_t LPTIM4_CFGR_PRESC (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field TRGFLT: Configurable digital filter for trigger
    inline uint32_t LPTIM4_CFGR_TRGFLT (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field CKFLT: Configurable digital filter for external clock
    inline uint32_t LPTIM4_CFGR_CKFLT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field CKPOL: Clock Polarity
    inline uint32_t LPTIM4_CFGR_CKPOL (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field CKSEL: Clock selector
    const uint32_t LPTIM4_CFGR_CKSEL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: Control Register
  #define LPTIM4_CR (* ((volatile uint32_t *) (0x58002C00 + 16)))

  // Field ENABLE: LPTIM Enable
    const uint32_t LPTIM4_CR_ENABLE = 1U << 0 ;

  // Field SNGSTRT: LPTIM start in single mode
    const uint32_t LPTIM4_CR_SNGSTRT = 1U << 1 ;

  // Field CNTSTRT: Timer start in continuous mode
    const uint32_t LPTIM4_CR_CNTSTRT = 1U << 2 ;

  // Field COUNTRST: Counter reset
    const uint32_t LPTIM4_CR_COUNTRST = 1U << 3 ;

  // Field RSTARE: Reset after read enable
    const uint32_t LPTIM4_CR_RSTARE = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CMP: Compare Register
  #define LPTIM4_CMP (* ((volatile uint32_t *) (0x58002C00 + 20)))

  // Field CMP: Compare value
    inline uint32_t LPTIM4_CMP_CMP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: Autoreload Register
  #define LPTIM4_ARR (* ((volatile uint32_t *) (0x58002C00 + 24)))

  // Field ARR: Auto reload value
    inline uint32_t LPTIM4_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CNT: Counter Register
  #define LPTIM4_CNT (* ((const volatile uint32_t *) (0x58002C00 + 28)))

  // Field CNT: Counter value
    inline uint32_t LPTIM4_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: LPTIM configuration register 2
  #define LPTIM4_CFGR2 (* ((volatile uint32_t *) (0x58002C00 + 36)))

  // Field IN1SEL: LPTIM Input 1 selection
    inline uint32_t LPTIM4_CFGR2_IN1SEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral LPTIM5
//------------------------------------------------------------------------------

//---  Register ISR: Interrupt and Status Register
  #define LPTIM5_ISR (* ((const volatile uint32_t *) (0x58003000 + 0)))

  // Field DOWN: Counter direction change up to down
    const uint32_t LPTIM5_ISR_DOWN = 1U << 6 ;

  // Field UP: Counter direction change down to up
    const uint32_t LPTIM5_ISR_UP = 1U << 5 ;

  // Field ARROK: Autoreload register update OK
    const uint32_t LPTIM5_ISR_ARROK = 1U << 4 ;

  // Field CMPOK: Compare register update OK
    const uint32_t LPTIM5_ISR_CMPOK = 1U << 3 ;

  // Field EXTTRIG: External trigger edge event
    const uint32_t LPTIM5_ISR_EXTTRIG = 1U << 2 ;

  // Field ARRM: Autoreload match
    const uint32_t LPTIM5_ISR_ARRM = 1U << 1 ;

  // Field CMPM: Compare match
    const uint32_t LPTIM5_ISR_CMPM = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define LPTIM5_ICR (* ((volatile uint32_t *) (0x58003000 + 4)))

  // Field DOWNCF: Direction change to down Clear Flag
    const uint32_t LPTIM5_ICR_DOWNCF = 1U << 6 ;

  // Field UPCF: Direction change to UP Clear Flag
    const uint32_t LPTIM5_ICR_UPCF = 1U << 5 ;

  // Field ARROKCF: Autoreload register update OK Clear Flag
    const uint32_t LPTIM5_ICR_ARROKCF = 1U << 4 ;

  // Field CMPOKCF: Compare register update OK Clear Flag
    const uint32_t LPTIM5_ICR_CMPOKCF = 1U << 3 ;

  // Field EXTTRIGCF: External trigger valid edge Clear Flag
    const uint32_t LPTIM5_ICR_EXTTRIGCF = 1U << 2 ;

  // Field ARRMCF: Autoreload match Clear Flag
    const uint32_t LPTIM5_ICR_ARRMCF = 1U << 1 ;

  // Field CMPMCF: compare match Clear Flag
    const uint32_t LPTIM5_ICR_CMPMCF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define LPTIM5_IER (* ((volatile uint32_t *) (0x58003000 + 8)))

  // Field DOWNIE: Direction change to down Interrupt Enable
    const uint32_t LPTIM5_IER_DOWNIE = 1U << 6 ;

  // Field UPIE: Direction change to UP Interrupt Enable
    const uint32_t LPTIM5_IER_UPIE = 1U << 5 ;

  // Field ARROKIE: Autoreload register update OK Interrupt Enable
    const uint32_t LPTIM5_IER_ARROKIE = 1U << 4 ;

  // Field CMPOKIE: Compare register update OK Interrupt Enable
    const uint32_t LPTIM5_IER_CMPOKIE = 1U << 3 ;

  // Field EXTTRIGIE: External trigger valid edge Interrupt Enable
    const uint32_t LPTIM5_IER_EXTTRIGIE = 1U << 2 ;

  // Field ARRMIE: Autoreload match Interrupt Enable
    const uint32_t LPTIM5_IER_ARRMIE = 1U << 1 ;

  // Field CMPMIE: Compare match Interrupt Enable
    const uint32_t LPTIM5_IER_CMPMIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CFGR: Configuration Register
  #define LPTIM5_CFGR (* ((volatile uint32_t *) (0x58003000 + 12)))

  // Field ENC: Encoder mode enable
    const uint32_t LPTIM5_CFGR_ENC = 1U << 24 ;

  // Field COUNTMODE: counter mode enabled
    const uint32_t LPTIM5_CFGR_COUNTMODE = 1U << 23 ;

  // Field PRELOAD: Registers update mode
    const uint32_t LPTIM5_CFGR_PRELOAD = 1U << 22 ;

  // Field WAVPOL: Waveform shape polarity
    const uint32_t LPTIM5_CFGR_WAVPOL = 1U << 21 ;

  // Field WAVE: Waveform shape
    const uint32_t LPTIM5_CFGR_WAVE = 1U << 20 ;

  // Field TIMOUT: Timeout enable
    const uint32_t LPTIM5_CFGR_TIMOUT = 1U << 19 ;

  // Field TRIGEN: Trigger enable and polarity
    inline uint32_t LPTIM5_CFGR_TRIGEN (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field TRIGSEL: Trigger selector
    inline uint32_t LPTIM5_CFGR_TRIGSEL (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field PRESC: Clock prescaler
    inline uint32_t LPTIM5_CFGR_PRESC (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field TRGFLT: Configurable digital filter for trigger
    inline uint32_t LPTIM5_CFGR_TRGFLT (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field CKFLT: Configurable digital filter for external clock
    inline uint32_t LPTIM5_CFGR_CKFLT (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field CKPOL: Clock Polarity
    inline uint32_t LPTIM5_CFGR_CKPOL (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field CKSEL: Clock selector
    const uint32_t LPTIM5_CFGR_CKSEL = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR: Control Register
  #define LPTIM5_CR (* ((volatile uint32_t *) (0x58003000 + 16)))

  // Field ENABLE: LPTIM Enable
    const uint32_t LPTIM5_CR_ENABLE = 1U << 0 ;

  // Field SNGSTRT: LPTIM start in single mode
    const uint32_t LPTIM5_CR_SNGSTRT = 1U << 1 ;

  // Field CNTSTRT: Timer start in continuous mode
    const uint32_t LPTIM5_CR_CNTSTRT = 1U << 2 ;

  // Field COUNTRST: Counter reset
    const uint32_t LPTIM5_CR_COUNTRST = 1U << 3 ;

  // Field RSTARE: Reset after read enable
    const uint32_t LPTIM5_CR_RSTARE = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CMP: Compare Register
  #define LPTIM5_CMP (* ((volatile uint32_t *) (0x58003000 + 20)))

  // Field CMP: Compare value
    inline uint32_t LPTIM5_CMP_CMP (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: Autoreload Register
  #define LPTIM5_ARR (* ((volatile uint32_t *) (0x58003000 + 24)))

  // Field ARR: Auto reload value
    inline uint32_t LPTIM5_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CNT: Counter Register
  #define LPTIM5_CNT (* ((const volatile uint32_t *) (0x58003000 + 28)))

  // Field CNT: Counter value
    inline uint32_t LPTIM5_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR2: LPTIM configuration register 2
  #define LPTIM5_CFGR2 (* ((volatile uint32_t *) (0x58003000 + 36)))

  // Field IN1SEL: LPTIM Input 1 selection
    inline uint32_t LPTIM5_CFGR2_IN1SEL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral LPUART1: LPUART1
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define LPUART1_CR1 (* ((volatile uint32_t *) (0x58000C00 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t LPUART1_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t LPUART1_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t LPUART1_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t LPUART1_CR1_M1 = 1U << 28 ;

  // Field DEAT: Driver Enable assertion time
    inline uint32_t LPUART1_CR1_DEAT (const uint32_t inValue) {return (inValue & 0x1FU) << 21 ; }

  // Field DEDT: Driver Enable deassertion time
    inline uint32_t LPUART1_CR1_DEDT (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field CMIE: Character match interrupt enable
    const uint32_t LPUART1_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t LPUART1_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t LPUART1_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t LPUART1_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t LPUART1_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t LPUART1_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t LPUART1_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t LPUART1_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t LPUART1_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t LPUART1_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t LPUART1_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t LPUART1_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t LPUART1_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t LPUART1_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t LPUART1_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define LPUART1_CR2 (* ((volatile uint32_t *) (0x58000C00 + 4)))

  // Field ADD: Address of the USART node
    inline uint32_t LPUART1_CR2_ADD (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field MSBFIRST: Most significant bit first
    const uint32_t LPUART1_CR2_MSBFIRST = 1U << 19 ;

  // Field DATAINV: Binary data inversion
    const uint32_t LPUART1_CR2_DATAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t LPUART1_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t LPUART1_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t LPUART1_CR2_SWAP = 1U << 15 ;

  // Field STOP: STOP bits
    inline uint32_t LPUART1_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t LPUART1_CR2_ADDM7 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define LPUART1_CR3 (* ((volatile uint32_t *) (0x58000C00 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t LPUART1_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t LPUART1_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t LPUART1_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t LPUART1_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t LPUART1_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t LPUART1_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t LPUART1_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t LPUART1_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t LPUART1_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t LPUART1_CR3_OVRDIS = 1U << 12 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t LPUART1_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t LPUART1_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t LPUART1_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t LPUART1_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t LPUART1_CR3_DMAR = 1U << 6 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t LPUART1_CR3_HDSEL = 1U << 3 ;

  // Field EIE: Error interrupt enable
    const uint32_t LPUART1_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define LPUART1_BRR (* ((volatile uint32_t *) (0x58000C00 + 12)))

  // Field BRR: BRR
    inline uint32_t LPUART1_BRR_BRR (const uint32_t inValue) {return (inValue & 0xFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define LPUART1_GTPR (* ((volatile uint32_t *) (0x58000C00 + 16)))

  // Field GT: Guard time value
    inline uint32_t LPUART1_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t LPUART1_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define LPUART1_RTOR (* ((volatile uint32_t *) (0x58000C00 + 20)))

  // Field BLEN: Block Length
    inline uint32_t LPUART1_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t LPUART1_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define LPUART1_RQR (* ((volatile uint32_t *) (0x58000C00 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t LPUART1_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t LPUART1_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t LPUART1_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t LPUART1_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t LPUART1_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define LPUART1_ISR (* ((const volatile uint32_t *) (0x58000C00 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t LPUART1_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t LPUART1_ISR_RXFT = 1U << 26 ;

  // Field RXFF: RXFIFO Full
    const uint32_t LPUART1_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t LPUART1_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t LPUART1_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t LPUART1_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t LPUART1_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t LPUART1_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t LPUART1_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t LPUART1_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t LPUART1_ISR_BUSY = 1U << 16 ;

  // Field CTS: CTS
    const uint32_t LPUART1_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t LPUART1_ISR_CTSIF = 1U << 9 ;

  // Field TXE: TXE
    const uint32_t LPUART1_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t LPUART1_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t LPUART1_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t LPUART1_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t LPUART1_ISR_ORE = 1U << 3 ;

  // Field NE: NE
    const uint32_t LPUART1_ISR_NE = 1U << 2 ;

  // Field FE: FE
    const uint32_t LPUART1_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t LPUART1_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define LPUART1_ICR (* ((volatile uint32_t *) (0x58000C00 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t LPUART1_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t LPUART1_ICR_CMCF = 1U << 17 ;

  // Field CTSCF: CTS clear flag
    const uint32_t LPUART1_ICR_CTSCF = 1U << 9 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t LPUART1_ICR_TCCF = 1U << 6 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t LPUART1_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t LPUART1_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t LPUART1_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t LPUART1_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t LPUART1_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define LPUART1_RDR (* ((const volatile uint32_t *) (0x58000C00 + 36)))

  // Field RDR: Receive data value
    inline uint32_t LPUART1_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define LPUART1_TDR (* ((volatile uint32_t *) (0x58000C00 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t LPUART1_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: Prescaler register
  #define LPUART1_PRESC (* ((volatile uint32_t *) (0x58000C00 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t LPUART1_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral LTDC: LCD-TFT Controller
//------------------------------------------------------------------------------

//---  Register SSCR: Synchronization Size Configuration Register
  #define LTDC_SSCR (* ((volatile uint32_t *) (0x50001000 + 8)))

  // Field HSW: Horizontal Synchronization Width (in units of pixel clock period)
    inline uint32_t LTDC_SSCR_HSW (const uint32_t inValue) {return (inValue & 0x3FFU) << 16 ; }

  // Field VSH: Vertical Synchronization Height (in units of horizontal scan line)
    inline uint32_t LTDC_SSCR_VSH (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BPCR: Back Porch Configuration Register
  #define LTDC_BPCR (* ((volatile uint32_t *) (0x50001000 + 12)))

  // Field AHBP: Accumulated Horizontal back porch (in units of pixel clock period)
    inline uint32_t LTDC_BPCR_AHBP (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field AVBP: Accumulated Vertical back porch (in units of horizontal scan line)
    inline uint32_t LTDC_BPCR_AVBP (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AWCR: Active Width Configuration Register
  #define LTDC_AWCR (* ((volatile uint32_t *) (0x50001000 + 16)))

  // Field AAV: AAV
    inline uint32_t LTDC_AWCR_AAV (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field AAH: Accumulated Active Height (in units of horizontal scan line)
    inline uint32_t LTDC_AWCR_AAH (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TWCR: Total Width Configuration Register
  #define LTDC_TWCR (* ((volatile uint32_t *) (0x50001000 + 20)))

  // Field TOTALW: Total Width (in units of pixel clock period)
    inline uint32_t LTDC_TWCR_TOTALW (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field TOTALH: Total Height (in units of horizontal scan line)
    inline uint32_t LTDC_TWCR_TOTALH (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GCR: Global Control Register
  #define LTDC_GCR (* ((volatile uint32_t *) (0x50001000 + 24)))

  // Field HSPOL: Horizontal Synchronization Polarity
    const uint32_t LTDC_GCR_HSPOL = 1U << 31 ;

  // Field VSPOL: Vertical Synchronization Polarity
    const uint32_t LTDC_GCR_VSPOL = 1U << 30 ;

  // Field DEPOL: Data Enable Polarity
    const uint32_t LTDC_GCR_DEPOL = 1U << 29 ;

  // Field PCPOL: Pixel Clock Polarity
    const uint32_t LTDC_GCR_PCPOL = 1U << 28 ;

  // Field DEN: Dither Enable
    const uint32_t LTDC_GCR_DEN = 1U << 16 ;

  // Field DRW: Dither Red Width
    inline uint32_t LTDC_GCR_DRW (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DGW: Dither Green Width
    inline uint32_t LTDC_GCR_DGW (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DBW: Dither Blue Width
    inline uint32_t LTDC_GCR_DBW (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field LTDCEN: LCD-TFT controller enable bit
    const uint32_t LTDC_GCR_LTDCEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SRCR: Shadow Reload Configuration Register
  #define LTDC_SRCR (* ((volatile uint32_t *) (0x50001000 + 36)))

  // Field VBR: Vertical Blanking Reload
    const uint32_t LTDC_SRCR_VBR = 1U << 1 ;

  // Field IMR: Immediate Reload
    const uint32_t LTDC_SRCR_IMR = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BCCR: Background Color Configuration Register
  #define LTDC_BCCR (* ((volatile uint32_t *) (0x50001000 + 44)))

  // Field BCBLUE: Background Color Blue value
    inline uint32_t LTDC_BCCR_BCBLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BCGREEN: Background Color Green value
    inline uint32_t LTDC_BCCR_BCGREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BCRED: Background Color Red value
    inline uint32_t LTDC_BCCR_BCRED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define LTDC_IER (* ((volatile uint32_t *) (0x50001000 + 52)))

  // Field RRIE: Register Reload interrupt enable
    const uint32_t LTDC_IER_RRIE = 1U << 3 ;

  // Field TERRIE: Transfer Error Interrupt Enable
    const uint32_t LTDC_IER_TERRIE = 1U << 2 ;

  // Field FUIE: FIFO Underrun Interrupt Enable
    const uint32_t LTDC_IER_FUIE = 1U << 1 ;

  // Field LIE: Line Interrupt Enable
    const uint32_t LTDC_IER_LIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt Status Register
  #define LTDC_ISR (* ((const volatile uint32_t *) (0x50001000 + 56)))

  // Field RRIF: Register Reload Interrupt Flag
    const uint32_t LTDC_ISR_RRIF = 1U << 3 ;

  // Field TERRIF: Transfer Error interrupt flag
    const uint32_t LTDC_ISR_TERRIF = 1U << 2 ;

  // Field FUIF: FIFO Underrun Interrupt flag
    const uint32_t LTDC_ISR_FUIF = 1U << 1 ;

  // Field LIF: Line Interrupt flag
    const uint32_t LTDC_ISR_LIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt Clear Register
  #define LTDC_ICR (* ((volatile uint32_t *) (0x50001000 + 60)))

  // Field CRRIF: Clears Register Reload Interrupt Flag
    const uint32_t LTDC_ICR_CRRIF = 1U << 3 ;

  // Field CTERRIF: Clears the Transfer Error Interrupt Flag
    const uint32_t LTDC_ICR_CTERRIF = 1U << 2 ;

  // Field CFUIF: Clears the FIFO Underrun Interrupt flag
    const uint32_t LTDC_ICR_CFUIF = 1U << 1 ;

  // Field CLIF: Clears the Line Interrupt Flag
    const uint32_t LTDC_ICR_CLIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register LIPCR: Line Interrupt Position Configuration Register
  #define LTDC_LIPCR (* ((volatile uint32_t *) (0x50001000 + 64)))

  // Field LIPOS: Line Interrupt Position
    inline uint32_t LTDC_LIPCR_LIPOS (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CPSR: Current Position Status Register
  #define LTDC_CPSR (* ((const volatile uint32_t *) (0x50001000 + 68)))

  // Field CXPOS: Current X Position
    inline uint32_t LTDC_CPSR_CXPOS (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CYPOS: Current Y Position
    inline uint32_t LTDC_CPSR_CYPOS (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CDSR: Current Display Status Register
  #define LTDC_CDSR (* ((const volatile uint32_t *) (0x50001000 + 72)))

  // Field HSYNCS: Horizontal Synchronization display Status
    const uint32_t LTDC_CDSR_HSYNCS = 1U << 3 ;

  // Field VSYNCS: Vertical Synchronization display Status
    const uint32_t LTDC_CDSR_VSYNCS = 1U << 2 ;

  // Field HDES: Horizontal Data Enable display Status
    const uint32_t LTDC_CDSR_HDES = 1U << 1 ;

  // Field VDES: Vertical Data Enable display Status
    const uint32_t LTDC_CDSR_VDES = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register L1CR: Layerx Control Register
  #define LTDC_L1CR (* ((volatile uint32_t *) (0x50001000 + 132)))

  // Field CLUTEN: Color Look-Up Table Enable
    const uint32_t LTDC_L1CR_CLUTEN = 1U << 4 ;

  // Field COLKEN: Color Keying Enable
    const uint32_t LTDC_L1CR_COLKEN = 1U << 1 ;

  // Field LEN: Layer Enable
    const uint32_t LTDC_L1CR_LEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register L1WHPCR: Layerx Window Horizontal Position Configuration Register
  #define LTDC_L1WHPCR (* ((volatile uint32_t *) (0x50001000 + 136)))

  // Field WHSPPOS: Window Horizontal Stop Position
    inline uint32_t LTDC_L1WHPCR_WHSPPOS (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field WHSTPOS: Window Horizontal Start Position
    inline uint32_t LTDC_L1WHPCR_WHSTPOS (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1WVPCR: Layerx Window Vertical Position Configuration Register
  #define LTDC_L1WVPCR (* ((volatile uint32_t *) (0x50001000 + 140)))

  // Field WVSPPOS: Window Vertical Stop Position
    inline uint32_t LTDC_L1WVPCR_WVSPPOS (const uint32_t inValue) {return (inValue & 0x7FFU) << 16 ; }

  // Field WVSTPOS: Window Vertical Start Position
    inline uint32_t LTDC_L1WVPCR_WVSTPOS (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1CKCR: Layerx Color Keying Configuration Register
  #define LTDC_L1CKCR (* ((volatile uint32_t *) (0x50001000 + 144)))

  // Field CKRED: Color Key Red value
    inline uint32_t LTDC_L1CKCR_CKRED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKGREEN: Color Key Green value
    inline uint32_t LTDC_L1CKCR_CKGREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field CKBLUE: Color Key Blue value
    inline uint32_t LTDC_L1CKCR_CKBLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1PFCR: Layerx Pixel Format Configuration Register
  #define LTDC_L1PFCR (* ((volatile uint32_t *) (0x50001000 + 148)))

  // Field PF: Pixel Format
    inline uint32_t LTDC_L1PFCR_PF (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1CACR: Layerx Constant Alpha Configuration Register
  #define LTDC_L1CACR (* ((volatile uint32_t *) (0x50001000 + 152)))

  // Field CONSTA: Constant Alpha
    inline uint32_t LTDC_L1CACR_CONSTA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1DCCR: Layerx Default Color Configuration Register
  #define LTDC_L1DCCR (* ((volatile uint32_t *) (0x50001000 + 156)))

  // Field DCALPHA: Default Color Alpha
    inline uint32_t LTDC_L1DCCR_DCALPHA (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field DCRED: Default Color Red
    inline uint32_t LTDC_L1DCCR_DCRED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DCGREEN: Default Color Green
    inline uint32_t LTDC_L1DCCR_DCGREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field DCBLUE: Default Color Blue
    inline uint32_t LTDC_L1DCCR_DCBLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1BFCR: Layerx Blending Factors Configuration Register
  #define LTDC_L1BFCR (* ((volatile uint32_t *) (0x50001000 + 160)))

  // Field BF1: Blending Factor 1
    inline uint32_t LTDC_L1BFCR_BF1 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field BF2: Blending Factor 2
    inline uint32_t LTDC_L1BFCR_BF2 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1CFBAR: Layerx Color Frame Buffer Address Register
  #define LTDC_L1CFBAR (* ((volatile uint32_t *) (0x50001000 + 172)))

  // Field CFBADD: Color Frame Buffer Start Address
    inline uint32_t LTDC_L1CFBAR_CFBADD (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1CFBLR: Layerx Color Frame Buffer Length Register
  #define LTDC_L1CFBLR (* ((volatile uint32_t *) (0x50001000 + 176)))

  // Field CFBP: Color Frame Buffer Pitch in bytes
    inline uint32_t LTDC_L1CFBLR_CFBP (const uint32_t inValue) {return (inValue & 0x1FFFU) << 16 ; }

  // Field CFBLL: Color Frame Buffer Line Length
    inline uint32_t LTDC_L1CFBLR_CFBLL (const uint32_t inValue) {return (inValue & 0x1FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1CFBLNR: Layerx ColorFrame Buffer Line Number Register
  #define LTDC_L1CFBLNR (* ((volatile uint32_t *) (0x50001000 + 180)))

  // Field CFBLNBR: Frame Buffer Line Number
    inline uint32_t LTDC_L1CFBLNR_CFBLNBR (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L1CLUTWR: Layerx CLUT Write Register
  #define LTDC_L1CLUTWR (* ((volatile uint32_t *) (0x50001000 + 196)))

  // Field CLUTADD: CLUT Address
    inline uint32_t LTDC_L1CLUTWR_CLUTADD (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RED: Red value
    inline uint32_t LTDC_L1CLUTWR_RED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field GREEN: Green value
    inline uint32_t LTDC_L1CLUTWR_GREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BLUE: Blue value
    inline uint32_t LTDC_L1CLUTWR_BLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CR: Layerx Control Register
  #define LTDC_L2CR (* ((volatile uint32_t *) (0x50001000 + 260)))

  // Field CLUTEN: Color Look-Up Table Enable
    const uint32_t LTDC_L2CR_CLUTEN = 1U << 4 ;

  // Field COLKEN: Color Keying Enable
    const uint32_t LTDC_L2CR_COLKEN = 1U << 1 ;

  // Field LEN: Layer Enable
    const uint32_t LTDC_L2CR_LEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register L2WHPCR: Layerx Window Horizontal Position Configuration Register
  #define LTDC_L2WHPCR (* ((volatile uint32_t *) (0x50001000 + 264)))

  // Field WHSPPOS: Window Horizontal Stop Position
    inline uint32_t LTDC_L2WHPCR_WHSPPOS (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

  // Field WHSTPOS: Window Horizontal Start Position
    inline uint32_t LTDC_L2WHPCR_WHSTPOS (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2WVPCR: Layerx Window Vertical Position Configuration Register
  #define LTDC_L2WVPCR (* ((volatile uint32_t *) (0x50001000 + 268)))

  // Field WVSPPOS: Window Vertical Stop Position
    inline uint32_t LTDC_L2WVPCR_WVSPPOS (const uint32_t inValue) {return (inValue & 0x7FFU) << 16 ; }

  // Field WVSTPOS: Window Vertical Start Position
    inline uint32_t LTDC_L2WVPCR_WVSTPOS (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CKCR: Layerx Color Keying Configuration Register
  #define LTDC_L2CKCR (* ((volatile uint32_t *) (0x50001000 + 272)))

  // Field CKRED: Color Key Red value
    inline uint32_t LTDC_L2CKCR_CKRED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field CKGREEN: Color Key Green value
    inline uint32_t LTDC_L2CKCR_CKGREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field CKBLUE: Color Key Blue value
    inline uint32_t LTDC_L2CKCR_CKBLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2PFCR: Layerx Pixel Format Configuration Register
  #define LTDC_L2PFCR (* ((volatile uint32_t *) (0x50001000 + 276)))

  // Field PF: Pixel Format
    inline uint32_t LTDC_L2PFCR_PF (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CACR: Layerx Constant Alpha Configuration Register
  #define LTDC_L2CACR (* ((volatile uint32_t *) (0x50001000 + 280)))

  // Field CONSTA: Constant Alpha
    inline uint32_t LTDC_L2CACR_CONSTA (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2DCCR: Layerx Default Color Configuration Register
  #define LTDC_L2DCCR (* ((volatile uint32_t *) (0x50001000 + 284)))

  // Field DCALPHA: Default Color Alpha
    inline uint32_t LTDC_L2DCCR_DCALPHA (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field DCRED: Default Color Red
    inline uint32_t LTDC_L2DCCR_DCRED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DCGREEN: Default Color Green
    inline uint32_t LTDC_L2DCCR_DCGREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field DCBLUE: Default Color Blue
    inline uint32_t LTDC_L2DCCR_DCBLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2BFCR: Layerx Blending Factors Configuration Register
  #define LTDC_L2BFCR (* ((volatile uint32_t *) (0x50001000 + 288)))

  // Field BF1: Blending Factor 1
    inline uint32_t LTDC_L2BFCR_BF1 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field BF2: Blending Factor 2
    inline uint32_t LTDC_L2BFCR_BF2 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CFBAR: Layerx Color Frame Buffer Address Register
  #define LTDC_L2CFBAR (* ((volatile uint32_t *) (0x50001000 + 300)))

  // Field CFBADD: Color Frame Buffer Start Address
    inline uint32_t LTDC_L2CFBAR_CFBADD (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CFBLR: Layerx Color Frame Buffer Length Register
  #define LTDC_L2CFBLR (* ((volatile uint32_t *) (0x50001000 + 304)))

  // Field CFBP: Color Frame Buffer Pitch in bytes
    inline uint32_t LTDC_L2CFBLR_CFBP (const uint32_t inValue) {return (inValue & 0x1FFFU) << 16 ; }

  // Field CFBLL: Color Frame Buffer Line Length
    inline uint32_t LTDC_L2CFBLR_CFBLL (const uint32_t inValue) {return (inValue & 0x1FFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CFBLNR: Layerx ColorFrame Buffer Line Number Register
  #define LTDC_L2CFBLNR (* ((volatile uint32_t *) (0x50001000 + 308)))

  // Field CFBLNBR: Frame Buffer Line Number
    inline uint32_t LTDC_L2CFBLNR_CFBLNBR (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register L2CLUTWR: Layerx CLUT Write Register
  #define LTDC_L2CLUTWR (* ((volatile uint32_t *) (0x50001000 + 324)))

  // Field CLUTADD: CLUT Address
    inline uint32_t LTDC_L2CLUTWR_CLUTADD (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RED: Red value
    inline uint32_t LTDC_L2CLUTWR_RED (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field GREEN: Green value
    inline uint32_t LTDC_L2CLUTWR_GREEN (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field BLUE: Blue value
    inline uint32_t LTDC_L2CLUTWR_BLUE (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral MDIOS: Management data input/output slave
//------------------------------------------------------------------------------

//---  Register CR: MDIOS configuration register
  #define MDIOS_CR (* ((volatile uint32_t *) (0x40009400 + 0)))

  // Field EN: Peripheral enable
    const uint32_t MDIOS_CR_EN = 1U << 0 ;

  // Field WRIE: Register write interrupt enable
    const uint32_t MDIOS_CR_WRIE = 1U << 1 ;

  // Field RDIE: Register Read Interrupt Enable
    const uint32_t MDIOS_CR_RDIE = 1U << 2 ;

  // Field EIE: Error interrupt enable
    const uint32_t MDIOS_CR_EIE = 1U << 3 ;

  // Field DPC: Disable Preamble Check
    const uint32_t MDIOS_CR_DPC = 1U << 7 ;

  // Field PORT_ADDRESS: Slaves's address
    inline uint32_t MDIOS_CR_PORT_ADDRESS (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register WRFR: MDIOS write flag register
  #define MDIOS_WRFR (* ((const volatile uint32_t *) (0x40009400 + 4)))

  // Field WRF: Write flags for MDIO registers 0 to 31
    inline uint32_t MDIOS_WRFR_WRF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CWRFR: MDIOS clear write flag register
  #define MDIOS_CWRFR (* ((volatile uint32_t *) (0x40009400 + 8)))

  // Field CWRF: Clear the write flag
    inline uint32_t MDIOS_CWRFR_CWRF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RDFR: MDIOS read flag register
  #define MDIOS_RDFR (* ((const volatile uint32_t *) (0x40009400 + 12)))

  // Field RDF: Read flags for MDIO registers 0 to 31
    inline uint32_t MDIOS_RDFR_RDF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRDFR: MDIOS clear read flag register
  #define MDIOS_CRDFR (* ((volatile uint32_t *) (0x40009400 + 16)))

  // Field CRDF: Clear the read flag
    inline uint32_t MDIOS_CRDFR_CRDF (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SR: MDIOS status register
  #define MDIOS_SR (* ((const volatile uint32_t *) (0x40009400 + 20)))

  // Field PERF: Preamble error flag
    const uint32_t MDIOS_SR_PERF = 1U << 0 ;

  // Field SERF: Start error flag
    const uint32_t MDIOS_SR_SERF = 1U << 1 ;

  // Field TERF: Turnaround error flag
    const uint32_t MDIOS_SR_TERF = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register CLRFR: MDIOS clear flag register
  #define MDIOS_CLRFR (* ((volatile uint32_t *) (0x40009400 + 24)))

  // Field CPERF: Clear the preamble error flag
    const uint32_t MDIOS_CLRFR_CPERF = 1U << 0 ;

  // Field CSERF: Clear the start error flag
    const uint32_t MDIOS_CLRFR_CSERF = 1U << 1 ;

  // Field CTERF: Clear the turnaround error flag
    const uint32_t MDIOS_CLRFR_CTERF = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register DINR0: MDIOS input data register 0
  #define MDIOS_DINR0 (* ((const volatile uint32_t *) (0x40009400 + 28)))

  // Field DIN0: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR0_DIN0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR1: MDIOS input data register 1
  #define MDIOS_DINR1 (* ((const volatile uint32_t *) (0x40009400 + 32)))

  // Field DIN1: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR1_DIN1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR2: MDIOS input data register 2
  #define MDIOS_DINR2 (* ((const volatile uint32_t *) (0x40009400 + 36)))

  // Field DIN2: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR2_DIN2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR3: MDIOS input data register 3
  #define MDIOS_DINR3 (* ((const volatile uint32_t *) (0x40009400 + 40)))

  // Field DIN3: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR3_DIN3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR4: MDIOS input data register 4
  #define MDIOS_DINR4 (* ((const volatile uint32_t *) (0x40009400 + 44)))

  // Field DIN4: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR4_DIN4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR5: MDIOS input data register 5
  #define MDIOS_DINR5 (* ((const volatile uint32_t *) (0x40009400 + 48)))

  // Field DIN5: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR5_DIN5 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR6: MDIOS input data register 6
  #define MDIOS_DINR6 (* ((const volatile uint32_t *) (0x40009400 + 52)))

  // Field DIN6: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR6_DIN6 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR7: MDIOS input data register 7
  #define MDIOS_DINR7 (* ((const volatile uint32_t *) (0x40009400 + 56)))

  // Field DIN7: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR7_DIN7 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR8: MDIOS input data register 8
  #define MDIOS_DINR8 (* ((const volatile uint32_t *) (0x40009400 + 60)))

  // Field DIN8: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR8_DIN8 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR9: MDIOS input data register 9
  #define MDIOS_DINR9 (* ((const volatile uint32_t *) (0x40009400 + 64)))

  // Field DIN9: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR9_DIN9 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR10: MDIOS input data register 10
  #define MDIOS_DINR10 (* ((const volatile uint32_t *) (0x40009400 + 68)))

  // Field DIN10: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR10_DIN10 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR11: MDIOS input data register 11
  #define MDIOS_DINR11 (* ((const volatile uint32_t *) (0x40009400 + 72)))

  // Field DIN11: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR11_DIN11 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR12: MDIOS input data register 12
  #define MDIOS_DINR12 (* ((const volatile uint32_t *) (0x40009400 + 76)))

  // Field DIN12: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR12_DIN12 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR13: MDIOS input data register 13
  #define MDIOS_DINR13 (* ((const volatile uint32_t *) (0x40009400 + 80)))

  // Field DIN13: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR13_DIN13 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR14: MDIOS input data register 14
  #define MDIOS_DINR14 (* ((const volatile uint32_t *) (0x40009400 + 84)))

  // Field DIN14: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR14_DIN14 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR15: MDIOS input data register 15
  #define MDIOS_DINR15 (* ((const volatile uint32_t *) (0x40009400 + 88)))

  // Field DIN15: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR15_DIN15 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR16: MDIOS input data register 16
  #define MDIOS_DINR16 (* ((const volatile uint32_t *) (0x40009400 + 92)))

  // Field DIN16: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR16_DIN16 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR17: MDIOS input data register 17
  #define MDIOS_DINR17 (* ((const volatile uint32_t *) (0x40009400 + 96)))

  // Field DIN17: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR17_DIN17 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR18: MDIOS input data register 18
  #define MDIOS_DINR18 (* ((const volatile uint32_t *) (0x40009400 + 100)))

  // Field DIN18: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR18_DIN18 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR19: MDIOS input data register 19
  #define MDIOS_DINR19 (* ((const volatile uint32_t *) (0x40009400 + 104)))

  // Field DIN19: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR19_DIN19 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR20: MDIOS input data register 20
  #define MDIOS_DINR20 (* ((const volatile uint32_t *) (0x40009400 + 108)))

  // Field DIN20: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR20_DIN20 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR21: MDIOS input data register 21
  #define MDIOS_DINR21 (* ((const volatile uint32_t *) (0x40009400 + 112)))

  // Field DIN21: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR21_DIN21 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR22: MDIOS input data register 22
  #define MDIOS_DINR22 (* ((const volatile uint32_t *) (0x40009400 + 116)))

  // Field DIN22: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR22_DIN22 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR23: MDIOS input data register 23
  #define MDIOS_DINR23 (* ((const volatile uint32_t *) (0x40009400 + 120)))

  // Field DIN23: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR23_DIN23 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR24: MDIOS input data register 24
  #define MDIOS_DINR24 (* ((const volatile uint32_t *) (0x40009400 + 124)))

  // Field DIN24: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR24_DIN24 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR25: MDIOS input data register 25
  #define MDIOS_DINR25 (* ((const volatile uint32_t *) (0x40009400 + 128)))

  // Field DIN25: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR25_DIN25 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR26: MDIOS input data register 26
  #define MDIOS_DINR26 (* ((const volatile uint32_t *) (0x40009400 + 132)))

  // Field DIN26: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR26_DIN26 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR27: MDIOS input data register 27
  #define MDIOS_DINR27 (* ((const volatile uint32_t *) (0x40009400 + 136)))

  // Field DIN27: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR27_DIN27 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR28: MDIOS input data register 28
  #define MDIOS_DINR28 (* ((const volatile uint32_t *) (0x40009400 + 140)))

  // Field DIN28: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR28_DIN28 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR29: MDIOS input data register 29
  #define MDIOS_DINR29 (* ((const volatile uint32_t *) (0x40009400 + 144)))

  // Field DIN29: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR29_DIN29 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR30: MDIOS input data register 30
  #define MDIOS_DINR30 (* ((const volatile uint32_t *) (0x40009400 + 148)))

  // Field DIN30: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR30_DIN30 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DINR31: MDIOS input data register 31
  #define MDIOS_DINR31 (* ((const volatile uint32_t *) (0x40009400 + 152)))

  // Field DIN31: Input data received from MDIO Master during write frames
    inline uint32_t MDIOS_DINR31_DIN31 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR0: MDIOS output data register 0
  #define MDIOS_DOUTR0 (* ((volatile uint32_t *) (0x40009400 + 156)))

  // Field DOUT0: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR0_DOUT0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR1: MDIOS output data register 1
  #define MDIOS_DOUTR1 (* ((volatile uint32_t *) (0x40009400 + 160)))

  // Field DOUT1: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR1_DOUT1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR2: MDIOS output data register 2
  #define MDIOS_DOUTR2 (* ((volatile uint32_t *) (0x40009400 + 164)))

  // Field DOUT2: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR2_DOUT2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR3: MDIOS output data register 3
  #define MDIOS_DOUTR3 (* ((volatile uint32_t *) (0x40009400 + 168)))

  // Field DOUT3: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR3_DOUT3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR4: MDIOS output data register 4
  #define MDIOS_DOUTR4 (* ((volatile uint32_t *) (0x40009400 + 172)))

  // Field DOUT4: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR4_DOUT4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR5: MDIOS output data register 5
  #define MDIOS_DOUTR5 (* ((volatile uint32_t *) (0x40009400 + 176)))

  // Field DOUT5: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR5_DOUT5 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR6: MDIOS output data register 6
  #define MDIOS_DOUTR6 (* ((volatile uint32_t *) (0x40009400 + 180)))

  // Field DOUT6: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR6_DOUT6 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR7: MDIOS output data register 7
  #define MDIOS_DOUTR7 (* ((volatile uint32_t *) (0x40009400 + 184)))

  // Field DOUT7: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR7_DOUT7 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR8: MDIOS output data register 8
  #define MDIOS_DOUTR8 (* ((volatile uint32_t *) (0x40009400 + 188)))

  // Field DOUT8: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR8_DOUT8 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR9: MDIOS output data register 9
  #define MDIOS_DOUTR9 (* ((volatile uint32_t *) (0x40009400 + 192)))

  // Field DOUT9: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR9_DOUT9 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR10: MDIOS output data register 10
  #define MDIOS_DOUTR10 (* ((volatile uint32_t *) (0x40009400 + 196)))

  // Field DOUT10: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR10_DOUT10 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR11: MDIOS output data register 11
  #define MDIOS_DOUTR11 (* ((volatile uint32_t *) (0x40009400 + 200)))

  // Field DOUT11: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR11_DOUT11 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR12: MDIOS output data register 12
  #define MDIOS_DOUTR12 (* ((volatile uint32_t *) (0x40009400 + 204)))

  // Field DOUT12: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR12_DOUT12 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR13: MDIOS output data register 13
  #define MDIOS_DOUTR13 (* ((volatile uint32_t *) (0x40009400 + 208)))

  // Field DOUT13: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR13_DOUT13 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR14: MDIOS output data register 14
  #define MDIOS_DOUTR14 (* ((volatile uint32_t *) (0x40009400 + 212)))

  // Field DOUT14: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR14_DOUT14 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR15: MDIOS output data register 15
  #define MDIOS_DOUTR15 (* ((volatile uint32_t *) (0x40009400 + 216)))

  // Field DOUT15: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR15_DOUT15 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR16: MDIOS output data register 16
  #define MDIOS_DOUTR16 (* ((volatile uint32_t *) (0x40009400 + 220)))

  // Field DOUT16: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR16_DOUT16 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR17: MDIOS output data register 17
  #define MDIOS_DOUTR17 (* ((volatile uint32_t *) (0x40009400 + 224)))

  // Field DOUT17: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR17_DOUT17 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR18: MDIOS output data register 18
  #define MDIOS_DOUTR18 (* ((volatile uint32_t *) (0x40009400 + 228)))

  // Field DOUT18: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR18_DOUT18 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR19: MDIOS output data register 19
  #define MDIOS_DOUTR19 (* ((volatile uint32_t *) (0x40009400 + 232)))

  // Field DOUT19: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR19_DOUT19 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR20: MDIOS output data register 20
  #define MDIOS_DOUTR20 (* ((volatile uint32_t *) (0x40009400 + 236)))

  // Field DOUT20: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR20_DOUT20 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR21: MDIOS output data register 21
  #define MDIOS_DOUTR21 (* ((volatile uint32_t *) (0x40009400 + 240)))

  // Field DOUT21: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR21_DOUT21 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR22: MDIOS output data register 22
  #define MDIOS_DOUTR22 (* ((volatile uint32_t *) (0x40009400 + 244)))

  // Field DOUT22: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR22_DOUT22 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR23: MDIOS output data register 23
  #define MDIOS_DOUTR23 (* ((volatile uint32_t *) (0x40009400 + 248)))

  // Field DOUT23: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR23_DOUT23 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR24: MDIOS output data register 24
  #define MDIOS_DOUTR24 (* ((volatile uint32_t *) (0x40009400 + 252)))

  // Field DOUT24: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR24_DOUT24 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR25: MDIOS output data register 25
  #define MDIOS_DOUTR25 (* ((volatile uint32_t *) (0x40009400 + 256)))

  // Field DOUT25: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR25_DOUT25 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR26: MDIOS output data register 26
  #define MDIOS_DOUTR26 (* ((volatile uint32_t *) (0x40009400 + 260)))

  // Field DOUT26: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR26_DOUT26 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR27: MDIOS output data register 27
  #define MDIOS_DOUTR27 (* ((volatile uint32_t *) (0x40009400 + 264)))

  // Field DOUT27: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR27_DOUT27 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR28: MDIOS output data register 28
  #define MDIOS_DOUTR28 (* ((volatile uint32_t *) (0x40009400 + 268)))

  // Field DOUT28: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR28_DOUT28 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR29: MDIOS output data register 29
  #define MDIOS_DOUTR29 (* ((volatile uint32_t *) (0x40009400 + 272)))

  // Field DOUT29: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR29_DOUT29 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR30: MDIOS output data register 30
  #define MDIOS_DOUTR30 (* ((volatile uint32_t *) (0x40009400 + 276)))

  // Field DOUT30: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR30_DOUT30 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DOUTR31: MDIOS output data register 31
  #define MDIOS_DOUTR31 (* ((volatile uint32_t *) (0x40009400 + 280)))

  // Field DOUT31: Output data sent to MDIO Master during read frames
    inline uint32_t MDIOS_DOUTR31_DOUT31 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral MDMA: MDMA
//------------------------------------------------------------------------------

//---  Register MDMA_GISR0: MDMA Global Interrupt/Status Register
  #define MDMA_MDMA_GISR0 (* ((const volatile uint32_t *) (0x52000000 + 0)))

  // Field GIF0: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF0 = 1U << 0 ;

  // Field GIF1: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF1 = 1U << 1 ;

  // Field GIF2: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF2 = 1U << 2 ;

  // Field GIF3: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF3 = 1U << 3 ;

  // Field GIF4: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF4 = 1U << 4 ;

  // Field GIF5: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF5 = 1U << 5 ;

  // Field GIF6: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF6 = 1U << 6 ;

  // Field GIF7: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF7 = 1U << 7 ;

  // Field GIF8: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF8 = 1U << 8 ;

  // Field GIF9: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF9 = 1U << 9 ;

  // Field GIF10: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF10 = 1U << 10 ;

  // Field GIF11: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF11 = 1U << 11 ;

  // Field GIF12: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF12 = 1U << 12 ;

  // Field GIF13: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF13 = 1U << 13 ;

  // Field GIF14: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF14 = 1U << 14 ;

  // Field GIF15: Channel x global interrupt flag (x=...) This bit is set and reset by hardware. It is a logical OR of all the Channel x interrupt flags (CTCIFx, BTIFx, BRTIFx, TEIFx) which are enabled in the interrupt mask register (CTCIEx, BTIEx, BRTIEx, TEIEx)
    const uint32_t MDMA_MDMA_GISR0_GIF15 = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C0ISR (* ((const volatile uint32_t *) (0x52000000 + 64)))

  // Field TEIF0: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ISR_TEIF0 = 1U << 0 ;

  // Field CTCIF0: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C0ISR_CTCIF0 = 1U << 1 ;

  // Field BRTIF0: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ISR_BRTIF0 = 1U << 2 ;

  // Field BTIF0: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ISR_BTIF0 = 1U << 3 ;

  // Field TCIF0: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C0ISR_TCIF0 = 1U << 4 ;

  // Field CRQA0: channel x request active flag
    const uint32_t MDMA_MDMA_C0ISR_CRQA0 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C0IFCR (* ((volatile uint32_t *) (0x52000000 + 68)))

  // Field CTEIF0: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C0IFCR_CTEIF0 = 1U << 0 ;

  // Field CCTCIF0: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C0IFCR_CCTCIF0 = 1U << 1 ;

  // Field CBRTIF0: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C0IFCR_CBRTIF0 = 1U << 2 ;

  // Field CBTIF0: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C0IFCR_CBTIF0 = 1U << 3 ;

  // Field CLTCIF0: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C0IFCR_CLTCIF0 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C0ESR (* ((const volatile uint32_t *) (0x52000000 + 72)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C0ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C0ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C0ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C0CR (* ((volatile uint32_t *) (0x52000000 + 76)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C0CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C0CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C0CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C0CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C0CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C0CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C0CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C0CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C0CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C0CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C0CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C0TCR (* ((volatile uint32_t *) (0x52000000 + 80)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C0TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C0TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C0TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C0TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C0TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C0TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C0TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C0TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C0TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C0TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C0TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C0TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C0TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C0TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C0BNDTR (* ((volatile uint32_t *) (0x52000000 + 84)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C0BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C0BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C0BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C0BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C0SAR: MDMA channel x source address register
  #define MDMA_MDMA_C0SAR (* ((volatile uint32_t *) (0x52000000 + 88)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C0SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C0DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C0DAR (* ((volatile uint32_t *) (0x52000000 + 92)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C0DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C0BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C0BRUR (* ((volatile uint32_t *) (0x52000000 + 96)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C0BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C0BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C0LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C0LAR (* ((volatile uint32_t *) (0x52000000 + 100)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C0LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C0TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C0TBR (* ((volatile uint32_t *) (0x52000000 + 104)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C0TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C0TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C0TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C0MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C0MAR (* ((volatile uint32_t *) (0x52000000 + 112)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C0MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C0MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C0MDR (* ((volatile uint32_t *) (0x52000000 + 116)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C0MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C1ISR (* ((const volatile uint32_t *) (0x52000000 + 128)))

  // Field TEIF1: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ISR_TEIF1 = 1U << 0 ;

  // Field CTCIF1: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C1ISR_CTCIF1 = 1U << 1 ;

  // Field BRTIF1: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ISR_BRTIF1 = 1U << 2 ;

  // Field BTIF1: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ISR_BTIF1 = 1U << 3 ;

  // Field TCIF1: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C1ISR_TCIF1 = 1U << 4 ;

  // Field CRQA1: channel x request active flag
    const uint32_t MDMA_MDMA_C1ISR_CRQA1 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C1IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C1IFCR (* ((volatile uint32_t *) (0x52000000 + 132)))

  // Field CTEIF1: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C1IFCR_CTEIF1 = 1U << 0 ;

  // Field CCTCIF1: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C1IFCR_CCTCIF1 = 1U << 1 ;

  // Field CBRTIF1: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C1IFCR_CBRTIF1 = 1U << 2 ;

  // Field CBTIF1: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C1IFCR_CBTIF1 = 1U << 3 ;

  // Field CLTCIF1: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C1IFCR_CLTCIF1 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C1ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C1ESR (* ((const volatile uint32_t *) (0x52000000 + 136)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C1ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C1ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C1ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C1CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C1CR (* ((volatile uint32_t *) (0x52000000 + 140)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C1CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C1CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C1CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C1CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C1CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C1CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C1CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C1CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C1CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C1CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C1CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C1TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C1TCR (* ((volatile uint32_t *) (0x52000000 + 144)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C1TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C1TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C1TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C1TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C1TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C1TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C1TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C1TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C1TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C1TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C1TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C1TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C1TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C1TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C1BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C1BNDTR (* ((volatile uint32_t *) (0x52000000 + 148)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C1BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C1BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C1BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C1BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1SAR: MDMA channel x source address register
  #define MDMA_MDMA_C1SAR (* ((volatile uint32_t *) (0x52000000 + 152)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C1SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C1DAR (* ((volatile uint32_t *) (0x52000000 + 156)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C1DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C1BRUR (* ((volatile uint32_t *) (0x52000000 + 160)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C1BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C1BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C1LAR (* ((volatile uint32_t *) (0x52000000 + 164)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C1LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C1TBR (* ((volatile uint32_t *) (0x52000000 + 168)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C1TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C1TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C1TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C1MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C1MAR (* ((volatile uint32_t *) (0x52000000 + 176)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C1MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C1MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C1MDR (* ((volatile uint32_t *) (0x52000000 + 180)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C1MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C2ISR (* ((const volatile uint32_t *) (0x52000000 + 192)))

  // Field TEIF2: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ISR_TEIF2 = 1U << 0 ;

  // Field CTCIF2: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C2ISR_CTCIF2 = 1U << 1 ;

  // Field BRTIF2: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ISR_BRTIF2 = 1U << 2 ;

  // Field BTIF2: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ISR_BTIF2 = 1U << 3 ;

  // Field TCIF2: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C2ISR_TCIF2 = 1U << 4 ;

  // Field CRQA2: channel x request active flag
    const uint32_t MDMA_MDMA_C2ISR_CRQA2 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C2IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C2IFCR (* ((volatile uint32_t *) (0x52000000 + 196)))

  // Field CTEIF2: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C2IFCR_CTEIF2 = 1U << 0 ;

  // Field CCTCIF2: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C2IFCR_CCTCIF2 = 1U << 1 ;

  // Field CBRTIF2: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C2IFCR_CBRTIF2 = 1U << 2 ;

  // Field CBTIF2: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C2IFCR_CBTIF2 = 1U << 3 ;

  // Field CLTCIF2: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C2IFCR_CLTCIF2 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C2ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C2ESR (* ((const volatile uint32_t *) (0x52000000 + 200)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C2ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C2ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C2ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C2CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C2CR (* ((volatile uint32_t *) (0x52000000 + 204)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C2CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C2CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C2CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C2CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C2CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C2CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C2CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C2CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C2CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C2CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C2CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C2TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C2TCR (* ((volatile uint32_t *) (0x52000000 + 208)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C2TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C2TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C2TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C2TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C2TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C2TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C2TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C2TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C2TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C2TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C2TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C2TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C2TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C2TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C2BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C2BNDTR (* ((volatile uint32_t *) (0x52000000 + 212)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C2BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C2BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C2BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C2BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2SAR: MDMA channel x source address register
  #define MDMA_MDMA_C2SAR (* ((volatile uint32_t *) (0x52000000 + 216)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C2SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C2DAR (* ((volatile uint32_t *) (0x52000000 + 220)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C2DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C2BRUR (* ((volatile uint32_t *) (0x52000000 + 224)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C2BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C2BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C2LAR (* ((volatile uint32_t *) (0x52000000 + 228)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C2LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C2TBR (* ((volatile uint32_t *) (0x52000000 + 232)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C2TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C2TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C2TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C2MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C2MAR (* ((volatile uint32_t *) (0x52000000 + 240)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C2MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C2MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C2MDR (* ((volatile uint32_t *) (0x52000000 + 244)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C2MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C3ISR (* ((const volatile uint32_t *) (0x52000000 + 256)))

  // Field TEIF3: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ISR_TEIF3 = 1U << 0 ;

  // Field CTCIF3: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C3ISR_CTCIF3 = 1U << 1 ;

  // Field BRTIF3: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ISR_BRTIF3 = 1U << 2 ;

  // Field BTIF3: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ISR_BTIF3 = 1U << 3 ;

  // Field TCIF3: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C3ISR_TCIF3 = 1U << 4 ;

  // Field CRQA3: channel x request active flag
    const uint32_t MDMA_MDMA_C3ISR_CRQA3 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C3IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C3IFCR (* ((volatile uint32_t *) (0x52000000 + 260)))

  // Field CTEIF3: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C3IFCR_CTEIF3 = 1U << 0 ;

  // Field CCTCIF3: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C3IFCR_CCTCIF3 = 1U << 1 ;

  // Field CBRTIF3: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C3IFCR_CBRTIF3 = 1U << 2 ;

  // Field CBTIF3: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C3IFCR_CBTIF3 = 1U << 3 ;

  // Field CLTCIF3: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C3IFCR_CLTCIF3 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C3ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C3ESR (* ((const volatile uint32_t *) (0x52000000 + 264)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C3ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C3ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C3ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C3CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C3CR (* ((volatile uint32_t *) (0x52000000 + 268)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C3CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C3CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C3CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C3CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C3CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C3CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C3CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C3CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C3CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C3CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C3CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C3TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C3TCR (* ((volatile uint32_t *) (0x52000000 + 272)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C3TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C3TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C3TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C3TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C3TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C3TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C3TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C3TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C3TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C3TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C3TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C3TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C3TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C3TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C3BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C3BNDTR (* ((volatile uint32_t *) (0x52000000 + 276)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C3BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C3BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C3BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C3BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3SAR: MDMA channel x source address register
  #define MDMA_MDMA_C3SAR (* ((volatile uint32_t *) (0x52000000 + 280)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C3SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C3DAR (* ((volatile uint32_t *) (0x52000000 + 284)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C3DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C3BRUR (* ((volatile uint32_t *) (0x52000000 + 288)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C3BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C3BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C3LAR (* ((volatile uint32_t *) (0x52000000 + 292)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C3LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C3TBR (* ((volatile uint32_t *) (0x52000000 + 296)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C3TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C3TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C3TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C3MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C3MAR (* ((volatile uint32_t *) (0x52000000 + 304)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C3MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C3MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C3MDR (* ((volatile uint32_t *) (0x52000000 + 308)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C3MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C4ISR (* ((const volatile uint32_t *) (0x52000000 + 320)))

  // Field TEIF4: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ISR_TEIF4 = 1U << 0 ;

  // Field CTCIF4: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C4ISR_CTCIF4 = 1U << 1 ;

  // Field BRTIF4: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ISR_BRTIF4 = 1U << 2 ;

  // Field BTIF4: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ISR_BTIF4 = 1U << 3 ;

  // Field TCIF4: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C4ISR_TCIF4 = 1U << 4 ;

  // Field CRQA4: channel x request active flag
    const uint32_t MDMA_MDMA_C4ISR_CRQA4 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C4IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C4IFCR (* ((volatile uint32_t *) (0x52000000 + 324)))

  // Field CTEIF4: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C4IFCR_CTEIF4 = 1U << 0 ;

  // Field CCTCIF4: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C4IFCR_CCTCIF4 = 1U << 1 ;

  // Field CBRTIF4: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C4IFCR_CBRTIF4 = 1U << 2 ;

  // Field CBTIF4: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C4IFCR_CBTIF4 = 1U << 3 ;

  // Field CLTCIF4: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C4IFCR_CLTCIF4 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C4ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C4ESR (* ((const volatile uint32_t *) (0x52000000 + 328)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C4ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C4ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C4ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C4CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C4CR (* ((volatile uint32_t *) (0x52000000 + 332)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C4CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C4CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C4CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C4CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C4CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C4CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C4CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C4CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C4CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C4CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C4CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C4TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C4TCR (* ((volatile uint32_t *) (0x52000000 + 336)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C4TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C4TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C4TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C4TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C4TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C4TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C4TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C4TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C4TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C4TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C4TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C4TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C4TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C4TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C4BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C4BNDTR (* ((volatile uint32_t *) (0x52000000 + 340)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C4BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C4BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C4BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C4BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4SAR: MDMA channel x source address register
  #define MDMA_MDMA_C4SAR (* ((volatile uint32_t *) (0x52000000 + 344)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C4SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C4DAR (* ((volatile uint32_t *) (0x52000000 + 348)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C4DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C4BRUR (* ((volatile uint32_t *) (0x52000000 + 352)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C4BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C4BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C4LAR (* ((volatile uint32_t *) (0x52000000 + 356)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C4LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C4TBR (* ((volatile uint32_t *) (0x52000000 + 360)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C4TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C4TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C4TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C4MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C4MAR (* ((volatile uint32_t *) (0x52000000 + 368)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C4MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C4MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C4MDR (* ((volatile uint32_t *) (0x52000000 + 372)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C4MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C5ISR (* ((const volatile uint32_t *) (0x52000000 + 384)))

  // Field TEIF5: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ISR_TEIF5 = 1U << 0 ;

  // Field CTCIF5: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C5ISR_CTCIF5 = 1U << 1 ;

  // Field BRTIF5: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ISR_BRTIF5 = 1U << 2 ;

  // Field BTIF5: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ISR_BTIF5 = 1U << 3 ;

  // Field TCIF5: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C5ISR_TCIF5 = 1U << 4 ;

  // Field CRQA5: channel x request active flag
    const uint32_t MDMA_MDMA_C5ISR_CRQA5 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C5IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C5IFCR (* ((volatile uint32_t *) (0x52000000 + 388)))

  // Field CTEIF5: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C5IFCR_CTEIF5 = 1U << 0 ;

  // Field CCTCIF5: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C5IFCR_CCTCIF5 = 1U << 1 ;

  // Field CBRTIF5: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C5IFCR_CBRTIF5 = 1U << 2 ;

  // Field CBTIF5: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C5IFCR_CBTIF5 = 1U << 3 ;

  // Field CLTCIF5: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C5IFCR_CLTCIF5 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C5ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C5ESR (* ((const volatile uint32_t *) (0x52000000 + 392)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C5ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C5ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C5ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C5CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C5CR (* ((volatile uint32_t *) (0x52000000 + 396)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C5CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C5CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C5CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C5CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C5CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C5CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C5CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C5CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C5CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C5CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C5CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C5TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C5TCR (* ((volatile uint32_t *) (0x52000000 + 400)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C5TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C5TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C5TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C5TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C5TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C5TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C5TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C5TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C5TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C5TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C5TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C5TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C5TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C5TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C5BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C5BNDTR (* ((volatile uint32_t *) (0x52000000 + 404)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C5BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C5BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C5BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C5BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5SAR: MDMA channel x source address register
  #define MDMA_MDMA_C5SAR (* ((volatile uint32_t *) (0x52000000 + 408)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C5SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C5DAR (* ((volatile uint32_t *) (0x52000000 + 412)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C5DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C5BRUR (* ((volatile uint32_t *) (0x52000000 + 416)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C5BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C5BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C5LAR (* ((volatile uint32_t *) (0x52000000 + 420)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C5LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C5TBR (* ((volatile uint32_t *) (0x52000000 + 424)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C5TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C5TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C5TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C5MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C5MAR (* ((volatile uint32_t *) (0x52000000 + 432)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C5MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C5MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C5MDR (* ((volatile uint32_t *) (0x52000000 + 436)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C5MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C6ISR (* ((const volatile uint32_t *) (0x52000000 + 448)))

  // Field TEIF6: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ISR_TEIF6 = 1U << 0 ;

  // Field CTCIF6: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C6ISR_CTCIF6 = 1U << 1 ;

  // Field BRTIF6: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ISR_BRTIF6 = 1U << 2 ;

  // Field BTIF6: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ISR_BTIF6 = 1U << 3 ;

  // Field TCIF6: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C6ISR_TCIF6 = 1U << 4 ;

  // Field CRQA6: channel x request active flag
    const uint32_t MDMA_MDMA_C6ISR_CRQA6 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C6IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C6IFCR (* ((volatile uint32_t *) (0x52000000 + 452)))

  // Field CTEIF6: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C6IFCR_CTEIF6 = 1U << 0 ;

  // Field CCTCIF6: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C6IFCR_CCTCIF6 = 1U << 1 ;

  // Field CBRTIF6: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C6IFCR_CBRTIF6 = 1U << 2 ;

  // Field CBTIF6: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C6IFCR_CBTIF6 = 1U << 3 ;

  // Field CLTCIF6: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C6IFCR_CLTCIF6 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C6ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C6ESR (* ((const volatile uint32_t *) (0x52000000 + 456)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C6ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C6ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C6ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C6CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C6CR (* ((volatile uint32_t *) (0x52000000 + 460)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C6CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C6CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C6CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C6CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C6CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C6CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C6CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C6CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C6CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C6CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C6CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C6TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C6TCR (* ((volatile uint32_t *) (0x52000000 + 464)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C6TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C6TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C6TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C6TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C6TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C6TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C6TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C6TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C6TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C6TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C6TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C6TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C6TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C6TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C6BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C6BNDTR (* ((volatile uint32_t *) (0x52000000 + 468)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C6BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C6BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C6BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C6BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6SAR: MDMA channel x source address register
  #define MDMA_MDMA_C6SAR (* ((volatile uint32_t *) (0x52000000 + 472)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C6SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C6DAR (* ((volatile uint32_t *) (0x52000000 + 476)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C6DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C6BRUR (* ((volatile uint32_t *) (0x52000000 + 480)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C6BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C6BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C6LAR (* ((volatile uint32_t *) (0x52000000 + 484)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C6LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C6TBR (* ((volatile uint32_t *) (0x52000000 + 488)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C6TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C6TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C6TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C6MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C6MAR (* ((volatile uint32_t *) (0x52000000 + 496)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C6MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C6MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C6MDR (* ((volatile uint32_t *) (0x52000000 + 500)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C6MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C7ISR (* ((const volatile uint32_t *) (0x52000000 + 512)))

  // Field TEIF7: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ISR_TEIF7 = 1U << 0 ;

  // Field CTCIF7: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C7ISR_CTCIF7 = 1U << 1 ;

  // Field BRTIF7: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ISR_BRTIF7 = 1U << 2 ;

  // Field BTIF7: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ISR_BTIF7 = 1U << 3 ;

  // Field TCIF7: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C7ISR_TCIF7 = 1U << 4 ;

  // Field CRQA7: channel x request active flag
    const uint32_t MDMA_MDMA_C7ISR_CRQA7 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C7IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C7IFCR (* ((volatile uint32_t *) (0x52000000 + 516)))

  // Field CTEIF7: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C7IFCR_CTEIF7 = 1U << 0 ;

  // Field CCTCIF7: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C7IFCR_CCTCIF7 = 1U << 1 ;

  // Field CBRTIF7: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C7IFCR_CBRTIF7 = 1U << 2 ;

  // Field CBTIF7: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C7IFCR_CBTIF7 = 1U << 3 ;

  // Field CLTCIF7: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C7IFCR_CLTCIF7 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C7ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C7ESR (* ((const volatile uint32_t *) (0x52000000 + 520)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C7ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C7ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C7ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C7CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C7CR (* ((volatile uint32_t *) (0x52000000 + 524)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C7CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C7CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C7CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C7CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C7CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C7CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C7CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C7CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C7CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C7CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C7CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C7TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C7TCR (* ((volatile uint32_t *) (0x52000000 + 528)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C7TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C7TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C7TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C7TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C7TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C7TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C7TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C7TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C7TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C7TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C7TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C7TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C7TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C7TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C7BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C7BNDTR (* ((volatile uint32_t *) (0x52000000 + 532)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C7BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C7BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C7BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C7BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7SAR: MDMA channel x source address register
  #define MDMA_MDMA_C7SAR (* ((volatile uint32_t *) (0x52000000 + 536)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C7SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C7DAR (* ((volatile uint32_t *) (0x52000000 + 540)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C7DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C7BRUR (* ((volatile uint32_t *) (0x52000000 + 544)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C7BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C7BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C7LAR (* ((volatile uint32_t *) (0x52000000 + 548)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C7LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C7TBR (* ((volatile uint32_t *) (0x52000000 + 552)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C7TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C7TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C7TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C7MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C7MAR (* ((volatile uint32_t *) (0x52000000 + 560)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C7MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C7MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C7MDR (* ((volatile uint32_t *) (0x52000000 + 564)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C7MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C8ISR (* ((const volatile uint32_t *) (0x52000000 + 576)))

  // Field TEIF8: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ISR_TEIF8 = 1U << 0 ;

  // Field CTCIF8: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C8ISR_CTCIF8 = 1U << 1 ;

  // Field BRTIF8: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ISR_BRTIF8 = 1U << 2 ;

  // Field BTIF8: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ISR_BTIF8 = 1U << 3 ;

  // Field TCIF8: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C8ISR_TCIF8 = 1U << 4 ;

  // Field CRQA8: channel x request active flag
    const uint32_t MDMA_MDMA_C8ISR_CRQA8 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C8IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C8IFCR (* ((volatile uint32_t *) (0x52000000 + 580)))

  // Field CTEIF8: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C8IFCR_CTEIF8 = 1U << 0 ;

  // Field CCTCIF8: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C8IFCR_CCTCIF8 = 1U << 1 ;

  // Field CBRTIF8: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C8IFCR_CBRTIF8 = 1U << 2 ;

  // Field CBTIF8: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C8IFCR_CBTIF8 = 1U << 3 ;

  // Field CLTCIF8: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C8IFCR_CLTCIF8 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C8ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C8ESR (* ((const volatile uint32_t *) (0x52000000 + 584)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C8ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C8ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C8ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C8CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C8CR (* ((volatile uint32_t *) (0x52000000 + 588)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C8CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C8CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C8CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C8CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C8CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C8CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C8CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C8CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C8CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C8CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C8CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C8TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C8TCR (* ((volatile uint32_t *) (0x52000000 + 592)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C8TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C8TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C8TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C8TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C8TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C8TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C8TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C8TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C8TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C8TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C8TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C8TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C8TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C8TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C8BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C8BNDTR (* ((volatile uint32_t *) (0x52000000 + 596)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C8BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C8BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C8BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C8BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8SAR: MDMA channel x source address register
  #define MDMA_MDMA_C8SAR (* ((volatile uint32_t *) (0x52000000 + 600)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C8SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C8DAR (* ((volatile uint32_t *) (0x52000000 + 604)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C8DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C8BRUR (* ((volatile uint32_t *) (0x52000000 + 608)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C8BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C8BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C8LAR (* ((volatile uint32_t *) (0x52000000 + 612)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C8LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C8TBR (* ((volatile uint32_t *) (0x52000000 + 616)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C8TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C8TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C8TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C8MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C8MAR (* ((volatile uint32_t *) (0x52000000 + 624)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C8MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C8MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C8MDR (* ((volatile uint32_t *) (0x52000000 + 628)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C8MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C9ISR (* ((const volatile uint32_t *) (0x52000000 + 640)))

  // Field TEIF9: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ISR_TEIF9 = 1U << 0 ;

  // Field CTCIF9: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C9ISR_CTCIF9 = 1U << 1 ;

  // Field BRTIF9: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ISR_BRTIF9 = 1U << 2 ;

  // Field BTIF9: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ISR_BTIF9 = 1U << 3 ;

  // Field TCIF9: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C9ISR_TCIF9 = 1U << 4 ;

  // Field CRQA9: channel x request active flag
    const uint32_t MDMA_MDMA_C9ISR_CRQA9 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C9IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C9IFCR (* ((volatile uint32_t *) (0x52000000 + 644)))

  // Field CTEIF9: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C9IFCR_CTEIF9 = 1U << 0 ;

  // Field CCTCIF9: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C9IFCR_CCTCIF9 = 1U << 1 ;

  // Field CBRTIF9: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C9IFCR_CBRTIF9 = 1U << 2 ;

  // Field CBTIF9: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C9IFCR_CBTIF9 = 1U << 3 ;

  // Field CLTCIF9: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C9IFCR_CLTCIF9 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C9ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C9ESR (* ((const volatile uint32_t *) (0x52000000 + 648)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C9ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C9ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C9ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C9CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C9CR (* ((volatile uint32_t *) (0x52000000 + 652)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C9CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C9CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C9CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C9CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C9CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C9CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C9CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C9CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C9CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C9CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C9CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C9TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C9TCR (* ((volatile uint32_t *) (0x52000000 + 656)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C9TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C9TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C9TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C9TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C9TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C9TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C9TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C9TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C9TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C9TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C9TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C9TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C9TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C9TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C9BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C9BNDTR (* ((volatile uint32_t *) (0x52000000 + 660)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C9BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C9BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C9BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C9BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9SAR: MDMA channel x source address register
  #define MDMA_MDMA_C9SAR (* ((volatile uint32_t *) (0x52000000 + 664)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C9SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C9DAR (* ((volatile uint32_t *) (0x52000000 + 668)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C9DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C9BRUR (* ((volatile uint32_t *) (0x52000000 + 672)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C9BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C9BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C9LAR (* ((volatile uint32_t *) (0x52000000 + 676)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C9LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C9TBR (* ((volatile uint32_t *) (0x52000000 + 680)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C9TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C9TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C9TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C9MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C9MAR (* ((volatile uint32_t *) (0x52000000 + 688)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C9MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C9MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C9MDR (* ((volatile uint32_t *) (0x52000000 + 692)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C9MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C10ISR (* ((const volatile uint32_t *) (0x52000000 + 704)))

  // Field TEIF10: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ISR_TEIF10 = 1U << 0 ;

  // Field CTCIF10: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C10ISR_CTCIF10 = 1U << 1 ;

  // Field BRTIF10: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ISR_BRTIF10 = 1U << 2 ;

  // Field BTIF10: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ISR_BTIF10 = 1U << 3 ;

  // Field TCIF10: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C10ISR_TCIF10 = 1U << 4 ;

  // Field CRQA10: channel x request active flag
    const uint32_t MDMA_MDMA_C10ISR_CRQA10 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C10IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C10IFCR (* ((volatile uint32_t *) (0x52000000 + 708)))

  // Field CTEIF10: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C10IFCR_CTEIF10 = 1U << 0 ;

  // Field CCTCIF10: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C10IFCR_CCTCIF10 = 1U << 1 ;

  // Field CBRTIF10: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C10IFCR_CBRTIF10 = 1U << 2 ;

  // Field CBTIF10: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C10IFCR_CBTIF10 = 1U << 3 ;

  // Field CLTCIF10: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C10IFCR_CLTCIF10 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C10ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C10ESR (* ((const volatile uint32_t *) (0x52000000 + 712)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C10ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C10ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C10ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C10CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C10CR (* ((volatile uint32_t *) (0x52000000 + 716)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C10CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C10CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C10CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C10CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C10CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C10CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C10CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C10CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C10CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C10CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C10CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C10TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C10TCR (* ((volatile uint32_t *) (0x52000000 + 720)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C10TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C10TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C10TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C10TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C10TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C10TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C10TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C10TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C10TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C10TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C10TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C10TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C10TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C10TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C10BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C10BNDTR (* ((volatile uint32_t *) (0x52000000 + 724)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C10BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C10BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C10BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C10BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10SAR: MDMA channel x source address register
  #define MDMA_MDMA_C10SAR (* ((volatile uint32_t *) (0x52000000 + 728)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C10SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C10DAR (* ((volatile uint32_t *) (0x52000000 + 732)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C10DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C10BRUR (* ((volatile uint32_t *) (0x52000000 + 736)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C10BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C10BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C10LAR (* ((volatile uint32_t *) (0x52000000 + 740)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C10LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C10TBR (* ((volatile uint32_t *) (0x52000000 + 744)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C10TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C10TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C10TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C10MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C10MAR (* ((volatile uint32_t *) (0x52000000 + 752)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C10MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C10MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C10MDR (* ((volatile uint32_t *) (0x52000000 + 756)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C10MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C11ISR (* ((const volatile uint32_t *) (0x52000000 + 768)))

  // Field TEIF11: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ISR_TEIF11 = 1U << 0 ;

  // Field CTCIF11: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C11ISR_CTCIF11 = 1U << 1 ;

  // Field BRTIF11: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ISR_BRTIF11 = 1U << 2 ;

  // Field BTIF11: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ISR_BTIF11 = 1U << 3 ;

  // Field TCIF11: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C11ISR_TCIF11 = 1U << 4 ;

  // Field CRQA11: channel x request active flag
    const uint32_t MDMA_MDMA_C11ISR_CRQA11 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C11IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C11IFCR (* ((volatile uint32_t *) (0x52000000 + 772)))

  // Field CTEIF11: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C11IFCR_CTEIF11 = 1U << 0 ;

  // Field CCTCIF11: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C11IFCR_CCTCIF11 = 1U << 1 ;

  // Field CBRTIF11: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C11IFCR_CBRTIF11 = 1U << 2 ;

  // Field CBTIF11: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C11IFCR_CBTIF11 = 1U << 3 ;

  // Field CLTCIF11: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C11IFCR_CLTCIF11 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C11ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C11ESR (* ((const volatile uint32_t *) (0x52000000 + 776)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C11ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C11ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C11ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C11CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C11CR (* ((volatile uint32_t *) (0x52000000 + 780)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C11CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C11CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C11CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C11CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C11CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C11CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C11CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C11CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C11CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C11CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C11CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C11TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C11TCR (* ((volatile uint32_t *) (0x52000000 + 784)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C11TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C11TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C11TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C11TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C11TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C11TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C11TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C11TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C11TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C11TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C11TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C11TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C11TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C11TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C11BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C11BNDTR (* ((volatile uint32_t *) (0x52000000 + 788)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C11BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C11BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C11BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C11BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11SAR: MDMA channel x source address register
  #define MDMA_MDMA_C11SAR (* ((volatile uint32_t *) (0x52000000 + 792)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C11SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C11DAR (* ((volatile uint32_t *) (0x52000000 + 796)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C11DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C11BRUR (* ((volatile uint32_t *) (0x52000000 + 800)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C11BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C11BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C11LAR (* ((volatile uint32_t *) (0x52000000 + 804)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C11LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C11TBR (* ((volatile uint32_t *) (0x52000000 + 808)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C11TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C11TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C11TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C11MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C11MAR (* ((volatile uint32_t *) (0x52000000 + 816)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C11MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C11MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C11MDR (* ((volatile uint32_t *) (0x52000000 + 820)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C11MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C12ISR (* ((const volatile uint32_t *) (0x52000000 + 832)))

  // Field TEIF12: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ISR_TEIF12 = 1U << 0 ;

  // Field CTCIF12: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C12ISR_CTCIF12 = 1U << 1 ;

  // Field BRTIF12: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ISR_BRTIF12 = 1U << 2 ;

  // Field BTIF12: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ISR_BTIF12 = 1U << 3 ;

  // Field TCIF12: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C12ISR_TCIF12 = 1U << 4 ;

  // Field CRQA12: channel x request active flag
    const uint32_t MDMA_MDMA_C12ISR_CRQA12 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C12IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C12IFCR (* ((volatile uint32_t *) (0x52000000 + 836)))

  // Field CTEIF12: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C12IFCR_CTEIF12 = 1U << 0 ;

  // Field CCTCIF12: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C12IFCR_CCTCIF12 = 1U << 1 ;

  // Field CBRTIF12: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C12IFCR_CBRTIF12 = 1U << 2 ;

  // Field CBTIF12: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C12IFCR_CBTIF12 = 1U << 3 ;

  // Field CLTCIF12: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C12IFCR_CLTCIF12 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C12ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C12ESR (* ((const volatile uint32_t *) (0x52000000 + 840)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C12ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C12ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C12ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C12CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C12CR (* ((volatile uint32_t *) (0x52000000 + 844)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C12CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C12CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C12CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C12CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C12CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C12CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C12CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C12CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C12CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C12CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C12CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C12TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C12TCR (* ((volatile uint32_t *) (0x52000000 + 848)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C12TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C12TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C12TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C12TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C12TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C12TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C12TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C12TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C12TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C12TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C12TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C12TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C12TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C12TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C12BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C12BNDTR (* ((volatile uint32_t *) (0x52000000 + 852)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C12BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C12BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C12BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C12BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12SAR: MDMA channel x source address register
  #define MDMA_MDMA_C12SAR (* ((volatile uint32_t *) (0x52000000 + 856)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C12SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C12DAR (* ((volatile uint32_t *) (0x52000000 + 860)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C12DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C12BRUR (* ((volatile uint32_t *) (0x52000000 + 864)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C12BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C12BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C12LAR (* ((volatile uint32_t *) (0x52000000 + 868)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C12LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C12TBR (* ((volatile uint32_t *) (0x52000000 + 872)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C12TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C12TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C12TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C12MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C12MAR (* ((volatile uint32_t *) (0x52000000 + 880)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C12MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C12MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C12MDR (* ((volatile uint32_t *) (0x52000000 + 884)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C12MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C13ISR (* ((const volatile uint32_t *) (0x52000000 + 896)))

  // Field TEIF13: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ISR_TEIF13 = 1U << 0 ;

  // Field CTCIF13: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C13ISR_CTCIF13 = 1U << 1 ;

  // Field BRTIF13: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ISR_BRTIF13 = 1U << 2 ;

  // Field BTIF13: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ISR_BTIF13 = 1U << 3 ;

  // Field TCIF13: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C13ISR_TCIF13 = 1U << 4 ;

  // Field CRQA13: channel x request active flag
    const uint32_t MDMA_MDMA_C13ISR_CRQA13 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C13IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C13IFCR (* ((volatile uint32_t *) (0x52000000 + 900)))

  // Field CTEIF13: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C13IFCR_CTEIF13 = 1U << 0 ;

  // Field CCTCIF13: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C13IFCR_CCTCIF13 = 1U << 1 ;

  // Field CBRTIF13: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C13IFCR_CBRTIF13 = 1U << 2 ;

  // Field CBTIF13: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C13IFCR_CBTIF13 = 1U << 3 ;

  // Field CLTCIF13: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C13IFCR_CLTCIF13 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C13ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C13ESR (* ((const volatile uint32_t *) (0x52000000 + 904)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C13ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C13ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C13ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C13CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C13CR (* ((volatile uint32_t *) (0x52000000 + 908)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C13CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C13CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C13CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C13CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C13CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C13CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C13CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C13CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C13CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C13CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C13CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C13TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C13TCR (* ((volatile uint32_t *) (0x52000000 + 912)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C13TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C13TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C13TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C13TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C13TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C13TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C13TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C13TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C13TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C13TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C13TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C13TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C13TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C13TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C13BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C13BNDTR (* ((volatile uint32_t *) (0x52000000 + 916)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C13BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C13BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C13BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C13BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13SAR: MDMA channel x source address register
  #define MDMA_MDMA_C13SAR (* ((volatile uint32_t *) (0x52000000 + 920)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C13SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C13DAR (* ((volatile uint32_t *) (0x52000000 + 924)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C13DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C13BRUR (* ((volatile uint32_t *) (0x52000000 + 928)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C13BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C13BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C13LAR (* ((volatile uint32_t *) (0x52000000 + 932)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C13LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C13TBR (* ((volatile uint32_t *) (0x52000000 + 936)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C13TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C13TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C13TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C13MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C13MAR (* ((volatile uint32_t *) (0x52000000 + 944)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C13MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C13MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C13MDR (* ((volatile uint32_t *) (0x52000000 + 948)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C13MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C14ISR (* ((const volatile uint32_t *) (0x52000000 + 960)))

  // Field TEIF14: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ISR_TEIF14 = 1U << 0 ;

  // Field CTCIF14: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C14ISR_CTCIF14 = 1U << 1 ;

  // Field BRTIF14: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ISR_BRTIF14 = 1U << 2 ;

  // Field BTIF14: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ISR_BTIF14 = 1U << 3 ;

  // Field TCIF14: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C14ISR_TCIF14 = 1U << 4 ;

  // Field CRQA14: channel x request active flag
    const uint32_t MDMA_MDMA_C14ISR_CRQA14 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C14IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C14IFCR (* ((volatile uint32_t *) (0x52000000 + 964)))

  // Field CTEIF14: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C14IFCR_CTEIF14 = 1U << 0 ;

  // Field CCTCIF14: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C14IFCR_CCTCIF14 = 1U << 1 ;

  // Field CBRTIF14: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C14IFCR_CBRTIF14 = 1U << 2 ;

  // Field CBTIF14: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C14IFCR_CBTIF14 = 1U << 3 ;

  // Field CLTCIF14: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C14IFCR_CLTCIF14 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C14ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C14ESR (* ((const volatile uint32_t *) (0x52000000 + 968)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C14ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C14ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C14ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C14CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C14CR (* ((volatile uint32_t *) (0x52000000 + 972)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C14CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C14CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C14CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C14CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C14CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C14CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C14CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C14CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C14CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C14CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C14CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C14TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C14TCR (* ((volatile uint32_t *) (0x52000000 + 976)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C14TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C14TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C14TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C14TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C14TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C14TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C14TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C14TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C14TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C14TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C14TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C14TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C14TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C14TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C14BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C14BNDTR (* ((volatile uint32_t *) (0x52000000 + 980)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C14BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C14BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C14BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C14BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14SAR: MDMA channel x source address register
  #define MDMA_MDMA_C14SAR (* ((volatile uint32_t *) (0x52000000 + 984)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C14SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C14DAR (* ((volatile uint32_t *) (0x52000000 + 988)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C14DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C14BRUR (* ((volatile uint32_t *) (0x52000000 + 992)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C14BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C14BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C14LAR (* ((volatile uint32_t *) (0x52000000 + 996)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C14LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C14TBR (* ((volatile uint32_t *) (0x52000000 + 1000)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C14TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C14TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C14TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C14MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C14MAR (* ((volatile uint32_t *) (0x52000000 + 1008)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C14MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C14MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C14MDR (* ((volatile uint32_t *) (0x52000000 + 1012)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C14MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15ISR: MDMA channel x interrupt/status register
  #define MDMA_MDMA_C15ISR (* ((const volatile uint32_t *) (0x52000000 + 1024)))

  // Field TEIF15: Channel x transfer error interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ISR_TEIF15 = 1U << 0 ;

  // Field CTCIF15: Channel x Channel Transfer Complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register. CTC is set when the last block was transferred and the channel has been automatically disabled. CTC is also set when the channel is suspended, as a result of writing EN bit to 0.
    const uint32_t MDMA_MDMA_C15ISR_CTCIF15 = 1U << 1 ;

  // Field BRTIF15: Channel x block repeat transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ISR_BRTIF15 = 1U << 2 ;

  // Field BTIF15: Channel x block transfer complete interrupt flag This bit is set by hardware. It is cleared by software writing 1 to the corresponding bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ISR_BTIF15 = 1U << 3 ;

  // Field TCIF15: channel x buffer transfer complete
    const uint32_t MDMA_MDMA_C15ISR_TCIF15 = 1U << 4 ;

  // Field CRQA15: channel x request active flag
    const uint32_t MDMA_MDMA_C15ISR_CRQA15 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C15IFCR: MDMA channel x interrupt flag clear register
  #define MDMA_MDMA_C15IFCR (* ((volatile uint32_t *) (0x52000000 + 1028)))

  // Field CTEIF15: Channel x clear transfer error interrupt flag Writing a 1 into this bit clears TEIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C15IFCR_CTEIF15 = 1U << 0 ;

  // Field CCTCIF15: Clear Channel transfer complete interrupt flag for channel x Writing a 1 into this bit clears CTCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C15IFCR_CCTCIF15 = 1U << 1 ;

  // Field CBRTIF15: Channel x clear block repeat transfer complete interrupt flag Writing a 1 into this bit clears BRTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C15IFCR_CBRTIF15 = 1U << 2 ;

  // Field CBTIF15: Channel x Clear block transfer complete interrupt flag Writing a 1 into this bit clears BTIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C15IFCR_CBTIF15 = 1U << 3 ;

  // Field CLTCIF15: CLear buffer Transfer Complete Interrupt Flag for channel x Writing a 1 into this bit clears TCIFx in the MDMA_ISRy register
    const uint32_t MDMA_MDMA_C15IFCR_CLTCIF15 = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C15ESR: MDMA Channel x error status register
  #define MDMA_MDMA_C15ESR (* ((const volatile uint32_t *) (0x52000000 + 1032)))

  // Field TEA: Transfer Error Address These bits are set and cleared by HW, in case of an MDMA data transfer error. It is used in conjunction with TED. This field indicates the 7 LSBits of the address which generated a transfer/access error. It may be used by SW to retrieve the failing address, by adding this value (truncated to the buffer transfer length size) to the current SAR/DAR value. Note: The SAR/DAR current value doesnt reflect this last address due to the FIFO management system. The SAR/DAR are only updated at the end of a (buffer) transfer (of TLEN+1 bytes). Note: It is not set in case of a link data error.
    inline uint32_t MDMA_MDMA_C15ESR_TEA (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field TED: Transfer Error Direction These bit is set and cleared by HW, in case of an MDMA data transfer error.
    const uint32_t MDMA_MDMA_C15ESR_TED = 1U << 7 ;

  // Field TELD: Transfer Error Link Data These bit is set by HW, in case of a transfer error while reading the block link data structure. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ESR_TELD = 1U << 8 ;

  // Field TEMD: Transfer Error Mask Data These bit is set by HW, in case of a transfer error while writing the Mask Data. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ESR_TEMD = 1U << 9 ;

  // Field ASE: Address/Size Error These bit is set by HW, when the programmed address is not aligned with the data size. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ESR_ASE = 1U << 10 ;

  // Field BSE: Block Size Error These bit is set by HW, when the block size is not an integer multiple of the data size either for source or destination. TED will indicate whether the problem is on the source or destination. It is cleared by software writing 1 to the CTEIFx bit in the DMA_IFCRy register.
    const uint32_t MDMA_MDMA_C15ESR_BSE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C15CR: This register is used to control the concerned channel.
  #define MDMA_MDMA_C15CR (* ((volatile uint32_t *) (0x52000000 + 1036)))

  // Field EN: channel enable
    const uint32_t MDMA_MDMA_C15CR_EN = 1U << 0 ;

  // Field TEIE: Transfer error interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C15CR_TEIE = 1U << 1 ;

  // Field CTCIE: Channel Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C15CR_CTCIE = 1U << 2 ;

  // Field BRTIE: Block Repeat transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C15CR_BRTIE = 1U << 3 ;

  // Field BTIE: Block Transfer interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C15CR_BTIE = 1U << 4 ;

  // Field TCIE: buffer Transfer Complete interrupt enable This bit is set and cleared by software.
    const uint32_t MDMA_MDMA_C15CR_TCIE = 1U << 5 ;

  // Field PL: Priority level These bits are set and cleared by software. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C15CR_PL (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field BEX: byte Endianness exchange
    const uint32_t MDMA_MDMA_C15CR_BEX = 1U << 12 ;

  // Field HEX: Half word Endianes exchange
    const uint32_t MDMA_MDMA_C15CR_HEX = 1U << 13 ;

  // Field WEX: Word Endianness exchange
    const uint32_t MDMA_MDMA_C15CR_WEX = 1U << 14 ;

  // Field SWRQ: SW ReQuest Writing a 1 into this bit sets the CRQAx in MDMA_ISRy register, activating the request on Channel x Note: Either the whole CxCR register or the 8-bit/16-bit register @ Address offset: 0x4E + 0x40 chn may be used for SWRQ activation. In case of a SW request, acknowledge is not generated (neither HW signal, nor CxMAR write access).
    const uint32_t MDMA_MDMA_C15CR_SWRQ = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C15TCR: This register is used to configure the concerned channel.
  #define MDMA_MDMA_C15TCR (* ((volatile uint32_t *) (0x52000000 + 1040)))

  // Field SINC: Source increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When source is AHB (SBUS=1), SINC = 00 is forbidden. In Linked List Mode, at the end of a block (single or last block in repeated block transfer mode), this register will be loaded from memory (from address given by current LAR[31:0] + 0x00).
    inline uint32_t MDMA_MDMA_C15TCR_SINC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DINC: Destination increment mode These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: When destination is AHB (DBUS=1), DINC = 00 is forbidden.
    inline uint32_t MDMA_MDMA_C15TCR_DINC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field SSIZE: Source data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0 Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If SINCOS &lt; SSIZE and SINC &#8800; 00, the result will be unpredictable. Note: SSIZE = 11 (double-word) is forbidden when source is TCM/AHB bus (SBUS=1).
    inline uint32_t MDMA_MDMA_C15TCR_SSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DSIZE: Destination data size These bits are set and cleared by software. These bits are protected and can be written only if EN is 0. Note: If a value of 11 is programmed for the TCM access/AHB port, a transfer error will occur (TEIF bit set) If DINCOS &lt; DSIZE and DINC &#8800; 00, the result will be unpredictable. Note: DSIZE = 11 (double-word) is forbidden when destination is TCM/AHB bus (DBUS=1).
    inline uint32_t MDMA_MDMA_C15TCR_DSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field SINCOS: source increment offset size
    inline uint32_t MDMA_MDMA_C15TCR_SINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DINCOS: Destination increment offset
    inline uint32_t MDMA_MDMA_C15TCR_DINCOS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field SBURST: source burst transfer configuration
    inline uint32_t MDMA_MDMA_C15TCR_SBURST (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DBURST: Destination burst transfer configuration
    inline uint32_t MDMA_MDMA_C15TCR_DBURST (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field TLEN: buffer transfer lengh
    inline uint32_t MDMA_MDMA_C15TCR_TLEN (const uint32_t inValue) {return (inValue & 0x7FU) << 18 ; }

  // Field PKE: PacK Enable These bit is set and cleared by software. If the Source Size is smaller than the destination, it will be padded according to the PAM value. If the Source data size is larger than the destination one, it will be truncated. The alignment will be done according to the PAM[0] value. This bit is protected and can be written only if EN is 0
    const uint32_t MDMA_MDMA_C15TCR_PKE = 1U << 25 ;

  // Field PAM: Padding/Alignement Mode These bits are set and cleared by software. Case 1: Source data size smaller than destination data size - 3 options are valid. Case 2: Source data size larger than destination data size. The remainder part is discarded. When PKE = 1 or DSIZE=SSIZE, these bits are ignored. These bits are protected and can be written only if EN is 0
    inline uint32_t MDMA_MDMA_C15TCR_PAM (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field TRGM: Trigger Mode These bits are set and cleared by software. Note: If TRGM is 11 for the current block, all the values loaded at the end of the current block through the linked list mechanism must keep the same value (TRGM=11) and the same SWRM value, otherwise the result is undefined. These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C15TCR_TRGM (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWRM: SW Request Mode This bit is set and cleared by software. If a HW or SW request is currently active, the bit change will be delayed until the current transfer is completed. If the CxMAR contains a valid address, the CxMDR value will also be written @ CxMAR address. This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C15TCR_SWRM = 1U << 30 ;

  // Field BWM: Bufferable Write Mode This bit is set and cleared by software. This bit is protected and can be written only if EN is 0. Note: All MDMA destination accesses are non-cacheable.
    const uint32_t MDMA_MDMA_C15TCR_BWM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C15BNDTR: MDMA Channel x block number of data register
  #define MDMA_MDMA_C15BNDTR (* ((volatile uint32_t *) (0x52000000 + 1044)))

  // Field BNDT: block number of data to transfer
    inline uint32_t MDMA_MDMA_C15BNDTR_BNDT (const uint32_t inValue) {return (inValue & 0x1FFFFU) << 0 ; }

  // Field BRSUM: Block Repeat Source address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C15BNDTR_BRSUM = 1U << 18 ;

  // Field BRDUM: Block Repeat Destination address Update Mode These bits are protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C15BNDTR_BRDUM = 1U << 19 ;

  // Field BRC: Block Repeat Count This field contains the number of repetitions of the current block (0 to 4095). When the channel is enabled, this register is read-only, indicating the remaining number of blocks, excluding the current one. This register decrements after each complete block transfer. Once the last block transfer has completed, this register can either stay at zero or be reloaded automatically from memory (in Linked List mode - i.e. Link Address valid). These bits are protected and can be written only if EN is 0.
    inline uint32_t MDMA_MDMA_C15BNDTR_BRC (const uint32_t inValue) {return (inValue & 0xFFFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15SAR: MDMA channel x source address register
  #define MDMA_MDMA_C15SAR (* ((volatile uint32_t *) (0x52000000 + 1048)))

  // Field SAR: source adr base
    inline uint32_t MDMA_MDMA_C15SAR_SAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15DAR: MDMA channel x destination address register
  #define MDMA_MDMA_C15DAR (* ((volatile uint32_t *) (0x52000000 + 1052)))

  // Field DAR: Destination adr base
    inline uint32_t MDMA_MDMA_C15DAR_DAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15BRUR: MDMA channel x Block Repeat address Update register
  #define MDMA_MDMA_C15BRUR (* ((volatile uint32_t *) (0x52000000 + 1056)))

  // Field SUV: source adresse update value
    inline uint32_t MDMA_MDMA_C15BRUR_SUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DUV: destination address update
    inline uint32_t MDMA_MDMA_C15BRUR_DUV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15LAR: MDMA channel x Link Address register
  #define MDMA_MDMA_C15LAR (* ((volatile uint32_t *) (0x52000000 + 1060)))

  // Field LAR: Link address register
    inline uint32_t MDMA_MDMA_C15LAR_LAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15TBR: MDMA channel x Trigger and Bus selection Register
  #define MDMA_MDMA_C15TBR (* ((volatile uint32_t *) (0x52000000 + 1064)))

  // Field TSEL: Trigger selection
    inline uint32_t MDMA_MDMA_C15TBR_TSEL (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field SBUS: Source BUS select This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C15TBR_SBUS = 1U << 16 ;

  // Field DBUS: Destination BUS slect This bit is protected and can be written only if EN is 0.
    const uint32_t MDMA_MDMA_C15TBR_DBUS = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register MDMA_C15MAR: MDMA channel x Mask address register
  #define MDMA_MDMA_C15MAR (* ((volatile uint32_t *) (0x52000000 + 1072)))

  // Field MAR: Mask address
    inline uint32_t MDMA_MDMA_C15MAR_MAR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MDMA_C15MDR: MDMA channel x Mask Data register
  #define MDMA_MDMA_C15MDR (* ((volatile uint32_t *) (0x52000000 + 1076)))

  // Field MDR: Mask data
    inline uint32_t MDMA_MDMA_C15MDR_MDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral MPU: Memory protection unit
//------------------------------------------------------------------------------

//---  Register MPU_TYPER: MPU type register
  #define MPU_MPU_TYPER (* ((const volatile uint32_t *) (0xE000ED90 + 0)))

  // Field SEPARATE: Separate flag
    const uint32_t MPU_MPU_TYPER_SEPARATE = 1U << 0 ;

  // Field DREGION: Number of MPU data regions
    inline uint32_t MPU_MPU_TYPER_DREGION (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IREGION: Number of MPU instruction regions
    inline uint32_t MPU_MPU_TYPER_IREGION (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register MPU_CTRL: MPU control register
  #define MPU_MPU_CTRL (* ((volatile uint32_t *) (0xE000ED90 + 4)))

  // Field ENABLE: Enables the MPU
    const uint32_t MPU_MPU_CTRL_ENABLE = 1U << 0 ;

  // Field HFNMIENA: Enables the operation of MPU during hard fault
    const uint32_t MPU_MPU_CTRL_HFNMIENA = 1U << 1 ;

  // Field PRIVDEFENA: Enable priviliged software access to default memory map
    const uint32_t MPU_MPU_CTRL_PRIVDEFENA = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register MPU_RNR: MPU region number register
  #define MPU_MPU_RNR (* ((volatile uint32_t *) (0xE000ED90 + 8)))

  // Field REGION: MPU region
    inline uint32_t MPU_MPU_RNR_REGION (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register MPU_RBAR: MPU region base address register
  #define MPU_MPU_RBAR (* ((volatile uint32_t *) (0xE000ED90 + 12)))

  // Field REGION: MPU region field
    inline uint32_t MPU_MPU_RBAR_REGION (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field VALID: MPU region number valid
    const uint32_t MPU_MPU_RBAR_VALID = 1U << 4 ;

  // Field ADDR: Region base address field
    inline uint32_t MPU_MPU_RBAR_ADDR (const uint32_t inValue) {return (inValue & 0x7FFFFFFU) << 5 ; }

//------------------------------------------------------------------------------

//---  Register MPU_RASR: MPU region attribute and size register
  #define MPU_MPU_RASR (* ((volatile uint32_t *) (0xE000ED90 + 16)))

  // Field ENABLE: Region enable bit.
    const uint32_t MPU_MPU_RASR_ENABLE = 1U << 0 ;

  // Field SIZE: Size of the MPU protection region
    inline uint32_t MPU_MPU_RASR_SIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 1 ; }

  // Field SRD: Subregion disable bits
    inline uint32_t MPU_MPU_RASR_SRD (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field B: memory attribute
    const uint32_t MPU_MPU_RASR_B = 1U << 16 ;

  // Field C: memory attribute
    const uint32_t MPU_MPU_RASR_C = 1U << 17 ;

  // Field S: Shareable memory attribute
    const uint32_t MPU_MPU_RASR_S = 1U << 18 ;

  // Field TEX: memory attribute
    inline uint32_t MPU_MPU_RASR_TEX (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field AP: Access permission
    inline uint32_t MPU_MPU_RASR_AP (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field XN: Instruction access disable bit
    const uint32_t MPU_MPU_RASR_XN = 1U << 28 ;

//------------------------------------------------------------------------------
// Peripheral NVIC: Nested Vectored Interrupt       Controller
//------------------------------------------------------------------------------

//---  Register ISER0: Interrupt Set-Enable Register
  #define NVIC_ISER0 (* ((volatile uint32_t *) (0xE000E100 + 0)))

  // Field SETENA: SETENA
    inline uint32_t NVIC_ISER0_SETENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISER1: Interrupt Set-Enable Register
  #define NVIC_ISER1 (* ((volatile uint32_t *) (0xE000E100 + 4)))

  // Field SETENA: SETENA
    inline uint32_t NVIC_ISER1_SETENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISER2: Interrupt Set-Enable Register
  #define NVIC_ISER2 (* ((volatile uint32_t *) (0xE000E100 + 8)))

  // Field SETENA: SETENA
    inline uint32_t NVIC_ISER2_SETENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ICER0: Interrupt Clear-Enable Register
  #define NVIC_ICER0 (* ((volatile uint32_t *) (0xE000E100 + 128)))

  // Field CLRENA: CLRENA
    inline uint32_t NVIC_ICER0_CLRENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ICER1: Interrupt Clear-Enable Register
  #define NVIC_ICER1 (* ((volatile uint32_t *) (0xE000E100 + 132)))

  // Field CLRENA: CLRENA
    inline uint32_t NVIC_ICER1_CLRENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ICER2: Interrupt Clear-Enable Register
  #define NVIC_ICER2 (* ((volatile uint32_t *) (0xE000E100 + 136)))

  // Field CLRENA: CLRENA
    inline uint32_t NVIC_ICER2_CLRENA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISPR0: Interrupt Set-Pending Register
  #define NVIC_ISPR0 (* ((volatile uint32_t *) (0xE000E100 + 256)))

  // Field SETPEND: SETPEND
    inline uint32_t NVIC_ISPR0_SETPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISPR1: Interrupt Set-Pending Register
  #define NVIC_ISPR1 (* ((volatile uint32_t *) (0xE000E100 + 260)))

  // Field SETPEND: SETPEND
    inline uint32_t NVIC_ISPR1_SETPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISPR2: Interrupt Set-Pending Register
  #define NVIC_ISPR2 (* ((volatile uint32_t *) (0xE000E100 + 264)))

  // Field SETPEND: SETPEND
    inline uint32_t NVIC_ISPR2_SETPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ICPR0: Interrupt Clear-Pending Register
  #define NVIC_ICPR0 (* ((volatile uint32_t *) (0xE000E100 + 384)))

  // Field CLRPEND: CLRPEND
    inline uint32_t NVIC_ICPR0_CLRPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ICPR1: Interrupt Clear-Pending Register
  #define NVIC_ICPR1 (* ((volatile uint32_t *) (0xE000E100 + 388)))

  // Field CLRPEND: CLRPEND
    inline uint32_t NVIC_ICPR1_CLRPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ICPR2: Interrupt Clear-Pending Register
  #define NVIC_ICPR2 (* ((volatile uint32_t *) (0xE000E100 + 392)))

  // Field CLRPEND: CLRPEND
    inline uint32_t NVIC_ICPR2_CLRPEND (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IABR0: Interrupt Active Bit Register
  #define NVIC_IABR0 (* ((const volatile uint32_t *) (0xE000E100 + 512)))

  // Field ACTIVE: ACTIVE
    inline uint32_t NVIC_IABR0_ACTIVE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IABR1: Interrupt Active Bit Register
  #define NVIC_IABR1 (* ((const volatile uint32_t *) (0xE000E100 + 516)))

  // Field ACTIVE: ACTIVE
    inline uint32_t NVIC_IABR1_ACTIVE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IABR2: Interrupt Active Bit Register
  #define NVIC_IABR2 (* ((const volatile uint32_t *) (0xE000E100 + 520)))

  // Field ACTIVE: ACTIVE
    inline uint32_t NVIC_IABR2_ACTIVE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IPR0: Interrupt Priority Register
  #define NVIC_IPR0 (* ((volatile uint32_t *) (0xE000E100 + 768)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR0_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR0_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR0_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR0_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR1: Interrupt Priority Register
  #define NVIC_IPR1 (* ((volatile uint32_t *) (0xE000E100 + 772)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR1_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR1_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR1_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR1_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR2: Interrupt Priority Register
  #define NVIC_IPR2 (* ((volatile uint32_t *) (0xE000E100 + 776)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR2_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR2_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR2_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR2_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR3: Interrupt Priority Register
  #define NVIC_IPR3 (* ((volatile uint32_t *) (0xE000E100 + 780)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR3_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR3_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR3_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR3_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR4: Interrupt Priority Register
  #define NVIC_IPR4 (* ((volatile uint32_t *) (0xE000E100 + 784)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR4_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR4_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR4_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR4_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR5: Interrupt Priority Register
  #define NVIC_IPR5 (* ((volatile uint32_t *) (0xE000E100 + 788)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR5_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR5_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR5_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR5_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR6: Interrupt Priority Register
  #define NVIC_IPR6 (* ((volatile uint32_t *) (0xE000E100 + 792)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR6_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR6_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR6_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR6_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR7: Interrupt Priority Register
  #define NVIC_IPR7 (* ((volatile uint32_t *) (0xE000E100 + 796)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR7_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR7_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR7_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR7_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR8: Interrupt Priority Register
  #define NVIC_IPR8 (* ((volatile uint32_t *) (0xE000E100 + 800)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR8_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR8_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR8_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR8_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR9: Interrupt Priority Register
  #define NVIC_IPR9 (* ((volatile uint32_t *) (0xE000E100 + 804)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR9_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR9_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR9_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR9_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR10: Interrupt Priority Register
  #define NVIC_IPR10 (* ((volatile uint32_t *) (0xE000E100 + 808)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR10_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR10_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR10_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR10_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR11: Interrupt Priority Register
  #define NVIC_IPR11 (* ((volatile uint32_t *) (0xE000E100 + 812)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR11_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR11_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR11_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR11_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR12: Interrupt Priority Register
  #define NVIC_IPR12 (* ((volatile uint32_t *) (0xE000E100 + 816)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR12_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR12_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR12_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR12_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR13: Interrupt Priority Register
  #define NVIC_IPR13 (* ((volatile uint32_t *) (0xE000E100 + 820)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR13_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR13_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR13_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR13_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR14: Interrupt Priority Register
  #define NVIC_IPR14 (* ((volatile uint32_t *) (0xE000E100 + 824)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR14_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR14_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR14_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR14_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR15: Interrupt Priority Register
  #define NVIC_IPR15 (* ((volatile uint32_t *) (0xE000E100 + 828)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR15_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR15_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR15_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR15_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR16: Interrupt Priority Register
  #define NVIC_IPR16 (* ((volatile uint32_t *) (0xE000E100 + 832)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR16_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR16_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR16_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR16_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR17: Interrupt Priority Register
  #define NVIC_IPR17 (* ((volatile uint32_t *) (0xE000E100 + 836)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR17_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR17_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR17_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR17_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR18: Interrupt Priority Register
  #define NVIC_IPR18 (* ((volatile uint32_t *) (0xE000E100 + 840)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR18_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR18_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR18_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR18_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR19: Interrupt Priority Register
  #define NVIC_IPR19 (* ((volatile uint32_t *) (0xE000E100 + 844)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR19_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR19_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR19_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR19_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR20: Interrupt Priority Register
  #define NVIC_IPR20 (* ((volatile uint32_t *) (0xE000E100 + 848)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR20_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR20_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR20_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR20_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR21: Interrupt Priority Register
  #define NVIC_IPR21 (* ((volatile uint32_t *) (0xE000E100 + 852)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR21_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR21_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR21_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR21_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR22: Interrupt Priority Register
  #define NVIC_IPR22 (* ((volatile uint32_t *) (0xE000E100 + 856)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR22_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR22_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR22_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR22_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR23: Interrupt Priority Register
  #define NVIC_IPR23 (* ((volatile uint32_t *) (0xE000E100 + 860)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR23_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR23_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR23_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR23_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR24: Interrupt Priority Register
  #define NVIC_IPR24 (* ((volatile uint32_t *) (0xE000E100 + 864)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR24_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR24_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR24_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR24_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR25: Interrupt Priority Register
  #define NVIC_IPR25 (* ((volatile uint32_t *) (0xE000E100 + 868)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR25_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR25_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR25_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR25_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR26: Interrupt Priority Register
  #define NVIC_IPR26 (* ((volatile uint32_t *) (0xE000E100 + 872)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR26_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR26_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR26_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR26_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR27: Interrupt Priority Register
  #define NVIC_IPR27 (* ((volatile uint32_t *) (0xE000E100 + 876)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR27_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR27_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR27_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR27_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR28: Interrupt Priority Register
  #define NVIC_IPR28 (* ((volatile uint32_t *) (0xE000E100 + 880)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR28_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR28_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR28_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR28_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR29: Interrupt Priority Register
  #define NVIC_IPR29 (* ((volatile uint32_t *) (0xE000E100 + 884)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR29_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR29_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR29_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR29_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR30: Interrupt Priority Register
  #define NVIC_IPR30 (* ((volatile uint32_t *) (0xE000E100 + 888)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR30_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR30_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR30_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR30_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR31: Interrupt Priority Register
  #define NVIC_IPR31 (* ((volatile uint32_t *) (0xE000E100 + 892)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR31_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR31_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR31_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR31_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR32: Interrupt Priority Register
  #define NVIC_IPR32 (* ((volatile uint32_t *) (0xE000E100 + 896)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR32_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR32_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR32_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR32_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR33: Interrupt Priority Register
  #define NVIC_IPR33 (* ((volatile uint32_t *) (0xE000E100 + 900)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR33_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR33_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR33_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR33_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR34: Interrupt Priority Register
  #define NVIC_IPR34 (* ((volatile uint32_t *) (0xE000E100 + 904)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR34_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR34_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR34_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR34_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR35: Interrupt Priority Register
  #define NVIC_IPR35 (* ((volatile uint32_t *) (0xE000E100 + 908)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR35_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR35_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR35_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR35_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR36: Interrupt Priority Register
  #define NVIC_IPR36 (* ((volatile uint32_t *) (0xE000E100 + 912)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR36_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR36_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR36_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR36_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR37: Interrupt Priority Register
  #define NVIC_IPR37 (* ((volatile uint32_t *) (0xE000E100 + 916)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR37_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR37_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR37_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR37_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR38: Interrupt Priority Register
  #define NVIC_IPR38 (* ((volatile uint32_t *) (0xE000E100 + 920)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR38_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR38_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR38_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR38_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register IPR39: Interrupt Priority Register
  #define NVIC_IPR39 (* ((volatile uint32_t *) (0xE000E100 + 924)))

  // Field IPR_N0: IPR_N0
    inline uint32_t NVIC_IPR39_IPR_N0 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IPR_N1: IPR_N1
    inline uint32_t NVIC_IPR39_IPR_N1 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field IPR_N2: IPR_N2
    inline uint32_t NVIC_IPR39_IPR_N2 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field IPR_N3: IPR_N3
    inline uint32_t NVIC_IPR39_IPR_N3 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register ISER3: Interrupt Set-Enable Register
  #define NVIC_ISER3 (* ((volatile uint32_t *) (0xE000E100 + 12)))

//------------------------------------------------------------------------------

//---  Register ISER4: Interrupt Set-Enable Register
  #define NVIC_ISER4 (* ((volatile uint32_t *) (0xE000E100 + 16)))

//------------------------------------------------------------------------------

//---  Register ICER3: Interrupt Clear-Enable Register
  #define NVIC_ICER3 (* ((volatile uint32_t *) (0xE000E100 + 140)))

//------------------------------------------------------------------------------

//---  Register ICER4: Interrupt Clear-Enable Register
  #define NVIC_ICER4 (* ((volatile uint32_t *) (0xE000E100 + 144)))

//------------------------------------------------------------------------------

//---  Register ISPR3: Interrupt Set-Pending Register
  #define NVIC_ISPR3 (* ((volatile uint32_t *) (0xE000E100 + 268)))

//------------------------------------------------------------------------------

//---  Register ISPR4: Interrupt Set-Pending Register
  #define NVIC_ISPR4 (* ((volatile uint32_t *) (0xE000E100 + 272)))

//------------------------------------------------------------------------------

//---  Register ICPR3: Interrupt Clear-Pending Register
  #define NVIC_ICPR3 (* ((volatile uint32_t *) (0xE000E100 + 448)))

//------------------------------------------------------------------------------

//---  Register ICPR4: Interrupt Clear-Pending Register
  #define NVIC_ICPR4 (* ((volatile uint32_t *) (0xE000E100 + 452)))

//------------------------------------------------------------------------------

//---  Register IABR3: Interrupt Active Bit Register
  #define NVIC_IABR3 (* ((volatile uint32_t *) (0xE000E100 + 524)))

//------------------------------------------------------------------------------

//---  Register IABR4: Interrupt Active Bit Register
  #define NVIC_IABR4 (* ((volatile uint32_t *) (0xE000E100 + 528)))

//------------------------------------------------------------------------------
// Peripheral NVIC_STIR: Nested vectored interrupt       controller
//------------------------------------------------------------------------------

//---  Register STIR: Software trigger interrupt register
  #define NVIC_STIR_STIR (* ((volatile uint32_t *) (0xE000EF00 + 0)))

  // Field INTID: Software generated interrupt ID
    inline uint32_t NVIC_STIR_STIR_INTID (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral OPAMP: Operational amplifiers
//------------------------------------------------------------------------------

//---  Register OPAMP1_CSR: OPAMP1 control/status register
  #define OPAMP_OPAMP1_CSR (* ((volatile uint32_t *) (0x40009000 + 0)))

  // Field OPAEN: Operational amplifier Enable
    const uint32_t OPAMP_OPAMP1_CSR_OPAEN = 1U << 0 ;

  // Field FORCE_VP: Force internal reference on VP (reserved for test
    const uint32_t OPAMP_OPAMP1_CSR_FORCE_VP = 1U << 1 ;

  // Field VP_SEL: Operational amplifier PGA mode
    inline uint32_t OPAMP_OPAMP1_CSR_VP_SEL (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field VM_SEL: Inverting input selection
    inline uint32_t OPAMP_OPAMP1_CSR_VM_SEL (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field OPAHSM: Operational amplifier high-speed mode
    const uint32_t OPAMP_OPAMP1_CSR_OPAHSM = 1U << 8 ;

  // Field CALON: Calibration mode enabled
    const uint32_t OPAMP_OPAMP1_CSR_CALON = 1U << 11 ;

  // Field CALSEL: Calibration selection
    inline uint32_t OPAMP_OPAMP1_CSR_CALSEL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PGA_GAIN: allows to switch from AOP offset trimmed values to AOP offset
    inline uint32_t OPAMP_OPAMP1_CSR_PGA_GAIN (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

  // Field USERTRIM: User trimming enable
    const uint32_t OPAMP_OPAMP1_CSR_USERTRIM = 1U << 18 ;

  // Field TSTREF: OPAMP calibration reference voltage output control (reserved for test)
    const uint32_t OPAMP_OPAMP1_CSR_TSTREF = 1U << 29 ;

  // Field CALOUT: Operational amplifier calibration output
    const uint32_t OPAMP_OPAMP1_CSR_CALOUT = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OPAMP1_OTR: OPAMP1 offset trimming register in normal mode
  #define OPAMP_OPAMP1_OTR (* ((volatile uint32_t *) (0x40009000 + 4)))

  // Field TRIMOFFSETN: Trim for NMOS differential pairs
    inline uint32_t OPAMP_OPAMP1_OTR_TRIMOFFSETN (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field TRIMOFFSETP: Trim for PMOS differential pairs
    inline uint32_t OPAMP_OPAMP1_OTR_TRIMOFFSETP (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register OPAMP1_HSOTR: OPAMP1 offset trimming register in low-power mode
  #define OPAMP_OPAMP1_HSOTR (* ((volatile uint32_t *) (0x40009000 + 8)))

  // Field TRIMLPOFFSETN: Trim for NMOS differential pairs
    inline uint32_t OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETN (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field TRIMLPOFFSETP: Trim for PMOS differential pairs
    inline uint32_t OPAMP_OPAMP1_HSOTR_TRIMLPOFFSETP (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register OPAMP2_CSR: OPAMP2 control/status register
  #define OPAMP_OPAMP2_CSR (* ((volatile uint32_t *) (0x40009000 + 16)))

  // Field OPAEN: Operational amplifier Enable
    const uint32_t OPAMP_OPAMP2_CSR_OPAEN = 1U << 0 ;

  // Field FORCE_VP: Force internal reference on VP (reserved for test)
    const uint32_t OPAMP_OPAMP2_CSR_FORCE_VP = 1U << 1 ;

  // Field VM_SEL: Inverting input selection
    inline uint32_t OPAMP_OPAMP2_CSR_VM_SEL (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field OPAHSM: Operational amplifier high-speed mode
    const uint32_t OPAMP_OPAMP2_CSR_OPAHSM = 1U << 8 ;

  // Field CALON: Calibration mode enabled
    const uint32_t OPAMP_OPAMP2_CSR_CALON = 1U << 11 ;

  // Field CALSEL: Calibration selection
    inline uint32_t OPAMP_OPAMP2_CSR_CALSEL (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field PGA_GAIN: Operational amplifier Programmable amplifier gain value
    inline uint32_t OPAMP_OPAMP2_CSR_PGA_GAIN (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

  // Field USERTRIM: User trimming enable
    const uint32_t OPAMP_OPAMP2_CSR_USERTRIM = 1U << 18 ;

  // Field TSTREF: OPAMP calibration reference voltage output control (reserved for test)
    const uint32_t OPAMP_OPAMP2_CSR_TSTREF = 1U << 29 ;

  // Field CALOUT: Operational amplifier calibration output
    const uint32_t OPAMP_OPAMP2_CSR_CALOUT = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OPAMP2_OTR: OPAMP2 offset trimming register in normal mode
  #define OPAMP_OPAMP2_OTR (* ((volatile uint32_t *) (0x40009000 + 20)))

  // Field TRIMOFFSETN: Trim for NMOS differential pairs
    inline uint32_t OPAMP_OPAMP2_OTR_TRIMOFFSETN (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field TRIMOFFSETP: Trim for PMOS differential pairs
    inline uint32_t OPAMP_OPAMP2_OTR_TRIMOFFSETP (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register OPAMP2_HSOTR: OPAMP2 offset trimming register in low-power mode
  #define OPAMP_OPAMP2_HSOTR (* ((volatile uint32_t *) (0x40009000 + 24)))

  // Field TRIMLPOFFSETN: Trim for NMOS differential pairs
    inline uint32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETN (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field TRIMLPOFFSETP: Trim for PMOS differential pairs
    inline uint32_t OPAMP_OPAMP2_HSOTR_TRIMLPOFFSETP (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

//------------------------------------------------------------------------------
// Peripheral OTG1_HS_DEVICE: USB 1 on the go high speed
//------------------------------------------------------------------------------

//---  Register OTG_HS_DCFG: OTG_HS device configuration register
  #define OTG1_HS_DEVICE_OTG_HS_DCFG (* ((volatile uint32_t *) (0x40040800 + 0)))

  // Field DSPD: Device speed
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_DSPD (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field NZLSOHSK: Nonzero-length status OUT handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK = 1U << 2 ;

  // Field DAD: Device address
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 4 ; }

  // Field PFIVL: Periodic (micro)frame interval
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_PFIVL (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field PERSCHIVL: Periodic scheduling interval
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DCTL: OTG_HS device control register
  #define OTG1_HS_DEVICE_OTG_HS_DCTL (* ((volatile uint32_t *) (0x40040800 + 4)))

  // Field RWUSIG: Remote wakeup signaling
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_RWUSIG = 1U << 0 ;

  // Field SDIS: Soft disconnect
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SDIS = 1U << 1 ;

  // Field GINSTS: Global IN NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_GINSTS = 1U << 2 ;

  // Field GONSTS: Global OUT NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_GONSTS = 1U << 3 ;

  // Field TCTL: Test control
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_TCTL (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SGINAK: Set global IN NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SGINAK = 1U << 7 ;

  // Field CGINAK: Clear global IN NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_CGINAK = 1U << 8 ;

  // Field SGONAK: Set global OUT NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_SGONAK = 1U << 9 ;

  // Field CGONAK: Clear global OUT NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_CGONAK = 1U << 10 ;

  // Field POPRGDNE: Power-on programming done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DCTL_POPRGDNE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DSTS: OTG_HS device status register
  #define OTG1_HS_DEVICE_OTG_HS_DSTS (* ((const volatile uint32_t *) (0x40040800 + 8)))

  // Field SUSPSTS: Suspend status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_SUSPSTS = 1U << 0 ;

  // Field ENUMSPD: Enumerated speed
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_ENUMSPD (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field EERR: Erratic error
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_EERR = 1U << 3 ;

  // Field FNSOF: Frame number of the received SOF
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DSTS_FNSOF (const uint32_t inValue) {return (inValue & 0x3FFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPMSK: OTG_HS device IN endpoint common interrupt mask register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPMSK (* ((volatile uint32_t *) (0x40040800 + 16)))

  // Field XFRCM: Transfer completed interrupt mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM = 1U << 0 ;

  // Field EPDM: Endpoint disabled interrupt mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_EPDM = 1U << 1 ;

  // Field TOM: Timeout condition mask (nonisochronous endpoints)
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TOM = 1U << 3 ;

  // Field ITTXFEMSK: IN token received when TxFIFO empty mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK = 1U << 4 ;

  // Field INEPNMM: IN token received with EP mismatch mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM = 1U << 5 ;

  // Field INEPNEM: IN endpoint NAK effective mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM = 1U << 6 ;

  // Field TXFURM: FIFO underrun mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM = 1U << 8 ;

  // Field BIM: BNA interrupt mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPMSK_BIM = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPMSK: OTG_HS device OUT endpoint common interrupt mask register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPMSK (* ((volatile uint32_t *) (0x40040800 + 20)))

  // Field XFRCM: Transfer completed interrupt mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM = 1U << 0 ;

  // Field EPDM: Endpoint disabled interrupt mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_EPDM = 1U << 1 ;

  // Field STUPM: SETUP phase done mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_STUPM = 1U << 3 ;

  // Field OTEPDM: OUT token received when endpoint disabled mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP = 1U << 6 ;

  // Field OPEM: OUT packet error mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_OPEM = 1U << 8 ;

  // Field BOIM: BNA interrupt mask
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPMSK_BOIM = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DAINT: OTG_HS device all endpoints interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DAINT (* ((const volatile uint32_t *) (0x40040800 + 24)))

  // Field IEPINT: IN endpoint interrupt bits
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DAINT_IEPINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field OEPINT: OUT endpoint interrupt bits
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DAINT_OEPINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DAINTMSK: OTG_HS all endpoints interrupt mask register
  #define OTG1_HS_DEVICE_OTG_HS_DAINTMSK (* ((volatile uint32_t *) (0x40040800 + 28)))

  // Field IEPM: IN EP interrupt mask bits
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_IEPM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field OEPM: OUT EP interrupt mask bits
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DAINTMSK_OEPM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DVBUSDIS: OTG_HS device VBUS discharge time register
  #define OTG1_HS_DEVICE_OTG_HS_DVBUSDIS (* ((volatile uint32_t *) (0x40040800 + 40)))

  // Field VBUSDT: Device VBUS discharge time
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DVBUSPULSE: OTG_HS device VBUS pulsing time register
  #define OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE (* ((volatile uint32_t *) (0x40040800 + 44)))

  // Field DVBUSP: Device VBUS pulsing time
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTHRCTL: OTG_HS Device threshold control register
  #define OTG1_HS_DEVICE_OTG_HS_DTHRCTL (* ((volatile uint32_t *) (0x40040800 + 48)))

  // Field NONISOTHREN: Nonisochronous IN endpoints threshold enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN = 1U << 0 ;

  // Field ISOTHREN: ISO IN endpoint threshold enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN = 1U << 1 ;

  // Field TXTHRLEN: Transmit threshold length
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN (const uint32_t inValue) {return (inValue & 0x1FFU) << 2 ; }

  // Field RXTHREN: Receive threshold enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN = 1U << 16 ;

  // Field RXTHRLEN: Receive threshold length
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN (const uint32_t inValue) {return (inValue & 0x1FFU) << 17 ; }

  // Field ARPEN: Arbiter parking enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPEMPMSK: OTG_HS device IN endpoint FIFO empty interrupt mask register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK (* ((volatile uint32_t *) (0x40040800 + 52)))

  // Field INEPTXFEM: IN EP Tx FIFO empty interrupt mask bits
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DEACHINT: OTG_HS device each endpoint interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DEACHINT (* ((volatile uint32_t *) (0x40040800 + 56)))

  // Field IEP1INT: IN endpoint 1interrupt bit
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT = 1U << 1 ;

  // Field OEP1INT: OUT endpoint 1 interrupt bit
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DEACHINTMSK: OTG_HS device each endpoint interrupt register mask
  #define OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK (* ((volatile uint32_t *) (0x40040800 + 60)))

  // Field IEP1INTM: IN Endpoint 1 interrupt mask bit
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM = 1U << 1 ;

  // Field OEP1INTM: OUT Endpoint 1 interrupt mask bit
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL0: OTG device endpoint-0 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL0 (* ((volatile uint32_t *) (0x40040800 + 256)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL0_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL1: OTG device endpoint-1 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL1 (* ((volatile uint32_t *) (0x40040800 + 288)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL1_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL2: OTG device endpoint-2 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL2 (* ((volatile uint32_t *) (0x40040800 + 320)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL2_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL3: OTG device endpoint-3 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL3 (* ((volatile uint32_t *) (0x40040800 + 352)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL3_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL4: OTG device endpoint-4 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL4 (* ((volatile uint32_t *) (0x40040800 + 384)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL4_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL5: OTG device endpoint-5 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL5 (* ((volatile uint32_t *) (0x40040800 + 416)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL5_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL6: OTG device endpoint-6 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL6 (* ((volatile uint32_t *) (0x40040800 + 448)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL6_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL7: OTG device endpoint-7 control register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPCTL7 (* ((volatile uint32_t *) (0x40040800 + 480)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPCTL7_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT0: OTG device endpoint-0 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT0 (* ((volatile uint32_t *) (0x40040800 + 264)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT0_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT1: OTG device endpoint-1 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT1 (* ((volatile uint32_t *) (0x40040800 + 296)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT1_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT2: OTG device endpoint-2 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT2 (* ((volatile uint32_t *) (0x40040800 + 328)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT2_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT3: OTG device endpoint-3 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT3 (* ((volatile uint32_t *) (0x40040800 + 360)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT3_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT4: OTG device endpoint-4 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT4 (* ((volatile uint32_t *) (0x40040800 + 392)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT4_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT5: OTG device endpoint-5 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT5 (* ((volatile uint32_t *) (0x40040800 + 424)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT5_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT6: OTG device endpoint-6 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT6 (* ((volatile uint32_t *) (0x40040800 + 456)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT6_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT7: OTG device endpoint-7 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPINT7 (* ((volatile uint32_t *) (0x40040800 + 488)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPINT7_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ0: OTG_HS device IN endpoint 0 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0 (* ((volatile uint32_t *) (0x40040800 + 272)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA1: OTG_HS device endpoint-1 DMA address register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPDMA1 (* ((volatile uint32_t *) (0x40040800 + 276)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMA1_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA2: OTG_HS device endpoint-2 DMA address register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPDMA2 (* ((volatile uint32_t *) (0x40040800 + 308)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMA2_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA3: OTG_HS device endpoint-3 DMA address register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPDMA3 (* ((volatile uint32_t *) (0x40040800 + 340)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMA3_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA4: OTG_HS device endpoint-4 DMA address register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPDMA4 (* ((volatile uint32_t *) (0x40040800 + 372)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMA4_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA5: OTG_HS device endpoint-5 DMA address register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPDMA5 (* ((volatile uint32_t *) (0x40040800 + 404)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPDMA5_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS0: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS0 (* ((const volatile uint32_t *) (0x40040800 + 280)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS1: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS1 (* ((const volatile uint32_t *) (0x40040800 + 312)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS2: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS2 (* ((const volatile uint32_t *) (0x40040800 + 344)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS3: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS3 (* ((const volatile uint32_t *) (0x40040800 + 376)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS4: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS4 (* ((const volatile uint32_t *) (0x40040800 + 408)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS5: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS5 (* ((const volatile uint32_t *) (0x40040800 + 440)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ1: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1 (* ((volatile uint32_t *) (0x40040800 + 304)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ2: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2 (* ((volatile uint32_t *) (0x40040800 + 336)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ3: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3 (* ((volatile uint32_t *) (0x40040800 + 368)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ4: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4 (* ((volatile uint32_t *) (0x40040800 + 400)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ5: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5 (* ((volatile uint32_t *) (0x40040800 + 432)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL0: OTG_HS device control OUT endpoint 0 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL0 (* ((volatile uint32_t *) (0x40040800 + 768)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP = 1U << 15 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK = 1U << 27 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL1: OTG device endpoint-1 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL1 (* ((volatile uint32_t *) (0x40040800 + 800)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL2: OTG device endpoint-2 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL2 (* ((volatile uint32_t *) (0x40040800 + 832)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL3: OTG device endpoint-3 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL3 (* ((volatile uint32_t *) (0x40040800 + 864)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT0: OTG_HS device endpoint-0 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT0 (* ((volatile uint32_t *) (0x40040800 + 776)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT0_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT0_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT0_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT0_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT0_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT0_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT1: OTG_HS device endpoint-1 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT1 (* ((volatile uint32_t *) (0x40040800 + 808)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT1_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT1_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT1_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT1_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT1_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT1_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT2: OTG_HS device endpoint-2 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT2 (* ((volatile uint32_t *) (0x40040800 + 840)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT2_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT2_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT2_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT2_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT2_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT2_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT3: OTG_HS device endpoint-3 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT3 (* ((volatile uint32_t *) (0x40040800 + 872)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT3_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT3_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT3_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT3_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT3_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT3_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT4: OTG_HS device endpoint-4 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT4 (* ((volatile uint32_t *) (0x40040800 + 904)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT4_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT4_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT4_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT4_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT4_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT4_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT5: OTG_HS device endpoint-5 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT5 (* ((volatile uint32_t *) (0x40040800 + 936)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT5_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT5_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT5_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT5_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT5_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT5_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT6: OTG_HS device endpoint-6 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT6 (* ((volatile uint32_t *) (0x40040800 + 968)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT6_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT6_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT6_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT6_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT6_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT6_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT7: OTG_HS device endpoint-7 interrupt register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPINT7 (* ((volatile uint32_t *) (0x40040800 + 1000)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT7_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT7_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT7_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT7_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT7_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPINT7_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ0: OTG_HS device endpoint-0 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0 (* ((volatile uint32_t *) (0x40040800 + 784)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field PKTCNT: Packet count
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT = 1U << 19 ;

  // Field STUPCNT: SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ1: OTG_HS device endpoint-1 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1 (* ((volatile uint32_t *) (0x40040800 + 816)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ2: OTG_HS device endpoint-2 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2 (* ((volatile uint32_t *) (0x40040800 + 848)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ3: OTG_HS device endpoint-3 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3 (* ((volatile uint32_t *) (0x40040800 + 880)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ4: OTG_HS device endpoint-4 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4 (* ((volatile uint32_t *) (0x40040800 + 912)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ6: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6 (* ((volatile uint32_t *) (0x40040800 + 416)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS6: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS6 (* ((volatile uint32_t *) (0x40040800 + 420)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ7: OTG_HS device endpoint transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7 (* ((volatile uint32_t *) (0x40040800 + 424)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS7: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG1_HS_DEVICE_OTG_HS_DTXFSTS7 (* ((volatile uint32_t *) (0x40040800 + 428)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL4: OTG device endpoint-4 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL4 (* ((volatile uint32_t *) (0x40040800 + 896)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL5: OTG device endpoint-5 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL5 (* ((volatile uint32_t *) (0x40040800 + 928)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL6: OTG device endpoint-6 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL6 (* ((volatile uint32_t *) (0x40040800 + 960)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL7: OTG device endpoint-7 control register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPCTL7 (* ((volatile uint32_t *) (0x40040800 + 992)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ5: OTG_HS device endpoint-5 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5 (* ((volatile uint32_t *) (0x40040800 + 944)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ6: OTG_HS device endpoint-6 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6 (* ((volatile uint32_t *) (0x40040800 + 976)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ7: OTG_HS device endpoint-7 transfer size register
  #define OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7 (* ((volatile uint32_t *) (0x40040800 + 1008)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG1_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------
// Peripheral OTG1_HS_GLOBAL: USB 1 on the go high speed
//------------------------------------------------------------------------------

//---  Register OTG_HS_GOTGCTL: OTG_HS control and status register
  #define OTG1_HS_GLOBAL_OTG_HS_GOTGCTL (* ((volatile uint32_t *) (0x40040000 + 0)))

  // Field SRQSCS: Session request success
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS = 1U << 0 ;

  // Field SRQ: Session request
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ = 1U << 1 ;

  // Field HNGSCS: Host negotiation success
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS = 1U << 8 ;

  // Field HNPRQ: HNP request
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ = 1U << 9 ;

  // Field HSHNPEN: Host set HNP enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN = 1U << 10 ;

  // Field DHNPEN: Device HNP enabled
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN = 1U << 11 ;

  // Field CIDSTS: Connector ID status
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS = 1U << 16 ;

  // Field DBCT: Long/short debounce time
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT = 1U << 17 ;

  // Field ASVLD: A-session valid
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD = 1U << 18 ;

  // Field BSVLD: B-session valid
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD = 1U << 19 ;

  // Field EHEN: Embedded host enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN = 1U << 12 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GOTGINT: OTG_HS interrupt register
  #define OTG1_HS_GLOBAL_OTG_HS_GOTGINT (* ((volatile uint32_t *) (0x40040000 + 4)))

  // Field SEDET: Session end detected
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SEDET = 1U << 2 ;

  // Field SRSSCHG: Session request success status change
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG = 1U << 8 ;

  // Field HNSSCHG: Host negotiation success status change
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG = 1U << 9 ;

  // Field HNGDET: Host negotiation detected
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET = 1U << 17 ;

  // Field ADTOCHG: A-device timeout change
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG = 1U << 18 ;

  // Field DBCDNE: Debounce done
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE = 1U << 19 ;

  // Field IDCHNG: ID input pin changed
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GAHBCFG: OTG_HS AHB configuration register
  #define OTG1_HS_GLOBAL_OTG_HS_GAHBCFG (* ((volatile uint32_t *) (0x40040000 + 8)))

  // Field GINT: Global interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_GINT = 1U << 0 ;

  // Field HBSTLEN: Burst length/type
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field DMAEN: DMA enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN = 1U << 5 ;

  // Field TXFELVL: TxFIFO empty level
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL = 1U << 7 ;

  // Field PTXFELVL: Periodic TxFIFO empty level
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GUSBCFG: OTG_HS USB configuration register
  #define OTG1_HS_GLOBAL_OTG_HS_GUSBCFG (* ((volatile uint32_t *) (0x40040000 + 12)))

  // Field TOCAL: FS timeout calibration
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field PHYSEL: USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL = 1U << 6 ;

  // Field SRPCAP: SRP-capable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP = 1U << 8 ;

  // Field HNPCAP: HNP-capable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP = 1U << 9 ;

  // Field TRDT: USB turnaround time
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT (const uint32_t inValue) {return (inValue & 0xFU) << 10 ; }

  // Field PHYLPCS: PHY Low-power clock select
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS = 1U << 15 ;

  // Field ULPIFSLS: ULPI FS/LS select
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS = 1U << 17 ;

  // Field ULPIAR: ULPI Auto-resume
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR = 1U << 18 ;

  // Field ULPICSM: ULPI Clock SuspendM
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM = 1U << 19 ;

  // Field ULPIEVBUSD: ULPI External VBUS Drive
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD = 1U << 20 ;

  // Field ULPIEVBUSI: ULPI external VBUS indicator
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI = 1U << 21 ;

  // Field TSDPS: TermSel DLine pulsing selection
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS = 1U << 22 ;

  // Field PCCI: Indicator complement
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI = 1U << 23 ;

  // Field PTCI: Indicator pass through
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI = 1U << 24 ;

  // Field ULPIIPD: ULPI interface protect disable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD = 1U << 25 ;

  // Field FHMOD: Forced host mode
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD = 1U << 29 ;

  // Field FDMOD: Forced peripheral mode
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRSTCTL: OTG_HS reset register
  #define OTG1_HS_GLOBAL_OTG_HS_GRSTCTL (* ((volatile uint32_t *) (0x40040000 + 16)))

  // Field CSRST: Core soft reset
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST = 1U << 0 ;

  // Field HSRST: HCLK soft reset
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST = 1U << 1 ;

  // Field FCRST: Host frame counter reset
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST = 1U << 2 ;

  // Field RXFFLSH: RxFIFO flush
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH = 1U << 4 ;

  // Field TXFFLSH: TxFIFO flush
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH = 1U << 5 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field AHBIDL: AHB master idle
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL = 1U << 31 ;

  // Field DMAREQ: DMA request signal enabled for USB OTG HS
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GINTSTS: OTG_HS core interrupt register
  #define OTG1_HS_GLOBAL_OTG_HS_GINTSTS (* ((volatile uint32_t *) (0x40040000 + 20)))

  // Field CMOD: Current mode of operation
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CMOD = 1U << 0 ;

  // Field MMIS: Mode mismatch interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_MMIS = 1U << 1 ;

  // Field OTGINT: OTG interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT = 1U << 2 ;

  // Field SOF: Start of frame
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SOF = 1U << 3 ;

  // Field RXFLVL: RxFIFO nonempty
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL = 1U << 4 ;

  // Field NPTXFE: Nonperiodic TxFIFO empty
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE = 1U << 5 ;

  // Field GINAKEFF: Global IN nonperiodic NAK effective
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF = 1U << 6 ;

  // Field BOUTNAKEFF: Global OUT NAK effective
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF = 1U << 7 ;

  // Field ESUSP: Early suspend
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP = 1U << 10 ;

  // Field USBSUSP: USB suspend
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP = 1U << 11 ;

  // Field USBRST: USB reset
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_USBRST = 1U << 12 ;

  // Field ENUMDNE: Enumeration done
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE = 1U << 13 ;

  // Field ISOODRP: Isochronous OUT packet dropped interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP = 1U << 14 ;

  // Field EOPF: End of periodic frame interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_EOPF = 1U << 15 ;

  // Field IEPINT: IN endpoint interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT = 1U << 18 ;

  // Field OEPINT: OUT endpoint interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT = 1U << 19 ;

  // Field IISOIXFR: Incomplete isochronous IN transfer
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR = 1U << 20 ;

  // Field PXFR_INCOMPISOOUT: Incomplete periodic transfer
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 1U << 21 ;

  // Field DATAFSUSP: Data fetch suspended
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP = 1U << 22 ;

  // Field HPRTINT: Host port interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT = 1U << 24 ;

  // Field HCINT: Host channels interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_HCINT = 1U << 25 ;

  // Field PTXFE: Periodic TxFIFO empty
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE = 1U << 26 ;

  // Field CIDSCHG: Connector ID status change
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG = 1U << 28 ;

  // Field DISCINT: Disconnect detected interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT = 1U << 29 ;

  // Field SRQINT: Session request/new session detected interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT = 1U << 30 ;

  // Field WKUINT: Resume/remote wakeup detected interrupt
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GINTMSK: OTG_HS interrupt mask register
  #define OTG1_HS_GLOBAL_OTG_HS_GINTMSK (* ((volatile uint32_t *) (0x40040000 + 24)))

  // Field MMISM: Mode mismatch interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_MMISM = 1U << 1 ;

  // Field OTGINT: OTG interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT = 1U << 2 ;

  // Field SOFM: Start of frame mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SOFM = 1U << 3 ;

  // Field RXFLVLM: Receive FIFO nonempty mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM = 1U << 4 ;

  // Field NPTXFEM: Nonperiodic TxFIFO empty mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM = 1U << 5 ;

  // Field GINAKEFFM: Global nonperiodic IN NAK effective mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM = 1U << 6 ;

  // Field GONAKEFFM: Global OUT NAK effective mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM = 1U << 7 ;

  // Field ESUSPM: Early suspend mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM = 1U << 10 ;

  // Field USBSUSPM: USB suspend mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM = 1U << 11 ;

  // Field USBRST: USB reset mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_USBRST = 1U << 12 ;

  // Field ENUMDNEM: Enumeration done mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM = 1U << 13 ;

  // Field ISOODRPM: Isochronous OUT packet dropped interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM = 1U << 14 ;

  // Field EOPFM: End of periodic frame interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM = 1U << 15 ;

  // Field IEPINT: IN endpoints interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT = 1U << 18 ;

  // Field OEPINT: OUT endpoints interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT = 1U << 19 ;

  // Field IISOIXFRM: Incomplete isochronous IN transfer mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM = 1U << 20 ;

  // Field PXFRM_IISOOXFRM: Incomplete periodic transfer mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 1U << 21 ;

  // Field FSUSPM: Data fetch suspended mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM = 1U << 22 ;

  // Field PRTIM: Host port interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM = 1U << 24 ;

  // Field HCIM: Host channels interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_HCIM = 1U << 25 ;

  // Field PTXFEM: Periodic TxFIFO empty mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM = 1U << 26 ;

  // Field CIDSCHGM: Connector ID status change mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM = 1U << 28 ;

  // Field DISCINT: Disconnect detected interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT = 1U << 29 ;

  // Field SRQIM: Session request/new session detected interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM = 1U << 30 ;

  // Field WUIM: Resume/remote wakeup detected interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_WUIM = 1U << 31 ;

  // Field RSTDE: Reset detected interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE = 1U << 23 ;

  // Field LPMINTM: LPM interrupt mask
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSR_Host: OTG_HS Receive status debug read register (host mode)
  #define OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host (* ((const volatile uint32_t *) (0x40040000 + 28)))

  // Field CHNUM: Channel number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_CHNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Host_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSP_Host: OTG_HS status read and pop register (host mode)
  #define OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host (* ((const volatile uint32_t *) (0x40040000 + 32)))

  // Field CHNUM: Channel number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_CHNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Host_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXFSIZ: OTG_HS Receive FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ (* ((volatile uint32_t *) (0x40040000 + 36)))

  // Field RXFD: RxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HNPTXFSIZ_Host: OTG_HS nonperiodic transmit FIFO size register (host mode)
  #define OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host (* ((volatile uint32_t *) (0x40040000 + 40)))

  // Field NPTXFSA: Nonperiodic transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field NPTXFD: Nonperiodic TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF0_Device: Endpoint 0 transmit FIFO size (peripheral mode)
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_Device (* ((volatile uint32_t *) (0x40040000 + 40)))

  // Field TX0FSA: Endpoint 0 transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field TX0FD: Endpoint 0 TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GNPTXSTS: OTG_HS nonperiodic transmit FIFO/queue status register
  #define OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS (* ((const volatile uint32_t *) (0x40040000 + 44)))

  // Field NPTXFSAV: Nonperiodic TxFIFO space available
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field NPTQXSAV: Nonperiodic transmit request queue space available
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field NPTXQTOP: Top of the nonperiodic transmit request queue
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GCCFG: OTG_HS general core configuration register
  #define OTG1_HS_GLOBAL_OTG_HS_GCCFG (* ((volatile uint32_t *) (0x40040000 + 56)))

  // Field PWRDWN: Power down
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN = 1U << 16 ;

  // Field BCDEN: Battery charging detector (BCD) enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_BCDEN = 1U << 17 ;

  // Field DCDEN: Data contact detection (DCD) mode enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDEN = 1U << 18 ;

  // Field PDEN: Primary detection (PD) mode enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDEN = 1U << 19 ;

  // Field SDEN: Secondary detection (SD) mode enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDEN = 1U << 20 ;

  // Field VBDEN: USB VBUS detection enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_VBDEN = 1U << 21 ;

  // Field DCDET: Data contact detection (DCD) status
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_DCDET = 1U << 0 ;

  // Field PDET: Primary detection (PD) status
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PDET = 1U << 1 ;

  // Field SDET: Secondary detection (SD) status
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_SDET = 1U << 2 ;

  // Field PS2DET: DM pull-up detection status
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GCCFG_PS2DET = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_CID: OTG_HS core ID register
  #define OTG1_HS_GLOBAL_OTG_HS_CID (* ((volatile uint32_t *) (0x40040000 + 60)))

  // Field PRODUCT_ID: Product ID field
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_CID_PRODUCT_ID (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HPTXFSIZ: OTG_HS Host periodic transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ (* ((volatile uint32_t *) (0x40040000 + 256)))

  // Field PTXSA: Host periodic TxFIFO start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field PTXFD: Host periodic TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF1: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1 (* ((volatile uint32_t *) (0x40040000 + 260)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF2: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2 (* ((volatile uint32_t *) (0x40040000 + 264)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF3: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3 (* ((volatile uint32_t *) (0x40040000 + 284)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF4: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4 (* ((volatile uint32_t *) (0x40040000 + 288)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF5: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5 (* ((volatile uint32_t *) (0x40040000 + 292)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF6: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6 (* ((volatile uint32_t *) (0x40040000 + 296)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF7: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7 (* ((volatile uint32_t *) (0x40040000 + 300)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSR_Device: OTG_HS Receive status debug read register (peripheral mode mode)
  #define OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device (* ((const volatile uint32_t *) (0x40040000 + 28)))

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

  // Field FRMNUM: Frame number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSR_Device_FRMNUM (const uint32_t inValue) {return (inValue & 0xFU) << 21 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSP_Device: OTG_HS status read and pop register (peripheral mode)
  #define OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device (* ((const volatile uint32_t *) (0x40040000 + 32)))

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

  // Field FRMNUM: Frame number
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GRXSTSP_Device_FRMNUM (const uint32_t inValue) {return (inValue & 0xFU) << 21 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GLPMCFG: OTG core LPM configuration register
  #define OTG1_HS_GLOBAL_OTG_HS_GLPMCFG (* ((volatile uint32_t *) (0x40040000 + 84)))

  // Field LPMEN: LPM support enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN = 1U << 0 ;

  // Field LPMACK: LPM token acknowledge enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK = 1U << 1 ;

  // Field BESL: Best effort service latency
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESL (const uint32_t inValue) {return (inValue & 0xFU) << 2 ; }

  // Field REMWAKE: bRemoteWake value
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE = 1U << 6 ;

  // Field L1SSEN: L1 Shallow Sleep enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN = 1U << 7 ;

  // Field BESLTHRS: BESL threshold
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field L1DSEN: L1 deep sleep enable
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN = 1U << 12 ;

  // Field LPMRST: LPM response
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field SLPSTS: Port sleep status
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS = 1U << 15 ;

  // Field L1RSMOK: Sleep State Resume OK
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK = 1U << 16 ;

  // Field LPMCHIDX: LPM Channel Index
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

  // Field LPMRCNT: LPM retry count
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SNDLPM: Send LPM transaction
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM = 1U << 24 ;

  // Field LPMRCNTSTS: LPM retry count status
    inline uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field ENBESL: Enable best effort service latency
    const uint32_t OTG1_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL = 1U << 28 ;

//------------------------------------------------------------------------------
// Peripheral OTG1_HS_HOST: USB 1 on the go high speed
//------------------------------------------------------------------------------

//---  Register OTG_HS_HCFG: OTG_HS host configuration register
  #define OTG1_HS_HOST_OTG_HS_HCFG (* ((volatile uint32_t *) (0x40040400 + 0)))

  // Field FSLSPCS: FS/LS PHY clock select
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCFG_FSLSPCS (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field FSLSS: FS- and LS-only support
    const uint32_t OTG1_HS_HOST_OTG_HS_HCFG_FSLSS = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HFIR: OTG_HS Host frame interval register
  #define OTG1_HS_HOST_OTG_HS_HFIR (* ((volatile uint32_t *) (0x40040400 + 4)))

  // Field FRIVL: Frame interval
    inline uint32_t OTG1_HS_HOST_OTG_HS_HFIR_FRIVL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HFNUM: OTG_HS host frame number/frame time remaining register
  #define OTG1_HS_HOST_OTG_HS_HFNUM (* ((const volatile uint32_t *) (0x40040400 + 8)))

  // Field FRNUM: Frame number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HFNUM_FRNUM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field FTREM: Frame time remaining
    inline uint32_t OTG1_HS_HOST_OTG_HS_HFNUM_FTREM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HPTXSTS: OTG_HS_Host periodic transmit FIFO/queue status register
  #define OTG1_HS_HOST_OTG_HS_HPTXSTS (* ((volatile uint32_t *) (0x40040400 + 16)))

  // Field PTXFSAVL: Periodic transmit data FIFO space available
    inline uint32_t OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field PTXQSAV: Periodic transmit request queue space available
    inline uint32_t OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field PTXQTOP: Top of the periodic transmit request queue
    inline uint32_t OTG1_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HAINT: OTG_HS Host all channels interrupt register
  #define OTG1_HS_HOST_OTG_HS_HAINT (* ((const volatile uint32_t *) (0x40040400 + 20)))

  // Field HAINT: Channel interrupts
    inline uint32_t OTG1_HS_HOST_OTG_HS_HAINT_HAINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HAINTMSK: OTG_HS host all channels interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HAINTMSK (* ((volatile uint32_t *) (0x40040400 + 24)))

  // Field HAINTM: Channel interrupt mask
    inline uint32_t OTG1_HS_HOST_OTG_HS_HAINTMSK_HAINTM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HPRT: OTG_HS host port control and status register
  #define OTG1_HS_HOST_OTG_HS_HPRT (* ((volatile uint32_t *) (0x40040400 + 64)))

  // Field PCSTS: Port connect status
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PCSTS = 1U << 0 ;

  // Field PCDET: Port connect detected
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PCDET = 1U << 1 ;

  // Field PENA: Port enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PENA = 1U << 2 ;

  // Field PENCHNG: Port enable/disable change
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PENCHNG = 1U << 3 ;

  // Field POCA: Port overcurrent active
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_POCA = 1U << 4 ;

  // Field POCCHNG: Port overcurrent change
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_POCCHNG = 1U << 5 ;

  // Field PRES: Port resume
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PRES = 1U << 6 ;

  // Field PSUSP: Port suspend
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PSUSP = 1U << 7 ;

  // Field PRST: Port reset
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PRST = 1U << 8 ;

  // Field PLSTS: Port line status
    inline uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PLSTS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PPWR: Port power
    const uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PPWR = 1U << 12 ;

  // Field PTCTL: Port test control
    inline uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PTCTL (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field PSPD: Port speed
    inline uint32_t OTG1_HS_HOST_OTG_HS_HPRT_PSPD (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR0: OTG_HS host channel-0 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR0 (* ((volatile uint32_t *) (0x40040400 + 256)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR0_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR1: OTG_HS host channel-1 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR1 (* ((volatile uint32_t *) (0x40040400 + 288)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR1_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR2: OTG_HS host channel-2 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR2 (* ((volatile uint32_t *) (0x40040400 + 320)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR2_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR3: OTG_HS host channel-3 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR3 (* ((volatile uint32_t *) (0x40040400 + 352)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR3_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR4: OTG_HS host channel-4 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR4 (* ((volatile uint32_t *) (0x40040400 + 384)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR4_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR5: OTG_HS host channel-5 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR5 (* ((volatile uint32_t *) (0x40040400 + 416)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR5_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR6: OTG_HS host channel-6 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR6 (* ((volatile uint32_t *) (0x40040400 + 448)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR6_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR7: OTG_HS host channel-7 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR7 (* ((volatile uint32_t *) (0x40040400 + 480)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR7_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR8: OTG_HS host channel-8 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR8 (* ((volatile uint32_t *) (0x40040400 + 512)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR8_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR9: OTG_HS host channel-9 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR9 (* ((volatile uint32_t *) (0x40040400 + 544)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR9_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR10: OTG_HS host channel-10 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR10 (* ((volatile uint32_t *) (0x40040400 + 576)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR10_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR11: OTG_HS host channel-11 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR11 (* ((volatile uint32_t *) (0x40040400 + 608)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR11_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT0: OTG_HS host channel-0 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT0 (* ((volatile uint32_t *) (0x40040400 + 260)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT0_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT0_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT0_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT0_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT0_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT1: OTG_HS host channel-1 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT1 (* ((volatile uint32_t *) (0x40040400 + 292)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT1_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT1_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT1_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT1_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT1_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT2: OTG_HS host channel-2 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT2 (* ((volatile uint32_t *) (0x40040400 + 324)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT2_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT2_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT2_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT2_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT2_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT3: OTG_HS host channel-3 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT3 (* ((volatile uint32_t *) (0x40040400 + 356)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT3_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT3_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT3_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT3_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT3_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT4: OTG_HS host channel-4 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT4 (* ((volatile uint32_t *) (0x40040400 + 388)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT4_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT4_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT4_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT4_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT4_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT5: OTG_HS host channel-5 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT5 (* ((volatile uint32_t *) (0x40040400 + 420)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT5_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT5_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT5_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT5_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT5_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT6: OTG_HS host channel-6 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT6 (* ((volatile uint32_t *) (0x40040400 + 452)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT6_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT6_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT6_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT6_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT6_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT7: OTG_HS host channel-7 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT7 (* ((volatile uint32_t *) (0x40040400 + 484)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT7_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT7_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT7_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT7_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT7_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT8: OTG_HS host channel-8 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT8 (* ((volatile uint32_t *) (0x40040400 + 516)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT8_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT8_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT8_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT8_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT8_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT9: OTG_HS host channel-9 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT9 (* ((volatile uint32_t *) (0x40040400 + 548)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT9_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT9_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT9_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT9_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT9_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT10: OTG_HS host channel-10 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT10 (* ((volatile uint32_t *) (0x40040400 + 580)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT10_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT10_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT10_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT10_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT10_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT11: OTG_HS host channel-11 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT11 (* ((volatile uint32_t *) (0x40040400 + 612)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT11_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT11_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT11_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT11_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT11_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT0: OTG_HS host channel-11 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT0 (* ((volatile uint32_t *) (0x40040400 + 264)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT0_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT1: OTG_HS host channel-1 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT1 (* ((volatile uint32_t *) (0x40040400 + 296)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT1_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT2: OTG_HS host channel-2 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT2 (* ((volatile uint32_t *) (0x40040400 + 328)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT2_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT3: OTG_HS host channel-3 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT3 (* ((volatile uint32_t *) (0x40040400 + 360)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT3_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT4: OTG_HS host channel-4 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT4 (* ((volatile uint32_t *) (0x40040400 + 392)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT4_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT5: OTG_HS host channel-5 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT5 (* ((volatile uint32_t *) (0x40040400 + 424)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT5_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT6: OTG_HS host channel-6 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT6 (* ((volatile uint32_t *) (0x40040400 + 456)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT6_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT7: OTG_HS host channel-7 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT7 (* ((volatile uint32_t *) (0x40040400 + 488)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT7_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT8: OTG_HS host channel-8 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT8 (* ((volatile uint32_t *) (0x40040400 + 520)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT8_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT9: OTG_HS host channel-9 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT9 (* ((volatile uint32_t *) (0x40040400 + 552)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT9_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT10: OTG_HS host channel-10 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT10 (* ((volatile uint32_t *) (0x40040400 + 584)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT10_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT11: OTG_HS host channel-11 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT11 (* ((volatile uint32_t *) (0x40040400 + 616)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT11_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK0: OTG_HS host channel-11 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK0 (* ((volatile uint32_t *) (0x40040400 + 268)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK0_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK1: OTG_HS host channel-1 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK1 (* ((volatile uint32_t *) (0x40040400 + 300)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK1_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK2: OTG_HS host channel-2 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK2 (* ((volatile uint32_t *) (0x40040400 + 332)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK2_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK3: OTG_HS host channel-3 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK3 (* ((volatile uint32_t *) (0x40040400 + 364)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK3_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK4: OTG_HS host channel-4 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK4 (* ((volatile uint32_t *) (0x40040400 + 396)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK4_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK5: OTG_HS host channel-5 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK5 (* ((volatile uint32_t *) (0x40040400 + 428)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK5_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK6: OTG_HS host channel-6 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK6 (* ((volatile uint32_t *) (0x40040400 + 460)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK6_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK7: OTG_HS host channel-7 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK7 (* ((volatile uint32_t *) (0x40040400 + 492)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK7_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK8: OTG_HS host channel-8 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK8 (* ((volatile uint32_t *) (0x40040400 + 524)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK8_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK9: OTG_HS host channel-9 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK9 (* ((volatile uint32_t *) (0x40040400 + 556)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK9_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK10: OTG_HS host channel-10 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK10 (* ((volatile uint32_t *) (0x40040400 + 588)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK10_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK11: OTG_HS host channel-11 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK11 (* ((volatile uint32_t *) (0x40040400 + 620)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK11_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ0: OTG_HS host channel-11 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ0 (* ((volatile uint32_t *) (0x40040400 + 272)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ0_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ1: OTG_HS host channel-1 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ1 (* ((volatile uint32_t *) (0x40040400 + 304)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ1_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ2: OTG_HS host channel-2 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ2 (* ((volatile uint32_t *) (0x40040400 + 336)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ2_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ3: OTG_HS host channel-3 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ3 (* ((volatile uint32_t *) (0x40040400 + 368)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ3_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ4: OTG_HS host channel-4 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ4 (* ((volatile uint32_t *) (0x40040400 + 400)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ4_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ5: OTG_HS host channel-5 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ5 (* ((volatile uint32_t *) (0x40040400 + 432)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ5_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ6: OTG_HS host channel-6 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ6 (* ((volatile uint32_t *) (0x40040400 + 464)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ6_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ7: OTG_HS host channel-7 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ7 (* ((volatile uint32_t *) (0x40040400 + 496)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ7_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ8: OTG_HS host channel-8 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ8 (* ((volatile uint32_t *) (0x40040400 + 528)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ8_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ9: OTG_HS host channel-9 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ9 (* ((volatile uint32_t *) (0x40040400 + 560)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ9_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ10: OTG_HS host channel-10 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ10 (* ((volatile uint32_t *) (0x40040400 + 592)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ10_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ11: OTG_HS host channel-11 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ11 (* ((volatile uint32_t *) (0x40040400 + 624)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ11_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA0: OTG_HS host channel-0 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA0 (* ((volatile uint32_t *) (0x40040400 + 276)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA0_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA1: OTG_HS host channel-1 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA1 (* ((volatile uint32_t *) (0x40040400 + 308)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA1_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA2: OTG_HS host channel-2 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA2 (* ((volatile uint32_t *) (0x40040400 + 340)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA2_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA3: OTG_HS host channel-3 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA3 (* ((volatile uint32_t *) (0x40040400 + 372)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA3_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA4: OTG_HS host channel-4 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA4 (* ((volatile uint32_t *) (0x40040400 + 404)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA4_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA5: OTG_HS host channel-5 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA5 (* ((volatile uint32_t *) (0x40040400 + 436)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA5_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA6: OTG_HS host channel-6 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA6 (* ((volatile uint32_t *) (0x40040400 + 468)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA6_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA7: OTG_HS host channel-7 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA7 (* ((volatile uint32_t *) (0x40040400 + 500)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA7_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA8: OTG_HS host channel-8 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA8 (* ((volatile uint32_t *) (0x40040400 + 532)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA8_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA9: OTG_HS host channel-9 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA9 (* ((volatile uint32_t *) (0x40040400 + 564)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA9_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA10: OTG_HS host channel-10 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA10 (* ((volatile uint32_t *) (0x40040400 + 596)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA10_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA11: OTG_HS host channel-11 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA11 (* ((volatile uint32_t *) (0x40040400 + 628)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA11_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR12: OTG_HS host channel-12 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR12 (* ((volatile uint32_t *) (0x40040400 + 632)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR12_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT12: OTG_HS host channel-12 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT12 (* ((volatile uint32_t *) (0x40040400 + 636)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT12_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT12_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT12_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT12_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT12_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT12: OTG_HS host channel-12 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT12 (* ((volatile uint32_t *) (0x40040400 + 640)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT12_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK12: OTG_HS host channel-12 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK12 (* ((volatile uint32_t *) (0x40040400 + 644)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK12_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ12: OTG_HS host channel-12 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ12 (* ((volatile uint32_t *) (0x40040400 + 648)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ12_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA12: OTG_HS host channel-12 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA12 (* ((volatile uint32_t *) (0x40040400 + 652)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA12_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR13: OTG_HS host channel-13 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR13 (* ((volatile uint32_t *) (0x40040400 + 656)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR13_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT13: OTG_HS host channel-13 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT13 (* ((volatile uint32_t *) (0x40040400 + 660)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT13_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT13_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT13_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT13_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT13_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT13: OTG_HS host channel-13 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT13 (* ((volatile uint32_t *) (0x40040400 + 664)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT13_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK13: OTG_HS host channel-13 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK13 (* ((volatile uint32_t *) (0x40040400 + 668)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_AHBERR = 1U << 2 ;

  // Field STALLM: STALLM response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK13_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ13: OTG_HS host channel-13 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ13 (* ((volatile uint32_t *) (0x40040400 + 672)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ13_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA13: OTG_HS host channel-13 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA13 (* ((volatile uint32_t *) (0x40040400 + 676)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA13_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR14: OTG_HS host channel-14 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR14 (* ((volatile uint32_t *) (0x40040400 + 680)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR14_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT14: OTG_HS host channel-14 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT14 (* ((volatile uint32_t *) (0x40040400 + 684)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT14_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT14_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT14_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT14_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT14_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT14: OTG_HS host channel-14 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT14 (* ((volatile uint32_t *) (0x40040400 + 688)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT14_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK14: OTG_HS host channel-14 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK14 (* ((volatile uint32_t *) (0x40040400 + 692)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_STALLM = 1U << 3 ;

  // Field NAKM: NAKM response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_NAKM = 1U << 4 ;

  // Field ACKM: ACKM response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK14_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ14: OTG_HS host channel-14 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ14 (* ((volatile uint32_t *) (0x40040400 + 696)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ14_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA14: OTG_HS host channel-14 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA14 (* ((volatile uint32_t *) (0x40040400 + 700)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA14_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR15: OTG_HS host channel-15 characteristics register
  #define OTG1_HS_HOST_OTG_HS_HCCHAR15 (* ((volatile uint32_t *) (0x40040400 + 704)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCCHAR15_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT15: OTG_HS host channel-15 split control register
  #define OTG1_HS_HOST_OTG_HS_HCSPLT15 (* ((volatile uint32_t *) (0x40040400 + 708)))

  // Field PRTADDR: Port address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT15_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT15_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT15_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT15_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG1_HS_HOST_OTG_HS_HCSPLT15_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT15: OTG_HS host channel-15 interrupt register
  #define OTG1_HS_HOST_OTG_HS_HCINT15 (* ((volatile uint32_t *) (0x40040400 + 712)))

  // Field XFRC: Transfer completed
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINT15_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK15: OTG_HS host channel-15 interrupt mask register
  #define OTG1_HS_HOST_OTG_HS_HCINTMSK15 (* ((volatile uint32_t *) (0x40040400 + 716)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_STALL = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG1_HS_HOST_OTG_HS_HCINTMSK15_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ15: OTG_HS host channel-15 transfer size register
  #define OTG1_HS_HOST_OTG_HS_HCTSIZ15 (* ((volatile uint32_t *) (0x40040400 + 720)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCTSIZ15_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA15: OTG_HS host channel-15 DMA address register
  #define OTG1_HS_HOST_OTG_HS_HCDMA15 (* ((volatile uint32_t *) (0x40040400 + 724)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG1_HS_HOST_OTG_HS_HCDMA15_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral OTG1_HS_PWRCLK: USB 1 on the go high speed
//------------------------------------------------------------------------------

//---  Register OTG_HS_PCGCR: Power and clock gating control register
  #define OTG1_HS_PWRCLK_OTG_HS_PCGCR (* ((volatile uint32_t *) (0x40040E00 + 0)))

  // Field STPPCLK: Stop PHY clock
    const uint32_t OTG1_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK = 1U << 0 ;

  // Field GATEHCLK: Gate HCLK
    const uint32_t OTG1_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK = 1U << 1 ;

  // Field PHYSUSP: PHY suspended
    const uint32_t OTG1_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP = 1U << 4 ;

//------------------------------------------------------------------------------
// Peripheral OTG2_HS_DEVICE
//------------------------------------------------------------------------------

//---  Register OTG_HS_DCFG: OTG_HS device configuration register
  #define OTG2_HS_DEVICE_OTG_HS_DCFG (* ((volatile uint32_t *) (0x40080800 + 0)))

  // Field DSPD: Device speed
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_DSPD (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field NZLSOHSK: Nonzero-length status OUT handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_NZLSOHSK = 1U << 2 ;

  // Field DAD: Device address
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 4 ; }

  // Field PFIVL: Periodic (micro)frame interval
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_PFIVL (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field PERSCHIVL: Periodic scheduling interval
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DCFG_PERSCHIVL (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DCTL: OTG_HS device control register
  #define OTG2_HS_DEVICE_OTG_HS_DCTL (* ((volatile uint32_t *) (0x40080800 + 4)))

  // Field RWUSIG: Remote wakeup signaling
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_RWUSIG = 1U << 0 ;

  // Field SDIS: Soft disconnect
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SDIS = 1U << 1 ;

  // Field GINSTS: Global IN NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_GINSTS = 1U << 2 ;

  // Field GONSTS: Global OUT NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_GONSTS = 1U << 3 ;

  // Field TCTL: Test control
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_TCTL (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SGINAK: Set global IN NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SGINAK = 1U << 7 ;

  // Field CGINAK: Clear global IN NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_CGINAK = 1U << 8 ;

  // Field SGONAK: Set global OUT NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_SGONAK = 1U << 9 ;

  // Field CGONAK: Clear global OUT NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_CGONAK = 1U << 10 ;

  // Field POPRGDNE: Power-on programming done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DCTL_POPRGDNE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DSTS: OTG_HS device status register
  #define OTG2_HS_DEVICE_OTG_HS_DSTS (* ((const volatile uint32_t *) (0x40080800 + 8)))

  // Field SUSPSTS: Suspend status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_SUSPSTS = 1U << 0 ;

  // Field ENUMSPD: Enumerated speed
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_ENUMSPD (const uint32_t inValue) {return (inValue & 0x3U) << 1 ; }

  // Field EERR: Erratic error
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_EERR = 1U << 3 ;

  // Field FNSOF: Frame number of the received SOF
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DSTS_FNSOF (const uint32_t inValue) {return (inValue & 0x3FFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPMSK: OTG_HS device IN endpoint common interrupt mask register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPMSK (* ((volatile uint32_t *) (0x40080800 + 16)))

  // Field XFRCM: Transfer completed interrupt mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_XFRCM = 1U << 0 ;

  // Field EPDM: Endpoint disabled interrupt mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_EPDM = 1U << 1 ;

  // Field TOM: Timeout condition mask (nonisochronous endpoints)
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TOM = 1U << 3 ;

  // Field ITTXFEMSK: IN token received when TxFIFO empty mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_ITTXFEMSK = 1U << 4 ;

  // Field INEPNMM: IN token received with EP mismatch mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNMM = 1U << 5 ;

  // Field INEPNEM: IN endpoint NAK effective mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_INEPNEM = 1U << 6 ;

  // Field TXFURM: FIFO underrun mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_TXFURM = 1U << 8 ;

  // Field BIM: BNA interrupt mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPMSK_BIM = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPMSK: OTG_HS device OUT endpoint common interrupt mask register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPMSK (* ((volatile uint32_t *) (0x40080800 + 20)))

  // Field XFRCM: Transfer completed interrupt mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_XFRCM = 1U << 0 ;

  // Field EPDM: Endpoint disabled interrupt mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_EPDM = 1U << 1 ;

  // Field STUPM: SETUP phase done mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_STUPM = 1U << 3 ;

  // Field OTEPDM: OUT token received when endpoint disabled mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OTEPDM = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_B2BSTUP = 1U << 6 ;

  // Field OPEM: OUT packet error mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_OPEM = 1U << 8 ;

  // Field BOIM: BNA interrupt mask
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPMSK_BOIM = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DAINT: OTG_HS device all endpoints interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DAINT (* ((const volatile uint32_t *) (0x40080800 + 24)))

  // Field IEPINT: IN endpoint interrupt bits
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DAINT_IEPINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field OEPINT: OUT endpoint interrupt bits
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DAINT_OEPINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DAINTMSK: OTG_HS all endpoints interrupt mask register
  #define OTG2_HS_DEVICE_OTG_HS_DAINTMSK (* ((volatile uint32_t *) (0x40080800 + 28)))

  // Field IEPM: IN EP interrupt mask bits
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_IEPM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field OEPM: OUT EP interrupt mask bits
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DAINTMSK_OEPM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DVBUSDIS: OTG_HS device VBUS discharge time register
  #define OTG2_HS_DEVICE_OTG_HS_DVBUSDIS (* ((volatile uint32_t *) (0x40080800 + 40)))

  // Field VBUSDT: Device VBUS discharge time
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSDIS_VBUSDT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DVBUSPULSE: OTG_HS device VBUS pulsing time register
  #define OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE (* ((volatile uint32_t *) (0x40080800 + 44)))

  // Field DVBUSP: Device VBUS pulsing time
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DVBUSPULSE_DVBUSP (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTHRCTL: OTG_HS Device threshold control register
  #define OTG2_HS_DEVICE_OTG_HS_DTHRCTL (* ((volatile uint32_t *) (0x40080800 + 48)))

  // Field NONISOTHREN: Nonisochronous IN endpoints threshold enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_NONISOTHREN = 1U << 0 ;

  // Field ISOTHREN: ISO IN endpoint threshold enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ISOTHREN = 1U << 1 ;

  // Field TXTHRLEN: Transmit threshold length
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_TXTHRLEN (const uint32_t inValue) {return (inValue & 0x1FFU) << 2 ; }

  // Field RXTHREN: Receive threshold enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHREN = 1U << 16 ;

  // Field RXTHRLEN: Receive threshold length
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_RXTHRLEN (const uint32_t inValue) {return (inValue & 0x1FFU) << 17 ; }

  // Field ARPEN: Arbiter parking enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DTHRCTL_ARPEN = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPEMPMSK: OTG_HS device IN endpoint FIFO empty interrupt mask register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK (* ((volatile uint32_t *) (0x40080800 + 52)))

  // Field INEPTXFEM: IN EP Tx FIFO empty interrupt mask bits
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPEMPMSK_INEPTXFEM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DEACHINT: OTG_HS device each endpoint interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DEACHINT (* ((volatile uint32_t *) (0x40080800 + 56)))

  // Field IEP1INT: IN endpoint 1interrupt bit
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_IEP1INT = 1U << 1 ;

  // Field OEP1INT: OUT endpoint 1 interrupt bit
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINT_OEP1INT = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DEACHINTMSK: OTG_HS device each endpoint interrupt register mask
  #define OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK (* ((volatile uint32_t *) (0x40080800 + 60)))

  // Field IEP1INTM: IN Endpoint 1 interrupt mask bit
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_IEP1INTM = 1U << 1 ;

  // Field OEP1INTM: OUT Endpoint 1 interrupt mask bit
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DEACHINTMSK_OEP1INTM = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL0: OTG device endpoint-0 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL0 (* ((volatile uint32_t *) (0x40080800 + 256)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL0_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL1: OTG device endpoint-1 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL1 (* ((volatile uint32_t *) (0x40080800 + 288)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL1_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL2: OTG device endpoint-2 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL2 (* ((volatile uint32_t *) (0x40080800 + 320)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL2_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL3: OTG device endpoint-3 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL3 (* ((volatile uint32_t *) (0x40080800 + 352)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL3_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL4: OTG device endpoint-4 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL4 (* ((volatile uint32_t *) (0x40080800 + 384)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL4_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL5: OTG device endpoint-5 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL5 (* ((volatile uint32_t *) (0x40080800 + 416)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL5_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL6: OTG device endpoint-6 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL6 (* ((volatile uint32_t *) (0x40080800 + 448)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL6_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPCTL7: OTG device endpoint-7 control register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPCTL7 (* ((volatile uint32_t *) (0x40080800 + 480)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even/odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_Stall = 1U << 21 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_TXFNUM (const uint32_t inValue) {return (inValue & 0xFU) << 22 ; }

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPCTL7_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT0: OTG device endpoint-0 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT0 (* ((volatile uint32_t *) (0x40080800 + 264)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT0_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT1: OTG device endpoint-1 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT1 (* ((volatile uint32_t *) (0x40080800 + 296)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT1_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT2: OTG device endpoint-2 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT2 (* ((volatile uint32_t *) (0x40080800 + 328)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT2_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT3: OTG device endpoint-3 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT3 (* ((volatile uint32_t *) (0x40080800 + 360)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT3_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT4: OTG device endpoint-4 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT4 (* ((volatile uint32_t *) (0x40080800 + 392)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT4_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT5: OTG device endpoint-5 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT5 (* ((volatile uint32_t *) (0x40080800 + 424)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT5_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT6: OTG device endpoint-6 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT6 (* ((volatile uint32_t *) (0x40080800 + 456)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT6_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPINT7: OTG device endpoint-7 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPINT7 (* ((volatile uint32_t *) (0x40080800 + 488)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_EPDISD = 1U << 1 ;

  // Field TOC: Timeout condition
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_TOC = 1U << 3 ;

  // Field ITTXFE: IN token received when TxFIFO is empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_ITTXFE = 1U << 4 ;

  // Field INEPNE: IN endpoint NAK effective
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_INEPNE = 1U << 6 ;

  // Field TXFE: Transmit FIFO empty
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_TXFE = 1U << 7 ;

  // Field TXFIFOUDRN: Transmit Fifo Underrun
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_TXFIFOUDRN = 1U << 8 ;

  // Field BNA: Buffer not available interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_BNA = 1U << 9 ;

  // Field PKTDRPSTS: Packet dropped status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_PKTDRPSTS = 1U << 11 ;

  // Field BERR: Babble error interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_BERR = 1U << 12 ;

  // Field NAK: NAK interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPINT7_NAK = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ0: OTG_HS device IN endpoint 0 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0 (* ((volatile uint32_t *) (0x40080800 + 272)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ0_PKTCNT (const uint32_t inValue) {return (inValue & 0x3U) << 19 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA1: OTG_HS device endpoint-1 DMA address register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPDMA1 (* ((volatile uint32_t *) (0x40080800 + 276)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMA1_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA2: OTG_HS device endpoint-2 DMA address register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPDMA2 (* ((volatile uint32_t *) (0x40080800 + 308)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMA2_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA3: OTG_HS device endpoint-3 DMA address register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPDMA3 (* ((volatile uint32_t *) (0x40080800 + 340)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMA3_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA4: OTG_HS device endpoint-4 DMA address register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPDMA4 (* ((volatile uint32_t *) (0x40080800 + 372)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMA4_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPDMA5: OTG_HS device endpoint-5 DMA address register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPDMA5 (* ((volatile uint32_t *) (0x40080800 + 404)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPDMA5_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS0: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS0 (* ((const volatile uint32_t *) (0x40080800 + 280)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS0_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS1: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS1 (* ((const volatile uint32_t *) (0x40080800 + 312)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS1_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS2: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS2 (* ((const volatile uint32_t *) (0x40080800 + 344)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS2_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS3: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS3 (* ((const volatile uint32_t *) (0x40080800 + 376)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS3_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS4: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS4 (* ((const volatile uint32_t *) (0x40080800 + 408)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS4_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS5: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS5 (* ((const volatile uint32_t *) (0x40080800 + 440)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS5_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ1: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1 (* ((volatile uint32_t *) (0x40080800 + 304)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ1_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ2: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2 (* ((volatile uint32_t *) (0x40080800 + 336)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ2_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ3: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3 (* ((volatile uint32_t *) (0x40080800 + 368)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ3_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ4: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4 (* ((volatile uint32_t *) (0x40080800 + 400)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ4_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ5: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5 (* ((volatile uint32_t *) (0x40080800 + 432)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ5_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL0: OTG_HS device control OUT endpoint 0 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL0 (* ((volatile uint32_t *) (0x40080800 + 768)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_MPSIZ (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_USBAEP = 1U << 15 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_SNAK = 1U << 27 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL0_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL1: OTG device endpoint-1 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL1 (* ((volatile uint32_t *) (0x40080800 + 800)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL1_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL2: OTG device endpoint-2 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL2 (* ((volatile uint32_t *) (0x40080800 + 832)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL2_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL3: OTG device endpoint-3 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL3 (* ((volatile uint32_t *) (0x40080800 + 864)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL3_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT0: OTG_HS device endpoint-0 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT0 (* ((volatile uint32_t *) (0x40080800 + 776)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT0_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT0_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT0_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT0_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT0_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT0_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT1: OTG_HS device endpoint-1 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT1 (* ((volatile uint32_t *) (0x40080800 + 808)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT1_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT1_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT1_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT1_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT1_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT1_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT2: OTG_HS device endpoint-2 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT2 (* ((volatile uint32_t *) (0x40080800 + 840)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT2_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT2_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT2_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT2_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT2_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT2_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT3: OTG_HS device endpoint-3 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT3 (* ((volatile uint32_t *) (0x40080800 + 872)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT3_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT3_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT3_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT3_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT3_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT3_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT4: OTG_HS device endpoint-4 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT4 (* ((volatile uint32_t *) (0x40080800 + 904)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT4_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT4_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT4_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT4_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT4_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT4_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT5: OTG_HS device endpoint-5 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT5 (* ((volatile uint32_t *) (0x40080800 + 936)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT5_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT5_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT5_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT5_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT5_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT5_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT6: OTG_HS device endpoint-6 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT6 (* ((volatile uint32_t *) (0x40080800 + 968)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT6_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT6_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT6_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT6_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT6_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT6_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPINT7: OTG_HS device endpoint-7 interrupt register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPINT7 (* ((volatile uint32_t *) (0x40080800 + 1000)))

  // Field XFRC: Transfer completed interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT7_XFRC = 1U << 0 ;

  // Field EPDISD: Endpoint disabled interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT7_EPDISD = 1U << 1 ;

  // Field STUP: SETUP phase done
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT7_STUP = 1U << 3 ;

  // Field OTEPDIS: OUT token received when endpoint disabled
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT7_OTEPDIS = 1U << 4 ;

  // Field B2BSTUP: Back-to-back SETUP packets received
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT7_B2BSTUP = 1U << 6 ;

  // Field NYET: NYET interrupt
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPINT7_NYET = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ0: OTG_HS device endpoint-0 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0 (* ((volatile uint32_t *) (0x40080800 + 784)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field PKTCNT: Packet count
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_PKTCNT = 1U << 19 ;

  // Field STUPCNT: SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ0_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ1: OTG_HS device endpoint-1 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1 (* ((volatile uint32_t *) (0x40080800 + 816)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ1_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ2: OTG_HS device endpoint-2 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2 (* ((volatile uint32_t *) (0x40080800 + 848)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ2_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ3: OTG_HS device endpoint-3 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3 (* ((volatile uint32_t *) (0x40080800 + 880)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ3_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ4: OTG_HS device endpoint-4 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4 (* ((volatile uint32_t *) (0x40080800 + 912)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ4_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ6: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6 (* ((volatile uint32_t *) (0x40080800 + 416)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ6_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS6: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS6 (* ((volatile uint32_t *) (0x40080800 + 420)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS6_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTSIZ7: OTG_HS device endpoint transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7 (* ((volatile uint32_t *) (0x40080800 + 424)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field MCNT: Multi count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DIEPTSIZ7_MCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DTXFSTS7: OTG_HS device IN endpoint transmit FIFO status register
  #define OTG2_HS_DEVICE_OTG_HS_DTXFSTS7 (* ((volatile uint32_t *) (0x40080800 + 428)))

  // Field INEPTFSAV: IN endpoint TxFIFO space avail
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DTXFSTS7_INEPTFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL4: OTG device endpoint-4 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL4 (* ((volatile uint32_t *) (0x40080800 + 896)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL4_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL5: OTG device endpoint-5 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL5 (* ((volatile uint32_t *) (0x40080800 + 928)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL5_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL6: OTG device endpoint-6 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL6 (* ((volatile uint32_t *) (0x40080800 + 960)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL6_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPCTL7: OTG device endpoint-7 control register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPCTL7 (* ((volatile uint32_t *) (0x40080800 + 992)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field USBAEP: USB active endpoint
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_USBAEP = 1U << 15 ;

  // Field EONUM_DPID: Even odd frame/Endpoint data PID
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EONUM_DPID = 1U << 16 ;

  // Field NAKSTS: NAK status
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_NAKSTS = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field SNPM: Snoop mode
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNPM = 1U << 20 ;

  // Field Stall: STALL handshake
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_Stall = 1U << 21 ;

  // Field CNAK: Clear NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_CNAK = 1U << 26 ;

  // Field SNAK: Set NAK
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SNAK = 1U << 27 ;

  // Field SD0PID_SEVNFRM: Set DATA0 PID/Set even frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SD0PID_SEVNFRM = 1U << 28 ;

  // Field SODDFRM: Set odd frame
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_SODDFRM = 1U << 29 ;

  // Field EPDIS: Endpoint disable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPDIS = 1U << 30 ;

  // Field EPENA: Endpoint enable
    const uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPCTL7_EPENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ5: OTG_HS device endpoint-5 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5 (* ((volatile uint32_t *) (0x40080800 + 944)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ5_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ6: OTG_HS device endpoint-6 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6 (* ((volatile uint32_t *) (0x40080800 + 976)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ6_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DOEPTSIZ7: OTG_HS device endpoint-7 transfer size register
  #define OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7 (* ((volatile uint32_t *) (0x40080800 + 1008)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field RXDPID_STUPCNT: Received data PID/SETUP packet count
    inline uint32_t OTG2_HS_DEVICE_OTG_HS_DOEPTSIZ7_RXDPID_STUPCNT (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------
// Peripheral OTG2_HS_GLOBAL
//------------------------------------------------------------------------------

//---  Register OTG_HS_GOTGCTL: OTG_HS control and status register
  #define OTG2_HS_GLOBAL_OTG_HS_GOTGCTL (* ((volatile uint32_t *) (0x40080000 + 0)))

  // Field SRQSCS: Session request success
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQSCS = 1U << 0 ;

  // Field SRQ: Session request
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_SRQ = 1U << 1 ;

  // Field HNGSCS: Host negotiation success
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNGSCS = 1U << 8 ;

  // Field HNPRQ: HNP request
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HNPRQ = 1U << 9 ;

  // Field HSHNPEN: Host set HNP enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_HSHNPEN = 1U << 10 ;

  // Field DHNPEN: Device HNP enabled
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DHNPEN = 1U << 11 ;

  // Field CIDSTS: Connector ID status
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_CIDSTS = 1U << 16 ;

  // Field DBCT: Long/short debounce time
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_DBCT = 1U << 17 ;

  // Field ASVLD: A-session valid
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_ASVLD = 1U << 18 ;

  // Field BSVLD: B-session valid
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_BSVLD = 1U << 19 ;

  // Field EHEN: Embedded host enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGCTL_EHEN = 1U << 12 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GOTGINT: OTG_HS interrupt register
  #define OTG2_HS_GLOBAL_OTG_HS_GOTGINT (* ((volatile uint32_t *) (0x40080000 + 4)))

  // Field SEDET: Session end detected
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SEDET = 1U << 2 ;

  // Field SRSSCHG: Session request success status change
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_SRSSCHG = 1U << 8 ;

  // Field HNSSCHG: Host negotiation success status change
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNSSCHG = 1U << 9 ;

  // Field HNGDET: Host negotiation detected
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_HNGDET = 1U << 17 ;

  // Field ADTOCHG: A-device timeout change
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_ADTOCHG = 1U << 18 ;

  // Field DBCDNE: Debounce done
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_DBCDNE = 1U << 19 ;

  // Field IDCHNG: ID input pin changed
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GOTGINT_IDCHNG = 1U << 20 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GAHBCFG: OTG_HS AHB configuration register
  #define OTG2_HS_GLOBAL_OTG_HS_GAHBCFG (* ((volatile uint32_t *) (0x40080000 + 8)))

  // Field GINT: Global interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_GINT = 1U << 0 ;

  // Field HBSTLEN: Burst length/type
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_HBSTLEN (const uint32_t inValue) {return (inValue & 0xFU) << 1 ; }

  // Field DMAEN: DMA enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_DMAEN = 1U << 5 ;

  // Field TXFELVL: TxFIFO empty level
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_TXFELVL = 1U << 7 ;

  // Field PTXFELVL: Periodic TxFIFO empty level
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GAHBCFG_PTXFELVL = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GUSBCFG: OTG_HS USB configuration register
  #define OTG2_HS_GLOBAL_OTG_HS_GUSBCFG (* ((volatile uint32_t *) (0x40080000 + 12)))

  // Field TOCAL: FS timeout calibration
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TOCAL (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field PHYSEL: USB 2.0 high-speed ULPI PHY or USB 1.1 full-speed serial transceiver select
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYSEL = 1U << 6 ;

  // Field SRPCAP: SRP-capable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_SRPCAP = 1U << 8 ;

  // Field HNPCAP: HNP-capable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_HNPCAP = 1U << 9 ;

  // Field TRDT: USB turnaround time
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TRDT (const uint32_t inValue) {return (inValue & 0xFU) << 10 ; }

  // Field PHYLPCS: PHY Low-power clock select
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PHYLPCS = 1U << 15 ;

  // Field ULPIFSLS: ULPI FS/LS select
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIFSLS = 1U << 17 ;

  // Field ULPIAR: ULPI Auto-resume
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIAR = 1U << 18 ;

  // Field ULPICSM: ULPI Clock SuspendM
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPICSM = 1U << 19 ;

  // Field ULPIEVBUSD: ULPI External VBUS Drive
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSD = 1U << 20 ;

  // Field ULPIEVBUSI: ULPI external VBUS indicator
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIEVBUSI = 1U << 21 ;

  // Field TSDPS: TermSel DLine pulsing selection
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_TSDPS = 1U << 22 ;

  // Field PCCI: Indicator complement
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PCCI = 1U << 23 ;

  // Field PTCI: Indicator pass through
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_PTCI = 1U << 24 ;

  // Field ULPIIPD: ULPI interface protect disable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_ULPIIPD = 1U << 25 ;

  // Field FHMOD: Forced host mode
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FHMOD = 1U << 29 ;

  // Field FDMOD: Forced peripheral mode
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GUSBCFG_FDMOD = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRSTCTL: OTG_HS reset register
  #define OTG2_HS_GLOBAL_OTG_HS_GRSTCTL (* ((volatile uint32_t *) (0x40080000 + 16)))

  // Field CSRST: Core soft reset
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_CSRST = 1U << 0 ;

  // Field HSRST: HCLK soft reset
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_HSRST = 1U << 1 ;

  // Field FCRST: Host frame counter reset
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_FCRST = 1U << 2 ;

  // Field RXFFLSH: RxFIFO flush
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_RXFFLSH = 1U << 4 ;

  // Field TXFFLSH: TxFIFO flush
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFFLSH = 1U << 5 ;

  // Field TXFNUM: TxFIFO number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_TXFNUM (const uint32_t inValue) {return (inValue & 0x1FU) << 6 ; }

  // Field AHBIDL: AHB master idle
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_AHBIDL = 1U << 31 ;

  // Field DMAREQ: DMA request signal enabled for USB OTG HS
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GRSTCTL_DMAREQ = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GINTSTS: OTG_HS core interrupt register
  #define OTG2_HS_GLOBAL_OTG_HS_GINTSTS (* ((volatile uint32_t *) (0x40080000 + 20)))

  // Field CMOD: Current mode of operation
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CMOD = 1U << 0 ;

  // Field MMIS: Mode mismatch interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_MMIS = 1U << 1 ;

  // Field OTGINT: OTG interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OTGINT = 1U << 2 ;

  // Field SOF: Start of frame
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SOF = 1U << 3 ;

  // Field RXFLVL: RxFIFO nonempty
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_RXFLVL = 1U << 4 ;

  // Field NPTXFE: Nonperiodic TxFIFO empty
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_NPTXFE = 1U << 5 ;

  // Field GINAKEFF: Global IN nonperiodic NAK effective
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_GINAKEFF = 1U << 6 ;

  // Field BOUTNAKEFF: Global OUT NAK effective
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_BOUTNAKEFF = 1U << 7 ;

  // Field ESUSP: Early suspend
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ESUSP = 1U << 10 ;

  // Field USBSUSP: USB suspend
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBSUSP = 1U << 11 ;

  // Field USBRST: USB reset
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_USBRST = 1U << 12 ;

  // Field ENUMDNE: Enumeration done
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ENUMDNE = 1U << 13 ;

  // Field ISOODRP: Isochronous OUT packet dropped interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_ISOODRP = 1U << 14 ;

  // Field EOPF: End of periodic frame interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_EOPF = 1U << 15 ;

  // Field IEPINT: IN endpoint interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IEPINT = 1U << 18 ;

  // Field OEPINT: OUT endpoint interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_OEPINT = 1U << 19 ;

  // Field IISOIXFR: Incomplete isochronous IN transfer
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_IISOIXFR = 1U << 20 ;

  // Field PXFR_INCOMPISOOUT: Incomplete periodic transfer
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PXFR_INCOMPISOOUT = 1U << 21 ;

  // Field DATAFSUSP: Data fetch suspended
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DATAFSUSP = 1U << 22 ;

  // Field HPRTINT: Host port interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HPRTINT = 1U << 24 ;

  // Field HCINT: Host channels interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_HCINT = 1U << 25 ;

  // Field PTXFE: Periodic TxFIFO empty
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_PTXFE = 1U << 26 ;

  // Field CIDSCHG: Connector ID status change
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_CIDSCHG = 1U << 28 ;

  // Field DISCINT: Disconnect detected interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_DISCINT = 1U << 29 ;

  // Field SRQINT: Session request/new session detected interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_SRQINT = 1U << 30 ;

  // Field WKUINT: Resume/remote wakeup detected interrupt
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTSTS_WKUINT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GINTMSK: OTG_HS interrupt mask register
  #define OTG2_HS_GLOBAL_OTG_HS_GINTMSK (* ((volatile uint32_t *) (0x40080000 + 24)))

  // Field MMISM: Mode mismatch interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_MMISM = 1U << 1 ;

  // Field OTGINT: OTG interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OTGINT = 1U << 2 ;

  // Field SOFM: Start of frame mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SOFM = 1U << 3 ;

  // Field RXFLVLM: Receive FIFO nonempty mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RXFLVLM = 1U << 4 ;

  // Field NPTXFEM: Nonperiodic TxFIFO empty mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_NPTXFEM = 1U << 5 ;

  // Field GINAKEFFM: Global nonperiodic IN NAK effective mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GINAKEFFM = 1U << 6 ;

  // Field GONAKEFFM: Global OUT NAK effective mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_GONAKEFFM = 1U << 7 ;

  // Field ESUSPM: Early suspend mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ESUSPM = 1U << 10 ;

  // Field USBSUSPM: USB suspend mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBSUSPM = 1U << 11 ;

  // Field USBRST: USB reset mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_USBRST = 1U << 12 ;

  // Field ENUMDNEM: Enumeration done mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ENUMDNEM = 1U << 13 ;

  // Field ISOODRPM: Isochronous OUT packet dropped interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_ISOODRPM = 1U << 14 ;

  // Field EOPFM: End of periodic frame interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_EOPFM = 1U << 15 ;

  // Field IEPINT: IN endpoints interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IEPINT = 1U << 18 ;

  // Field OEPINT: OUT endpoints interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_OEPINT = 1U << 19 ;

  // Field IISOIXFRM: Incomplete isochronous IN transfer mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_IISOIXFRM = 1U << 20 ;

  // Field PXFRM_IISOOXFRM: Incomplete periodic transfer mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PXFRM_IISOOXFRM = 1U << 21 ;

  // Field FSUSPM: Data fetch suspended mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_FSUSPM = 1U << 22 ;

  // Field PRTIM: Host port interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PRTIM = 1U << 24 ;

  // Field HCIM: Host channels interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_HCIM = 1U << 25 ;

  // Field PTXFEM: Periodic TxFIFO empty mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_PTXFEM = 1U << 26 ;

  // Field CIDSCHGM: Connector ID status change mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_CIDSCHGM = 1U << 28 ;

  // Field DISCINT: Disconnect detected interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_DISCINT = 1U << 29 ;

  // Field SRQIM: Session request/new session detected interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_SRQIM = 1U << 30 ;

  // Field WUIM: Resume/remote wakeup detected interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_WUIM = 1U << 31 ;

  // Field RSTDE: Reset detected interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_RSTDE = 1U << 23 ;

  // Field LPMINTM: LPM interrupt mask
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GINTMSK_LPMINTM = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSR_Host: OTG_HS Receive status debug read register (host mode)
  #define OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host (* ((const volatile uint32_t *) (0x40080000 + 28)))

  // Field CHNUM: Channel number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_CHNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Host_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSP_Host: OTG_HS status read and pop register (host mode)
  #define OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host (* ((const volatile uint32_t *) (0x40080000 + 32)))

  // Field CHNUM: Channel number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_CHNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Host_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXFSIZ: OTG_HS Receive FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ (* ((volatile uint32_t *) (0x40080000 + 36)))

  // Field RXFD: RxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXFSIZ_RXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HNPTXFSIZ_Host: OTG_HS nonperiodic transmit FIFO size register (host mode)
  #define OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host (* ((volatile uint32_t *) (0x40080000 + 40)))

  // Field NPTXFSA: Nonperiodic transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field NPTXFD: Nonperiodic TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_HNPTXFSIZ_Host_NPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF0_Device: Endpoint 0 transmit FIFO size (peripheral mode)
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_Device (* ((volatile uint32_t *) (0x40080000 + 40)))

  // Field TX0FSA: Endpoint 0 transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field TX0FD: Endpoint 0 TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF0_Device_TX0FD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GNPTXSTS: OTG_HS nonperiodic transmit FIFO/queue status register
  #define OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS (* ((const volatile uint32_t *) (0x40080000 + 44)))

  // Field NPTXFSAV: Nonperiodic TxFIFO space available
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXFSAV (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field NPTQXSAV: Nonperiodic transmit request queue space available
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTQXSAV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field NPTXQTOP: Top of the nonperiodic transmit request queue
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GNPTXSTS_NPTXQTOP (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GCCFG: OTG_HS general core configuration register
  #define OTG2_HS_GLOBAL_OTG_HS_GCCFG (* ((volatile uint32_t *) (0x40080000 + 56)))

  // Field PWRDWN: Power down
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PWRDWN = 1U << 16 ;

  // Field BCDEN: Battery charging detector (BCD) enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_BCDEN = 1U << 17 ;

  // Field DCDEN: Data contact detection (DCD) mode enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDEN = 1U << 18 ;

  // Field PDEN: Primary detection (PD) mode enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDEN = 1U << 19 ;

  // Field SDEN: Secondary detection (SD) mode enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDEN = 1U << 20 ;

  // Field VBDEN: USB VBUS detection enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_VBDEN = 1U << 21 ;

  // Field DCDET: Data contact detection (DCD) status
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_DCDET = 1U << 0 ;

  // Field PDET: Primary detection (PD) status
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PDET = 1U << 1 ;

  // Field SDET: Secondary detection (SD) status
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_SDET = 1U << 2 ;

  // Field PS2DET: DM pull-up detection status
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GCCFG_PS2DET = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_CID: OTG_HS core ID register
  #define OTG2_HS_GLOBAL_OTG_HS_CID (* ((volatile uint32_t *) (0x40080000 + 60)))

  // Field PRODUCT_ID: Product ID field
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_CID_PRODUCT_ID (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HPTXFSIZ: OTG_HS Host periodic transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ (* ((volatile uint32_t *) (0x40080000 + 256)))

  // Field PTXSA: Host periodic TxFIFO start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field PTXFD: Host periodic TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_HPTXFSIZ_PTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF1: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF1 (* ((volatile uint32_t *) (0x40080000 + 260)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF1_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF2: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF2 (* ((volatile uint32_t *) (0x40080000 + 264)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF2_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF3: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF3 (* ((volatile uint32_t *) (0x40080000 + 284)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF3_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF4: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF4 (* ((volatile uint32_t *) (0x40080000 + 288)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF4_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF5: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF5 (* ((volatile uint32_t *) (0x40080000 + 292)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF5_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF6: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF6 (* ((volatile uint32_t *) (0x40080000 + 296)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF6_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_DIEPTXF7: OTG_HS device IN endpoint transmit FIFO size register
  #define OTG2_HS_GLOBAL_OTG_HS_DIEPTXF7 (* ((volatile uint32_t *) (0x40080000 + 300)))

  // Field INEPTXSA: IN endpoint FIFOx transmit RAM start address
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXSA (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field INEPTXFD: IN endpoint TxFIFO depth
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_DIEPTXF7_INEPTXFD (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSR_Device: OTG_HS Receive status debug read register (peripheral mode mode)
  #define OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device (* ((const volatile uint32_t *) (0x40080000 + 28)))

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

  // Field FRMNUM: Frame number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSR_Device_FRMNUM (const uint32_t inValue) {return (inValue & 0xFU) << 21 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GRXSTSP_Device: OTG_HS status read and pop register (peripheral mode)
  #define OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device (* ((const volatile uint32_t *) (0x40080000 + 32)))

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field BCNT: Byte count
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_BCNT (const uint32_t inValue) {return (inValue & 0x7FFU) << 4 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 15 ; }

  // Field PKTSTS: Packet status
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_PKTSTS (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

  // Field FRMNUM: Frame number
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GRXSTSP_Device_FRMNUM (const uint32_t inValue) {return (inValue & 0xFU) << 21 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_GLPMCFG: OTG core LPM configuration register
  #define OTG2_HS_GLOBAL_OTG_HS_GLPMCFG (* ((volatile uint32_t *) (0x40080000 + 84)))

  // Field LPMEN: LPM support enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMEN = 1U << 0 ;

  // Field LPMACK: LPM token acknowledge enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMACK = 1U << 1 ;

  // Field BESL: Best effort service latency
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESL (const uint32_t inValue) {return (inValue & 0xFU) << 2 ; }

  // Field REMWAKE: bRemoteWake value
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_REMWAKE = 1U << 6 ;

  // Field L1SSEN: L1 Shallow Sleep enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1SSEN = 1U << 7 ;

  // Field BESLTHRS: BESL threshold
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_BESLTHRS (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field L1DSEN: L1 deep sleep enable
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1DSEN = 1U << 12 ;

  // Field LPMRST: LPM response
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRST (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field SLPSTS: Port sleep status
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SLPSTS = 1U << 15 ;

  // Field L1RSMOK: Sleep State Resume OK
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_L1RSMOK = 1U << 16 ;

  // Field LPMCHIDX: LPM Channel Index
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMCHIDX (const uint32_t inValue) {return (inValue & 0xFU) << 17 ; }

  // Field LPMRCNT: LPM retry count
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNT (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SNDLPM: Send LPM transaction
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_SNDLPM = 1U << 24 ;

  // Field LPMRCNTSTS: LPM retry count status
    inline uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_LPMRCNTSTS (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field ENBESL: Enable best effort service latency
    const uint32_t OTG2_HS_GLOBAL_OTG_HS_GLPMCFG_ENBESL = 1U << 28 ;

//------------------------------------------------------------------------------
// Peripheral OTG2_HS_HOST
//------------------------------------------------------------------------------

//---  Register OTG_HS_HCFG: OTG_HS host configuration register
  #define OTG2_HS_HOST_OTG_HS_HCFG (* ((volatile uint32_t *) (0x40080400 + 0)))

  // Field FSLSPCS: FS/LS PHY clock select
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCFG_FSLSPCS (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field FSLSS: FS- and LS-only support
    const uint32_t OTG2_HS_HOST_OTG_HS_HCFG_FSLSS = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HFIR: OTG_HS Host frame interval register
  #define OTG2_HS_HOST_OTG_HS_HFIR (* ((volatile uint32_t *) (0x40080400 + 4)))

  // Field FRIVL: Frame interval
    inline uint32_t OTG2_HS_HOST_OTG_HS_HFIR_FRIVL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HFNUM: OTG_HS host frame number/frame time remaining register
  #define OTG2_HS_HOST_OTG_HS_HFNUM (* ((const volatile uint32_t *) (0x40080400 + 8)))

  // Field FRNUM: Frame number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HFNUM_FRNUM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field FTREM: Frame time remaining
    inline uint32_t OTG2_HS_HOST_OTG_HS_HFNUM_FTREM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HPTXSTS: OTG_HS_Host periodic transmit FIFO/queue status register
  #define OTG2_HS_HOST_OTG_HS_HPTXSTS (* ((volatile uint32_t *) (0x40080400 + 16)))

  // Field PTXFSAVL: Periodic transmit data FIFO space available
    inline uint32_t OTG2_HS_HOST_OTG_HS_HPTXSTS_PTXFSAVL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field PTXQSAV: Periodic transmit request queue space available
    inline uint32_t OTG2_HS_HOST_OTG_HS_HPTXSTS_PTXQSAV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field PTXQTOP: Top of the periodic transmit request queue
    inline uint32_t OTG2_HS_HOST_OTG_HS_HPTXSTS_PTXQTOP (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HAINT: OTG_HS Host all channels interrupt register
  #define OTG2_HS_HOST_OTG_HS_HAINT (* ((const volatile uint32_t *) (0x40080400 + 20)))

  // Field HAINT: Channel interrupts
    inline uint32_t OTG2_HS_HOST_OTG_HS_HAINT_HAINT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HAINTMSK: OTG_HS host all channels interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HAINTMSK (* ((volatile uint32_t *) (0x40080400 + 24)))

  // Field HAINTM: Channel interrupt mask
    inline uint32_t OTG2_HS_HOST_OTG_HS_HAINTMSK_HAINTM (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HPRT: OTG_HS host port control and status register
  #define OTG2_HS_HOST_OTG_HS_HPRT (* ((volatile uint32_t *) (0x40080400 + 64)))

  // Field PCSTS: Port connect status
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PCSTS = 1U << 0 ;

  // Field PCDET: Port connect detected
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PCDET = 1U << 1 ;

  // Field PENA: Port enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PENA = 1U << 2 ;

  // Field PENCHNG: Port enable/disable change
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PENCHNG = 1U << 3 ;

  // Field POCA: Port overcurrent active
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_POCA = 1U << 4 ;

  // Field POCCHNG: Port overcurrent change
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_POCCHNG = 1U << 5 ;

  // Field PRES: Port resume
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PRES = 1U << 6 ;

  // Field PSUSP: Port suspend
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PSUSP = 1U << 7 ;

  // Field PRST: Port reset
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PRST = 1U << 8 ;

  // Field PLSTS: Port line status
    inline uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PLSTS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field PPWR: Port power
    const uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PPWR = 1U << 12 ;

  // Field PTCTL: Port test control
    inline uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PTCTL (const uint32_t inValue) {return (inValue & 0xFU) << 13 ; }

  // Field PSPD: Port speed
    inline uint32_t OTG2_HS_HOST_OTG_HS_HPRT_PSPD (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR0: OTG_HS host channel-0 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR0 (* ((volatile uint32_t *) (0x40080400 + 256)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR0_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR1: OTG_HS host channel-1 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR1 (* ((volatile uint32_t *) (0x40080400 + 288)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR1_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR2: OTG_HS host channel-2 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR2 (* ((volatile uint32_t *) (0x40080400 + 320)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR2_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR3: OTG_HS host channel-3 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR3 (* ((volatile uint32_t *) (0x40080400 + 352)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR3_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR4: OTG_HS host channel-4 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR4 (* ((volatile uint32_t *) (0x40080400 + 384)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR4_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR5: OTG_HS host channel-5 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR5 (* ((volatile uint32_t *) (0x40080400 + 416)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR5_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR6: OTG_HS host channel-6 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR6 (* ((volatile uint32_t *) (0x40080400 + 448)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR6_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR7: OTG_HS host channel-7 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR7 (* ((volatile uint32_t *) (0x40080400 + 480)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR7_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR8: OTG_HS host channel-8 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR8 (* ((volatile uint32_t *) (0x40080400 + 512)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR8_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR9: OTG_HS host channel-9 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR9 (* ((volatile uint32_t *) (0x40080400 + 544)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR9_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR10: OTG_HS host channel-10 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR10 (* ((volatile uint32_t *) (0x40080400 + 576)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR10_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR11: OTG_HS host channel-11 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR11 (* ((volatile uint32_t *) (0x40080400 + 608)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR11_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT0: OTG_HS host channel-0 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT0 (* ((volatile uint32_t *) (0x40080400 + 260)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT0_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT0_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT0_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT0_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT0_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT1: OTG_HS host channel-1 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT1 (* ((volatile uint32_t *) (0x40080400 + 292)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT1_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT1_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT1_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT1_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT1_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT2: OTG_HS host channel-2 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT2 (* ((volatile uint32_t *) (0x40080400 + 324)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT2_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT2_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT2_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT2_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT2_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT3: OTG_HS host channel-3 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT3 (* ((volatile uint32_t *) (0x40080400 + 356)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT3_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT3_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT3_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT3_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT3_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT4: OTG_HS host channel-4 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT4 (* ((volatile uint32_t *) (0x40080400 + 388)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT4_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT4_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT4_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT4_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT4_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT5: OTG_HS host channel-5 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT5 (* ((volatile uint32_t *) (0x40080400 + 420)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT5_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT5_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT5_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT5_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT5_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT6: OTG_HS host channel-6 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT6 (* ((volatile uint32_t *) (0x40080400 + 452)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT6_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT6_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT6_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT6_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT6_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT7: OTG_HS host channel-7 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT7 (* ((volatile uint32_t *) (0x40080400 + 484)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT7_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT7_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT7_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT7_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT7_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT8: OTG_HS host channel-8 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT8 (* ((volatile uint32_t *) (0x40080400 + 516)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT8_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT8_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT8_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT8_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT8_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT9: OTG_HS host channel-9 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT9 (* ((volatile uint32_t *) (0x40080400 + 548)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT9_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT9_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT9_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT9_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT9_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT10: OTG_HS host channel-10 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT10 (* ((volatile uint32_t *) (0x40080400 + 580)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT10_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT10_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT10_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT10_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT10_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT11: OTG_HS host channel-11 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT11 (* ((volatile uint32_t *) (0x40080400 + 612)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT11_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT11_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT11_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT11_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT11_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT0: OTG_HS host channel-11 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT0 (* ((volatile uint32_t *) (0x40080400 + 264)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT0_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT1: OTG_HS host channel-1 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT1 (* ((volatile uint32_t *) (0x40080400 + 296)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT1_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT2: OTG_HS host channel-2 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT2 (* ((volatile uint32_t *) (0x40080400 + 328)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT2_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT3: OTG_HS host channel-3 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT3 (* ((volatile uint32_t *) (0x40080400 + 360)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT3_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT4: OTG_HS host channel-4 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT4 (* ((volatile uint32_t *) (0x40080400 + 392)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT4_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT5: OTG_HS host channel-5 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT5 (* ((volatile uint32_t *) (0x40080400 + 424)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT5_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT6: OTG_HS host channel-6 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT6 (* ((volatile uint32_t *) (0x40080400 + 456)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT6_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT7: OTG_HS host channel-7 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT7 (* ((volatile uint32_t *) (0x40080400 + 488)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT7_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT8: OTG_HS host channel-8 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT8 (* ((volatile uint32_t *) (0x40080400 + 520)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT8_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT9: OTG_HS host channel-9 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT9 (* ((volatile uint32_t *) (0x40080400 + 552)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT9_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT10: OTG_HS host channel-10 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT10 (* ((volatile uint32_t *) (0x40080400 + 584)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT10_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT11: OTG_HS host channel-11 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT11 (* ((volatile uint32_t *) (0x40080400 + 616)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT11_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK0: OTG_HS host channel-11 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK0 (* ((volatile uint32_t *) (0x40080400 + 268)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK0_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK1: OTG_HS host channel-1 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK1 (* ((volatile uint32_t *) (0x40080400 + 300)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK1_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK2: OTG_HS host channel-2 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK2 (* ((volatile uint32_t *) (0x40080400 + 332)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK2_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK3: OTG_HS host channel-3 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK3 (* ((volatile uint32_t *) (0x40080400 + 364)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK3_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK4: OTG_HS host channel-4 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK4 (* ((volatile uint32_t *) (0x40080400 + 396)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK4_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK5: OTG_HS host channel-5 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK5 (* ((volatile uint32_t *) (0x40080400 + 428)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK5_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK6: OTG_HS host channel-6 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK6 (* ((volatile uint32_t *) (0x40080400 + 460)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK6_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK7: OTG_HS host channel-7 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK7 (* ((volatile uint32_t *) (0x40080400 + 492)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK7_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK8: OTG_HS host channel-8 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK8 (* ((volatile uint32_t *) (0x40080400 + 524)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK8_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK9: OTG_HS host channel-9 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK9 (* ((volatile uint32_t *) (0x40080400 + 556)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK9_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK10: OTG_HS host channel-10 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK10 (* ((volatile uint32_t *) (0x40080400 + 588)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK10_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK11: OTG_HS host channel-11 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK11 (* ((volatile uint32_t *) (0x40080400 + 620)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_ACKM = 1U << 5 ;

  // Field NYET: response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK11_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ0: OTG_HS host channel-11 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ0 (* ((volatile uint32_t *) (0x40080400 + 272)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ0_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ0_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ0_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ1: OTG_HS host channel-1 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ1 (* ((volatile uint32_t *) (0x40080400 + 304)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ1_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ1_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ1_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ2: OTG_HS host channel-2 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ2 (* ((volatile uint32_t *) (0x40080400 + 336)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ2_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ2_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ2_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ3: OTG_HS host channel-3 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ3 (* ((volatile uint32_t *) (0x40080400 + 368)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ3_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ3_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ3_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ4: OTG_HS host channel-4 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ4 (* ((volatile uint32_t *) (0x40080400 + 400)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ4_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ4_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ4_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ5: OTG_HS host channel-5 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ5 (* ((volatile uint32_t *) (0x40080400 + 432)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ5_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ5_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ5_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ6: OTG_HS host channel-6 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ6 (* ((volatile uint32_t *) (0x40080400 + 464)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ6_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ6_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ6_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ7: OTG_HS host channel-7 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ7 (* ((volatile uint32_t *) (0x40080400 + 496)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ7_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ7_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ7_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ8: OTG_HS host channel-8 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ8 (* ((volatile uint32_t *) (0x40080400 + 528)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ8_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ8_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ8_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ9: OTG_HS host channel-9 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ9 (* ((volatile uint32_t *) (0x40080400 + 560)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ9_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ9_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ9_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ10: OTG_HS host channel-10 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ10 (* ((volatile uint32_t *) (0x40080400 + 592)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ10_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ10_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ10_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ11: OTG_HS host channel-11 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ11 (* ((volatile uint32_t *) (0x40080400 + 624)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ11_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ11_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ11_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA0: OTG_HS host channel-0 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA0 (* ((volatile uint32_t *) (0x40080400 + 276)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA0_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA1: OTG_HS host channel-1 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA1 (* ((volatile uint32_t *) (0x40080400 + 308)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA1_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA2: OTG_HS host channel-2 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA2 (* ((volatile uint32_t *) (0x40080400 + 340)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA2_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA3: OTG_HS host channel-3 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA3 (* ((volatile uint32_t *) (0x40080400 + 372)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA3_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA4: OTG_HS host channel-4 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA4 (* ((volatile uint32_t *) (0x40080400 + 404)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA4_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA5: OTG_HS host channel-5 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA5 (* ((volatile uint32_t *) (0x40080400 + 436)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA5_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA6: OTG_HS host channel-6 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA6 (* ((volatile uint32_t *) (0x40080400 + 468)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA6_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA7: OTG_HS host channel-7 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA7 (* ((volatile uint32_t *) (0x40080400 + 500)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA7_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA8: OTG_HS host channel-8 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA8 (* ((volatile uint32_t *) (0x40080400 + 532)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA8_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA9: OTG_HS host channel-9 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA9 (* ((volatile uint32_t *) (0x40080400 + 564)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA9_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA10: OTG_HS host channel-10 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA10 (* ((volatile uint32_t *) (0x40080400 + 596)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA10_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA11: OTG_HS host channel-11 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA11 (* ((volatile uint32_t *) (0x40080400 + 628)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA11_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR12: OTG_HS host channel-12 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR12 (* ((volatile uint32_t *) (0x40080400 + 632)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR12_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT12: OTG_HS host channel-12 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT12 (* ((volatile uint32_t *) (0x40080400 + 636)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT12_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT12_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT12_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT12_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT12_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT12: OTG_HS host channel-12 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT12 (* ((volatile uint32_t *) (0x40080400 + 640)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT12_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK12: OTG_HS host channel-12 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK12 (* ((volatile uint32_t *) (0x40080400 + 644)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK12_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ12: OTG_HS host channel-12 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ12 (* ((volatile uint32_t *) (0x40080400 + 648)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ12_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ12_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ12_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA12: OTG_HS host channel-12 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA12 (* ((volatile uint32_t *) (0x40080400 + 652)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA12_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR13: OTG_HS host channel-13 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR13 (* ((volatile uint32_t *) (0x40080400 + 656)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR13_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT13: OTG_HS host channel-13 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT13 (* ((volatile uint32_t *) (0x40080400 + 660)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT13_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT13_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT13_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT13_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT13_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT13: OTG_HS host channel-13 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT13 (* ((volatile uint32_t *) (0x40080400 + 664)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT13_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK13: OTG_HS host channel-13 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK13 (* ((volatile uint32_t *) (0x40080400 + 668)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_AHBERR = 1U << 2 ;

  // Field STALLM: STALLM response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_STALLM = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK13_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ13: OTG_HS host channel-13 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ13 (* ((volatile uint32_t *) (0x40080400 + 672)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ13_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ13_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ13_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA13: OTG_HS host channel-13 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA13 (* ((volatile uint32_t *) (0x40080400 + 676)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA13_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR14: OTG_HS host channel-14 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR14 (* ((volatile uint32_t *) (0x40080400 + 680)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR14_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT14: OTG_HS host channel-14 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT14 (* ((volatile uint32_t *) (0x40080400 + 684)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT14_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT14_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT14_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT14_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT14_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT14: OTG_HS host channel-14 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT14 (* ((volatile uint32_t *) (0x40080400 + 688)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT14_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK14: OTG_HS host channel-14 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK14 (* ((volatile uint32_t *) (0x40080400 + 692)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_AHBERR = 1U << 2 ;

  // Field STALLM: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_STALLM = 1U << 3 ;

  // Field NAKM: NAKM response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_NAKM = 1U << 4 ;

  // Field ACKM: ACKM response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK14_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ14: OTG_HS host channel-14 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ14 (* ((volatile uint32_t *) (0x40080400 + 696)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ14_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ14_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ14_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA14: OTG_HS host channel-14 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA14 (* ((volatile uint32_t *) (0x40080400 + 700)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA14_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCCHAR15: OTG_HS host channel-15 characteristics register
  #define OTG2_HS_HOST_OTG_HS_HCCHAR15 (* ((volatile uint32_t *) (0x40080400 + 704)))

  // Field MPSIZ: Maximum packet size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_MPSIZ (const uint32_t inValue) {return (inValue & 0x7FFU) << 0 ; }

  // Field EPNUM: Endpoint number
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_EPNUM (const uint32_t inValue) {return (inValue & 0xFU) << 11 ; }

  // Field EPDIR: Endpoint direction
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_EPDIR = 1U << 15 ;

  // Field LSDEV: Low-speed device
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_LSDEV = 1U << 17 ;

  // Field EPTYP: Endpoint type
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_EPTYP (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field MC: Multi Count (MC) / Error Count (EC)
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_MC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DAD: Device address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_DAD (const uint32_t inValue) {return (inValue & 0x7FU) << 22 ; }

  // Field ODDFRM: Odd frame
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_ODDFRM = 1U << 29 ;

  // Field CHDIS: Channel disable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_CHDIS = 1U << 30 ;

  // Field CHENA: Channel enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCCHAR15_CHENA = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCSPLT15: OTG_HS host channel-15 split control register
  #define OTG2_HS_HOST_OTG_HS_HCSPLT15 (* ((volatile uint32_t *) (0x40080400 + 708)))

  // Field PRTADDR: Port address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT15_PRTADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field HUBADDR: Hub address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT15_HUBADDR (const uint32_t inValue) {return (inValue & 0x7FU) << 7 ; }

  // Field XACTPOS: XACTPOS
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT15_XACTPOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field COMPLSPLT: Do complete split
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT15_COMPLSPLT = 1U << 16 ;

  // Field SPLITEN: Split enable
    const uint32_t OTG2_HS_HOST_OTG_HS_HCSPLT15_SPLITEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINT15: OTG_HS host channel-15 interrupt register
  #define OTG2_HS_HOST_OTG_HS_HCINT15 (* ((volatile uint32_t *) (0x40080400 + 712)))

  // Field XFRC: Transfer completed
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_XFRC = 1U << 0 ;

  // Field CHH: Channel halted
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_CHH = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_STALL = 1U << 3 ;

  // Field NAK: NAK response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_NAK = 1U << 4 ;

  // Field ACK: ACK response received/transmitted interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_ACK = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_NYET = 1U << 6 ;

  // Field TXERR: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_TXERR = 1U << 7 ;

  // Field BBERR: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_BBERR = 1U << 8 ;

  // Field FRMOR: Frame overrun
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_FRMOR = 1U << 9 ;

  // Field DTERR: Data toggle error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINT15_DTERR = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCINTMSK15: OTG_HS host channel-15 interrupt mask register
  #define OTG2_HS_HOST_OTG_HS_HCINTMSK15 (* ((volatile uint32_t *) (0x40080400 + 716)))

  // Field XFRCM: Transfer completed mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_XFRCM = 1U << 0 ;

  // Field CHHM: Channel halted mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_CHHM = 1U << 1 ;

  // Field AHBERR: AHB error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_AHBERR = 1U << 2 ;

  // Field STALL: STALL response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_STALL = 1U << 3 ;

  // Field NAKM: NAK response received interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_NAKM = 1U << 4 ;

  // Field ACKM: ACK response received/transmitted interrupt mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_ACKM = 1U << 5 ;

  // Field NYET: Response received interrupt
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_NYET = 1U << 6 ;

  // Field TXERRM: Transaction error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_TXERRM = 1U << 7 ;

  // Field BBERRM: Babble error
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_BBERRM = 1U << 8 ;

  // Field FRMORM: Frame overrun mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_FRMORM = 1U << 9 ;

  // Field DTERRM: Data toggle error mask
    const uint32_t OTG2_HS_HOST_OTG_HS_HCINTMSK15_DTERRM = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCTSIZ15: OTG_HS host channel-15 transfer size register
  #define OTG2_HS_HOST_OTG_HS_HCTSIZ15 (* ((volatile uint32_t *) (0x40080400 + 720)))

  // Field XFRSIZ: Transfer size
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ15_XFRSIZ (const uint32_t inValue) {return (inValue & 0x7FFFFU) << 0 ; }

  // Field PKTCNT: Packet count
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ15_PKTCNT (const uint32_t inValue) {return (inValue & 0x3FFU) << 19 ; }

  // Field DPID: Data PID
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCTSIZ15_DPID (const uint32_t inValue) {return (inValue & 0x3U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register OTG_HS_HCDMA15: OTG_HS host channel-15 DMA address register
  #define OTG2_HS_HOST_OTG_HS_HCDMA15 (* ((volatile uint32_t *) (0x40080400 + 724)))

  // Field DMAADDR: DMA address
    inline uint32_t OTG2_HS_HOST_OTG_HS_HCDMA15_DMAADDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral OTG2_HS_PWRCLK
//------------------------------------------------------------------------------

//---  Register OTG_HS_PCGCR: Power and clock gating control register
  #define OTG2_HS_PWRCLK_OTG_HS_PCGCR (* ((volatile uint32_t *) (0x40080E00 + 0)))

  // Field STPPCLK: Stop PHY clock
    const uint32_t OTG2_HS_PWRCLK_OTG_HS_PCGCR_STPPCLK = 1U << 0 ;

  // Field GATEHCLK: Gate HCLK
    const uint32_t OTG2_HS_PWRCLK_OTG_HS_PCGCR_GATEHCLK = 1U << 1 ;

  // Field PHYSUSP: PHY suspended
    const uint32_t OTG2_HS_PWRCLK_OTG_HS_PCGCR_PHYSUSP = 1U << 4 ;

//------------------------------------------------------------------------------
// Peripheral PF: Processor features
//------------------------------------------------------------------------------

//---  Register CLIDR: Cache Level ID register
  #define PF_CLIDR (* ((const volatile uint32_t *) (0xE000ED78 + 0)))

  // Field CL1: CL1
    inline uint32_t PF_CLIDR_CL1 (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field CL2: CL2
    inline uint32_t PF_CLIDR_CL2 (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field CL3: CL3
    inline uint32_t PF_CLIDR_CL3 (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field CL4: CL4
    inline uint32_t PF_CLIDR_CL4 (const uint32_t inValue) {return (inValue & 0x7U) << 9 ; }

  // Field CL5: CL5
    inline uint32_t PF_CLIDR_CL5 (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field CL6: CL6
    inline uint32_t PF_CLIDR_CL6 (const uint32_t inValue) {return (inValue & 0x7U) << 15 ; }

  // Field CL7: CL7
    inline uint32_t PF_CLIDR_CL7 (const uint32_t inValue) {return (inValue & 0x7U) << 18 ; }

  // Field LoUIS: LoUIS
    inline uint32_t PF_CLIDR_LoUIS (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field LoC: LoC
    inline uint32_t PF_CLIDR_LoC (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field LoU: LoU
    inline uint32_t PF_CLIDR_LoU (const uint32_t inValue) {return (inValue & 0x7U) << 27 ; }

//------------------------------------------------------------------------------

//---  Register CTR: Cache Type register
  #define PF_CTR (* ((const volatile uint32_t *) (0xE000ED78 + 4)))

  // Field _IminLine: IminLine
    inline uint32_t PF_CTR__IminLine (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DMinLine: DMinLine
    inline uint32_t PF_CTR_DMinLine (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field ERG: ERG
    inline uint32_t PF_CTR_ERG (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field CWG: CWG
    inline uint32_t PF_CTR_CWG (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field Format: Format
    inline uint32_t PF_CTR_Format (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register CCSIDR: Cache Size ID register
  #define PF_CCSIDR (* ((const volatile uint32_t *) (0xE000ED78 + 8)))

  // Field LineSize: LineSize
    inline uint32_t PF_CCSIDR_LineSize (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field Associativity: Associativity
    inline uint32_t PF_CCSIDR_Associativity (const uint32_t inValue) {return (inValue & 0x3FFU) << 3 ; }

  // Field NumSets: NumSets
    inline uint32_t PF_CCSIDR_NumSets (const uint32_t inValue) {return (inValue & 0x7FFFU) << 13 ; }

  // Field WA: WA
    const uint32_t PF_CCSIDR_WA = 1U << 28 ;

  // Field RA: RA
    const uint32_t PF_CCSIDR_RA = 1U << 29 ;

  // Field WB: WB
    const uint32_t PF_CCSIDR_WB = 1U << 30 ;

  // Field WT: WT
    const uint32_t PF_CCSIDR_WT = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral PWR: PWR
//------------------------------------------------------------------------------

//---  Register CR1: PWR control register 1
  #define PWR_CR1 (* ((volatile uint32_t *) (0x58024800 + 0)))

  // Field LPDS: Low-power Deepsleep with SVOS3 (SVOS4 and SVOS5 always use low-power, regardless of the setting of this bit)
    const uint32_t PWR_CR1_LPDS = 1U << 0 ;

  // Field PVDE: Programmable voltage detector enable
    const uint32_t PWR_CR1_PVDE = 1U << 4 ;

  // Field PLS: Programmable voltage detector level selection These bits select the voltage threshold detected by the PVD. Note: Refer to Section Electrical characteristics of the product datasheet for more details.
    inline uint32_t PWR_CR1_PLS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field DBP: Disable backup domain write protection In reset state, the RCC_BDCR register, the RTC registers (including the backup registers), BREN and MOEN bits in PWR_CR2 register, are protected against parasitic write access. This bit must be set to enable write access to these registers.
    const uint32_t PWR_CR1_DBP = 1U << 8 ;

  // Field FLPS: Flash low-power mode in DStop mode This bit allows to obtain the best trade-off between low-power consumption and restart time when exiting from DStop mode. When it is set, the Flash memory enters low-power mode when D1 domain is in DStop mode.
    const uint32_t PWR_CR1_FLPS = 1U << 9 ;

  // Field SVOS: System Stop mode voltage scaling selection These bits control the VCORE voltage level in system Stop mode, to obtain the best trade-off between power consumption and performance.
    inline uint32_t PWR_CR1_SVOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field AVDEN: Peripheral voltage monitor on VDDA enable
    const uint32_t PWR_CR1_AVDEN = 1U << 16 ;

  // Field ALS: Analog voltage detector level selection These bits select the voltage threshold detected by the AVD.
    inline uint32_t PWR_CR1_ALS (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

//------------------------------------------------------------------------------

//---  Register CSR1: PWR control status register 1
  #define PWR_CSR1 (* ((const volatile uint32_t *) (0x58024800 + 4)))

  // Field PVDO: Programmable voltage detect output This bit is set and cleared by hardware. It is valid only if the PVD has been enabled by the PVDE bit. Note: since the PVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the PVDE bit is set.
    const uint32_t PWR_CSR1_PVDO = 1U << 4 ;

  // Field ACTVOSRDY: Voltage levels ready bit for currently used VOS and SDLEVEL This bit is set to 1 by hardware when the voltage regulator and the SD converter are both disabled and Bypass mode is selected in PWR control register 3 (PWR_CR3).
    const uint32_t PWR_CSR1_ACTVOSRDY = 1U << 13 ;

  // Field ACTVOS: VOS currently applied for VCORE voltage scaling selection. These bits reflect the last VOS value applied to the PMU.
    inline uint32_t PWR_CSR1_ACTVOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field AVDO: Analog voltage detector output on VDDA This bit is set and cleared by hardware. It is valid only if AVD on VDDA is enabled by the AVDEN bit. Note: Since the AVD is disabled in Standby mode, this bit is equal to 0 after Standby or reset until the AVDEN bit is set.
    const uint32_t PWR_CSR1_AVDO = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register CR2: This register is not reset by wakeup from Standby mode, RESET signal and VDD POR. It is only reset by VSW POR and VSWRST reset. This register shall not be accessed when VSWRST bit in RCC_BDCR register resets the VSW domain.After reset, PWR_CR2 register is write-protected. Prior to modifying its content, the DBP bit in PWR_CR1 register must be set to disable the write protection.
  #define PWR_CR2 (* ((volatile uint32_t *) (0x58024800 + 8)))

  // Field BREN: Backup regulator enable When set, the Backup regulator (used to maintain the backup RAM content in Standby and VBAT modes) is enabled. If BREN is reset, the backup regulator is switched off. The backup RAM can still be used in Run and Stop modes. However, its content will be lost in Standby and VBAT modes. If BREN is set, the application must wait till the Backup Regulator Ready flag (BRRDY) is set to indicate that the data written into the SRAM will be maintained in Standby and VBAT modes.
    const uint32_t PWR_CR2_BREN = 1U << 0 ;

  // Field MONEN: VBAT and temperature monitoring enable When set, the VBAT supply and temperature monitoring is enabled.
    const uint32_t PWR_CR2_MONEN = 1U << 4 ;

  // Field BRRDY: Backup regulator ready This bit is set by hardware to indicate that the Backup regulator is ready.
    const uint32_t PWR_CR2_BRRDY = 1U << 16 ;

  // Field VBATL: VBAT level monitoring versus low threshold
    const uint32_t PWR_CR2_VBATL = 1U << 20 ;

  // Field VBATH: VBAT level monitoring versus high threshold
    const uint32_t PWR_CR2_VBATH = 1U << 21 ;

  // Field TEMPL: Temperature level monitoring versus low threshold
    const uint32_t PWR_CR2_TEMPL = 1U << 22 ;

  // Field TEMPH: Temperature level monitoring versus high threshold
    const uint32_t PWR_CR2_TEMPH = 1U << 23 ;

//------------------------------------------------------------------------------

//---  Register CR3: Reset only by POR only, not reset by wakeup from Standby mode and RESET pad. The lower byte of this register is written once after POR and shall be written before changing VOS level or ck_sys clock frequency. No limitation applies to the upper bytes.Programming data corresponding to an invalid combination of SDLEVEL, SDEXTHP, SDEN, LDOEN and BYPASS bits (see Table9) will be ignored: data will not be written, the written-once mechanism will lock the register and any further write access will be ignored. The default supply configuration will be kept and the ACTVOSRDY bit in PWR control status register 1 (PWR_CSR1) will go on indicating invalid voltage levels. The system shall be power cycled before writing a new value.
  #define PWR_CR3 (* ((volatile uint32_t *) (0x58024800 + 12)))

  // Field BYPASS: Power management unit bypass
    const uint32_t PWR_CR3_BYPASS = 1U << 0 ;

  // Field LDOEN: Low drop-out regulator enable
    const uint32_t PWR_CR3_LDOEN = 1U << 1 ;

  // Field SCUEN: SD converter Enable
    const uint32_t PWR_CR3_SCUEN = 1U << 2 ;

  // Field VBE: VBAT charging enable
    const uint32_t PWR_CR3_VBE = 1U << 8 ;

  // Field VBRS: VBAT charging resistor selection
    const uint32_t PWR_CR3_VBRS = 1U << 9 ;

  // Field USB33DEN: VDD33USB voltage level detector enable.
    const uint32_t PWR_CR3_USB33DEN = 1U << 24 ;

  // Field USBREGEN: USB regulator enable.
    const uint32_t PWR_CR3_USBREGEN = 1U << 25 ;

  // Field USB33RDY: USB supply ready.
    const uint32_t PWR_CR3_USB33RDY = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register CPUCR: This register allows controlling CPU1 power.
  #define PWR_CPUCR (* ((volatile uint32_t *) (0x58024800 + 16)))

  // Field PDDS_D1: D1 domain Power Down Deepsleep selection. This bit allows CPU1 to define the Deepsleep mode for D1 domain.
    const uint32_t PWR_CPUCR_PDDS_D1 = 1U << 0 ;

  // Field PDDS_D2: D2 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for D2 domain.
    const uint32_t PWR_CPUCR_PDDS_D2 = 1U << 1 ;

  // Field PDDS_D3: System D3 domain Power Down Deepsleep. This bit allows CPU1 to define the Deepsleep mode for System D3 domain.
    const uint32_t PWR_CPUCR_PDDS_D3 = 1U << 2 ;

  // Field STOPF: STOP flag This bit is set by hardware and cleared only by any reset or by setting the CPU1 CSSF bit.
    const uint32_t PWR_CPUCR_STOPF = 1U << 5 ;

  // Field SBF: System Standby flag This bit is set by hardware and cleared only by a POR (Power-on Reset) or by setting the CPU1 CSSF bit
    const uint32_t PWR_CPUCR_SBF = 1U << 6 ;

  // Field SBF_D1: D1 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D1 domain is no longer in DStandby mode.
    const uint32_t PWR_CPUCR_SBF_D1 = 1U << 7 ;

  // Field SBF_D2: D2 domain DStandby flag This bit is set by hardware and cleared by any system reset or by setting the CPU1 CSSF bit. Once set, this bit can be cleared only when the D2 domain is no longer in DStandby mode.
    const uint32_t PWR_CPUCR_SBF_D2 = 1U << 8 ;

  // Field CSSF: Clear D1 domain CPU1 Standby, Stop and HOLD flags (always read as 0) This bit is cleared to 0 by hardware.
    const uint32_t PWR_CPUCR_CSSF = 1U << 9 ;

  // Field RUN_D3: Keep system D3 domain in Run mode regardless of the CPU sub-systems modes
    const uint32_t PWR_CPUCR_RUN_D3 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register D3CR: This register allows controlling D3 domain power.Following reset VOSRDY will be read 1 by software
  #define PWR_D3CR (* ((volatile uint32_t *) (0x58024800 + 24)))

  // Field VOSRDY: VOS Ready bit for VCORE voltage scaling output selection. This bit is set to 1 by hardware when Bypass mode is selected in PWR control register 3 (PWR_CR3).
    const uint32_t PWR_D3CR_VOSRDY = 1U << 13 ;

  // Field VOS: Voltage scaling selection according to performance These bits control the VCORE voltage level and allow to obtains the best trade-off between power consumption and performance: When increasing the performance, the voltage scaling shall be changed before increasing the system frequency. When decreasing performance, the system frequency shall first be decreased before changing the voltage scaling.
    inline uint32_t PWR_D3CR_VOS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register WKUPCR: reset only by system reset, not reset by wakeup from Standby mode5 wait states are required when writing this register (when clearing a WKUPF bit in PWR_WKUPFR, the AHB write access will complete after the WKUPF has been cleared).
  #define PWR_WKUPCR (* ((volatile uint32_t *) (0x58024800 + 32)))

  // Field WKUPC: Clear Wakeup pin flag for WKUP. These bits are always read as 0.
    inline uint32_t PWR_WKUPCR_WKUPC (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register WKUPFR: reset only by system reset, not reset by wakeup from Standby mode
  #define PWR_WKUPFR (* ((volatile uint32_t *) (0x58024800 + 36)))

  // Field WKUPF1: Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    const uint32_t PWR_WKUPFR_WKUPF1 = 1U << 0 ;

  // Field WKUPF2: Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    const uint32_t PWR_WKUPFR_WKUPF2 = 1U << 1 ;

  // Field WKUPF3: Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    const uint32_t PWR_WKUPFR_WKUPF3 = 1U << 2 ;

  // Field WKUPF4: Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    const uint32_t PWR_WKUPFR_WKUPF4 = 1U << 3 ;

  // Field WKUPF5: Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    const uint32_t PWR_WKUPFR_WKUPF5 = 1U << 4 ;

  // Field WKUPF6: Wakeup pin WKUPF flag. This bit is set by hardware and cleared only by a Reset pin or by setting the WKUPCn+1 bit in the PWR wakeup clear register (PWR_WKUPCR).
    const uint32_t PWR_WKUPFR_WKUPF6 = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register WKUPEPR: Reset only by system reset, not reset by wakeup from Standby mode
  #define PWR_WKUPEPR (* ((volatile uint32_t *) (0x58024800 + 40)))

  // Field WKUPEN1: Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    const uint32_t PWR_WKUPEPR_WKUPEN1 = 1U << 0 ;

  // Field WKUPEN2: Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    const uint32_t PWR_WKUPEPR_WKUPEN2 = 1U << 1 ;

  // Field WKUPEN3: Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    const uint32_t PWR_WKUPEPR_WKUPEN3 = 1U << 2 ;

  // Field WKUPEN4: Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    const uint32_t PWR_WKUPEPR_WKUPEN4 = 1U << 3 ;

  // Field WKUPEN5: Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    const uint32_t PWR_WKUPEPR_WKUPEN5 = 1U << 4 ;

  // Field WKUPEN6: Enable Wakeup Pin WKUPn+1 Each bit is set and cleared by software. Note: An additional wakeup event is detected if WKUPn+1 pin is enabled (by setting the WKUPENn+1 bit) when WKUPn+1 pin level is already high when WKUPPn+1 selects rising edge, or low when WKUPPn+1 selects falling edge.
    const uint32_t PWR_WKUPEPR_WKUPEN6 = 1U << 5 ;

  // Field WKUPP1: Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    const uint32_t PWR_WKUPEPR_WKUPP1 = 1U << 8 ;

  // Field WKUPP2: Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    const uint32_t PWR_WKUPEPR_WKUPP2 = 1U << 9 ;

  // Field WKUPP3: Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    const uint32_t PWR_WKUPEPR_WKUPP3 = 1U << 10 ;

  // Field WKUPP4: Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    const uint32_t PWR_WKUPEPR_WKUPP4 = 1U << 11 ;

  // Field WKUPP5: Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    const uint32_t PWR_WKUPEPR_WKUPP5 = 1U << 12 ;

  // Field WKUPP6: Wakeup pin polarity bit for WKUPn-7 These bits define the polarity used for event detection on WKUPn-7 external wakeup pin.
    const uint32_t PWR_WKUPEPR_WKUPP6 = 1U << 13 ;

  // Field WKUPPUPD1: Wakeup pin pull configuration
    inline uint32_t PWR_WKUPEPR_WKUPPUPD1 (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field WKUPPUPD2: Wakeup pin pull configuration
    inline uint32_t PWR_WKUPEPR_WKUPPUPD2 (const uint32_t inValue) {return (inValue & 0x3U) << 18 ; }

  // Field WKUPPUPD3: Wakeup pin pull configuration
    inline uint32_t PWR_WKUPEPR_WKUPPUPD3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field WKUPPUPD4: Wakeup pin pull configuration
    inline uint32_t PWR_WKUPEPR_WKUPPUPD4 (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field WKUPPUPD5: Wakeup pin pull configuration
    inline uint32_t PWR_WKUPEPR_WKUPPUPD5 (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field WKUPPUPD6: Wakeup pin pull configuration for WKUP(truncate(n/2)-7) These bits define the I/O pad pull configuration used when WKUPEN(truncate(n/2)-7) = 1. The associated GPIO port pull configuration shall be set to the same value or to 00. The Wakeup pin pull configuration is kept in Standby mode.
    inline uint32_t PWR_WKUPEPR_WKUPPUPD6 (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

//------------------------------------------------------------------------------
// Peripheral QUADSPI: QUADSPI
//------------------------------------------------------------------------------

//---  Register CR: QUADSPI control register
  #define QUADSPI_CR (* ((volatile uint32_t *) (0x52005000 + 0)))

  // Field EN: Enable Enable the QUADSPI.
    const uint32_t QUADSPI_CR_EN = 1U << 0 ;

  // Field ABORT: Abort request This bit aborts the on-going command sequence. It is automatically reset once the abort is complete. This bit stops the current transfer. In polling mode or memory-mapped mode, this bit also reset the APM bit or the DM bit.
    const uint32_t QUADSPI_CR_ABORT = 1U << 1 ;

  // Field DMAEN: DMA enable In indirect mode, DMA can be used to input or output data via the QUADSPI_DR register. DMA transfers are initiated when the FIFO threshold flag, FTF, is set.
    const uint32_t QUADSPI_CR_DMAEN = 1U << 2 ;

  // Field TCEN: Timeout counter enable This bit is valid only when memory-mapped mode (FMODE = 11) is selected. Activating this bit causes the chip select (nCS) to be released (and thus reduces consumption) if there has not been an access after a certain amount of time, where this time is defined by TIMEOUT[15:0] (QUADSPI_LPTR). Enable the timeout counter. By default, the QUADSPI never stops its prefetch operation, keeping the previous read operation active with nCS maintained low, even if no access to the Flash memory occurs for a long time. Since Flash memories tend to consume more when nCS is held low, the application might want to activate the timeout counter (TCEN = 1, QUADSPI_CR[3]) so that nCS is released after a period of TIMEOUT[15:0] (QUADSPI_LPTR) cycles have elapsed without an access since when the FIFO becomes full with prefetch data. This bit can be modified only when BUSY = 0.
    const uint32_t QUADSPI_CR_TCEN = 1U << 3 ;

  // Field SSHIFT: Sample shift By default, the QUADSPI samples data 1/2 of a CLK cycle after the data is driven by the Flash memory. This bit allows the data is to be sampled later in order to account for external signal delays. Firmware must assure that SSHIFT = 0 when in DDR mode (when DDRM = 1). This field can be modified only when BUSY = 0.
    const uint32_t QUADSPI_CR_SSHIFT = 1U << 4 ;

  // Field DFM: Dual-flash mode This bit activates dual-flash mode, where two external Flash memories are used simultaneously to double throughput and capacity. This bit can be modified only when BUSY = 0.
    const uint32_t QUADSPI_CR_DFM = 1U << 6 ;

  // Field FSEL: Flash memory selection This bit selects the Flash memory to be addressed in single flash mode (when DFM = 0). This bit can be modified only when BUSY = 0. This bit is ignored when DFM = 1.
    const uint32_t QUADSPI_CR_FSEL = 1U << 7 ;

  // Field FTHRES: FIFO threshold level Defines, in indirect mode, the threshold number of bytes in the FIFO that will cause the FIFO threshold flag (FTF, QUADSPI_SR[2]) to be set. In indirect write mode (FMODE = 00): ... In indirect read mode (FMODE = 01): ... If DMAEN = 1, then the DMA controller for the corresponding channel must be disabled before changing the FTHRES value.
    inline uint32_t QUADSPI_CR_FTHRES (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field TEIE: Transfer error interrupt enable This bit enables the transfer error interrupt.
    const uint32_t QUADSPI_CR_TEIE = 1U << 16 ;

  // Field TCIE: Transfer complete interrupt enable This bit enables the transfer complete interrupt.
    const uint32_t QUADSPI_CR_TCIE = 1U << 17 ;

  // Field FTIE: FIFO threshold interrupt enable This bit enables the FIFO threshold interrupt.
    const uint32_t QUADSPI_CR_FTIE = 1U << 18 ;

  // Field SMIE: Status match interrupt enable This bit enables the status match interrupt.
    const uint32_t QUADSPI_CR_SMIE = 1U << 19 ;

  // Field TOIE: TimeOut interrupt enable This bit enables the TimeOut interrupt.
    const uint32_t QUADSPI_CR_TOIE = 1U << 20 ;

  // Field APMS: Automatic poll mode stop This bit determines if automatic polling is stopped after a match. This bit can be modified only when BUSY = 0.
    const uint32_t QUADSPI_CR_APMS = 1U << 22 ;

  // Field PMM: Polling match mode This bit indicates which method should be used for determining a match during automatic polling mode. This bit can be modified only when BUSY = 0.
    const uint32_t QUADSPI_CR_PMM = 1U << 23 ;

  // Field PRESCALER: clock prescaler
    inline uint32_t QUADSPI_CR_PRESCALER (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register DCR: QUADSPI device configuration register
  #define QUADSPI_DCR (* ((volatile uint32_t *) (0x52005000 + 4)))

  // Field CKMODE: indicates the level that clk takes between command
    const uint32_t QUADSPI_DCR_CKMODE = 1U << 0 ;

  // Field CSHT: Chip select high time CSHT+1 defines the minimum number of CLK cycles which the chip select (nCS) must remain high between commands issued to the Flash memory. ... This field can be modified only when BUSY = 0.
    inline uint32_t QUADSPI_DCR_CSHT (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field FSIZE: Flash memory size This field defines the size of external memory using the following formula: Number of bytes in Flash memory = 2[FSIZE+1] FSIZE+1 is effectively the number of address bits required to address the Flash memory. The Flash memory capacity can be up to 4GB (addressed using 32 bits) in indirect mode, but the addressable space in memory-mapped mode is limited to 256MB. If DFM = 1, FSIZE indicates the total capacity of the two Flash memories together. This field can be modified only when BUSY = 0.
    inline uint32_t QUADSPI_DCR_FSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SR: QUADSPI status register
  #define QUADSPI_SR (* ((const volatile uint32_t *) (0x52005000 + 8)))

  // Field TEF: Transfer error flag This bit is set in indirect mode when an invalid address is being accessed in indirect mode. It is cleared by writing 1 to CTEF.
    const uint32_t QUADSPI_SR_TEF = 1U << 0 ;

  // Field TCF: Transfer complete flag This bit is set in indirect mode when the programmed number of data has been transferred or in any mode when the transfer has been aborted.It is cleared by writing 1 to CTCF.
    const uint32_t QUADSPI_SR_TCF = 1U << 1 ;

  // Field FTF: FIFO threshold flag In indirect mode, this bit is set when the FIFO threshold has been reached, or if there is any data left in the FIFO after reads from the Flash memory are complete. It is cleared automatically as soon as threshold condition is no longer true. In automatic polling mode this bit is set every time the status register is read, and the bit is cleared when the data register is read.
    const uint32_t QUADSPI_SR_FTF = 1U << 2 ;

  // Field SMF: Status match flag This bit is set in automatic polling mode when the unmasked received data matches the corresponding bits in the match register (QUADSPI_PSMAR). It is cleared by writing 1 to CSMF.
    const uint32_t QUADSPI_SR_SMF = 1U << 3 ;

  // Field TOF: Timeout flag This bit is set when timeout occurs. It is cleared by writing 1 to CTOF.
    const uint32_t QUADSPI_SR_TOF = 1U << 4 ;

  // Field BUSY: Busy This bit is set when an operation is on going. This bit clears automatically when the operation with the Flash memory is finished and the FIFO is empty.
    const uint32_t QUADSPI_SR_BUSY = 1U << 5 ;

  // Field FLEVEL: FIFO level This field gives the number of valid bytes which are being held in the FIFO. FLEVEL = 0 when the FIFO is empty, and 16 when it is full. In memory-mapped mode and in automatic status polling mode, FLEVEL is zero.
    inline uint32_t QUADSPI_SR_FLEVEL (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register FCR: QUADSPI flag clear register
  #define QUADSPI_FCR (* ((volatile uint32_t *) (0x52005000 + 12)))

  // Field CTEF: Clear transfer error flag Writing 1 clears the TEF flag in the QUADSPI_SR register
    const uint32_t QUADSPI_FCR_CTEF = 1U << 0 ;

  // Field CTCF: Clear transfer complete flag Writing 1 clears the TCF flag in the QUADSPI_SR register
    const uint32_t QUADSPI_FCR_CTCF = 1U << 1 ;

  // Field CSMF: Clear status match flag Writing 1 clears the SMF flag in the QUADSPI_SR register
    const uint32_t QUADSPI_FCR_CSMF = 1U << 3 ;

  // Field CTOF: Clear timeout flag Writing 1 clears the TOF flag in the QUADSPI_SR register
    const uint32_t QUADSPI_FCR_CTOF = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register DLR: QUADSPI data length register
  #define QUADSPI_DLR (* ((volatile uint32_t *) (0x52005000 + 16)))

  // Field DL: Data length Number of data to be retrieved (value+1) in indirect and status-polling modes. A value no greater than 3 (indicating 4 bytes) should be used for status-polling mode. All 1s in indirect mode means undefined length, where QUADSPI will continue until the end of memory, as defined by FSIZE. 0x0000_0000: 1 byte is to be transferred 0x0000_0001: 2 bytes are to be transferred 0x0000_0002: 3 bytes are to be transferred 0x0000_0003: 4 bytes are to be transferred ... 0xFFFF_FFFD: 4,294,967,294 (4G-2) bytes are to be transferred 0xFFFF_FFFE: 4,294,967,295 (4G-1) bytes are to be transferred 0xFFFF_FFFF: undefined length -- all bytes until the end of Flash memory (as defined by FSIZE) are to be transferred. Continue reading indefinitely if FSIZE = 0x1F. DL[0] is stuck at 1 in dual-flash mode (DFM = 1) even when 0 is written to this bit, thus assuring that each access transfers an even number of bytes. This field has no effect when in memory-mapped mode (FMODE = 10). This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_DLR_DL (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR: QUADSPI communication configuration register
  #define QUADSPI_CCR (* ((volatile uint32_t *) (0x52005000 + 20)))

  // Field INSTRUCTION: Instruction Instruction to be send to the external SPI device. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_INSTRUCTION (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field IMODE: Instruction mode This field defines the instruction phase mode of operation: This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_IMODE (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ADMODE: Address mode This field defines the address phase mode of operation: This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_ADMODE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field ADSIZE: Address size This bit defines address size: This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_ADSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ABMODE: Alternate bytes mode This field defines the alternate-bytes phase mode of operation: This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_ABMODE (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field ABSIZE: Alternate bytes size This bit defines alternate bytes size: This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_ABSIZE (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field DCYC: Number of dummy cycles This field defines the duration of the dummy phase. In both SDR and DDR modes, it specifies a number of CLK cycles (0-31). This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_DCYC (const uint32_t inValue) {return (inValue & 0x1FU) << 18 ; }

  // Field DMODE: Data mode This field defines the data phases mode of operation: This field also determines the dummy phase mode of operation. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_DMODE (const uint32_t inValue) {return (inValue & 0x3U) << 24 ; }

  // Field FMODE: Functional mode This field defines the QUADSPI functional mode of operation. If DMAEN = 1 already, then the DMA controller for the corresponding channel must be disabled before changing the FMODE value. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_CCR_FMODE (const uint32_t inValue) {return (inValue & 0x3U) << 26 ; }

  // Field SIOO: Send instruction only once mode See Section15.3.11: Sending the instruction only once on page13. This bit has no effect when IMODE = 00. This field can be written only when BUSY = 0.
    const uint32_t QUADSPI_CCR_SIOO = 1U << 28 ;

  // Field DHHC: DDR hold Delay the data output by 1/4 of the QUADSPI output clock cycle in DDR mode: This feature is only active in DDR mode. This field can be written only when BUSY = 0.
    const uint32_t QUADSPI_CCR_DHHC = 1U << 30 ;

  // Field DDRM: Double data rate mode This bit sets the DDR mode for the address, alternate byte and data phase: This field can be written only when BUSY = 0.
    const uint32_t QUADSPI_CCR_DDRM = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AR: QUADSPI address register
  #define QUADSPI_AR (* ((volatile uint32_t *) (0x52005000 + 24)))

  // Field ADDRESS: [31 0]: Address Address to be send to the external Flash memory Writes to this field are ignored when BUSY = 0 or when FMODE = 11 (memory-mapped mode). In dual flash mode, ADDRESS[0] is automatically stuck to 0 as the address should always be even
    inline uint32_t QUADSPI_AR_ADDRESS (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ABR: QUADSPI alternate bytes registers
  #define QUADSPI_ABR (* ((volatile uint32_t *) (0x52005000 + 28)))

  // Field ALTERNATE: Alternate Bytes Optional data to be send to the external SPI device right after the address. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_ABR_ALTERNATE (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR: QUADSPI data register
  #define QUADSPI_DR (* ((volatile uint32_t *) (0x52005000 + 32)))

  // Field DATA: Data Data to be sent/received to/from the external SPI device. In indirect write mode, data written to this register is stored on the FIFO before it is sent to the Flash memory during the data phase. If the FIFO is too full, a write operation is stalled until the FIFO has enough space to accept the amount of data being written. In indirect read mode, reading this register gives (via the FIFO) the data which was received from the Flash memory. If the FIFO does not have as many bytes as requested by the read operation and if BUSY=1, the read operation is stalled until enough data is present or until the transfer is complete, whichever happens first. In automatic polling mode, this register contains the last data read from the Flash memory (without masking). Word, halfword, and byte accesses to this register are supported. In indirect write mode, a byte write adds 1 byte to the FIFO, a halfword write 2, and a word write 4. Similarly, in indirect read mode, a byte read removes 1 byte from the FIFO, a halfword read 2, and a word read 4. Accesses in indirect mode must be aligned to the bottom of this register: a byte read must read DATA[7:0] and a halfword read must read DATA[15:0].
    inline uint32_t QUADSPI_DR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PSMKR: QUADSPI polling status mask register
  #define QUADSPI_PSMKR (* ((volatile uint32_t *) (0x52005000 + 36)))

  // Field MASK: Status mask Mask to be applied to the status bytes received in polling mode. For bit n: This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_PSMKR_MASK (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PSMAR: QUADSPI polling status match register
  #define QUADSPI_PSMAR (* ((volatile uint32_t *) (0x52005000 + 40)))

  // Field MATCH: Status match Value to be compared with the masked status register to get a match. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_PSMAR_MATCH (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PIR: QUADSPI polling interval register
  #define QUADSPI_PIR (* ((volatile uint32_t *) (0x52005000 + 44)))

  // Field INTERVAL: Polling interval Number of CLK cycles between to read during automatic polling phases. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_PIR_INTERVAL (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register LPTR: QUADSPI low-power timeout register
  #define QUADSPI_LPTR (* ((volatile uint32_t *) (0x52005000 + 48)))

  // Field TIMEOUT: Timeout period After each access in memory-mapped mode, the QUADSPI prefetches the subsequent bytes and holds these bytes in the FIFO. This field indicates how many CLK cycles the QUADSPI waits after the FIFO becomes full until it raises nCS, putting the Flash memory in a lower-consumption state. This field can be written only when BUSY = 0.
    inline uint32_t QUADSPI_LPTR_TIMEOUT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral RCC: Reset and clock control
//------------------------------------------------------------------------------

//---  Register CR: clock control register
  #define RCC_CR (* ((volatile uint32_t *) (0x58024400 + 0)))

  // Field HSION: Internal high-speed clock enable
    const uint32_t RCC_CR_HSION = 1U << 0 ;

  // Field HSIKERON: High Speed Internal clock enable in Stop mode
    const uint32_t RCC_CR_HSIKERON = 1U << 1 ;

  // Field HSIRDY: HSI clock ready flag
    const uint32_t RCC_CR_HSIRDY = 1U << 2 ;

  // Field HSIDIV: HSI clock divider
    inline uint32_t RCC_CR_HSIDIV (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field HSIDIVF: HSI divider flag
    const uint32_t RCC_CR_HSIDIVF = 1U << 5 ;

  // Field CSION: CSI clock enable
    const uint32_t RCC_CR_CSION = 1U << 7 ;

  // Field CSIRDY: CSI clock ready flag
    const uint32_t RCC_CR_CSIRDY = 1U << 8 ;

  // Field CSIKERON: CSI clock enable in Stop mode
    const uint32_t RCC_CR_CSIKERON = 1U << 9 ;

  // Field RC48ON: RC48 clock enable
    const uint32_t RCC_CR_RC48ON = 1U << 12 ;

  // Field RC48RDY: RC48 clock ready flag
    const uint32_t RCC_CR_RC48RDY = 1U << 13 ;

  // Field D1CKRDY: D1 domain clocks ready flag
    const uint32_t RCC_CR_D1CKRDY = 1U << 14 ;

  // Field D2CKRDY: D2 domain clocks ready flag
    const uint32_t RCC_CR_D2CKRDY = 1U << 15 ;

  // Field HSEON: HSE clock enable
    const uint32_t RCC_CR_HSEON = 1U << 16 ;

  // Field HSERDY: HSE clock ready flag
    const uint32_t RCC_CR_HSERDY = 1U << 17 ;

  // Field HSEBYP: HSE clock bypass
    const uint32_t RCC_CR_HSEBYP = 1U << 18 ;

  // Field HSECSSON: HSE Clock Security System enable
    const uint32_t RCC_CR_HSECSSON = 1U << 19 ;

  // Field PLL1ON: PLL1 enable
    const uint32_t RCC_CR_PLL1ON = 1U << 24 ;

  // Field PLL1RDY: PLL1 clock ready flag
    const uint32_t RCC_CR_PLL1RDY = 1U << 25 ;

  // Field PLL2ON: PLL2 enable
    const uint32_t RCC_CR_PLL2ON = 1U << 26 ;

  // Field PLL2RDY: PLL2 clock ready flag
    const uint32_t RCC_CR_PLL2RDY = 1U << 27 ;

  // Field PLL3ON: PLL3 enable
    const uint32_t RCC_CR_PLL3ON = 1U << 28 ;

  // Field PLL3RDY: PLL3 clock ready flag
    const uint32_t RCC_CR_PLL3RDY = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register ICSCR: RCC Internal Clock Source Calibration Register
  #define RCC_ICSCR (* ((volatile uint32_t *) (0x58024400 + 4)))

  // Field HSICAL: HSI clock calibration
    inline uint32_t RCC_ICSCR_HSICAL (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field HSITRIM: HSI clock trimming
    inline uint32_t RCC_ICSCR_HSITRIM (const uint32_t inValue) {return (inValue & 0x3FU) << 12 ; }

  // Field CSICAL: CSI clock calibration
    inline uint32_t RCC_ICSCR_CSICAL (const uint32_t inValue) {return (inValue & 0xFFU) << 18 ; }

  // Field CSITRIM: CSI clock trimming
    inline uint32_t RCC_ICSCR_CSITRIM (const uint32_t inValue) {return (inValue & 0x1FU) << 26 ; }

//------------------------------------------------------------------------------

//---  Register CRRCR: RCC Clock Recovery RC Register
  #define RCC_CRRCR (* ((const volatile uint32_t *) (0x58024400 + 8)))

  // Field RC48CAL: Internal RC 48 MHz clock calibration
    inline uint32_t RCC_CRRCR_RC48CAL (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFGR: RCC Clock Configuration Register
  #define RCC_CFGR (* ((volatile uint32_t *) (0x58024400 + 16)))

  // Field SW: System clock switch
    inline uint32_t RCC_CFGR_SW (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field SWS: System clock switch status
    inline uint32_t RCC_CFGR_SWS (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field STOPWUCK: System clock selection after a wake up from system Stop
    const uint32_t RCC_CFGR_STOPWUCK = 1U << 6 ;

  // Field STOPKERWUCK: Kernel clock selection after a wake up from system Stop
    const uint32_t RCC_CFGR_STOPKERWUCK = 1U << 7 ;

  // Field RTCPRE: HSE division factor for RTC clock
    inline uint32_t RCC_CFGR_RTCPRE (const uint32_t inValue) {return (inValue & 0x3FU) << 8 ; }

  // Field HRTIMSEL: High Resolution Timer clock prescaler selection
    const uint32_t RCC_CFGR_HRTIMSEL = 1U << 14 ;

  // Field TIMPRE: Timers clocks prescaler selection
    const uint32_t RCC_CFGR_TIMPRE = 1U << 15 ;

  // Field MCO1PRE: MCO1 prescaler
    inline uint32_t RCC_CFGR_MCO1PRE (const uint32_t inValue) {return (inValue & 0xFU) << 18 ; }

  // Field MCO1SEL: Micro-controller clock output 1
    inline uint32_t RCC_CFGR_MCO1SEL (const uint32_t inValue) {return (inValue & 0x7U) << 22 ; }

  // Field MCO2PRE: MCO2 prescaler
    inline uint32_t RCC_CFGR_MCO2PRE (const uint32_t inValue) {return (inValue & 0xFU) << 25 ; }

  // Field MCO2SEL: Micro-controller clock output 2
    inline uint32_t RCC_CFGR_MCO2SEL (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

//------------------------------------------------------------------------------

//---  Register D1CFGR: RCC Domain 1 Clock Configuration Register
  #define RCC_D1CFGR (* ((volatile uint32_t *) (0x58024400 + 24)))

  // Field HPRE: D1 domain AHB prescaler
    inline uint32_t RCC_D1CFGR_HPRE (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field D1PPRE: D1 domain APB3 prescaler
    inline uint32_t RCC_D1CFGR_D1PPRE (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field D1CPRE: D1 domain Core prescaler
    inline uint32_t RCC_D1CFGR_D1CPRE (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register D2CFGR: RCC Domain 2 Clock Configuration Register
  #define RCC_D2CFGR (* ((volatile uint32_t *) (0x58024400 + 28)))

  // Field D2PPRE1: D2 domain APB1 prescaler
    inline uint32_t RCC_D2CFGR_D2PPRE1 (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field D2PPRE2: D2 domain APB2 prescaler
    inline uint32_t RCC_D2CFGR_D2PPRE2 (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

//------------------------------------------------------------------------------

//---  Register D3CFGR: RCC Domain 3 Clock Configuration Register
  #define RCC_D3CFGR (* ((volatile uint32_t *) (0x58024400 + 32)))

  // Field D3PPRE: D3 domain APB4 prescaler
    inline uint32_t RCC_D3CFGR_D3PPRE (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register PLLCKSELR: RCC PLLs Clock Source Selection Register
  #define RCC_PLLCKSELR (* ((volatile uint32_t *) (0x58024400 + 40)))

  // Field PLLSRC: DIVMx and PLLs clock source selection
    inline uint32_t RCC_PLLCKSELR_PLLSRC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field DIVM1: Prescaler for PLL1
    inline uint32_t RCC_PLLCKSELR_DIVM1 (const uint32_t inValue) {return (inValue & 0x3FU) << 4 ; }

  // Field DIVM2: Prescaler for PLL2
    inline uint32_t RCC_PLLCKSELR_DIVM2 (const uint32_t inValue) {return (inValue & 0x3FU) << 12 ; }

  // Field DIVM3: Prescaler for PLL3
    inline uint32_t RCC_PLLCKSELR_DIVM3 (const uint32_t inValue) {return (inValue & 0x3FU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register PLLCFGR: RCC PLLs Configuration Register
  #define RCC_PLLCFGR (* ((volatile uint32_t *) (0x58024400 + 44)))

  // Field PLL1FRACEN: PLL1 fractional latch enable
    const uint32_t RCC_PLLCFGR_PLL1FRACEN = 1U << 0 ;

  // Field PLL1VCOSEL: PLL1 VCO selection
    const uint32_t RCC_PLLCFGR_PLL1VCOSEL = 1U << 1 ;

  // Field PLL1RGE: PLL1 input frequency range
    inline uint32_t RCC_PLLCFGR_PLL1RGE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field PLL2FRACEN: PLL2 fractional latch enable
    const uint32_t RCC_PLLCFGR_PLL2FRACEN = 1U << 4 ;

  // Field PLL2VCOSEL: PLL2 VCO selection
    const uint32_t RCC_PLLCFGR_PLL2VCOSEL = 1U << 5 ;

  // Field PLL2RGE: PLL2 input frequency range
    inline uint32_t RCC_PLLCFGR_PLL2RGE (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field PLL3FRACEN: PLL3 fractional latch enable
    const uint32_t RCC_PLLCFGR_PLL3FRACEN = 1U << 8 ;

  // Field PLL3VCOSEL: PLL3 VCO selection
    const uint32_t RCC_PLLCFGR_PLL3VCOSEL = 1U << 9 ;

  // Field PLL3RGE: PLL3 input frequency range
    inline uint32_t RCC_PLLCFGR_PLL3RGE (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field DIVP1EN: PLL1 DIVP divider output enable
    const uint32_t RCC_PLLCFGR_DIVP1EN = 1U << 16 ;

  // Field DIVQ1EN: PLL1 DIVQ divider output enable
    const uint32_t RCC_PLLCFGR_DIVQ1EN = 1U << 17 ;

  // Field DIVR1EN: PLL1 DIVR divider output enable
    const uint32_t RCC_PLLCFGR_DIVR1EN = 1U << 18 ;

  // Field DIVP2EN: PLL2 DIVP divider output enable
    const uint32_t RCC_PLLCFGR_DIVP2EN = 1U << 19 ;

  // Field DIVQ2EN: PLL2 DIVQ divider output enable
    const uint32_t RCC_PLLCFGR_DIVQ2EN = 1U << 20 ;

  // Field DIVR2EN: PLL2 DIVR divider output enable
    const uint32_t RCC_PLLCFGR_DIVR2EN = 1U << 21 ;

  // Field DIVP3EN: PLL3 DIVP divider output enable
    const uint32_t RCC_PLLCFGR_DIVP3EN = 1U << 22 ;

  // Field DIVQ3EN: PLL3 DIVQ divider output enable
    const uint32_t RCC_PLLCFGR_DIVQ3EN = 1U << 23 ;

  // Field DIVR3EN: PLL3 DIVR divider output enable
    const uint32_t RCC_PLLCFGR_DIVR3EN = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register PLL1DIVR: RCC PLL1 Dividers Configuration Register
  #define RCC_PLL1DIVR (* ((volatile uint32_t *) (0x58024400 + 48)))

  // Field DIVN1: Multiplication factor for PLL1 VCO
    inline uint32_t RCC_PLL1DIVR_DIVN1 (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field DIVP1: PLL1 DIVP division factor
    inline uint32_t RCC_PLL1DIVR_DIVP1 (const uint32_t inValue) {return (inValue & 0x7FU) << 9 ; }

  // Field DIVQ1: PLL1 DIVQ division factor
    inline uint32_t RCC_PLL1DIVR_DIVQ1 (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field DIVR1: PLL1 DIVR division factor
    inline uint32_t RCC_PLL1DIVR_DIVR1 (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register PLL1FRACR: RCC PLL1 Fractional Divider Register
  #define RCC_PLL1FRACR (* ((volatile uint32_t *) (0x58024400 + 52)))

  // Field FRACN1: Fractional part of the multiplication factor for PLL1 VCO
    inline uint32_t RCC_PLL1FRACR_FRACN1 (const uint32_t inValue) {return (inValue & 0x1FFFU) << 3 ; }

//------------------------------------------------------------------------------

//---  Register PLL2DIVR: RCC PLL2 Dividers Configuration Register
  #define RCC_PLL2DIVR (* ((volatile uint32_t *) (0x58024400 + 56)))

  // Field DIVN1: Multiplication factor for PLL1 VCO
    inline uint32_t RCC_PLL2DIVR_DIVN1 (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field DIVP1: PLL1 DIVP division factor
    inline uint32_t RCC_PLL2DIVR_DIVP1 (const uint32_t inValue) {return (inValue & 0x7FU) << 9 ; }

  // Field DIVQ1: PLL1 DIVQ division factor
    inline uint32_t RCC_PLL2DIVR_DIVQ1 (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field DIVR1: PLL1 DIVR division factor
    inline uint32_t RCC_PLL2DIVR_DIVR1 (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register PLL2FRACR: RCC PLL2 Fractional Divider Register
  #define RCC_PLL2FRACR (* ((volatile uint32_t *) (0x58024400 + 60)))

  // Field FRACN2: Fractional part of the multiplication factor for PLL VCO
    inline uint32_t RCC_PLL2FRACR_FRACN2 (const uint32_t inValue) {return (inValue & 0x1FFFU) << 3 ; }

//------------------------------------------------------------------------------

//---  Register PLL3DIVR: RCC PLL3 Dividers Configuration Register
  #define RCC_PLL3DIVR (* ((volatile uint32_t *) (0x58024400 + 64)))

  // Field DIVN3: Multiplication factor for PLL1 VCO
    inline uint32_t RCC_PLL3DIVR_DIVN3 (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field DIVP3: PLL DIVP division factor
    inline uint32_t RCC_PLL3DIVR_DIVP3 (const uint32_t inValue) {return (inValue & 0x7FU) << 9 ; }

  // Field DIVQ3: PLL DIVQ division factor
    inline uint32_t RCC_PLL3DIVR_DIVQ3 (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

  // Field DIVR3: PLL DIVR division factor
    inline uint32_t RCC_PLL3DIVR_DIVR3 (const uint32_t inValue) {return (inValue & 0x7FU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register PLL3FRACR: RCC PLL3 Fractional Divider Register
  #define RCC_PLL3FRACR (* ((volatile uint32_t *) (0x58024400 + 68)))

  // Field FRACN3: Fractional part of the multiplication factor for PLL3 VCO
    inline uint32_t RCC_PLL3FRACR_FRACN3 (const uint32_t inValue) {return (inValue & 0x1FFFU) << 3 ; }

//------------------------------------------------------------------------------

//---  Register D1CCIPR: RCC Domain 1 Kernel Clock Configuration Register
  #define RCC_D1CCIPR (* ((volatile uint32_t *) (0x58024400 + 76)))

  // Field FMCSRC: FMC kernel clock source selection
    inline uint32_t RCC_D1CCIPR_FMCSRC (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field QSPISRC: QUADSPI kernel clock source selection
    inline uint32_t RCC_D1CCIPR_QSPISRC (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SDMMCSRC: SDMMC kernel clock source selection
    const uint32_t RCC_D1CCIPR_SDMMCSRC = 1U << 16 ;

  // Field CKPERSRC: per_ck clock source selection
    inline uint32_t RCC_D1CCIPR_CKPERSRC (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register D2CCIP1R: RCC Domain 2 Kernel Clock Configuration Register
  #define RCC_D2CCIP1R (* ((volatile uint32_t *) (0x58024400 + 80)))

  // Field SAI1SRC: SAI1 and DFSDM1 kernel Aclk clock source selection
    inline uint32_t RCC_D2CCIP1R_SAI1SRC (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field SAI23SRC: SAI2 and SAI3 kernel clock source selection
    inline uint32_t RCC_D2CCIP1R_SAI23SRC (const uint32_t inValue) {return (inValue & 0x7U) << 6 ; }

  // Field SPI123SRC: SPI/I2S1,2 and 3 kernel clock source selection
    inline uint32_t RCC_D2CCIP1R_SPI123SRC (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field SPI45SRC: SPI4 and 5 kernel clock source selection
    inline uint32_t RCC_D2CCIP1R_SPI45SRC (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field SPDIFSRC: SPDIFRX kernel clock source selection
    inline uint32_t RCC_D2CCIP1R_SPDIFSRC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field DFSDM1SRC: DFSDM1 kernel Clk clock source selection
    const uint32_t RCC_D2CCIP1R_DFSDM1SRC = 1U << 24 ;

  // Field FDCANSRC: FDCAN kernel clock source selection
    inline uint32_t RCC_D2CCIP1R_FDCANSRC (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field SWPSRC: SWPMI kernel clock source selection
    const uint32_t RCC_D2CCIP1R_SWPSRC = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register D2CCIP2R: RCC Domain 2 Kernel Clock Configuration Register
  #define RCC_D2CCIP2R (* ((volatile uint32_t *) (0x58024400 + 84)))

  // Field USART234578SRC: USART2/3, UART4,5, 7/8 (APB1) kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_USART234578SRC (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field USART16SRC: USART1 and 6 kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_USART16SRC (const uint32_t inValue) {return (inValue & 0x7U) << 3 ; }

  // Field RNGSRC: RNG kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_RNGSRC (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field I2C123SRC: I2C1,2,3 kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_I2C123SRC (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field USBSRC: USBOTG 1 and 2 kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_USBSRC (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field CECSRC: HDMI-CEC kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_CECSRC (const uint32_t inValue) {return (inValue & 0x3U) << 22 ; }

  // Field LPTIM1SRC: LPTIM1 kernel clock source selection
    inline uint32_t RCC_D2CCIP2R_LPTIM1SRC (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register D3CCIPR: RCC Domain 3 Kernel Clock Configuration Register
  #define RCC_D3CCIPR (* ((volatile uint32_t *) (0x58024400 + 88)))

  // Field LPUART1SRC: LPUART1 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_LPUART1SRC (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field I2C4SRC: I2C4 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_I2C4SRC (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field LPTIM2SRC: LPTIM2 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_LPTIM2SRC (const uint32_t inValue) {return (inValue & 0x7U) << 10 ; }

  // Field LPTIM345SRC: LPTIM3,4,5 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_LPTIM345SRC (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field ADCSRC: SAR ADC kernel clock source selection
    inline uint32_t RCC_D3CCIPR_ADCSRC (const uint32_t inValue) {return (inValue & 0x3U) << 16 ; }

  // Field SAI4ASRC: Sub-Block A of SAI4 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_SAI4ASRC (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field SAI4BSRC: Sub-Block B of SAI4 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_SAI4BSRC (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field SPI6SRC: SPI6 kernel clock source selection
    inline uint32_t RCC_D3CCIPR_SPI6SRC (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register CIER: RCC Clock Source Interrupt Enable Register
  #define RCC_CIER (* ((volatile uint32_t *) (0x58024400 + 96)))

  // Field LSIRDYIE: LSI ready Interrupt Enable
    const uint32_t RCC_CIER_LSIRDYIE = 1U << 0 ;

  // Field LSERDYIE: LSE ready Interrupt Enable
    const uint32_t RCC_CIER_LSERDYIE = 1U << 1 ;

  // Field HSIRDYIE: HSI ready Interrupt Enable
    const uint32_t RCC_CIER_HSIRDYIE = 1U << 2 ;

  // Field HSERDYIE: HSE ready Interrupt Enable
    const uint32_t RCC_CIER_HSERDYIE = 1U << 3 ;

  // Field CSIRDYIE: CSI ready Interrupt Enable
    const uint32_t RCC_CIER_CSIRDYIE = 1U << 4 ;

  // Field RC48RDYIE: RC48 ready Interrupt Enable
    const uint32_t RCC_CIER_RC48RDYIE = 1U << 5 ;

  // Field PLL1RDYIE: PLL1 ready Interrupt Enable
    const uint32_t RCC_CIER_PLL1RDYIE = 1U << 6 ;

  // Field PLL2RDYIE: PLL2 ready Interrupt Enable
    const uint32_t RCC_CIER_PLL2RDYIE = 1U << 7 ;

  // Field PLL3RDYIE: PLL3 ready Interrupt Enable
    const uint32_t RCC_CIER_PLL3RDYIE = 1U << 8 ;

  // Field LSECSSIE: LSE clock security system Interrupt Enable
    const uint32_t RCC_CIER_LSECSSIE = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register CIFR: RCC Clock Source Interrupt Flag Register
  #define RCC_CIFR (* ((volatile uint32_t *) (0x58024400 + 100)))

  // Field LSIRDYF: LSI ready Interrupt Flag
    const uint32_t RCC_CIFR_LSIRDYF = 1U << 0 ;

  // Field LSERDYF: LSE ready Interrupt Flag
    const uint32_t RCC_CIFR_LSERDYF = 1U << 1 ;

  // Field HSIRDYF: HSI ready Interrupt Flag
    const uint32_t RCC_CIFR_HSIRDYF = 1U << 2 ;

  // Field HSERDYF: HSE ready Interrupt Flag
    const uint32_t RCC_CIFR_HSERDYF = 1U << 3 ;

  // Field CSIRDY: CSI ready Interrupt Flag
    const uint32_t RCC_CIFR_CSIRDY = 1U << 4 ;

  // Field RC48RDYF: RC48 ready Interrupt Flag
    const uint32_t RCC_CIFR_RC48RDYF = 1U << 5 ;

  // Field PLL1RDYF: PLL1 ready Interrupt Flag
    const uint32_t RCC_CIFR_PLL1RDYF = 1U << 6 ;

  // Field PLL2RDYF: PLL2 ready Interrupt Flag
    const uint32_t RCC_CIFR_PLL2RDYF = 1U << 7 ;

  // Field PLL3RDYF: PLL3 ready Interrupt Flag
    const uint32_t RCC_CIFR_PLL3RDYF = 1U << 8 ;

  // Field LSECSSF: LSE clock security system Interrupt Flag
    const uint32_t RCC_CIFR_LSECSSF = 1U << 9 ;

  // Field HSECSSF: HSE clock security system Interrupt Flag
    const uint32_t RCC_CIFR_HSECSSF = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register CICR: RCC Clock Source Interrupt Clear Register
  #define RCC_CICR (* ((volatile uint32_t *) (0x58024400 + 104)))

  // Field LSIRDYC: LSI ready Interrupt Clear
    const uint32_t RCC_CICR_LSIRDYC = 1U << 0 ;

  // Field LSERDYC: LSE ready Interrupt Clear
    const uint32_t RCC_CICR_LSERDYC = 1U << 1 ;

  // Field HSIRDYC: HSI ready Interrupt Clear
    const uint32_t RCC_CICR_HSIRDYC = 1U << 2 ;

  // Field HSERDYC: HSE ready Interrupt Clear
    const uint32_t RCC_CICR_HSERDYC = 1U << 3 ;

  // Field HSE_ready_Interrupt_Clear: CSI ready Interrupt Clear
    const uint32_t RCC_CICR_HSE_ready_Interrupt_Clear = 1U << 4 ;

  // Field RC48RDYC: RC48 ready Interrupt Clear
    const uint32_t RCC_CICR_RC48RDYC = 1U << 5 ;

  // Field PLL1RDYC: PLL1 ready Interrupt Clear
    const uint32_t RCC_CICR_PLL1RDYC = 1U << 6 ;

  // Field PLL2RDYC: PLL2 ready Interrupt Clear
    const uint32_t RCC_CICR_PLL2RDYC = 1U << 7 ;

  // Field PLL3RDYC: PLL3 ready Interrupt Clear
    const uint32_t RCC_CICR_PLL3RDYC = 1U << 8 ;

  // Field LSECSSC: LSE clock security system Interrupt Clear
    const uint32_t RCC_CICR_LSECSSC = 1U << 9 ;

  // Field HSECSSC: HSE clock security system Interrupt Clear
    const uint32_t RCC_CICR_HSECSSC = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register BDCR: RCC Backup Domain Control Register
  #define RCC_BDCR (* ((volatile uint32_t *) (0x58024400 + 112)))

  // Field LSEON: LSE oscillator enabled
    const uint32_t RCC_BDCR_LSEON = 1U << 0 ;

  // Field LSERDY: LSE oscillator ready
    const uint32_t RCC_BDCR_LSERDY = 1U << 1 ;

  // Field LSEBYP: LSE oscillator bypass
    const uint32_t RCC_BDCR_LSEBYP = 1U << 2 ;

  // Field LSEDRV: LSE oscillator driving capability
    inline uint32_t RCC_BDCR_LSEDRV (const uint32_t inValue) {return (inValue & 0x3U) << 3 ; }

  // Field LSECSSON: LSE clock security system enable
    const uint32_t RCC_BDCR_LSECSSON = 1U << 5 ;

  // Field LSECSSD: LSE clock security system failure detection
    const uint32_t RCC_BDCR_LSECSSD = 1U << 6 ;

  // Field RTCSRC: RTC clock source selection
    inline uint32_t RCC_BDCR_RTCSRC (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field RTCEN: RTC clock enable
    const uint32_t RCC_BDCR_RTCEN = 1U << 15 ;

  // Field VSWRST: VSwitch domain software reset
    const uint32_t RCC_BDCR_VSWRST = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register CSR: RCC Clock Control and Status Register
  #define RCC_CSR (* ((volatile uint32_t *) (0x58024400 + 116)))

  // Field LSION: LSI oscillator enable
    const uint32_t RCC_CSR_LSION = 1U << 0 ;

  // Field LSIRDY: LSI oscillator ready
    const uint32_t RCC_CSR_LSIRDY = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register AHB3RSTR: RCC AHB3 Reset Register
  #define RCC_AHB3RSTR (* ((volatile uint32_t *) (0x58024400 + 124)))

  // Field MDMARST: MDMA block reset
    const uint32_t RCC_AHB3RSTR_MDMARST = 1U << 0 ;

  // Field DMA2DRST: DMA2D block reset
    const uint32_t RCC_AHB3RSTR_DMA2DRST = 1U << 4 ;

  // Field JPGDECRST: JPGDEC block reset
    const uint32_t RCC_AHB3RSTR_JPGDECRST = 1U << 5 ;

  // Field FMCRST: FMC block reset
    const uint32_t RCC_AHB3RSTR_FMCRST = 1U << 12 ;

  // Field QSPIRST: QUADSPI and QUADSPI delay block reset
    const uint32_t RCC_AHB3RSTR_QSPIRST = 1U << 14 ;

  // Field SDMMC1RST: SDMMC1 and SDMMC1 delay block reset
    const uint32_t RCC_AHB3RSTR_SDMMC1RST = 1U << 16 ;

  // Field CPURST: CPU reset
    const uint32_t RCC_AHB3RSTR_CPURST = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB1RSTR: RCC AHB1 Peripheral Reset Register
  #define RCC_AHB1RSTR (* ((volatile uint32_t *) (0x58024400 + 128)))

  // Field DMA1RST: DMA1 block reset
    const uint32_t RCC_AHB1RSTR_DMA1RST = 1U << 0 ;

  // Field DMA2RST: DMA2 block reset
    const uint32_t RCC_AHB1RSTR_DMA2RST = 1U << 1 ;

  // Field ADC12RST: ADC1&2 block reset
    const uint32_t RCC_AHB1RSTR_ADC12RST = 1U << 5 ;

  // Field ETH1MACRST: ETH1MAC block reset
    const uint32_t RCC_AHB1RSTR_ETH1MACRST = 1U << 15 ;

  // Field USB1OTGRST: USB1OTG block reset
    const uint32_t RCC_AHB1RSTR_USB1OTGRST = 1U << 25 ;

  // Field USB2OTGRST: USB2OTG block reset
    const uint32_t RCC_AHB1RSTR_USB2OTGRST = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register AHB2RSTR: RCC AHB2 Peripheral Reset Register
  #define RCC_AHB2RSTR (* ((volatile uint32_t *) (0x58024400 + 132)))

  // Field CAMITFRST: CAMITF block reset
    const uint32_t RCC_AHB2RSTR_CAMITFRST = 1U << 0 ;

  // Field CRYPTRST: Cryptography block reset
    const uint32_t RCC_AHB2RSTR_CRYPTRST = 1U << 4 ;

  // Field HASHRST: Hash block reset
    const uint32_t RCC_AHB2RSTR_HASHRST = 1U << 5 ;

  // Field RNGRST: Random Number Generator block reset
    const uint32_t RCC_AHB2RSTR_RNGRST = 1U << 6 ;

  // Field SDMMC2RST: SDMMC2 and SDMMC2 Delay block reset
    const uint32_t RCC_AHB2RSTR_SDMMC2RST = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register AHB4RSTR: RCC AHB4 Peripheral Reset Register
  #define RCC_AHB4RSTR (* ((volatile uint32_t *) (0x58024400 + 136)))

  // Field GPIOARST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOARST = 1U << 0 ;

  // Field GPIOBRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOBRST = 1U << 1 ;

  // Field GPIOCRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOCRST = 1U << 2 ;

  // Field GPIODRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIODRST = 1U << 3 ;

  // Field GPIOERST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOERST = 1U << 4 ;

  // Field GPIOFRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOFRST = 1U << 5 ;

  // Field GPIOGRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOGRST = 1U << 6 ;

  // Field GPIOHRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOHRST = 1U << 7 ;

  // Field GPIOIRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOIRST = 1U << 8 ;

  // Field GPIOJRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOJRST = 1U << 9 ;

  // Field GPIOKRST: GPIO block reset
    const uint32_t RCC_AHB4RSTR_GPIOKRST = 1U << 10 ;

  // Field CRCRST: CRC block reset
    const uint32_t RCC_AHB4RSTR_CRCRST = 1U << 19 ;

  // Field BDMARST: BDMA block reset
    const uint32_t RCC_AHB4RSTR_BDMARST = 1U << 21 ;

  // Field ADC3RST: ADC3 block reset
    const uint32_t RCC_AHB4RSTR_ADC3RST = 1U << 24 ;

  // Field HSEMRST: HSEM block reset
    const uint32_t RCC_AHB4RSTR_HSEMRST = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register APB3RSTR: RCC APB3 Peripheral Reset Register
  #define RCC_APB3RSTR (* ((volatile uint32_t *) (0x58024400 + 140)))

  // Field LTDCRST: LTDC block reset
    const uint32_t RCC_APB3RSTR_LTDCRST = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register APB1LRSTR: RCC APB1 Peripheral Reset Register
  #define RCC_APB1LRSTR (* ((volatile uint32_t *) (0x58024400 + 144)))

  // Field TIM2RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM2RST = 1U << 0 ;

  // Field TIM3RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM3RST = 1U << 1 ;

  // Field TIM4RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM4RST = 1U << 2 ;

  // Field TIM5RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM5RST = 1U << 3 ;

  // Field TIM6RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM6RST = 1U << 4 ;

  // Field TIM7RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM7RST = 1U << 5 ;

  // Field TIM12RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM12RST = 1U << 6 ;

  // Field TIM13RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM13RST = 1U << 7 ;

  // Field TIM14RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_TIM14RST = 1U << 8 ;

  // Field LPTIM1RST: TIM block reset
    const uint32_t RCC_APB1LRSTR_LPTIM1RST = 1U << 9 ;

  // Field SPI2RST: SPI2 block reset
    const uint32_t RCC_APB1LRSTR_SPI2RST = 1U << 14 ;

  // Field SPI3RST: SPI3 block reset
    const uint32_t RCC_APB1LRSTR_SPI3RST = 1U << 15 ;

  // Field SPDIFRXRST: SPDIFRX block reset
    const uint32_t RCC_APB1LRSTR_SPDIFRXRST = 1U << 16 ;

  // Field USART2RST: USART2 block reset
    const uint32_t RCC_APB1LRSTR_USART2RST = 1U << 17 ;

  // Field USART3RST: USART3 block reset
    const uint32_t RCC_APB1LRSTR_USART3RST = 1U << 18 ;

  // Field UART4RST: UART4 block reset
    const uint32_t RCC_APB1LRSTR_UART4RST = 1U << 19 ;

  // Field UART5RST: UART5 block reset
    const uint32_t RCC_APB1LRSTR_UART5RST = 1U << 20 ;

  // Field I2C1RST: I2C1 block reset
    const uint32_t RCC_APB1LRSTR_I2C1RST = 1U << 21 ;

  // Field I2C2RST: I2C2 block reset
    const uint32_t RCC_APB1LRSTR_I2C2RST = 1U << 22 ;

  // Field I2C3RST: I2C3 block reset
    const uint32_t RCC_APB1LRSTR_I2C3RST = 1U << 23 ;

  // Field CECRST: HDMI-CEC block reset
    const uint32_t RCC_APB1LRSTR_CECRST = 1U << 27 ;

  // Field DAC12RST: DAC1 and 2 Blocks Reset
    const uint32_t RCC_APB1LRSTR_DAC12RST = 1U << 29 ;

  // Field USART7RST: USART7 block reset
    const uint32_t RCC_APB1LRSTR_USART7RST = 1U << 30 ;

  // Field USART8RST: USART8 block reset
    const uint32_t RCC_APB1LRSTR_USART8RST = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register APB1HRSTR: RCC APB1 Peripheral Reset Register
  #define RCC_APB1HRSTR (* ((volatile uint32_t *) (0x58024400 + 148)))

  // Field CRSRST: Clock Recovery System reset
    const uint32_t RCC_APB1HRSTR_CRSRST = 1U << 1 ;

  // Field SWPRST: SWPMI block reset
    const uint32_t RCC_APB1HRSTR_SWPRST = 1U << 2 ;

  // Field OPAMPRST: OPAMP block reset
    const uint32_t RCC_APB1HRSTR_OPAMPRST = 1U << 4 ;

  // Field MDIOSRST: MDIOS block reset
    const uint32_t RCC_APB1HRSTR_MDIOSRST = 1U << 5 ;

  // Field FDCANRST: FDCAN block reset
    const uint32_t RCC_APB1HRSTR_FDCANRST = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register APB2RSTR: RCC APB2 Peripheral Reset Register
  #define RCC_APB2RSTR (* ((volatile uint32_t *) (0x58024400 + 152)))

  // Field TIM1RST: TIM1 block reset
    const uint32_t RCC_APB2RSTR_TIM1RST = 1U << 0 ;

  // Field TIM8RST: TIM8 block reset
    const uint32_t RCC_APB2RSTR_TIM8RST = 1U << 1 ;

  // Field USART1RST: USART1 block reset
    const uint32_t RCC_APB2RSTR_USART1RST = 1U << 4 ;

  // Field USART6RST: USART6 block reset
    const uint32_t RCC_APB2RSTR_USART6RST = 1U << 5 ;

  // Field SPI1RST: SPI1 block reset
    const uint32_t RCC_APB2RSTR_SPI1RST = 1U << 12 ;

  // Field SPI4RST: SPI4 block reset
    const uint32_t RCC_APB2RSTR_SPI4RST = 1U << 13 ;

  // Field TIM15RST: TIM15 block reset
    const uint32_t RCC_APB2RSTR_TIM15RST = 1U << 16 ;

  // Field TIM16RST: TIM16 block reset
    const uint32_t RCC_APB2RSTR_TIM16RST = 1U << 17 ;

  // Field TIM17RST: TIM17 block reset
    const uint32_t RCC_APB2RSTR_TIM17RST = 1U << 18 ;

  // Field SPI5RST: SPI5 block reset
    const uint32_t RCC_APB2RSTR_SPI5RST = 1U << 20 ;

  // Field SAI1RST: SAI1 block reset
    const uint32_t RCC_APB2RSTR_SAI1RST = 1U << 22 ;

  // Field SAI2RST: SAI2 block reset
    const uint32_t RCC_APB2RSTR_SAI2RST = 1U << 23 ;

  // Field SAI3RST: SAI3 block reset
    const uint32_t RCC_APB2RSTR_SAI3RST = 1U << 24 ;

  // Field DFSDM1RST: DFSDM1 block reset
    const uint32_t RCC_APB2RSTR_DFSDM1RST = 1U << 28 ;

  // Field HRTIMRST: HRTIM block reset
    const uint32_t RCC_APB2RSTR_HRTIMRST = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register APB4RSTR: RCC APB4 Peripheral Reset Register
  #define RCC_APB4RSTR (* ((volatile uint32_t *) (0x58024400 + 156)))

  // Field SYSCFGRST: SYSCFG block reset
    const uint32_t RCC_APB4RSTR_SYSCFGRST = 1U << 1 ;

  // Field LPUART1RST: LPUART1 block reset
    const uint32_t RCC_APB4RSTR_LPUART1RST = 1U << 3 ;

  // Field SPI6RST: SPI6 block reset
    const uint32_t RCC_APB4RSTR_SPI6RST = 1U << 5 ;

  // Field I2C4RST: I2C4 block reset
    const uint32_t RCC_APB4RSTR_I2C4RST = 1U << 7 ;

  // Field LPTIM2RST: LPTIM2 block reset
    const uint32_t RCC_APB4RSTR_LPTIM2RST = 1U << 9 ;

  // Field LPTIM3RST: LPTIM3 block reset
    const uint32_t RCC_APB4RSTR_LPTIM3RST = 1U << 10 ;

  // Field LPTIM4RST: LPTIM4 block reset
    const uint32_t RCC_APB4RSTR_LPTIM4RST = 1U << 11 ;

  // Field LPTIM5RST: LPTIM5 block reset
    const uint32_t RCC_APB4RSTR_LPTIM5RST = 1U << 12 ;

  // Field COMP12RST: COMP12 Blocks Reset
    const uint32_t RCC_APB4RSTR_COMP12RST = 1U << 14 ;

  // Field VREFRST: VREF block reset
    const uint32_t RCC_APB4RSTR_VREFRST = 1U << 15 ;

  // Field SAI4RST: SAI4 block reset
    const uint32_t RCC_APB4RSTR_SAI4RST = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register GCR: RCC Global Control Register
  #define RCC_GCR (* ((volatile uint32_t *) (0x58024400 + 160)))

  // Field WW1RSC: WWDG1 reset scope control
    const uint32_t RCC_GCR_WW1RSC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register D3AMR: RCC D3 Autonomous mode Register
  #define RCC_D3AMR (* ((volatile uint32_t *) (0x58024400 + 168)))

  // Field BDMAAMEN: BDMA and DMAMUX Autonomous mode enable
    const uint32_t RCC_D3AMR_BDMAAMEN = 1U << 0 ;

  // Field LPUART1AMEN: LPUART1 Autonomous mode enable
    const uint32_t RCC_D3AMR_LPUART1AMEN = 1U << 3 ;

  // Field SPI6AMEN: SPI6 Autonomous mode enable
    const uint32_t RCC_D3AMR_SPI6AMEN = 1U << 5 ;

  // Field I2C4AMEN: I2C4 Autonomous mode enable
    const uint32_t RCC_D3AMR_I2C4AMEN = 1U << 7 ;

  // Field LPTIM2AMEN: LPTIM2 Autonomous mode enable
    const uint32_t RCC_D3AMR_LPTIM2AMEN = 1U << 9 ;

  // Field LPTIM3AMEN: LPTIM3 Autonomous mode enable
    const uint32_t RCC_D3AMR_LPTIM3AMEN = 1U << 10 ;

  // Field LPTIM4AMEN: LPTIM4 Autonomous mode enable
    const uint32_t RCC_D3AMR_LPTIM4AMEN = 1U << 11 ;

  // Field LPTIM5AMEN: LPTIM5 Autonomous mode enable
    const uint32_t RCC_D3AMR_LPTIM5AMEN = 1U << 12 ;

  // Field COMP12AMEN: COMP12 Autonomous mode enable
    const uint32_t RCC_D3AMR_COMP12AMEN = 1U << 14 ;

  // Field VREFAMEN: VREF Autonomous mode enable
    const uint32_t RCC_D3AMR_VREFAMEN = 1U << 15 ;

  // Field RTCAMEN: RTC Autonomous mode enable
    const uint32_t RCC_D3AMR_RTCAMEN = 1U << 16 ;

  // Field CRCAMEN: CRC Autonomous mode enable
    const uint32_t RCC_D3AMR_CRCAMEN = 1U << 19 ;

  // Field SAI4AMEN: SAI4 Autonomous mode enable
    const uint32_t RCC_D3AMR_SAI4AMEN = 1U << 21 ;

  // Field ADC3AMEN: ADC3 Autonomous mode enable
    const uint32_t RCC_D3AMR_ADC3AMEN = 1U << 24 ;

  // Field BKPRAMAMEN: Backup RAM Autonomous mode enable
    const uint32_t RCC_D3AMR_BKPRAMAMEN = 1U << 28 ;

  // Field SRAM4AMEN: SRAM4 Autonomous mode enable
    const uint32_t RCC_D3AMR_SRAM4AMEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register RSR: RCC Reset Status Register
  #define RCC_RSR (* ((volatile uint32_t *) (0x58024400 + 208)))

  // Field RMVF: Remove reset flag
    const uint32_t RCC_RSR_RMVF = 1U << 16 ;

  // Field CPURSTF: CPU reset flag
    const uint32_t RCC_RSR_CPURSTF = 1U << 17 ;

  // Field D1RSTF: D1 domain power switch reset flag
    const uint32_t RCC_RSR_D1RSTF = 1U << 19 ;

  // Field D2RSTF: D2 domain power switch reset flag
    const uint32_t RCC_RSR_D2RSTF = 1U << 20 ;

  // Field BORRSTF: BOR reset flag
    const uint32_t RCC_RSR_BORRSTF = 1U << 21 ;

  // Field PINRSTF: Pin reset flag (NRST)
    const uint32_t RCC_RSR_PINRSTF = 1U << 22 ;

  // Field PORRSTF: POR/PDR reset flag
    const uint32_t RCC_RSR_PORRSTF = 1U << 23 ;

  // Field SFTRSTF: System reset from CPU reset flag
    const uint32_t RCC_RSR_SFTRSTF = 1U << 24 ;

  // Field IWDG1RSTF: Independent Watchdog reset flag
    const uint32_t RCC_RSR_IWDG1RSTF = 1U << 26 ;

  // Field WWDG1RSTF: Window Watchdog reset flag
    const uint32_t RCC_RSR_WWDG1RSTF = 1U << 28 ;

  // Field LPWRRSTF: Reset due to illegal D1 DStandby or CPU CStop flag
    const uint32_t RCC_RSR_LPWRRSTF = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register C1_RSR: RCC Reset Status Register
  #define RCC_C1_RSR (* ((volatile uint32_t *) (0x58024400 + 304)))

  // Field RMVF: Remove reset flag
    const uint32_t RCC_C1_RSR_RMVF = 1U << 16 ;

  // Field CPURSTF: CPU reset flag
    const uint32_t RCC_C1_RSR_CPURSTF = 1U << 17 ;

  // Field D1RSTF: D1 domain power switch reset flag
    const uint32_t RCC_C1_RSR_D1RSTF = 1U << 19 ;

  // Field D2RSTF: D2 domain power switch reset flag
    const uint32_t RCC_C1_RSR_D2RSTF = 1U << 20 ;

  // Field BORRSTF: BOR reset flag
    const uint32_t RCC_C1_RSR_BORRSTF = 1U << 21 ;

  // Field PINRSTF: Pin reset flag (NRST)
    const uint32_t RCC_C1_RSR_PINRSTF = 1U << 22 ;

  // Field PORRSTF: POR/PDR reset flag
    const uint32_t RCC_C1_RSR_PORRSTF = 1U << 23 ;

  // Field SFTRSTF: System reset from CPU reset flag
    const uint32_t RCC_C1_RSR_SFTRSTF = 1U << 24 ;

  // Field IWDG1RSTF: Independent Watchdog reset flag
    const uint32_t RCC_C1_RSR_IWDG1RSTF = 1U << 26 ;

  // Field WWDG1RSTF: Window Watchdog reset flag
    const uint32_t RCC_C1_RSR_WWDG1RSTF = 1U << 28 ;

  // Field LPWRRSTF: Reset due to illegal D1 DStandby or CPU CStop flag
    const uint32_t RCC_C1_RSR_LPWRRSTF = 1U << 30 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB3ENR: RCC AHB3 Clock Register
  #define RCC_C1_AHB3ENR (* ((volatile uint32_t *) (0x58024400 + 308)))

  // Field MDMAEN: MDMA Peripheral Clock Enable
    const uint32_t RCC_C1_AHB3ENR_MDMAEN = 1U << 0 ;

  // Field DMA2DEN: DMA2D Peripheral Clock Enable
    const uint32_t RCC_C1_AHB3ENR_DMA2DEN = 1U << 4 ;

  // Field JPGDECEN: JPGDEC Peripheral Clock Enable
    const uint32_t RCC_C1_AHB3ENR_JPGDECEN = 1U << 5 ;

  // Field FMCEN: FMC Peripheral Clocks Enable
    const uint32_t RCC_C1_AHB3ENR_FMCEN = 1U << 12 ;

  // Field QSPIEN: QUADSPI and QUADSPI Delay Clock Enable
    const uint32_t RCC_C1_AHB3ENR_QSPIEN = 1U << 14 ;

  // Field SDMMC1EN: SDMMC1 and SDMMC1 Delay Clock Enable
    const uint32_t RCC_C1_AHB3ENR_SDMMC1EN = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AHB3ENR: RCC AHB3 Clock Register
  #define RCC_AHB3ENR (* ((volatile uint32_t *) (0x58024400 + 212)))

  // Field MDMAEN: MDMA Peripheral Clock Enable
    const uint32_t RCC_AHB3ENR_MDMAEN = 1U << 0 ;

  // Field DMA2DEN: DMA2D Peripheral Clock Enable
    const uint32_t RCC_AHB3ENR_DMA2DEN = 1U << 4 ;

  // Field JPGDECEN: JPGDEC Peripheral Clock Enable
    const uint32_t RCC_AHB3ENR_JPGDECEN = 1U << 5 ;

  // Field FMCEN: FMC Peripheral Clocks Enable
    const uint32_t RCC_AHB3ENR_FMCEN = 1U << 12 ;

  // Field QSPIEN: QUADSPI and QUADSPI Delay Clock Enable
    const uint32_t RCC_AHB3ENR_QSPIEN = 1U << 14 ;

  // Field SDMMC1EN: SDMMC1 and SDMMC1 Delay Clock Enable
    const uint32_t RCC_AHB3ENR_SDMMC1EN = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register AHB1ENR: RCC AHB1 Clock Register
  #define RCC_AHB1ENR (* ((volatile uint32_t *) (0x58024400 + 216)))

  // Field DMA1EN: DMA1 Clock Enable
    const uint32_t RCC_AHB1ENR_DMA1EN = 1U << 0 ;

  // Field DMA2EN: DMA2 Clock Enable
    const uint32_t RCC_AHB1ENR_DMA2EN = 1U << 1 ;

  // Field ADC12EN: ADC1/2 Peripheral Clocks Enable
    const uint32_t RCC_AHB1ENR_ADC12EN = 1U << 5 ;

  // Field ETH1MACEN: Ethernet MAC bus interface Clock Enable
    const uint32_t RCC_AHB1ENR_ETH1MACEN = 1U << 15 ;

  // Field ETH1TXEN: Ethernet Transmission Clock Enable
    const uint32_t RCC_AHB1ENR_ETH1TXEN = 1U << 16 ;

  // Field ETH1RXEN: Ethernet Reception Clock Enable
    const uint32_t RCC_AHB1ENR_ETH1RXEN = 1U << 17 ;

  // Field USB2OTGHSULPIEN: Enable USB_PHY2 clocks
    const uint32_t RCC_AHB1ENR_USB2OTGHSULPIEN = 1U << 18 ;

  // Field USB1OTGEN: USB1OTG Peripheral Clocks Enable
    const uint32_t RCC_AHB1ENR_USB1OTGEN = 1U << 25 ;

  // Field USB1ULPIEN: USB_PHY1 Clocks Enable
    const uint32_t RCC_AHB1ENR_USB1ULPIEN = 1U << 26 ;

  // Field USB2OTGEN: USB2OTG Peripheral Clocks Enable
    const uint32_t RCC_AHB1ENR_USB2OTGEN = 1U << 27 ;

  // Field USB2ULPIEN: USB_PHY2 Clocks Enable
    const uint32_t RCC_AHB1ENR_USB2ULPIEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB1ENR: RCC AHB1 Clock Register
  #define RCC_C1_AHB1ENR (* ((volatile uint32_t *) (0x58024400 + 312)))

  // Field DMA1EN: DMA1 Clock Enable
    const uint32_t RCC_C1_AHB1ENR_DMA1EN = 1U << 0 ;

  // Field DMA2EN: DMA2 Clock Enable
    const uint32_t RCC_C1_AHB1ENR_DMA2EN = 1U << 1 ;

  // Field ADC12EN: ADC1/2 Peripheral Clocks Enable
    const uint32_t RCC_C1_AHB1ENR_ADC12EN = 1U << 5 ;

  // Field ETH1MACEN: Ethernet MAC bus interface Clock Enable
    const uint32_t RCC_C1_AHB1ENR_ETH1MACEN = 1U << 15 ;

  // Field ETH1TXEN: Ethernet Transmission Clock Enable
    const uint32_t RCC_C1_AHB1ENR_ETH1TXEN = 1U << 16 ;

  // Field ETH1RXEN: Ethernet Reception Clock Enable
    const uint32_t RCC_C1_AHB1ENR_ETH1RXEN = 1U << 17 ;

  // Field USB1OTGEN: USB1OTG Peripheral Clocks Enable
    const uint32_t RCC_C1_AHB1ENR_USB1OTGEN = 1U << 25 ;

  // Field USB1ULPIEN: USB_PHY1 Clocks Enable
    const uint32_t RCC_C1_AHB1ENR_USB1ULPIEN = 1U << 26 ;

  // Field USB2OTGEN: USB2OTG Peripheral Clocks Enable
    const uint32_t RCC_C1_AHB1ENR_USB2OTGEN = 1U << 27 ;

  // Field USB2ULPIEN: USB_PHY2 Clocks Enable
    const uint32_t RCC_C1_AHB1ENR_USB2ULPIEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB2ENR: RCC AHB2 Clock Register
  #define RCC_C1_AHB2ENR (* ((volatile uint32_t *) (0x58024400 + 316)))

  // Field CAMITFEN: CAMITF peripheral clock enable
    const uint32_t RCC_C1_AHB2ENR_CAMITFEN = 1U << 0 ;

  // Field CRYPTEN: CRYPT peripheral clock enable
    const uint32_t RCC_C1_AHB2ENR_CRYPTEN = 1U << 4 ;

  // Field HASHEN: HASH peripheral clock enable
    const uint32_t RCC_C1_AHB2ENR_HASHEN = 1U << 5 ;

  // Field RNGEN: RNG peripheral clocks enable
    const uint32_t RCC_C1_AHB2ENR_RNGEN = 1U << 6 ;

  // Field SDMMC2EN: SDMMC2 and SDMMC2 delay clock enable
    const uint32_t RCC_C1_AHB2ENR_SDMMC2EN = 1U << 9 ;

  // Field SRAM1EN: SRAM1 block enable
    const uint32_t RCC_C1_AHB2ENR_SRAM1EN = 1U << 29 ;

  // Field SRAM2EN: SRAM2 block enable
    const uint32_t RCC_C1_AHB2ENR_SRAM2EN = 1U << 30 ;

  // Field SRAM3EN: SRAM3 block enable
    const uint32_t RCC_C1_AHB2ENR_SRAM3EN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB2ENR: RCC AHB2 Clock Register
  #define RCC_AHB2ENR (* ((volatile uint32_t *) (0x58024400 + 220)))

  // Field CAMITFEN: CAMITF peripheral clock enable
    const uint32_t RCC_AHB2ENR_CAMITFEN = 1U << 0 ;

  // Field CRYPTEN: CRYPT peripheral clock enable
    const uint32_t RCC_AHB2ENR_CRYPTEN = 1U << 4 ;

  // Field HASHEN: HASH peripheral clock enable
    const uint32_t RCC_AHB2ENR_HASHEN = 1U << 5 ;

  // Field RNGEN: RNG peripheral clocks enable
    const uint32_t RCC_AHB2ENR_RNGEN = 1U << 6 ;

  // Field SDMMC2EN: SDMMC2 and SDMMC2 delay clock enable
    const uint32_t RCC_AHB2ENR_SDMMC2EN = 1U << 9 ;

  // Field SRAM1EN: SRAM1 block enable
    const uint32_t RCC_AHB2ENR_SRAM1EN = 1U << 29 ;

  // Field SRAM2EN: SRAM2 block enable
    const uint32_t RCC_AHB2ENR_SRAM2EN = 1U << 30 ;

  // Field SRAM3EN: SRAM3 block enable
    const uint32_t RCC_AHB2ENR_SRAM3EN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB4ENR: RCC AHB4 Clock Register
  #define RCC_AHB4ENR (* ((volatile uint32_t *) (0x58024400 + 224)))

  // Field GPIOAEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOAEN = 1U << 0 ;

  // Field GPIOBEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOBEN = 1U << 1 ;

  // Field GPIOCEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOCEN = 1U << 2 ;

  // Field GPIODEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIODEN = 1U << 3 ;

  // Field GPIOEEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOEEN = 1U << 4 ;

  // Field GPIOFEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOFEN = 1U << 5 ;

  // Field GPIOGEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOGEN = 1U << 6 ;

  // Field GPIOHEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOHEN = 1U << 7 ;

  // Field GPIOIEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOIEN = 1U << 8 ;

  // Field GPIOJEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOJEN = 1U << 9 ;

  // Field GPIOKEN: 0GPIO peripheral clock enable
    const uint32_t RCC_AHB4ENR_GPIOKEN = 1U << 10 ;

  // Field CRCEN: CRC peripheral clock enable
    const uint32_t RCC_AHB4ENR_CRCEN = 1U << 19 ;

  // Field BDMAEN: BDMA and DMAMUX2 Clock Enable
    const uint32_t RCC_AHB4ENR_BDMAEN = 1U << 21 ;

  // Field ADC3EN: ADC3 Peripheral Clocks Enable
    const uint32_t RCC_AHB4ENR_ADC3EN = 1U << 24 ;

  // Field HSEMEN: HSEM peripheral clock enable
    const uint32_t RCC_AHB4ENR_HSEMEN = 1U << 25 ;

  // Field BKPRAMEN: Backup RAM Clock Enable
    const uint32_t RCC_AHB4ENR_BKPRAMEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB4ENR: RCC AHB4 Clock Register
  #define RCC_C1_AHB4ENR (* ((volatile uint32_t *) (0x58024400 + 320)))

  // Field GPIOAEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOAEN = 1U << 0 ;

  // Field GPIOBEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOBEN = 1U << 1 ;

  // Field GPIOCEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOCEN = 1U << 2 ;

  // Field GPIODEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIODEN = 1U << 3 ;

  // Field GPIOEEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOEEN = 1U << 4 ;

  // Field GPIOFEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOFEN = 1U << 5 ;

  // Field GPIOGEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOGEN = 1U << 6 ;

  // Field GPIOHEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOHEN = 1U << 7 ;

  // Field GPIOIEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOIEN = 1U << 8 ;

  // Field GPIOJEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOJEN = 1U << 9 ;

  // Field GPIOKEN: 0GPIO peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_GPIOKEN = 1U << 10 ;

  // Field CRCEN: CRC peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_CRCEN = 1U << 19 ;

  // Field BDMAEN: BDMA and DMAMUX2 Clock Enable
    const uint32_t RCC_C1_AHB4ENR_BDMAEN = 1U << 21 ;

  // Field ADC3EN: ADC3 Peripheral Clocks Enable
    const uint32_t RCC_C1_AHB4ENR_ADC3EN = 1U << 24 ;

  // Field HSEMEN: HSEM peripheral clock enable
    const uint32_t RCC_C1_AHB4ENR_HSEMEN = 1U << 25 ;

  // Field BKPRAMEN: Backup RAM Clock Enable
    const uint32_t RCC_C1_AHB4ENR_BKPRAMEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register C1_APB3ENR: RCC APB3 Clock Register
  #define RCC_C1_APB3ENR (* ((volatile uint32_t *) (0x58024400 + 324)))

  // Field LTDCEN: LTDC peripheral clock enable
    const uint32_t RCC_C1_APB3ENR_LTDCEN = 1U << 3 ;

  // Field WWDG1EN: WWDG1 Clock Enable
    const uint32_t RCC_C1_APB3ENR_WWDG1EN = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register APB3ENR: RCC APB3 Clock Register
  #define RCC_APB3ENR (* ((volatile uint32_t *) (0x58024400 + 228)))

  // Field LTDCEN: LTDC peripheral clock enable
    const uint32_t RCC_APB3ENR_LTDCEN = 1U << 3 ;

  // Field WWDG1EN: WWDG1 Clock Enable
    const uint32_t RCC_APB3ENR_WWDG1EN = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register APB1LENR: RCC APB1 Clock Register
  #define RCC_APB1LENR (* ((volatile uint32_t *) (0x58024400 + 232)))

  // Field TIM2EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM2EN = 1U << 0 ;

  // Field TIM3EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM3EN = 1U << 1 ;

  // Field TIM4EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM4EN = 1U << 2 ;

  // Field TIM5EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM5EN = 1U << 3 ;

  // Field TIM6EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM6EN = 1U << 4 ;

  // Field TIM7EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM7EN = 1U << 5 ;

  // Field TIM12EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM12EN = 1U << 6 ;

  // Field TIM13EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM13EN = 1U << 7 ;

  // Field TIM14EN: TIM peripheral clock enable
    const uint32_t RCC_APB1LENR_TIM14EN = 1U << 8 ;

  // Field LPTIM1EN: LPTIM1 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_LPTIM1EN = 1U << 9 ;

  // Field SPI2EN: SPI2 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_SPI2EN = 1U << 14 ;

  // Field SPI3EN: SPI3 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_SPI3EN = 1U << 15 ;

  // Field SPDIFRXEN: SPDIFRX Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_SPDIFRXEN = 1U << 16 ;

  // Field USART2EN: USART2 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_USART2EN = 1U << 17 ;

  // Field USART3EN: USART3 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_USART3EN = 1U << 18 ;

  // Field UART4EN: UART4 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_UART4EN = 1U << 19 ;

  // Field UART5EN: UART5 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_UART5EN = 1U << 20 ;

  // Field I2C1EN: I2C1 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_I2C1EN = 1U << 21 ;

  // Field I2C2EN: I2C2 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_I2C2EN = 1U << 22 ;

  // Field I2C3EN: I2C3 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_I2C3EN = 1U << 23 ;

  // Field CECEN: HDMI-CEC peripheral clock enable
    const uint32_t RCC_APB1LENR_CECEN = 1U << 27 ;

  // Field DAC12EN: DAC1&2 peripheral clock enable
    const uint32_t RCC_APB1LENR_DAC12EN = 1U << 29 ;

  // Field USART7EN: USART7 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_USART7EN = 1U << 30 ;

  // Field USART8EN: USART8 Peripheral Clocks Enable
    const uint32_t RCC_APB1LENR_USART8EN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register C1_APB1LENR: RCC APB1 Clock Register
  #define RCC_C1_APB1LENR (* ((volatile uint32_t *) (0x58024400 + 328)))

  // Field TIM2EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM2EN = 1U << 0 ;

  // Field TIM3EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM3EN = 1U << 1 ;

  // Field TIM4EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM4EN = 1U << 2 ;

  // Field TIM5EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM5EN = 1U << 3 ;

  // Field TIM6EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM6EN = 1U << 4 ;

  // Field TIM7EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM7EN = 1U << 5 ;

  // Field TIM12EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM12EN = 1U << 6 ;

  // Field TIM13EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM13EN = 1U << 7 ;

  // Field TIM14EN: TIM peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_TIM14EN = 1U << 8 ;

  // Field LPTIM1EN: LPTIM1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_LPTIM1EN = 1U << 9 ;

  // Field SPI2EN: SPI2 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_SPI2EN = 1U << 14 ;

  // Field SPI3EN: SPI3 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_SPI3EN = 1U << 15 ;

  // Field SPDIFRXEN: SPDIFRX Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_SPDIFRXEN = 1U << 16 ;

  // Field USART2EN: USART2 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_USART2EN = 1U << 17 ;

  // Field USART3EN: USART3 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_USART3EN = 1U << 18 ;

  // Field UART4EN: UART4 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_UART4EN = 1U << 19 ;

  // Field UART5EN: UART5 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_UART5EN = 1U << 20 ;

  // Field I2C1EN: I2C1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_I2C1EN = 1U << 21 ;

  // Field I2C2EN: I2C2 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_I2C2EN = 1U << 22 ;

  // Field I2C3EN: I2C3 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_I2C3EN = 1U << 23 ;

  // Field HDMICECEN: HDMI-CEC peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_HDMICECEN = 1U << 27 ;

  // Field DAC12EN: DAC1&2 peripheral clock enable
    const uint32_t RCC_C1_APB1LENR_DAC12EN = 1U << 29 ;

  // Field USART7EN: USART7 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_USART7EN = 1U << 30 ;

  // Field USART8EN: USART8 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1LENR_USART8EN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register APB1HENR: RCC APB1 Clock Register
  #define RCC_APB1HENR (* ((volatile uint32_t *) (0x58024400 + 236)))

  // Field CRSEN: Clock Recovery System peripheral clock enable
    const uint32_t RCC_APB1HENR_CRSEN = 1U << 1 ;

  // Field SWPEN: SWPMI Peripheral Clocks Enable
    const uint32_t RCC_APB1HENR_SWPEN = 1U << 2 ;

  // Field OPAMPEN: OPAMP peripheral clock enable
    const uint32_t RCC_APB1HENR_OPAMPEN = 1U << 4 ;

  // Field MDIOSEN: MDIOS peripheral clock enable
    const uint32_t RCC_APB1HENR_MDIOSEN = 1U << 5 ;

  // Field FDCANEN: FDCAN Peripheral Clocks Enable
    const uint32_t RCC_APB1HENR_FDCANEN = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register C1_APB1HENR: RCC APB1 Clock Register
  #define RCC_C1_APB1HENR (* ((volatile uint32_t *) (0x58024400 + 332)))

  // Field CRSEN: Clock Recovery System peripheral clock enable
    const uint32_t RCC_C1_APB1HENR_CRSEN = 1U << 1 ;

  // Field SWPEN: SWPMI Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1HENR_SWPEN = 1U << 2 ;

  // Field OPAMPEN: OPAMP peripheral clock enable
    const uint32_t RCC_C1_APB1HENR_OPAMPEN = 1U << 4 ;

  // Field MDIOSEN: MDIOS peripheral clock enable
    const uint32_t RCC_C1_APB1HENR_MDIOSEN = 1U << 5 ;

  // Field FDCANEN: FDCAN Peripheral Clocks Enable
    const uint32_t RCC_C1_APB1HENR_FDCANEN = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register C1_APB2ENR: RCC APB2 Clock Register
  #define RCC_C1_APB2ENR (* ((volatile uint32_t *) (0x58024400 + 336)))

  // Field TIM1EN: TIM1 peripheral clock enable
    const uint32_t RCC_C1_APB2ENR_TIM1EN = 1U << 0 ;

  // Field TIM8EN: TIM8 peripheral clock enable
    const uint32_t RCC_C1_APB2ENR_TIM8EN = 1U << 1 ;

  // Field USART1EN: USART1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_USART1EN = 1U << 4 ;

  // Field USART6EN: USART6 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_USART6EN = 1U << 5 ;

  // Field SPI1EN: SPI1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_SPI1EN = 1U << 12 ;

  // Field SPI4EN: SPI4 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_SPI4EN = 1U << 13 ;

  // Field TIM16EN: TIM16 peripheral clock enable
    const uint32_t RCC_C1_APB2ENR_TIM16EN = 1U << 17 ;

  // Field TIM15EN: TIM15 peripheral clock enable
    const uint32_t RCC_C1_APB2ENR_TIM15EN = 1U << 16 ;

  // Field TIM17EN: TIM17 peripheral clock enable
    const uint32_t RCC_C1_APB2ENR_TIM17EN = 1U << 18 ;

  // Field SPI5EN: SPI5 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_SPI5EN = 1U << 20 ;

  // Field SAI1EN: SAI1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_SAI1EN = 1U << 22 ;

  // Field SAI2EN: SAI2 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_SAI2EN = 1U << 23 ;

  // Field SAI3EN: SAI3 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_SAI3EN = 1U << 24 ;

  // Field DFSDM1EN: DFSDM1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB2ENR_DFSDM1EN = 1U << 28 ;

  // Field HRTIMEN: HRTIM peripheral clock enable
    const uint32_t RCC_C1_APB2ENR_HRTIMEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register APB2ENR: RCC APB2 Clock Register
  #define RCC_APB2ENR (* ((volatile uint32_t *) (0x58024400 + 240)))

  // Field TIM1EN: TIM1 peripheral clock enable
    const uint32_t RCC_APB2ENR_TIM1EN = 1U << 0 ;

  // Field TIM8EN: TIM8 peripheral clock enable
    const uint32_t RCC_APB2ENR_TIM8EN = 1U << 1 ;

  // Field USART1EN: USART1 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_USART1EN = 1U << 4 ;

  // Field USART6EN: USART6 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_USART6EN = 1U << 5 ;

  // Field SPI1EN: SPI1 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_SPI1EN = 1U << 12 ;

  // Field SPI4EN: SPI4 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_SPI4EN = 1U << 13 ;

  // Field TIM16EN: TIM16 peripheral clock enable
    const uint32_t RCC_APB2ENR_TIM16EN = 1U << 17 ;

  // Field TIM15EN: TIM15 peripheral clock enable
    const uint32_t RCC_APB2ENR_TIM15EN = 1U << 16 ;

  // Field TIM17EN: TIM17 peripheral clock enable
    const uint32_t RCC_APB2ENR_TIM17EN = 1U << 18 ;

  // Field SPI5EN: SPI5 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_SPI5EN = 1U << 20 ;

  // Field SAI1EN: SAI1 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_SAI1EN = 1U << 22 ;

  // Field SAI2EN: SAI2 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_SAI2EN = 1U << 23 ;

  // Field SAI3EN: SAI3 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_SAI3EN = 1U << 24 ;

  // Field DFSDM1EN: DFSDM1 Peripheral Clocks Enable
    const uint32_t RCC_APB2ENR_DFSDM1EN = 1U << 28 ;

  // Field HRTIMEN: HRTIM peripheral clock enable
    const uint32_t RCC_APB2ENR_HRTIMEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register APB4ENR: RCC APB4 Clock Register
  #define RCC_APB4ENR (* ((volatile uint32_t *) (0x58024400 + 244)))

  // Field SYSCFGEN: SYSCFG peripheral clock enable
    const uint32_t RCC_APB4ENR_SYSCFGEN = 1U << 1 ;

  // Field LPUART1EN: LPUART1 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_LPUART1EN = 1U << 3 ;

  // Field SPI6EN: SPI6 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_SPI6EN = 1U << 5 ;

  // Field I2C4EN: I2C4 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_I2C4EN = 1U << 7 ;

  // Field LPTIM2EN: LPTIM2 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_LPTIM2EN = 1U << 9 ;

  // Field LPTIM3EN: LPTIM3 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_LPTIM3EN = 1U << 10 ;

  // Field LPTIM4EN: LPTIM4 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_LPTIM4EN = 1U << 11 ;

  // Field LPTIM5EN: LPTIM5 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_LPTIM5EN = 1U << 12 ;

  // Field COMP12EN: COMP1/2 peripheral clock enable
    const uint32_t RCC_APB4ENR_COMP12EN = 1U << 14 ;

  // Field VREFEN: VREF peripheral clock enable
    const uint32_t RCC_APB4ENR_VREFEN = 1U << 15 ;

  // Field RTCAPBEN: RTC APB Clock Enable
    const uint32_t RCC_APB4ENR_RTCAPBEN = 1U << 16 ;

  // Field SAI4EN: SAI4 Peripheral Clocks Enable
    const uint32_t RCC_APB4ENR_SAI4EN = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register C1_APB4ENR: RCC APB4 Clock Register
  #define RCC_C1_APB4ENR (* ((volatile uint32_t *) (0x58024400 + 340)))

  // Field SYSCFGEN: SYSCFG peripheral clock enable
    const uint32_t RCC_C1_APB4ENR_SYSCFGEN = 1U << 1 ;

  // Field LPUART1EN: LPUART1 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_LPUART1EN = 1U << 3 ;

  // Field SPI6EN: SPI6 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_SPI6EN = 1U << 5 ;

  // Field I2C4EN: I2C4 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_I2C4EN = 1U << 7 ;

  // Field LPTIM2EN: LPTIM2 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_LPTIM2EN = 1U << 9 ;

  // Field LPTIM3EN: LPTIM3 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_LPTIM3EN = 1U << 10 ;

  // Field LPTIM4EN: LPTIM4 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_LPTIM4EN = 1U << 11 ;

  // Field LPTIM5EN: LPTIM5 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_LPTIM5EN = 1U << 12 ;

  // Field COMP12EN: COMP1/2 peripheral clock enable
    const uint32_t RCC_C1_APB4ENR_COMP12EN = 1U << 14 ;

  // Field VREFEN: VREF peripheral clock enable
    const uint32_t RCC_C1_APB4ENR_VREFEN = 1U << 15 ;

  // Field RTCAPBEN: RTC APB Clock Enable
    const uint32_t RCC_C1_APB4ENR_RTCAPBEN = 1U << 16 ;

  // Field SAI4EN: SAI4 Peripheral Clocks Enable
    const uint32_t RCC_C1_APB4ENR_SAI4EN = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB3LPENR: RCC AHB3 Sleep Clock Register
  #define RCC_C1_AHB3LPENR (* ((volatile uint32_t *) (0x58024400 + 348)))

  // Field MDMALPEN: MDMA Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_MDMALPEN = 1U << 0 ;

  // Field DMA2DLPEN: DMA2D Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_DMA2DLPEN = 1U << 4 ;

  // Field JPGDECLPEN: JPGDEC Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_JPGDECLPEN = 1U << 5 ;

  // Field FLITFLPEN: FLITF Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_FLITFLPEN = 1U << 8 ;

  // Field FMCLPEN: FMC Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_FMCLPEN = 1U << 12 ;

  // Field QSPILPEN: QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_QSPILPEN = 1U << 14 ;

  // Field SDMMC1LPEN: SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB3LPENR_SDMMC1LPEN = 1U << 16 ;

  // Field D1DTCM1LPEN: D1DTCM1 Block Clock Enable During CSleep mode
    const uint32_t RCC_C1_AHB3LPENR_D1DTCM1LPEN = 1U << 28 ;

  // Field DTCM2LPEN: D1 DTCM2 Block Clock Enable During CSleep mode
    const uint32_t RCC_C1_AHB3LPENR_DTCM2LPEN = 1U << 29 ;

  // Field ITCMLPEN: D1ITCM Block Clock Enable During CSleep mode
    const uint32_t RCC_C1_AHB3LPENR_ITCMLPEN = 1U << 30 ;

  // Field AXISRAMLPEN: AXISRAM Block Clock Enable During CSleep mode
    const uint32_t RCC_C1_AHB3LPENR_AXISRAMLPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB3LPENR: RCC AHB3 Sleep Clock Register
  #define RCC_AHB3LPENR (* ((volatile uint32_t *) (0x58024400 + 252)))

  // Field MDMALPEN: MDMA Clock Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_MDMALPEN = 1U << 0 ;

  // Field DMA2DLPEN: DMA2D Clock Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_DMA2DLPEN = 1U << 4 ;

  // Field JPGDECLPEN: JPGDEC Clock Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_JPGDECLPEN = 1U << 5 ;

  // Field FLASHLPEN: FLITF Clock Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_FLASHLPEN = 1U << 8 ;

  // Field FMCLPEN: FMC Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_FMCLPEN = 1U << 12 ;

  // Field QSPILPEN: QUADSPI and QUADSPI Delay Clock Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_QSPILPEN = 1U << 14 ;

  // Field SDMMC1LPEN: SDMMC1 and SDMMC1 Delay Clock Enable During CSleep Mode
    const uint32_t RCC_AHB3LPENR_SDMMC1LPEN = 1U << 16 ;

  // Field D1DTCM1LPEN: D1DTCM1 Block Clock Enable During CSleep mode
    const uint32_t RCC_AHB3LPENR_D1DTCM1LPEN = 1U << 28 ;

  // Field DTCM2LPEN: D1 DTCM2 Block Clock Enable During CSleep mode
    const uint32_t RCC_AHB3LPENR_DTCM2LPEN = 1U << 29 ;

  // Field ITCMLPEN: D1ITCM Block Clock Enable During CSleep mode
    const uint32_t RCC_AHB3LPENR_ITCMLPEN = 1U << 30 ;

  // Field AXISRAMLPEN: AXISRAM Block Clock Enable During CSleep mode
    const uint32_t RCC_AHB3LPENR_AXISRAMLPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB1LPENR: RCC AHB1 Sleep Clock Register
  #define RCC_AHB1LPENR (* ((volatile uint32_t *) (0x58024400 + 256)))

  // Field DMA1LPEN: DMA1 Clock Enable During CSleep Mode
    const uint32_t RCC_AHB1LPENR_DMA1LPEN = 1U << 0 ;

  // Field DMA2LPEN: DMA2 Clock Enable During CSleep Mode
    const uint32_t RCC_AHB1LPENR_DMA2LPEN = 1U << 1 ;

  // Field ADC12LPEN: ADC1/2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_AHB1LPENR_ADC12LPEN = 1U << 5 ;

  // Field ETH1MACLPEN: Ethernet MAC bus interface Clock Enable During CSleep Mode
    const uint32_t RCC_AHB1LPENR_ETH1MACLPEN = 1U << 15 ;

  // Field ETH1TXLPEN: Ethernet Transmission Clock Enable During CSleep Mode
    const uint32_t RCC_AHB1LPENR_ETH1TXLPEN = 1U << 16 ;

  // Field ETH1RXLPEN: Ethernet Reception Clock Enable During CSleep Mode
    const uint32_t RCC_AHB1LPENR_ETH1RXLPEN = 1U << 17 ;

  // Field USB1OTGHSLPEN: USB1OTG peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB1LPENR_USB1OTGHSLPEN = 1U << 25 ;

  // Field USB1OTGHSULPILPEN: USB_PHY1 clock enable during CSleep mode
    const uint32_t RCC_AHB1LPENR_USB1OTGHSULPILPEN = 1U << 26 ;

  // Field USB2OTGHSLPEN: USB2OTG peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB1LPENR_USB2OTGHSLPEN = 1U << 27 ;

  // Field USB2OTGHSULPILPEN: USB_PHY2 clocks enable during CSleep mode
    const uint32_t RCC_AHB1LPENR_USB2OTGHSULPILPEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB1LPENR: RCC AHB1 Sleep Clock Register
  #define RCC_C1_AHB1LPENR (* ((volatile uint32_t *) (0x58024400 + 352)))

  // Field DMA1LPEN: DMA1 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB1LPENR_DMA1LPEN = 1U << 0 ;

  // Field DMA2LPEN: DMA2 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB1LPENR_DMA2LPEN = 1U << 1 ;

  // Field ADC12LPEN: ADC1/2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_AHB1LPENR_ADC12LPEN = 1U << 5 ;

  // Field ETH1MACLPEN: Ethernet MAC bus interface Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB1LPENR_ETH1MACLPEN = 1U << 15 ;

  // Field ETH1TXLPEN: Ethernet Transmission Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB1LPENR_ETH1TXLPEN = 1U << 16 ;

  // Field ETH1RXLPEN: Ethernet Reception Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB1LPENR_ETH1RXLPEN = 1U << 17 ;

  // Field USB1OTGLPEN: USB1OTG peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB1LPENR_USB1OTGLPEN = 1U << 25 ;

  // Field USB1ULPILPEN: USB_PHY1 clock enable during CSleep mode
    const uint32_t RCC_C1_AHB1LPENR_USB1ULPILPEN = 1U << 26 ;

  // Field USB2OTGLPEN: USB2OTG peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB1LPENR_USB2OTGLPEN = 1U << 27 ;

  // Field USB2ULPILPEN: USB_PHY2 clocks enable during CSleep mode
    const uint32_t RCC_C1_AHB1LPENR_USB2ULPILPEN = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB2LPENR: RCC AHB2 Sleep Clock Register
  #define RCC_C1_AHB2LPENR (* ((volatile uint32_t *) (0x58024400 + 356)))

  // Field CAMITFLPEN: CAMITF peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB2LPENR_CAMITFLPEN = 1U << 0 ;

  // Field CRYPTLPEN: CRYPT peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB2LPENR_CRYPTLPEN = 1U << 4 ;

  // Field HASHLPEN: HASH peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB2LPENR_HASHLPEN = 1U << 5 ;

  // Field SDMMC2LPEN: SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB2LPENR_SDMMC2LPEN = 1U << 9 ;

  // Field RNGLPEN: RNG peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB2LPENR_RNGLPEN = 1U << 6 ;

  // Field SRAM1LPEN: SRAM1 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB2LPENR_SRAM1LPEN = 1U << 29 ;

  // Field SRAM2LPEN: SRAM2 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB2LPENR_SRAM2LPEN = 1U << 30 ;

  // Field SRAM3LPEN: SRAM3 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB2LPENR_SRAM3LPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB2LPENR: RCC AHB2 Sleep Clock Register
  #define RCC_AHB2LPENR (* ((volatile uint32_t *) (0x58024400 + 260)))

  // Field CAMITFLPEN: CAMITF peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB2LPENR_CAMITFLPEN = 1U << 0 ;

  // Field CRYPTLPEN: CRYPT peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB2LPENR_CRYPTLPEN = 1U << 4 ;

  // Field HASHLPEN: HASH peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB2LPENR_HASHLPEN = 1U << 5 ;

  // Field SDMMC2LPEN: SDMMC2 and SDMMC2 Delay Clock Enable During CSleep Mode
    const uint32_t RCC_AHB2LPENR_SDMMC2LPEN = 1U << 9 ;

  // Field RNGLPEN: RNG peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB2LPENR_RNGLPEN = 1U << 6 ;

  // Field SRAM1LPEN: SRAM1 Clock Enable During CSleep Mode
    const uint32_t RCC_AHB2LPENR_SRAM1LPEN = 1U << 29 ;

  // Field SRAM2LPEN: SRAM2 Clock Enable During CSleep Mode
    const uint32_t RCC_AHB2LPENR_SRAM2LPEN = 1U << 30 ;

  // Field SRAM3LPEN: SRAM3 Clock Enable During CSleep Mode
    const uint32_t RCC_AHB2LPENR_SRAM3LPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register AHB4LPENR: RCC AHB4 Sleep Clock Register
  #define RCC_AHB4LPENR (* ((volatile uint32_t *) (0x58024400 + 264)))

  // Field GPIOALPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOALPEN = 1U << 0 ;

  // Field GPIOBLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOBLPEN = 1U << 1 ;

  // Field GPIOCLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOCLPEN = 1U << 2 ;

  // Field GPIODLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIODLPEN = 1U << 3 ;

  // Field GPIOELPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOELPEN = 1U << 4 ;

  // Field GPIOFLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOFLPEN = 1U << 5 ;

  // Field GPIOGLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOGLPEN = 1U << 6 ;

  // Field GPIOHLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOHLPEN = 1U << 7 ;

  // Field GPIOILPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOILPEN = 1U << 8 ;

  // Field GPIOJLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOJLPEN = 1U << 9 ;

  // Field GPIOKLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_GPIOKLPEN = 1U << 10 ;

  // Field CRCLPEN: CRC peripheral clock enable during CSleep mode
    const uint32_t RCC_AHB4LPENR_CRCLPEN = 1U << 19 ;

  // Field BDMALPEN: BDMA Clock Enable During CSleep Mode
    const uint32_t RCC_AHB4LPENR_BDMALPEN = 1U << 21 ;

  // Field ADC3LPEN: ADC3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_AHB4LPENR_ADC3LPEN = 1U << 24 ;

  // Field BKPRAMLPEN: Backup RAM Clock Enable During CSleep Mode
    const uint32_t RCC_AHB4LPENR_BKPRAMLPEN = 1U << 28 ;

  // Field SRAM4LPEN: SRAM4 Clock Enable During CSleep Mode
    const uint32_t RCC_AHB4LPENR_SRAM4LPEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register C1_AHB4LPENR: RCC AHB4 Sleep Clock Register
  #define RCC_C1_AHB4LPENR (* ((volatile uint32_t *) (0x58024400 + 360)))

  // Field GPIOALPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOALPEN = 1U << 0 ;

  // Field GPIOBLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOBLPEN = 1U << 1 ;

  // Field GPIOCLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOCLPEN = 1U << 2 ;

  // Field GPIODLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIODLPEN = 1U << 3 ;

  // Field GPIOELPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOELPEN = 1U << 4 ;

  // Field GPIOFLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOFLPEN = 1U << 5 ;

  // Field GPIOGLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOGLPEN = 1U << 6 ;

  // Field GPIOHLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOHLPEN = 1U << 7 ;

  // Field GPIOILPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOILPEN = 1U << 8 ;

  // Field GPIOJLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOJLPEN = 1U << 9 ;

  // Field GPIOKLPEN: GPIO peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_GPIOKLPEN = 1U << 10 ;

  // Field CRCLPEN: CRC peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_AHB4LPENR_CRCLPEN = 1U << 19 ;

  // Field BDMALPEN: BDMA Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB4LPENR_BDMALPEN = 1U << 21 ;

  // Field ADC3LPEN: ADC3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_AHB4LPENR_ADC3LPEN = 1U << 24 ;

  // Field BKPRAMLPEN: Backup RAM Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB4LPENR_BKPRAMLPEN = 1U << 28 ;

  // Field SRAM4LPEN: SRAM4 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_AHB4LPENR_SRAM4LPEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register C1_APB3LPENR: RCC APB3 Sleep Clock Register
  #define RCC_C1_APB3LPENR (* ((volatile uint32_t *) (0x58024400 + 364)))

  // Field LTDCLPEN: LTDC peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB3LPENR_LTDCLPEN = 1U << 3 ;

  // Field WWDG1LPEN: WWDG1 Clock Enable During CSleep Mode
    const uint32_t RCC_C1_APB3LPENR_WWDG1LPEN = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register APB3LPENR: RCC APB3 Sleep Clock Register
  #define RCC_APB3LPENR (* ((volatile uint32_t *) (0x58024400 + 268)))

  // Field LTDCLPEN: LTDC peripheral clock enable during CSleep mode
    const uint32_t RCC_APB3LPENR_LTDCLPEN = 1U << 3 ;

  // Field WWDG1LPEN: WWDG1 Clock Enable During CSleep Mode
    const uint32_t RCC_APB3LPENR_WWDG1LPEN = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register APB1LLPENR: RCC APB1 Low Sleep Clock Register
  #define RCC_APB1LLPENR (* ((volatile uint32_t *) (0x58024400 + 272)))

  // Field TIM2LPEN: TIM2 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM2LPEN = 1U << 0 ;

  // Field TIM3LPEN: TIM3 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM3LPEN = 1U << 1 ;

  // Field TIM4LPEN: TIM4 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM4LPEN = 1U << 2 ;

  // Field TIM5LPEN: TIM5 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM5LPEN = 1U << 3 ;

  // Field TIM6LPEN: TIM6 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM6LPEN = 1U << 4 ;

  // Field TIM7LPEN: TIM7 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM7LPEN = 1U << 5 ;

  // Field TIM12LPEN: TIM12 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM12LPEN = 1U << 6 ;

  // Field TIM13LPEN: TIM13 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM13LPEN = 1U << 7 ;

  // Field TIM14LPEN: TIM14 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_TIM14LPEN = 1U << 8 ;

  // Field LPTIM1LPEN: LPTIM1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_LPTIM1LPEN = 1U << 9 ;

  // Field SPI2LPEN: SPI2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_SPI2LPEN = 1U << 14 ;

  // Field SPI3LPEN: SPI3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_SPI3LPEN = 1U << 15 ;

  // Field SPDIFRXLPEN: SPDIFRX Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_SPDIFRXLPEN = 1U << 16 ;

  // Field USART2LPEN: USART2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_USART2LPEN = 1U << 17 ;

  // Field USART3LPEN: USART3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_USART3LPEN = 1U << 18 ;

  // Field UART4LPEN: UART4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_UART4LPEN = 1U << 19 ;

  // Field UART5LPEN: UART5 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_UART5LPEN = 1U << 20 ;

  // Field I2C1LPEN: I2C1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_I2C1LPEN = 1U << 21 ;

  // Field I2C2LPEN: I2C2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_I2C2LPEN = 1U << 22 ;

  // Field I2C3LPEN: I2C3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_I2C3LPEN = 1U << 23 ;

  // Field HDMICECLPEN: HDMI-CEC Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_HDMICECLPEN = 1U << 27 ;

  // Field DAC12LPEN: DAC1/2 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1LLPENR_DAC12LPEN = 1U << 29 ;

  // Field USART7LPEN: USART7 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_USART7LPEN = 1U << 30 ;

  // Field USART8LPEN: USART8 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1LLPENR_USART8LPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register C1_APB1LLPENR: RCC APB1 Low Sleep Clock Register
  #define RCC_C1_APB1LLPENR (* ((volatile uint32_t *) (0x58024400 + 368)))

  // Field TIM2LPEN: TIM2 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM2LPEN = 1U << 0 ;

  // Field TIM3LPEN: TIM3 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM3LPEN = 1U << 1 ;

  // Field TIM4LPEN: TIM4 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM4LPEN = 1U << 2 ;

  // Field TIM5LPEN: TIM5 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM5LPEN = 1U << 3 ;

  // Field TIM6LPEN: TIM6 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM6LPEN = 1U << 4 ;

  // Field TIM7LPEN: TIM7 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM7LPEN = 1U << 5 ;

  // Field TIM12LPEN: TIM12 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM12LPEN = 1U << 6 ;

  // Field TIM13LPEN: TIM13 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM13LPEN = 1U << 7 ;

  // Field TIM14LPEN: TIM14 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_TIM14LPEN = 1U << 8 ;

  // Field LPTIM1LPEN: LPTIM1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_LPTIM1LPEN = 1U << 9 ;

  // Field SPI2LPEN: SPI2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_SPI2LPEN = 1U << 14 ;

  // Field SPI3LPEN: SPI3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_SPI3LPEN = 1U << 15 ;

  // Field SPDIFRXLPEN: SPDIFRX Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_SPDIFRXLPEN = 1U << 16 ;

  // Field USART2LPEN: USART2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_USART2LPEN = 1U << 17 ;

  // Field USART3LPEN: USART3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_USART3LPEN = 1U << 18 ;

  // Field UART4LPEN: UART4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_UART4LPEN = 1U << 19 ;

  // Field UART5LPEN: UART5 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_UART5LPEN = 1U << 20 ;

  // Field I2C1LPEN: I2C1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_I2C1LPEN = 1U << 21 ;

  // Field I2C2LPEN: I2C2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_I2C2LPEN = 1U << 22 ;

  // Field I2C3LPEN: I2C3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_I2C3LPEN = 1U << 23 ;

  // Field HDMICECLPEN: HDMI-CEC Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_HDMICECLPEN = 1U << 27 ;

  // Field DAC12LPEN: DAC1/2 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1LLPENR_DAC12LPEN = 1U << 29 ;

  // Field USART7LPEN: USART7 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_USART7LPEN = 1U << 30 ;

  // Field USART8LPEN: USART8 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1LLPENR_USART8LPEN = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register C1_APB1HLPENR: RCC APB1 High Sleep Clock Register
  #define RCC_C1_APB1HLPENR (* ((volatile uint32_t *) (0x58024400 + 372)))

  // Field CRSLPEN: Clock Recovery System peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1HLPENR_CRSLPEN = 1U << 1 ;

  // Field SWPLPEN: SWPMI Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1HLPENR_SWPLPEN = 1U << 2 ;

  // Field OPAMPLPEN: OPAMP peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1HLPENR_OPAMPLPEN = 1U << 4 ;

  // Field MDIOSLPEN: MDIOS peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB1HLPENR_MDIOSLPEN = 1U << 5 ;

  // Field FDCANLPEN: FDCAN Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB1HLPENR_FDCANLPEN = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register APB1HLPENR: RCC APB1 High Sleep Clock Register
  #define RCC_APB1HLPENR (* ((volatile uint32_t *) (0x58024400 + 276)))

  // Field CRSLPEN: Clock Recovery System peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1HLPENR_CRSLPEN = 1U << 1 ;

  // Field SWPLPEN: SWPMI Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1HLPENR_SWPLPEN = 1U << 2 ;

  // Field OPAMPLPEN: OPAMP peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1HLPENR_OPAMPLPEN = 1U << 4 ;

  // Field MDIOSLPEN: MDIOS peripheral clock enable during CSleep mode
    const uint32_t RCC_APB1HLPENR_MDIOSLPEN = 1U << 5 ;

  // Field FDCANLPEN: FDCAN Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB1HLPENR_FDCANLPEN = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register APB2LPENR: RCC APB2 Sleep Clock Register
  #define RCC_APB2LPENR (* ((volatile uint32_t *) (0x58024400 + 280)))

  // Field TIM1LPEN: TIM1 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB2LPENR_TIM1LPEN = 1U << 0 ;

  // Field TIM8LPEN: TIM8 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB2LPENR_TIM8LPEN = 1U << 1 ;

  // Field USART1LPEN: USART1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_USART1LPEN = 1U << 4 ;

  // Field USART6LPEN: USART6 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_USART6LPEN = 1U << 5 ;

  // Field SPI1LPEN: SPI1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_SPI1LPEN = 1U << 12 ;

  // Field SPI4LPEN: SPI4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_SPI4LPEN = 1U << 13 ;

  // Field TIM15LPEN: TIM15 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB2LPENR_TIM15LPEN = 1U << 16 ;

  // Field TIM16LPEN: TIM16 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB2LPENR_TIM16LPEN = 1U << 17 ;

  // Field TIM17LPEN: TIM17 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB2LPENR_TIM17LPEN = 1U << 18 ;

  // Field SPI5LPEN: SPI5 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_SPI5LPEN = 1U << 20 ;

  // Field SAI1LPEN: SAI1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_SAI1LPEN = 1U << 22 ;

  // Field SAI2LPEN: SAI2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_SAI2LPEN = 1U << 23 ;

  // Field SAI3LPEN: SAI3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_SAI3LPEN = 1U << 24 ;

  // Field DFSDM1LPEN: DFSDM1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB2LPENR_DFSDM1LPEN = 1U << 28 ;

  // Field HRTIMLPEN: HRTIM peripheral clock enable during CSleep mode
    const uint32_t RCC_APB2LPENR_HRTIMLPEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register C1_APB2LPENR: RCC APB2 Sleep Clock Register
  #define RCC_C1_APB2LPENR (* ((volatile uint32_t *) (0x58024400 + 376)))

  // Field TIM1LPEN: TIM1 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB2LPENR_TIM1LPEN = 1U << 0 ;

  // Field TIM8LPEN: TIM8 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB2LPENR_TIM8LPEN = 1U << 1 ;

  // Field USART1LPEN: USART1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_USART1LPEN = 1U << 4 ;

  // Field USART6LPEN: USART6 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_USART6LPEN = 1U << 5 ;

  // Field SPI1LPEN: SPI1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_SPI1LPEN = 1U << 12 ;

  // Field SPI4LPEN: SPI4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_SPI4LPEN = 1U << 13 ;

  // Field TIM15LPEN: TIM15 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB2LPENR_TIM15LPEN = 1U << 16 ;

  // Field TIM16LPEN: TIM16 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB2LPENR_TIM16LPEN = 1U << 17 ;

  // Field TIM17LPEN: TIM17 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB2LPENR_TIM17LPEN = 1U << 18 ;

  // Field SPI5LPEN: SPI5 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_SPI5LPEN = 1U << 20 ;

  // Field SAI1LPEN: SAI1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_SAI1LPEN = 1U << 22 ;

  // Field SAI2LPEN: SAI2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_SAI2LPEN = 1U << 23 ;

  // Field SAI3LPEN: SAI3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_SAI3LPEN = 1U << 24 ;

  // Field DFSDM1LPEN: DFSDM1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB2LPENR_DFSDM1LPEN = 1U << 28 ;

  // Field HRTIMLPEN: HRTIM peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB2LPENR_HRTIMLPEN = 1U << 29 ;

//------------------------------------------------------------------------------

//---  Register C1_APB4LPENR: RCC APB4 Sleep Clock Register
  #define RCC_C1_APB4LPENR (* ((volatile uint32_t *) (0x58024400 + 380)))

  // Field SYSCFGLPEN: SYSCFG peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB4LPENR_SYSCFGLPEN = 1U << 1 ;

  // Field LPUART1LPEN: LPUART1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_LPUART1LPEN = 1U << 3 ;

  // Field SPI6LPEN: SPI6 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_SPI6LPEN = 1U << 5 ;

  // Field I2C4LPEN: I2C4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_I2C4LPEN = 1U << 7 ;

  // Field LPTIM2LPEN: LPTIM2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_LPTIM2LPEN = 1U << 9 ;

  // Field LPTIM3LPEN: LPTIM3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_LPTIM3LPEN = 1U << 10 ;

  // Field LPTIM4LPEN: LPTIM4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_LPTIM4LPEN = 1U << 11 ;

  // Field LPTIM5LPEN: LPTIM5 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_LPTIM5LPEN = 1U << 12 ;

  // Field COMP12LPEN: COMP1/2 peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB4LPENR_COMP12LPEN = 1U << 14 ;

  // Field VREFLPEN: VREF peripheral clock enable during CSleep mode
    const uint32_t RCC_C1_APB4LPENR_VREFLPEN = 1U << 15 ;

  // Field RTCAPBLPEN: RTC APB Clock Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_RTCAPBLPEN = 1U << 16 ;

  // Field SAI4LPEN: SAI4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_C1_APB4LPENR_SAI4LPEN = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register APB4LPENR: RCC APB4 Sleep Clock Register
  #define RCC_APB4LPENR (* ((volatile uint32_t *) (0x58024400 + 284)))

  // Field SYSCFGLPEN: SYSCFG peripheral clock enable during CSleep mode
    const uint32_t RCC_APB4LPENR_SYSCFGLPEN = 1U << 1 ;

  // Field LPUART1LPEN: LPUART1 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_LPUART1LPEN = 1U << 3 ;

  // Field SPI6LPEN: SPI6 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_SPI6LPEN = 1U << 5 ;

  // Field I2C4LPEN: I2C4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_I2C4LPEN = 1U << 7 ;

  // Field LPTIM2LPEN: LPTIM2 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_LPTIM2LPEN = 1U << 9 ;

  // Field LPTIM3LPEN: LPTIM3 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_LPTIM3LPEN = 1U << 10 ;

  // Field LPTIM4LPEN: LPTIM4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_LPTIM4LPEN = 1U << 11 ;

  // Field LPTIM5LPEN: LPTIM5 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_LPTIM5LPEN = 1U << 12 ;

  // Field COMP12LPEN: COMP1/2 peripheral clock enable during CSleep mode
    const uint32_t RCC_APB4LPENR_COMP12LPEN = 1U << 14 ;

  // Field VREFLPEN: VREF peripheral clock enable during CSleep mode
    const uint32_t RCC_APB4LPENR_VREFLPEN = 1U << 15 ;

  // Field RTCAPBLPEN: RTC APB Clock Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_RTCAPBLPEN = 1U << 16 ;

  // Field SAI4LPEN: SAI4 Peripheral Clocks Enable During CSleep Mode
    const uint32_t RCC_APB4LPENR_SAI4LPEN = 1U << 21 ;

//------------------------------------------------------------------------------
// Peripheral RNG: RNG
//------------------------------------------------------------------------------

//---  Register CR: RNG control register
  #define RNG_CR (* ((volatile uint32_t *) (0x48021800 + 0)))

  // Field RNGEN: Random number generator enable
    const uint32_t RNG_CR_RNGEN = 1U << 2 ;

  // Field IE: Interrupt enable
    const uint32_t RNG_CR_IE = 1U << 3 ;

  // Field CED: Clock error detection Note: The clock error detection can be used only when ck_rc48 or ck_pll1_q (ck_pll1_q = 48MHz) source is selected otherwise, CED bit must be equal to 1. The clock error detection cannot be enabled nor disabled on the fly when RNG peripheral is enabled, to enable or disable CED the RNG must be disabled.
    const uint32_t RNG_CR_CED = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register SR: RNG status register
  #define RNG_SR (* ((volatile uint32_t *) (0x48021800 + 4)))

  // Field DRDY: Data ready Note: If IE=1 in RNG_CR, an interrupt is generated when DRDY=1. It can rise when the peripheral is disabled. When the output buffer becomes empty (after reading RNG_DR), this bit returns to 0 until a new random value is generated.
    const uint32_t RNG_SR_DRDY = 1U << 0 ;

  // Field CECS: Clock error current status Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
    const uint32_t RNG_SR_CECS = 1U << 1 ;

  // Field SECS: Seed error current status ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01)
    const uint32_t RNG_SR_SECS = 1U << 2 ;

  // Field CEIS: Clock error interrupt status This bit is set at the same time as CECS. It is cleared by writing it to 0. An interrupt is pending if IE = 1 in the RNG_CR register. Note: This bit is meaningless if CED (Clock error detection) bit in RNG_CR is equal to 1.
    const uint32_t RNG_SR_CEIS = 1U << 5 ;

  // Field SEIS: Seed error interrupt status This bit is set at the same time as SECS. It is cleared by writing it to 0. ** More than 64 consecutive bits at the same value (0 or 1) ** More than 32 consecutive alternances of 0 and 1 (0101010101...01) An interrupt is pending if IE = 1 in the RNG_CR register.
    const uint32_t RNG_SR_SEIS = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register DR: The RNG_DR register is a read-only register that delivers a 32-bit random value when read. The content of this register is valid when DRDY= 1, even if RNGEN=0.
  #define RNG_DR (* ((const volatile uint32_t *) (0x48021800 + 8)))

  // Field RNDATA: Random data 32-bit random data which are valid when DRDY=1.
    inline uint32_t RNG_DR_RNDATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral RTC: RTC
//------------------------------------------------------------------------------

//---  Register RTC_TR: The RTC_TR is the calendar time shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_TR (* ((volatile uint32_t *) (0x58004000 + 0)))

  // Field SU: Second units in BCD format
    inline uint32_t RTC_RTC_TR_SU (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ST: Second tens in BCD format
    inline uint32_t RTC_RTC_TR_ST (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MNU: Minute units in BCD format
    inline uint32_t RTC_RTC_TR_MNU (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MNT: Minute tens in BCD format
    inline uint32_t RTC_RTC_TR_MNT (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field HU: Hour units in BCD format
    inline uint32_t RTC_RTC_TR_HU (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field HT: Hour tens in BCD format
    inline uint32_t RTC_RTC_TR_HT (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PM: AM/PM notation
    const uint32_t RTC_RTC_TR_PM = 1U << 22 ;

//------------------------------------------------------------------------------

//---  Register RTC_DR: The RTC_DR is the calendar date shadow register. This register must be written in initialization mode only. Refer to Calendar initialization and configuration on page9 and Reading the calendar on page10.This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_DR (* ((volatile uint32_t *) (0x58004000 + 4)))

  // Field DU: Date units in BCD format
    inline uint32_t RTC_RTC_DR_DU (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DT: Date tens in BCD format
    inline uint32_t RTC_RTC_DR_DT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MU: Month units in BCD format
    inline uint32_t RTC_RTC_DR_MU (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MT: Month tens in BCD format
    const uint32_t RTC_RTC_DR_MT = 1U << 12 ;

  // Field WDU: Week day units
    inline uint32_t RTC_RTC_DR_WDU (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

  // Field YU: Year units in BCD format
    inline uint32_t RTC_RTC_DR_YU (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field YT: Year tens in BCD format
    inline uint32_t RTC_RTC_DR_YT (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

//------------------------------------------------------------------------------

//---  Register RTC_CR: RTC control register
  #define RTC_RTC_CR (* ((volatile uint32_t *) (0x58004000 + 8)))

  // Field WUCKSEL: Wakeup clock selection
    inline uint32_t RTC_RTC_CR_WUCKSEL (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field TSEDGE: Time-stamp event active edge TSE must be reset when TSEDGE is changed to avoid unwanted TSF setting.
    const uint32_t RTC_RTC_CR_TSEDGE = 1U << 3 ;

  // Field REFCKON: RTC_REFIN reference clock detection enable (50 or 60Hz) Note: PREDIV_S must be 0x00FF.
    const uint32_t RTC_RTC_CR_REFCKON = 1U << 4 ;

  // Field BYPSHAD: Bypass the shadow registers Note: If the frequency of the APB clock is less than seven times the frequency of RTCCLK, BYPSHAD must be set to 1.
    const uint32_t RTC_RTC_CR_BYPSHAD = 1U << 5 ;

  // Field FMT: Hour format
    const uint32_t RTC_RTC_CR_FMT = 1U << 6 ;

  // Field ALRAE: Alarm A enable
    const uint32_t RTC_RTC_CR_ALRAE = 1U << 8 ;

  // Field ALRBE: Alarm B enable
    const uint32_t RTC_RTC_CR_ALRBE = 1U << 9 ;

  // Field WUTE: Wakeup timer enable
    const uint32_t RTC_RTC_CR_WUTE = 1U << 10 ;

  // Field TSE: timestamp enable
    const uint32_t RTC_RTC_CR_TSE = 1U << 11 ;

  // Field ALRAIE: Alarm A interrupt enable
    const uint32_t RTC_RTC_CR_ALRAIE = 1U << 12 ;

  // Field ALRBIE: Alarm B interrupt enable
    const uint32_t RTC_RTC_CR_ALRBIE = 1U << 13 ;

  // Field WUTIE: Wakeup timer interrupt enable
    const uint32_t RTC_RTC_CR_WUTIE = 1U << 14 ;

  // Field TSIE: Time-stamp interrupt enable
    const uint32_t RTC_RTC_CR_TSIE = 1U << 15 ;

  // Field ADD1H: Add 1 hour (summer time change) When this bit is set outside initialization mode, 1 hour is added to the calendar time. This bit is always read as 0.
    const uint32_t RTC_RTC_CR_ADD1H = 1U << 16 ;

  // Field SUB1H: Subtract 1 hour (winter time change) When this bit is set outside initialization mode, 1 hour is subtracted to the calendar time if the current hour is not 0. This bit is always read as 0. Setting this bit has no effect when current hour is 0.
    const uint32_t RTC_RTC_CR_SUB1H = 1U << 17 ;

  // Field BKP: Backup This bit can be written by the user to memorize whether the daylight saving time change has been performed or not.
    const uint32_t RTC_RTC_CR_BKP = 1U << 18 ;

  // Field COSEL: Calibration output selection When COE=1, this bit selects which signal is output on RTC_CALIB. These frequencies are valid for RTCCLK at 32.768 kHz and prescalers at their default values (PREDIV_A=127 and PREDIV_S=255). Refer to Section24.3.15: Calibration clock output
    const uint32_t RTC_RTC_CR_COSEL = 1U << 19 ;

  // Field POL: Output polarity This bit is used to configure the polarity of RTC_ALARM output
    const uint32_t RTC_RTC_CR_POL = 1U << 20 ;

  // Field OSEL: Output selection These bits are used to select the flag to be routed to RTC_ALARM output
    inline uint32_t RTC_RTC_CR_OSEL (const uint32_t inValue) {return (inValue & 0x3U) << 21 ; }

  // Field COE: Calibration output enable This bit enables the RTC_CALIB output
    const uint32_t RTC_RTC_CR_COE = 1U << 23 ;

  // Field ITSE: timestamp on internal event enable
    const uint32_t RTC_RTC_CR_ITSE = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register RTC_ISR: This register is write protected (except for RTC_ISR[13:8] bits). The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_ISR (* ((volatile uint32_t *) (0x58004000 + 12)))

  // Field ALRAWF: Alarm A write flag This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
    const uint32_t RTC_RTC_ISR_ALRAWF = 1U << 0 ;

  // Field ALRBWF: Alarm B write flag This bit is set by hardware when Alarm B values can be changed, after the ALRBE bit has been set to 0 in RTC_CR. It is cleared by hardware in initialization mode.
    const uint32_t RTC_RTC_ISR_ALRBWF = 1U << 1 ;

  // Field WUTWF: Wakeup timer write flag This bit is set by hardware up to 2 RTCCLK cycles after the WUTE bit has been set to 0 in RTC_CR, and is cleared up to 2 RTCCLK cycles after the WUTE bit has been set to 1. The wakeup timer values can be changed when WUTE bit is cleared and WUTWF is set.
    const uint32_t RTC_RTC_ISR_WUTWF = 1U << 2 ;

  // Field SHPF: Shift operation pending This flag is set by hardware as soon as a shift operation is initiated by a write to the RTC_SHIFTR register. It is cleared by hardware when the corresponding shift operation has been executed. Writing to the SHPF bit has no effect.
    const uint32_t RTC_RTC_ISR_SHPF = 1U << 3 ;

  // Field INITS: Initialization status flag This bit is set by hardware when the calendar year field is different from 0 (Backup domain reset state).
    const uint32_t RTC_RTC_ISR_INITS = 1U << 4 ;

  // Field RSF: Registers synchronization flag This bit is set by hardware each time the calendar registers are copied into the shadow registers (RTC_SSRx, RTC_TRx and RTC_DRx). This bit is cleared by hardware in initialization mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode (BYPSHAD=1). This bit can also be cleared by software. It is cleared either by software or by hardware in initialization mode.
    const uint32_t RTC_RTC_ISR_RSF = 1U << 5 ;

  // Field INITF: Initialization flag When this bit is set to 1, the RTC is in initialization state, and the time, date and prescaler registers can be updated.
    const uint32_t RTC_RTC_ISR_INITF = 1U << 6 ;

  // Field INIT: Initialization mode
    const uint32_t RTC_RTC_ISR_INIT = 1U << 7 ;

  // Field ALRAF: Alarm A flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR). This flag is cleared by software by writing 0.
    const uint32_t RTC_RTC_ISR_ALRAF = 1U << 8 ;

  // Field ALRBF: Alarm B flag This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm B register (RTC_ALRMBR). This flag is cleared by software by writing 0.
    const uint32_t RTC_RTC_ISR_ALRBF = 1U << 9 ;

  // Field WUTF: Wakeup timer flag This flag is set by hardware when the wakeup auto-reload counter reaches 0. This flag is cleared by software by writing 0. This flag must be cleared by software at least 1.5 RTCCLK periods before WUTF is set to 1 again.
    const uint32_t RTC_RTC_ISR_WUTF = 1U << 10 ;

  // Field TSF: Time-stamp flag This flag is set by hardware when a time-stamp event occurs. This flag is cleared by software by writing 0.
    const uint32_t RTC_RTC_ISR_TSF = 1U << 11 ;

  // Field TSOVF: Time-stamp overflow flag This flag is set by hardware when a time-stamp event occurs while TSF is already set. This flag is cleared by software by writing 0. It is recommended to check and then clear TSOVF only after clearing the TSF bit. Otherwise, an overflow might not be noticed if a time-stamp event occurs immediately before the TSF bit is cleared.
    const uint32_t RTC_RTC_ISR_TSOVF = 1U << 12 ;

  // Field TAMP1F: RTC_TAMP1 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP1 input. It is cleared by software writing 0
    const uint32_t RTC_RTC_ISR_TAMP1F = 1U << 13 ;

  // Field TAMP2F: RTC_TAMP2 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP2 input. It is cleared by software writing 0
    const uint32_t RTC_RTC_ISR_TAMP2F = 1U << 14 ;

  // Field TAMP3F: RTC_TAMP3 detection flag This flag is set by hardware when a tamper detection event is detected on the RTC_TAMP3 input. It is cleared by software writing 0
    const uint32_t RTC_RTC_ISR_TAMP3F = 1U << 15 ;

  // Field RECALPF: Recalibration pending Flag The RECALPF status flag is automatically set to 1 when software writes to the RTC_CALR register, indicating that the RTC_CALR register is blocked. When the new calibration settings are taken into account, this bit returns to 0. Refer to Re-calibration on-the-fly.
    const uint32_t RTC_RTC_ISR_RECALPF = 1U << 16 ;

  // Field ITSF: Internal tTime-stamp flag
    const uint32_t RTC_RTC_ISR_ITSF = 1U << 17 ;

//------------------------------------------------------------------------------

//---  Register RTC_PRER: This register must be written in initialization mode only. The initialization must be performed in two separate write accesses. Refer to Calendar initialization and configuration on page9.This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_PRER (* ((volatile uint32_t *) (0x58004000 + 16)))

  // Field PREDIV_S: Synchronous prescaler factor This is the synchronous division factor: ck_spre frequency = ck_apre frequency/(PREDIV_S+1)
    inline uint32_t RTC_RTC_PRER_PREDIV_S (const uint32_t inValue) {return (inValue & 0x7FFFU) << 0 ; }

  // Field PREDIV_A: Asynchronous prescaler factor This is the asynchronous division factor: ck_apre frequency = RTCCLK frequency/(PREDIV_A+1)
    inline uint32_t RTC_RTC_PRER_PREDIV_A (const uint32_t inValue) {return (inValue & 0x7FU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register RTC_WUTR: This register can be written only when WUTWF is set to 1 in RTC_ISR.This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_WUTR (* ((volatile uint32_t *) (0x58004000 + 20)))

  // Field WUT: Wakeup auto-reload value bits When the wakeup timer is enabled (WUTE set to 1), the WUTF flag is set every (WUT[15:0] + 1) ck_wut cycles. The ck_wut period is selected through WUCKSEL[2:0] bits of the RTC_CR register When WUCKSEL[2] = 1, the wakeup timer becomes 17-bits and WUCKSEL[1] effectively becomes WUT[16] the most-significant bit to be reloaded into the timer. The first assertion of WUTF occurs (WUT+1) ck_wut cycles after WUTE is set. Setting WUT[15:0] to 0x0000 with WUCKSEL[2:0] =011 (RTCCLK/2) is forbidden.
    inline uint32_t RTC_RTC_WUTR_WUT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_ALRMAR: This register can be written only when ALRAWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_ALRMAR (* ((volatile uint32_t *) (0x58004000 + 28)))

  // Field SU: Second units in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_SU (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ST: Second tens in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_ST (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MSK1: Alarm A seconds mask
    const uint32_t RTC_RTC_ALRMAR_MSK1 = 1U << 7 ;

  // Field MNU: Minute units in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_MNU (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MNT: Minute tens in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_MNT (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field MSK2: Alarm A minutes mask
    const uint32_t RTC_RTC_ALRMAR_MSK2 = 1U << 15 ;

  // Field HU: Hour units in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_HU (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field HT: Hour tens in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_HT (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PM: AM/PM notation
    const uint32_t RTC_RTC_ALRMAR_PM = 1U << 22 ;

  // Field MSK3: Alarm A hours mask
    const uint32_t RTC_RTC_ALRMAR_MSK3 = 1U << 23 ;

  // Field DU: Date units or day in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_DU (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field DT: Date tens in BCD format.
    inline uint32_t RTC_RTC_ALRMAR_DT (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field WDSEL: Week day selection
    const uint32_t RTC_RTC_ALRMAR_WDSEL = 1U << 30 ;

  // Field MSK4: Alarm A date mask
    const uint32_t RTC_RTC_ALRMAR_MSK4 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register RTC_ALRMBR: This register can be written only when ALRBWF is set to 1 in RTC_ISR, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_ALRMBR (* ((volatile uint32_t *) (0x58004000 + 32)))

  // Field SU: Second units in BCD format
    inline uint32_t RTC_RTC_ALRMBR_SU (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ST: Second tens in BCD format
    inline uint32_t RTC_RTC_ALRMBR_ST (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MSK1: Alarm B seconds mask
    const uint32_t RTC_RTC_ALRMBR_MSK1 = 1U << 7 ;

  // Field MNU: Minute units in BCD format
    inline uint32_t RTC_RTC_ALRMBR_MNU (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MNT: Minute tens in BCD format
    inline uint32_t RTC_RTC_ALRMBR_MNT (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field MSK2: Alarm B minutes mask
    const uint32_t RTC_RTC_ALRMBR_MSK2 = 1U << 15 ;

  // Field HU: Hour units in BCD format
    inline uint32_t RTC_RTC_ALRMBR_HU (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field HT: Hour tens in BCD format
    inline uint32_t RTC_RTC_ALRMBR_HT (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PM: AM/PM notation
    const uint32_t RTC_RTC_ALRMBR_PM = 1U << 22 ;

  // Field MSK3: Alarm B hours mask
    const uint32_t RTC_RTC_ALRMBR_MSK3 = 1U << 23 ;

  // Field DU: Date units or day in BCD format
    inline uint32_t RTC_RTC_ALRMBR_DU (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field DT: Date tens in BCD format
    inline uint32_t RTC_RTC_ALRMBR_DT (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

  // Field WDSEL: Week day selection
    const uint32_t RTC_RTC_ALRMBR_WDSEL = 1U << 30 ;

  // Field MSK4: Alarm B date mask
    const uint32_t RTC_RTC_ALRMBR_MSK4 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register RTC_WPR: RTC write protection register
  #define RTC_RTC_WPR (* ((volatile uint32_t *) (0x58004000 + 36)))

  // Field KEY: Write protection key This byte is written by software. Reading this byte always returns 0x00. Refer to RTC register write protection for a description of how to unlock RTC register write protection.
    inline uint32_t RTC_RTC_WPR_KEY (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_SSR: RTC sub second register
  #define RTC_RTC_SSR (* ((const volatile uint32_t *) (0x58004000 + 40)))

  // Field SS: Sub second value SS[15:0] is the value in the synchronous prescaler counter. The fraction of a second is given by the formula below: Second fraction = (PREDIV_S - SS) / (PREDIV_S + 1) Note: SS can be larger than PREDIV_S only after a shift operation. In that case, the correct time/date is one second less than as indicated by RTC_TR/RTC_DR.
    inline uint32_t RTC_RTC_SSR_SS (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_SHIFTR: This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_SHIFTR (* ((volatile uint32_t *) (0x58004000 + 44)))

  // Field SUBFS: Subtract a fraction of a second These bits are write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). The value which is written to SUBFS is added to the synchronous prescaler counter. Since this counter counts down, this operation effectively subtracts from (delays) the clock by: Delay (seconds) = SUBFS / (PREDIV_S + 1) A fraction of a second can effectively be added to the clock (advancing the clock) when the ADD1S function is used in conjunction with SUBFS, effectively advancing the clock by: Advance (seconds) = (1 - (SUBFS / (PREDIV_S + 1))). Note: Writing to SUBFS causes RSF to be cleared. Software can then wait until RSF=1 to be sure that the shadow registers have been updated with the shifted time.
    inline uint32_t RTC_RTC_SHIFTR_SUBFS (const uint32_t inValue) {return (inValue & 0x7FFFU) << 0 ; }

  // Field ADD1S: Add one second This bit is write only and is always read as zero. Writing to this bit has no effect when a shift operation is pending (when SHPF=1, in RTC_ISR). This function is intended to be used with SUBFS (see description below) in order to effectively add a fraction of a second to the clock in an atomic operation.
    const uint32_t RTC_RTC_SHIFTR_ADD1S = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register RTC_TSTR: The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
  #define RTC_RTC_TSTR (* ((const volatile uint32_t *) (0x58004000 + 48)))

  // Field SU: Second units in BCD format.
    inline uint32_t RTC_RTC_TSTR_SU (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field ST: Second tens in BCD format.
    inline uint32_t RTC_RTC_TSTR_ST (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MNU: Minute units in BCD format.
    inline uint32_t RTC_RTC_TSTR_MNU (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MNT: Minute tens in BCD format.
    inline uint32_t RTC_RTC_TSTR_MNT (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field HU: Hour units in BCD format.
    inline uint32_t RTC_RTC_TSTR_HU (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field HT: Hour tens in BCD format.
    inline uint32_t RTC_RTC_TSTR_HT (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field PM: AM/PM notation
    const uint32_t RTC_RTC_TSTR_PM = 1U << 22 ;

//------------------------------------------------------------------------------

//---  Register RTC_TSDR: The content of this register is valid only when TSF is set to 1 in RTC_ISR. It is cleared when TSF bit is reset.
  #define RTC_RTC_TSDR (* ((const volatile uint32_t *) (0x58004000 + 52)))

  // Field DU: Date units in BCD format
    inline uint32_t RTC_RTC_TSDR_DU (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field DT: Date tens in BCD format
    inline uint32_t RTC_RTC_TSDR_DT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field MU: Month units in BCD format
    inline uint32_t RTC_RTC_TSDR_MU (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MT: Month tens in BCD format
    const uint32_t RTC_RTC_TSDR_MT = 1U << 12 ;

  // Field WDU: Week day units
    inline uint32_t RTC_RTC_TSDR_WDU (const uint32_t inValue) {return (inValue & 0x7U) << 13 ; }

//------------------------------------------------------------------------------

//---  Register RTC_TSSSR: The content of this register is valid only when RTC_ISR/TSF is set. It is cleared when the RTC_ISR/TSF bit is reset.
  #define RTC_RTC_TSSSR (* ((const volatile uint32_t *) (0x58004000 + 56)))

  // Field SS: Sub second value SS[15:0] is the value of the synchronous prescaler counter when the timestamp event occurred.
    inline uint32_t RTC_RTC_TSSSR_SS (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_CALR: This register is write protected. The write access procedure is described in RTC register write protection on page9.
  #define RTC_RTC_CALR (* ((volatile uint32_t *) (0x58004000 + 60)))

  // Field CALM: Calibration minus The frequency of the calendar is reduced by masking CALM out of 220 RTCCLK pulses (32 seconds if the input frequency is 32768 Hz). This decreases the frequency of the calendar with a resolution of 0.9537 ppm. To increase the frequency of the calendar, this feature should be used in conjunction with CALP. See Section24.3.12: RTC smooth digital calibration on page13.
    inline uint32_t RTC_RTC_CALR_CALM (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field CALW16: Use a 16-second calibration cycle period When CALW16 is set to 1, the 16-second calibration cycle period is selected.This bit must not be set to 1 if CALW8=1. Note: CALM[0] is stuck at 0 when CALW16= 1. Refer to Section24.3.12: RTC smooth digital calibration.
    const uint32_t RTC_RTC_CALR_CALW16 = 1U << 13 ;

  // Field CALW8: Use an 8-second calibration cycle period When CALW8 is set to 1, the 8-second calibration cycle period is selected. Note: CALM[1:0] are stuck at 00; when CALW8= 1. Refer to Section24.3.12: RTC smooth digital calibration.
    const uint32_t RTC_RTC_CALR_CALW8 = 1U << 14 ;

  // Field CALP: Increase frequency of RTC by 488.5 ppm This feature is intended to be used in conjunction with CALM, which lowers the frequency of the calendar with a fine resolution. if the input frequency is 32768 Hz, the number of RTCCLK pulses added during a 32-second window is calculated as follows: (512 * CALP) - CALM. Refer to Section24.3.12: RTC smooth digital calibration.
    const uint32_t RTC_RTC_CALR_CALP = 1U << 15 ;

//------------------------------------------------------------------------------

//---  Register RTC_TAMPCR: RTC tamper and alternate function configuration register
  #define RTC_RTC_TAMPCR (* ((volatile uint32_t *) (0x58004000 + 64)))

  // Field TAMP1E: RTC_TAMP1 input detection enable
    const uint32_t RTC_RTC_TAMPCR_TAMP1E = 1U << 0 ;

  // Field TAMP1TRG: Active level for RTC_TAMP1 input If TAMPFLT != 00 if TAMPFLT = 00:
    const uint32_t RTC_RTC_TAMPCR_TAMP1TRG = 1U << 1 ;

  // Field TAMPIE: Tamper interrupt enable
    const uint32_t RTC_RTC_TAMPCR_TAMPIE = 1U << 2 ;

  // Field TAMP2E: RTC_TAMP2 input detection enable
    const uint32_t RTC_RTC_TAMPCR_TAMP2E = 1U << 3 ;

  // Field TAMP2TRG: Active level for RTC_TAMP2 input if TAMPFLT != 00: if TAMPFLT = 00:
    const uint32_t RTC_RTC_TAMPCR_TAMP2TRG = 1U << 4 ;

  // Field TAMP3E: RTC_TAMP3 detection enable
    const uint32_t RTC_RTC_TAMPCR_TAMP3E = 1U << 5 ;

  // Field TAMP3TRG: Active level for RTC_TAMP3 input if TAMPFLT != 00: if TAMPFLT = 00:
    const uint32_t RTC_RTC_TAMPCR_TAMP3TRG = 1U << 6 ;

  // Field TAMPTS: Activate timestamp on tamper detection event TAMPTS is valid even if TSE=0 in the RTC_CR register.
    const uint32_t RTC_RTC_TAMPCR_TAMPTS = 1U << 7 ;

  // Field TAMPFREQ: Tamper sampling frequency Determines the frequency at which each of the RTC_TAMPx inputs are sampled.
    inline uint32_t RTC_RTC_TAMPCR_TAMPFREQ (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field TAMPFLT: RTC_TAMPx filter count These bits determines the number of consecutive samples at the specified level (TAMP*TRG) needed to activate a Tamper event. TAMPFLT is valid for each of the RTC_TAMPx inputs.
    inline uint32_t RTC_RTC_TAMPCR_TAMPFLT (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field TAMPPRCH: RTC_TAMPx precharge duration These bit determines the duration of time during which the pull-up/is activated before each sample. TAMPPRCH is valid for each of the RTC_TAMPx inputs.
    inline uint32_t RTC_RTC_TAMPCR_TAMPPRCH (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TAMPPUDIS: RTC_TAMPx pull-up disable This bit determines if each of the RTC_TAMPx pins are pre-charged before each sample.
    const uint32_t RTC_RTC_TAMPCR_TAMPPUDIS = 1U << 15 ;

  // Field TAMP1IE: Tamper 1 interrupt enable
    const uint32_t RTC_RTC_TAMPCR_TAMP1IE = 1U << 16 ;

  // Field TAMP1NOERASE: Tamper 1 no erase
    const uint32_t RTC_RTC_TAMPCR_TAMP1NOERASE = 1U << 17 ;

  // Field TAMP1MF: Tamper 1 mask flag
    const uint32_t RTC_RTC_TAMPCR_TAMP1MF = 1U << 18 ;

  // Field TAMP2IE: Tamper 2 interrupt enable
    const uint32_t RTC_RTC_TAMPCR_TAMP2IE = 1U << 19 ;

  // Field TAMP2NOERASE: Tamper 2 no erase
    const uint32_t RTC_RTC_TAMPCR_TAMP2NOERASE = 1U << 20 ;

  // Field TAMP2MF: Tamper 2 mask flag
    const uint32_t RTC_RTC_TAMPCR_TAMP2MF = 1U << 21 ;

  // Field TAMP3IE: Tamper 3 interrupt enable
    const uint32_t RTC_RTC_TAMPCR_TAMP3IE = 1U << 22 ;

  // Field TAMP3NOERASE: Tamper 3 no erase
    const uint32_t RTC_RTC_TAMPCR_TAMP3NOERASE = 1U << 23 ;

  // Field TAMP3MF: Tamper 3 mask flag
    const uint32_t RTC_RTC_TAMPCR_TAMP3MF = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register RTC_ALRMASSR: This register can be written only when ALRAE is reset in RTC_CR register, or in initialization mode.This register is write protected. The write access procedure is described in RTC register write protection on page9
  #define RTC_RTC_ALRMASSR (* ((volatile uint32_t *) (0x58004000 + 68)))

  // Field SS: Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm A is to be activated. Only bits 0 up MASKSS-1 are compared.
    inline uint32_t RTC_RTC_ALRMASSR_SS (const uint32_t inValue) {return (inValue & 0x7FFFU) << 0 ; }

  // Field MASKSS: Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    inline uint32_t RTC_RTC_ALRMASSR_MASKSS (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register RTC_ALRMBSSR: This register can be written only when ALRBE is reset in RTC_CR register, or in initialization mode.This register is write protected.The write access procedure is described in Section: RTC register write protection.
  #define RTC_RTC_ALRMBSSR (* ((volatile uint32_t *) (0x58004000 + 72)))

  // Field SS: Sub seconds value This value is compared with the contents of the synchronous prescaler counter to determine if Alarm B is to be activated. Only bits 0 up to MASKSS-1 are compared.
    inline uint32_t RTC_RTC_ALRMBSSR_SS (const uint32_t inValue) {return (inValue & 0x7FFFU) << 0 ; }

  // Field MASKSS: Mask the most-significant bits starting at this bit ... The overflow bits of the synchronous counter (bits 15) is never compared. This bit can be different from 0 only after a shift operation.
    inline uint32_t RTC_RTC_ALRMBSSR_MASKSS (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP0R: RTC backup registers
  #define RTC_RTC_BKP0R (* ((volatile uint32_t *) (0x58004000 + 80)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP0R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP1R: RTC backup registers
  #define RTC_RTC_BKP1R (* ((volatile uint32_t *) (0x58004000 + 84)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP1R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP2R: RTC backup registers
  #define RTC_RTC_BKP2R (* ((volatile uint32_t *) (0x58004000 + 88)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP2R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP3R: RTC backup registers
  #define RTC_RTC_BKP3R (* ((volatile uint32_t *) (0x58004000 + 92)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP3R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP4R: RTC backup registers
  #define RTC_RTC_BKP4R (* ((volatile uint32_t *) (0x58004000 + 96)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP4R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP5R: RTC backup registers
  #define RTC_RTC_BKP5R (* ((volatile uint32_t *) (0x58004000 + 100)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP5R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP6R: RTC backup registers
  #define RTC_RTC_BKP6R (* ((volatile uint32_t *) (0x58004000 + 104)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP6R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP7R: RTC backup registers
  #define RTC_RTC_BKP7R (* ((volatile uint32_t *) (0x58004000 + 108)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP7R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP8R: RTC backup registers
  #define RTC_RTC_BKP8R (* ((volatile uint32_t *) (0x58004000 + 112)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP8R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP9R: RTC backup registers
  #define RTC_RTC_BKP9R (* ((volatile uint32_t *) (0x58004000 + 116)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP9R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP10R: RTC backup registers
  #define RTC_RTC_BKP10R (* ((volatile uint32_t *) (0x58004000 + 120)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP10R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP11R: RTC backup registers
  #define RTC_RTC_BKP11R (* ((volatile uint32_t *) (0x58004000 + 124)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP11R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP12R: RTC backup registers
  #define RTC_RTC_BKP12R (* ((volatile uint32_t *) (0x58004000 + 128)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP12R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP13R: RTC backup registers
  #define RTC_RTC_BKP13R (* ((volatile uint32_t *) (0x58004000 + 132)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP13R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP14R: RTC backup registers
  #define RTC_RTC_BKP14R (* ((volatile uint32_t *) (0x58004000 + 136)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP14R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP15R: RTC backup registers
  #define RTC_RTC_BKP15R (* ((volatile uint32_t *) (0x58004000 + 140)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP15R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_OR: RTC option register
  #define RTC_RTC_OR (* ((volatile uint32_t *) (0x58004000 + 76)))

  // Field RTC_ALARM_TYPE: RTC_ALARM output type on PC13
    const uint32_t RTC_RTC_OR_RTC_ALARM_TYPE = 1U << 0 ;

  // Field RTC_OUT_RMP: RTC_OUT remap
    const uint32_t RTC_RTC_OR_RTC_OUT_RMP = 1U << 1 ;

//------------------------------------------------------------------------------

//---  Register RTC_BKP16R: RTC backup registers
  #define RTC_RTC_BKP16R (* ((volatile uint32_t *) (0x58004000 + 144)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP16R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP17R: RTC backup registers
  #define RTC_RTC_BKP17R (* ((volatile uint32_t *) (0x58004000 + 148)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP17R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP18R: RTC backup registers
  #define RTC_RTC_BKP18R (* ((volatile uint32_t *) (0x58004000 + 152)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP18R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP19R: RTC backup registers
  #define RTC_RTC_BKP19R (* ((volatile uint32_t *) (0x58004000 + 156)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP19R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP20R: RTC backup registers
  #define RTC_RTC_BKP20R (* ((volatile uint32_t *) (0x58004000 + 160)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP20R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP21R: RTC backup registers
  #define RTC_RTC_BKP21R (* ((volatile uint32_t *) (0x58004000 + 164)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP21R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP22R: RTC backup registers
  #define RTC_RTC_BKP22R (* ((volatile uint32_t *) (0x58004000 + 168)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP22R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP23R: RTC backup registers
  #define RTC_RTC_BKP23R (* ((volatile uint32_t *) (0x58004000 + 172)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP23R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP24R: RTC backup registers
  #define RTC_RTC_BKP24R (* ((volatile uint32_t *) (0x58004000 + 176)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP24R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP25R: RTC backup registers
  #define RTC_RTC_BKP25R (* ((volatile uint32_t *) (0x58004000 + 180)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP25R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP26R: RTC backup registers
  #define RTC_RTC_BKP26R (* ((volatile uint32_t *) (0x58004000 + 184)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP26R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP27R: RTC backup registers
  #define RTC_RTC_BKP27R (* ((volatile uint32_t *) (0x58004000 + 188)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP27R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP28R: RTC backup registers
  #define RTC_RTC_BKP28R (* ((volatile uint32_t *) (0x58004000 + 192)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP28R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP29R: RTC backup registers
  #define RTC_RTC_BKP29R (* ((volatile uint32_t *) (0x58004000 + 196)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP29R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP30R: RTC backup registers
  #define RTC_RTC_BKP30R (* ((volatile uint32_t *) (0x58004000 + 200)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP30R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTC_BKP31R: RTC backup registers
  #define RTC_RTC_BKP31R (* ((volatile uint32_t *) (0x58004000 + 204)))

  // Field BKP: The application can write or read data to and from these registers. They are powered-on by VBAT when VDD is switched off, so that they are not reset by System reset, and their contents remain valid when the device operates in low-power mode. This register is reset on a tamper detection event, as long as TAMPxF=1. or when the Flash readout protection is disabled.
    inline uint32_t RTC_RTC_BKP31R_BKP (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral SAI1
//------------------------------------------------------------------------------

//---  Register SAI_GCR: Global configuration register
  #define SAI1_SAI_GCR (* ((volatile uint32_t *) (0x40015800 + 0)))

  // Field SYNCOUT: Synchronization outputs These bits are set and cleared by software.
    inline uint32_t SAI1_SAI_GCR_SYNCOUT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SYNCIN: Synchronization inputs
    inline uint32_t SAI1_SAI_GCR_SYNCIN (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACR1: Configuration register 1
  #define SAI1_SAI_ACR1 (* ((volatile uint32_t *) (0x40015800 + 4)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI1_SAI_ACR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI1_SAI_ACR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI1_SAI_ACR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI1_SAI_ACR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI1_SAI_ACR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI1_SAI_ACR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI1_SAI_ACR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI1_SAI_ACR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI1_SAI_ACR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI1_SAI_ACR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI1_SAI_ACR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI1_SAI_ACR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI1_SAI_ACR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_ACR2: Configuration register 2
  #define SAI1_SAI_ACR2 (* ((volatile uint32_t *) (0x40015800 + 8)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI1_SAI_ACR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI1_SAI_ACR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI1_SAI_ACR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI1_SAI_ACR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI1_SAI_ACR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI1_SAI_ACR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI1_SAI_ACR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI1_SAI_ACR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI1_SAI_AFRCR (* ((volatile uint32_t *) (0x40015800 + 12)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI1_SAI_AFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI1_SAI_AFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI1_SAI_AFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI1_SAI_AFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI1_SAI_AFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI1_SAI_ASLOTR (* ((volatile uint32_t *) (0x40015800 + 16)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_ASLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_ASLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_ASLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_ASLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AIM: Interrupt mask register 2
  #define SAI1_SAI_AIM (* ((volatile uint32_t *) (0x40015800 + 20)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI1_SAI_AIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI1_SAI_AIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI1_SAI_AIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI1_SAI_AIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI1_SAI_AIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI1_SAI_AIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI1_SAI_AIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASR: Status register
  #define SAI1_SAI_ASR (* ((const volatile uint32_t *) (0x40015800 + 24)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_ASR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI1_SAI_ASR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_ASR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI1_SAI_ASR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_ASR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_ASR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI1_SAI_ASR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI1_SAI_ASR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACLRFR: Clear flag register
  #define SAI1_SAI_ACLRFR (* ((volatile uint32_t *) (0x40015800 + 28)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_ACLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_ACLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_ACLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_ACLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_ACLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_ACLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ADR: Data register
  #define SAI1_SAI_ADR (* ((volatile uint32_t *) (0x40015800 + 32)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI1_SAI_ADR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCR1: Configuration register 1
  #define SAI1_SAI_BCR1 (* ((volatile uint32_t *) (0x40015800 + 36)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI1_SAI_BCR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI1_SAI_BCR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI1_SAI_BCR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI1_SAI_BCR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI1_SAI_BCR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI1_SAI_BCR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI1_SAI_BCR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI1_SAI_BCR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI1_SAI_BCR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI1_SAI_BCR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI1_SAI_BCR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI1_SAI_BCR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI1_SAI_BCR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_BCR2: Configuration register 2
  #define SAI1_SAI_BCR2 (* ((volatile uint32_t *) (0x40015800 + 40)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI1_SAI_BCR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI1_SAI_BCR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI1_SAI_BCR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI1_SAI_BCR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI1_SAI_BCR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI1_SAI_BCR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI1_SAI_BCR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI1_SAI_BCR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI1_SAI_BFRCR (* ((volatile uint32_t *) (0x40015800 + 44)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI1_SAI_BFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI1_SAI_BFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI1_SAI_BFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI1_SAI_BFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI1_SAI_BFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI1_SAI_BSLOTR (* ((volatile uint32_t *) (0x40015800 + 48)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_BSLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_BSLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_BSLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI1_SAI_BSLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BIM: Interrupt mask register 2
  #define SAI1_SAI_BIM (* ((volatile uint32_t *) (0x40015800 + 52)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI1_SAI_BIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI1_SAI_BIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI1_SAI_BIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI1_SAI_BIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI1_SAI_BIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI1_SAI_BIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI1_SAI_BIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSR: Status register
  #define SAI1_SAI_BSR (* ((const volatile uint32_t *) (0x40015800 + 56)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_BSR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI1_SAI_BSR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_BSR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI1_SAI_BSR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_BSR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI1_SAI_BSR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI1_SAI_BSR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI1_SAI_BSR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCLRFR: Clear flag register
  #define SAI1_SAI_BCLRFR (* ((volatile uint32_t *) (0x40015800 + 60)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_BCLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_BCLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_BCLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_BCLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_BCLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI1_SAI_BCLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BDR: Data register
  #define SAI1_SAI_BDR (* ((volatile uint32_t *) (0x40015800 + 64)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI1_SAI_BDR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_PDMCR: PDM control register
  #define SAI1_SAI_PDMCR (* ((volatile uint32_t *) (0x40015800 + 68)))

  // Field PDMEN: PDM enable
    const uint32_t SAI1_SAI_PDMCR_PDMEN = 1U << 0 ;

  // Field MICNBR: Number of microphones
    inline uint32_t SAI1_SAI_PDMCR_MICNBR (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field CKEN1: Clock enable of bitstream clock number 1
    const uint32_t SAI1_SAI_PDMCR_CKEN1 = 1U << 8 ;

  // Field CKEN2: Clock enable of bitstream clock number 2
    const uint32_t SAI1_SAI_PDMCR_CKEN2 = 1U << 9 ;

  // Field CKEN3: Clock enable of bitstream clock number 3
    const uint32_t SAI1_SAI_PDMCR_CKEN3 = 1U << 10 ;

  // Field CKEN4: Clock enable of bitstream clock number 4
    const uint32_t SAI1_SAI_PDMCR_CKEN4 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register SAI_PDMDLY: PDM delay register
  #define SAI1_SAI_PDMDLY (* ((volatile uint32_t *) (0x40015800 + 72)))

  // Field DLYM1L: Delay line adjust for first microphone of pair 1
    inline uint32_t SAI1_SAI_PDMDLY_DLYM1L (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field DLYM1R: Delay line adjust for second microphone of pair 1
    inline uint32_t SAI1_SAI_PDMDLY_DLYM1R (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DLYM2L: Delay line for first microphone of pair 2
    inline uint32_t SAI1_SAI_PDMDLY_DLYM2L (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DLYM2R: Delay line for second microphone of pair 2
    inline uint32_t SAI1_SAI_PDMDLY_DLYM2R (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DLYM3L: Delay line for first microphone of pair 3
    inline uint32_t SAI1_SAI_PDMDLY_DLYM3L (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field DLYM3R: Delay line for second microphone of pair 3
    inline uint32_t SAI1_SAI_PDMDLY_DLYM3R (const uint32_t inValue) {return (inValue & 0x7U) << 20 ; }

  // Field DLYM4L: Delay line for first microphone of pair 4
    inline uint32_t SAI1_SAI_PDMDLY_DLYM4L (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field DLYM4R: Delay line for second microphone of pair 4
    inline uint32_t SAI1_SAI_PDMDLY_DLYM4R (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral SAI2
//------------------------------------------------------------------------------

//---  Register SAI_GCR: Global configuration register
  #define SAI2_SAI_GCR (* ((volatile uint32_t *) (0x40015C00 + 0)))

  // Field SYNCOUT: Synchronization outputs These bits are set and cleared by software.
    inline uint32_t SAI2_SAI_GCR_SYNCOUT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SYNCIN: Synchronization inputs
    inline uint32_t SAI2_SAI_GCR_SYNCIN (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACR1: Configuration register 1
  #define SAI2_SAI_ACR1 (* ((volatile uint32_t *) (0x40015C00 + 4)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI2_SAI_ACR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI2_SAI_ACR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI2_SAI_ACR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI2_SAI_ACR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI2_SAI_ACR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI2_SAI_ACR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI2_SAI_ACR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI2_SAI_ACR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI2_SAI_ACR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI2_SAI_ACR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI2_SAI_ACR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI2_SAI_ACR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI2_SAI_ACR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_ACR2: Configuration register 2
  #define SAI2_SAI_ACR2 (* ((volatile uint32_t *) (0x40015C00 + 8)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI2_SAI_ACR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI2_SAI_ACR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI2_SAI_ACR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI2_SAI_ACR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI2_SAI_ACR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI2_SAI_ACR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI2_SAI_ACR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI2_SAI_ACR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI2_SAI_AFRCR (* ((volatile uint32_t *) (0x40015C00 + 12)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI2_SAI_AFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI2_SAI_AFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI2_SAI_AFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI2_SAI_AFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI2_SAI_AFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI2_SAI_ASLOTR (* ((volatile uint32_t *) (0x40015C00 + 16)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_ASLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_ASLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_ASLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_ASLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AIM: Interrupt mask register 2
  #define SAI2_SAI_AIM (* ((volatile uint32_t *) (0x40015C00 + 20)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI2_SAI_AIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI2_SAI_AIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI2_SAI_AIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI2_SAI_AIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI2_SAI_AIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI2_SAI_AIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI2_SAI_AIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASR: Status register
  #define SAI2_SAI_ASR (* ((const volatile uint32_t *) (0x40015C00 + 24)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_ASR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI2_SAI_ASR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_ASR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI2_SAI_ASR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_ASR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_ASR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI2_SAI_ASR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI2_SAI_ASR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACLRFR: Clear flag register
  #define SAI2_SAI_ACLRFR (* ((volatile uint32_t *) (0x40015C00 + 28)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_ACLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_ACLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_ACLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_ACLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_ACLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_ACLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ADR: Data register
  #define SAI2_SAI_ADR (* ((volatile uint32_t *) (0x40015C00 + 32)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI2_SAI_ADR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCR1: Configuration register 1
  #define SAI2_SAI_BCR1 (* ((volatile uint32_t *) (0x40015C00 + 36)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI2_SAI_BCR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI2_SAI_BCR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI2_SAI_BCR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI2_SAI_BCR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI2_SAI_BCR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI2_SAI_BCR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI2_SAI_BCR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI2_SAI_BCR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI2_SAI_BCR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI2_SAI_BCR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI2_SAI_BCR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI2_SAI_BCR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI2_SAI_BCR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_BCR2: Configuration register 2
  #define SAI2_SAI_BCR2 (* ((volatile uint32_t *) (0x40015C00 + 40)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI2_SAI_BCR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI2_SAI_BCR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI2_SAI_BCR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI2_SAI_BCR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI2_SAI_BCR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI2_SAI_BCR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI2_SAI_BCR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI2_SAI_BCR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI2_SAI_BFRCR (* ((volatile uint32_t *) (0x40015C00 + 44)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI2_SAI_BFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI2_SAI_BFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI2_SAI_BFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI2_SAI_BFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI2_SAI_BFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI2_SAI_BSLOTR (* ((volatile uint32_t *) (0x40015C00 + 48)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_BSLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_BSLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_BSLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI2_SAI_BSLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BIM: Interrupt mask register 2
  #define SAI2_SAI_BIM (* ((volatile uint32_t *) (0x40015C00 + 52)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI2_SAI_BIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI2_SAI_BIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI2_SAI_BIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI2_SAI_BIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI2_SAI_BIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI2_SAI_BIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI2_SAI_BIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSR: Status register
  #define SAI2_SAI_BSR (* ((const volatile uint32_t *) (0x40015C00 + 56)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_BSR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI2_SAI_BSR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_BSR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI2_SAI_BSR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_BSR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI2_SAI_BSR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI2_SAI_BSR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI2_SAI_BSR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCLRFR: Clear flag register
  #define SAI2_SAI_BCLRFR (* ((volatile uint32_t *) (0x40015C00 + 60)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_BCLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_BCLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_BCLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_BCLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_BCLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI2_SAI_BCLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BDR: Data register
  #define SAI2_SAI_BDR (* ((volatile uint32_t *) (0x40015C00 + 64)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI2_SAI_BDR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_PDMCR: PDM control register
  #define SAI2_SAI_PDMCR (* ((volatile uint32_t *) (0x40015C00 + 68)))

  // Field PDMEN: PDM enable
    const uint32_t SAI2_SAI_PDMCR_PDMEN = 1U << 0 ;

  // Field MICNBR: Number of microphones
    inline uint32_t SAI2_SAI_PDMCR_MICNBR (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field CKEN1: Clock enable of bitstream clock number 1
    const uint32_t SAI2_SAI_PDMCR_CKEN1 = 1U << 8 ;

  // Field CKEN2: Clock enable of bitstream clock number 2
    const uint32_t SAI2_SAI_PDMCR_CKEN2 = 1U << 9 ;

  // Field CKEN3: Clock enable of bitstream clock number 3
    const uint32_t SAI2_SAI_PDMCR_CKEN3 = 1U << 10 ;

  // Field CKEN4: Clock enable of bitstream clock number 4
    const uint32_t SAI2_SAI_PDMCR_CKEN4 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register SAI_PDMDLY: PDM delay register
  #define SAI2_SAI_PDMDLY (* ((volatile uint32_t *) (0x40015C00 + 72)))

  // Field DLYM1L: Delay line adjust for first microphone of pair 1
    inline uint32_t SAI2_SAI_PDMDLY_DLYM1L (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field DLYM1R: Delay line adjust for second microphone of pair 1
    inline uint32_t SAI2_SAI_PDMDLY_DLYM1R (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DLYM2L: Delay line for first microphone of pair 2
    inline uint32_t SAI2_SAI_PDMDLY_DLYM2L (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DLYM2R: Delay line for second microphone of pair 2
    inline uint32_t SAI2_SAI_PDMDLY_DLYM2R (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DLYM3L: Delay line for first microphone of pair 3
    inline uint32_t SAI2_SAI_PDMDLY_DLYM3L (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field DLYM3R: Delay line for second microphone of pair 3
    inline uint32_t SAI2_SAI_PDMDLY_DLYM3R (const uint32_t inValue) {return (inValue & 0x7U) << 20 ; }

  // Field DLYM4L: Delay line for first microphone of pair 4
    inline uint32_t SAI2_SAI_PDMDLY_DLYM4L (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field DLYM4R: Delay line for second microphone of pair 4
    inline uint32_t SAI2_SAI_PDMDLY_DLYM4R (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral SAI3
//------------------------------------------------------------------------------

//---  Register SAI_GCR: Global configuration register
  #define SAI3_SAI_GCR (* ((volatile uint32_t *) (0x40016000 + 0)))

  // Field SYNCOUT: Synchronization outputs These bits are set and cleared by software.
    inline uint32_t SAI3_SAI_GCR_SYNCOUT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SYNCIN: Synchronization inputs
    inline uint32_t SAI3_SAI_GCR_SYNCIN (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACR1: Configuration register 1
  #define SAI3_SAI_ACR1 (* ((volatile uint32_t *) (0x40016000 + 4)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI3_SAI_ACR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI3_SAI_ACR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI3_SAI_ACR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI3_SAI_ACR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI3_SAI_ACR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI3_SAI_ACR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI3_SAI_ACR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI3_SAI_ACR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI3_SAI_ACR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI3_SAI_ACR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI3_SAI_ACR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI3_SAI_ACR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI3_SAI_ACR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_ACR2: Configuration register 2
  #define SAI3_SAI_ACR2 (* ((volatile uint32_t *) (0x40016000 + 8)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI3_SAI_ACR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI3_SAI_ACR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI3_SAI_ACR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI3_SAI_ACR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI3_SAI_ACR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI3_SAI_ACR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI3_SAI_ACR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI3_SAI_ACR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI3_SAI_AFRCR (* ((volatile uint32_t *) (0x40016000 + 12)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI3_SAI_AFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI3_SAI_AFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI3_SAI_AFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI3_SAI_AFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI3_SAI_AFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI3_SAI_ASLOTR (* ((volatile uint32_t *) (0x40016000 + 16)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_ASLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_ASLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_ASLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_ASLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AIM: Interrupt mask register 2
  #define SAI3_SAI_AIM (* ((volatile uint32_t *) (0x40016000 + 20)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI3_SAI_AIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI3_SAI_AIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI3_SAI_AIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI3_SAI_AIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI3_SAI_AIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI3_SAI_AIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI3_SAI_AIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASR: Status register
  #define SAI3_SAI_ASR (* ((const volatile uint32_t *) (0x40016000 + 24)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_ASR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI3_SAI_ASR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_ASR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI3_SAI_ASR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_ASR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_ASR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI3_SAI_ASR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI3_SAI_ASR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACLRFR: Clear flag register
  #define SAI3_SAI_ACLRFR (* ((volatile uint32_t *) (0x40016000 + 28)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_ACLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_ACLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_ACLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_ACLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_ACLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_ACLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ADR: Data register
  #define SAI3_SAI_ADR (* ((volatile uint32_t *) (0x40016000 + 32)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI3_SAI_ADR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCR1: Configuration register 1
  #define SAI3_SAI_BCR1 (* ((volatile uint32_t *) (0x40016000 + 36)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI3_SAI_BCR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI3_SAI_BCR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI3_SAI_BCR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI3_SAI_BCR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI3_SAI_BCR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI3_SAI_BCR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI3_SAI_BCR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI3_SAI_BCR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI3_SAI_BCR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI3_SAI_BCR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI3_SAI_BCR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI3_SAI_BCR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI3_SAI_BCR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_BCR2: Configuration register 2
  #define SAI3_SAI_BCR2 (* ((volatile uint32_t *) (0x40016000 + 40)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI3_SAI_BCR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI3_SAI_BCR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI3_SAI_BCR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI3_SAI_BCR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI3_SAI_BCR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI3_SAI_BCR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI3_SAI_BCR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI3_SAI_BCR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI3_SAI_BFRCR (* ((volatile uint32_t *) (0x40016000 + 44)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI3_SAI_BFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI3_SAI_BFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI3_SAI_BFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI3_SAI_BFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI3_SAI_BFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI3_SAI_BSLOTR (* ((volatile uint32_t *) (0x40016000 + 48)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_BSLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_BSLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_BSLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI3_SAI_BSLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BIM: Interrupt mask register 2
  #define SAI3_SAI_BIM (* ((volatile uint32_t *) (0x40016000 + 52)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI3_SAI_BIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI3_SAI_BIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI3_SAI_BIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI3_SAI_BIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI3_SAI_BIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI3_SAI_BIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI3_SAI_BIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSR: Status register
  #define SAI3_SAI_BSR (* ((const volatile uint32_t *) (0x40016000 + 56)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_BSR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI3_SAI_BSR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_BSR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI3_SAI_BSR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_BSR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI3_SAI_BSR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI3_SAI_BSR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI3_SAI_BSR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCLRFR: Clear flag register
  #define SAI3_SAI_BCLRFR (* ((volatile uint32_t *) (0x40016000 + 60)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_BCLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_BCLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_BCLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_BCLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_BCLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI3_SAI_BCLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BDR: Data register
  #define SAI3_SAI_BDR (* ((volatile uint32_t *) (0x40016000 + 64)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI3_SAI_BDR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_PDMCR: PDM control register
  #define SAI3_SAI_PDMCR (* ((volatile uint32_t *) (0x40016000 + 68)))

  // Field PDMEN: PDM enable
    const uint32_t SAI3_SAI_PDMCR_PDMEN = 1U << 0 ;

  // Field MICNBR: Number of microphones
    inline uint32_t SAI3_SAI_PDMCR_MICNBR (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field CKEN1: Clock enable of bitstream clock number 1
    const uint32_t SAI3_SAI_PDMCR_CKEN1 = 1U << 8 ;

  // Field CKEN2: Clock enable of bitstream clock number 2
    const uint32_t SAI3_SAI_PDMCR_CKEN2 = 1U << 9 ;

  // Field CKEN3: Clock enable of bitstream clock number 3
    const uint32_t SAI3_SAI_PDMCR_CKEN3 = 1U << 10 ;

  // Field CKEN4: Clock enable of bitstream clock number 4
    const uint32_t SAI3_SAI_PDMCR_CKEN4 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register SAI_PDMDLY: PDM delay register
  #define SAI3_SAI_PDMDLY (* ((volatile uint32_t *) (0x40016000 + 72)))

  // Field DLYM1L: Delay line adjust for first microphone of pair 1
    inline uint32_t SAI3_SAI_PDMDLY_DLYM1L (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field DLYM1R: Delay line adjust for second microphone of pair 1
    inline uint32_t SAI3_SAI_PDMDLY_DLYM1R (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DLYM2L: Delay line for first microphone of pair 2
    inline uint32_t SAI3_SAI_PDMDLY_DLYM2L (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DLYM2R: Delay line for second microphone of pair 2
    inline uint32_t SAI3_SAI_PDMDLY_DLYM2R (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DLYM3L: Delay line for first microphone of pair 3
    inline uint32_t SAI3_SAI_PDMDLY_DLYM3L (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field DLYM3R: Delay line for second microphone of pair 3
    inline uint32_t SAI3_SAI_PDMDLY_DLYM3R (const uint32_t inValue) {return (inValue & 0x7U) << 20 ; }

  // Field DLYM4L: Delay line for first microphone of pair 4
    inline uint32_t SAI3_SAI_PDMDLY_DLYM4L (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field DLYM4R: Delay line for second microphone of pair 4
    inline uint32_t SAI3_SAI_PDMDLY_DLYM4R (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral SAI4: SAI
//------------------------------------------------------------------------------

//---  Register SAI_GCR: Global configuration register
  #define SAI4_SAI_GCR (* ((volatile uint32_t *) (0x58005400 + 0)))

  // Field SYNCOUT: Synchronization outputs These bits are set and cleared by software.
    inline uint32_t SAI4_SAI_GCR_SYNCOUT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field SYNCIN: Synchronization inputs
    inline uint32_t SAI4_SAI_GCR_SYNCIN (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACR1: Configuration register 1
  #define SAI4_SAI_ACR1 (* ((volatile uint32_t *) (0x58005400 + 4)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI4_SAI_ACR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI4_SAI_ACR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI4_SAI_ACR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI4_SAI_ACR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI4_SAI_ACR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI4_SAI_ACR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI4_SAI_ACR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI4_SAI_ACR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI4_SAI_ACR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI4_SAI_ACR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI4_SAI_ACR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI4_SAI_ACR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI4_SAI_ACR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_ACR2: Configuration register 2
  #define SAI4_SAI_ACR2 (* ((volatile uint32_t *) (0x58005400 + 8)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI4_SAI_ACR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI4_SAI_ACR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI4_SAI_ACR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI4_SAI_ACR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI4_SAI_ACR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI4_SAI_ACR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI4_SAI_ACR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI4_SAI_ACR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI4_SAI_AFRCR (* ((volatile uint32_t *) (0x58005400 + 12)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI4_SAI_AFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI4_SAI_AFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI4_SAI_AFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI4_SAI_AFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI4_SAI_AFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI4_SAI_ASLOTR (* ((volatile uint32_t *) (0x58005400 + 16)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_ASLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_ASLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_ASLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_ASLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_AIM: Interrupt mask register 2
  #define SAI4_SAI_AIM (* ((volatile uint32_t *) (0x58005400 + 20)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI4_SAI_AIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI4_SAI_AIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI4_SAI_AIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI4_SAI_AIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI4_SAI_AIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI4_SAI_AIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI4_SAI_AIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ASR: Status register
  #define SAI4_SAI_ASR (* ((const volatile uint32_t *) (0x58005400 + 24)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_ASR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI4_SAI_ASR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_ASR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI4_SAI_ASR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_ASR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_ASR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI4_SAI_ASR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI4_SAI_ASR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_ACLRFR: Clear flag register
  #define SAI4_SAI_ACLRFR (* ((volatile uint32_t *) (0x58005400 + 28)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_ACLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_ACLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_ACLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_ACLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_ACLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_ACLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_ADR: Data register
  #define SAI4_SAI_ADR (* ((volatile uint32_t *) (0x58005400 + 32)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI4_SAI_ADR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCR1: Configuration register 1
  #define SAI4_SAI_BCR1 (* ((volatile uint32_t *) (0x58005400 + 36)))

  // Field MODE: SAIx audio block mode immediately
    inline uint32_t SAI4_SAI_BCR1_MODE (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field PRTCFG: Protocol configuration. These bits are set and cleared by software. These bits have to be configured when the audio block is disabled.
    inline uint32_t SAI4_SAI_BCR1_PRTCFG (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DS: Data size. These bits are set and cleared by software. These bits are ignored when the SPDIF protocols are selected (bit PRTCFG[1:0]), because the frame and the data size are fixed in such case. When the companding mode is selected through COMP[1:0] bits, DS[1:0] are ignored since the data size is fixed to 8 bits by the algorithm. These bits must be configured when the audio block is disabled.
    inline uint32_t SAI4_SAI_BCR1_DS (const uint32_t inValue) {return (inValue & 0x7U) << 5 ; }

  // Field LSBFIRST: Least significant bit first. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in AC97 audio protocol since AC97 data are always transferred with the MSB first. This bit has no meaning in SPDIF audio protocol since in SPDIF data are always transferred with LSB first.
    const uint32_t SAI4_SAI_BCR1_LSBFIRST = 1U << 8 ;

  // Field CKSTR: Clock strobing edge. This bit is set and cleared by software. It must be configured when the audio block is disabled. This bit has no meaning in SPDIF audio protocol.
    const uint32_t SAI4_SAI_BCR1_CKSTR = 1U << 9 ;

  // Field SYNCEN: Synchronization enable. These bits are set and cleared by software. They must be configured when the audio sub-block is disabled. Note: The audio sub-block should be configured as asynchronous when SPDIF mode is enabled.
    inline uint32_t SAI4_SAI_BCR1_SYNCEN (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field MONO: Mono mode. This bit is set and cleared by software. It is meaningful only when the number of slots is equal to 2. When the mono mode is selected, slot 0 data are duplicated on slot 1 when the audio block operates as a transmitter. In reception mode, the slot1 is discarded and only the data received from slot 0 are stored. Refer to Section: Mono/stereo mode for more details.
    const uint32_t SAI4_SAI_BCR1_MONO = 1U << 12 ;

  // Field OUTDRIV: Output drive. This bit is set and cleared by software. Note: This bit has to be set before enabling the audio block and after the audio block configuration.
    const uint32_t SAI4_SAI_BCR1_OUTDRIV = 1U << 13 ;

  // Field SAIXEN: Audio block enable where x is A or B. This bit is set by software. To switch off the audio block, the application software must program this bit to 0 and poll the bit till it reads back 0, meaning that the block is completely disabled. Before setting this bit to 1, check that it is set to 0, otherwise the enable command will not be taken into account. This bit allows to control the state of SAIx audio block. If it is disabled when an audio frame transfer is ongoing, the ongoing transfer completes and the cell is fully disabled at the end of this audio frame transfer. Note: When SAIx block is configured in master mode, the clock must be present on the input of SAIx before setting SAIXEN bit.
    const uint32_t SAI4_SAI_BCR1_SAIXEN = 1U << 16 ;

  // Field DMAEN: DMA enable. This bit is set and cleared by software. Note: Since the audio block defaults to operate as a transmitter after reset, the MODE[1:0] bits must be configured before setting DMAEN to avoid a DMA request in receiver mode.
    const uint32_t SAI4_SAI_BCR1_DMAEN = 1U << 17 ;

  // Field NOMCK: No divider
    const uint32_t SAI4_SAI_BCR1_NOMCK = 1U << 19 ;

  // Field MCKDIV: Master clock divider. These bits are set and cleared by software. These bits are meaningless when the audio block operates in slave mode. They have to be configured when the audio block is disabled. Others: the master clock frequency is calculated accordingly to the following formula:
    inline uint32_t SAI4_SAI_BCR1_MCKDIV (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OSR: Oversampling ratio for master clock
    const uint32_t SAI4_SAI_BCR1_OSR = 1U << 26 ;

//------------------------------------------------------------------------------

//---  Register SAI_BCR2: Configuration register 2
  #define SAI4_SAI_BCR2 (* ((volatile uint32_t *) (0x58005400 + 40)))

  // Field FTH: FIFO threshold. This bit is set and cleared by software.
    inline uint32_t SAI4_SAI_BCR2_FTH (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field FFLUSH: FIFO flush. This bit is set by software. It is always read as 0. This bit should be configured when the SAI is disabled.
    const uint32_t SAI4_SAI_BCR2_FFLUSH = 1U << 3 ;

  // Field TRIS: Tristate management on data line. This bit is set and cleared by software. It is meaningful only if the audio block is configured as a transmitter. This bit is not used when the audio block is configured in SPDIF mode. It should be configured when SAI is disabled. Refer to Section: Output data line management on an inactive slot for more details.
    const uint32_t SAI4_SAI_BCR2_TRIS = 1U << 4 ;

  // Field MUTE: Mute. This bit is set and cleared by software. It is meaningful only when the audio block operates as a transmitter. The MUTE value is linked to value of MUTEVAL if the number of slots is lower or equal to 2, or equal to 0 if it is greater than 2. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI4_SAI_BCR2_MUTE = 1U << 5 ;

  // Field MUTEVAL: Mute value. This bit is set and cleared by software.It must be written before enabling the audio block: SAIXEN. This bit is meaningful only when the audio block operates as a transmitter, the number of slots is lower or equal to 2 and the MUTE bit is set. If more slots are declared, the bit value sent during the transmission in mute mode is equal to 0, whatever the value of MUTEVAL. if the number of slot is lower or equal to 2 and MUTEVAL = 1, the MUTE value transmitted for each slot is the one sent during the previous frame. Refer to Section: Mute mode for more details. Note: This bit is meaningless and should not be used for SPDIF audio blocks.
    const uint32_t SAI4_SAI_BCR2_MUTEVAL = 1U << 6 ;

  // Field MUTECNT: Mute counter. These bits are set and cleared by software. They are used only in reception mode. The value set in these bits is compared to the number of consecutive mute frames detected in reception. When the number of mute frames is equal to this value, the flag MUTEDET will be set and an interrupt will be generated if bit MUTEDETIE is set. Refer to Section: Mute mode for more details.
    inline uint32_t SAI4_SAI_BCR2_MUTECNT (const uint32_t inValue) {return (inValue & 0x3FU) << 7 ; }

  // Field CPL: Complement bit. This bit is set and cleared by software. It defines the type of complement to be used for companding mode Note: This bit has effect only when the companding mode is -Law algorithm or A-Law algorithm.
    const uint32_t SAI4_SAI_BCR2_CPL = 1U << 13 ;

  // Field COMP: Companding mode. These bits are set and cleared by software. The -Law and the A-Law log are a part of the CCITT G.711 recommendation, the type of complement that will be used depends on CPL bit. The data expansion or data compression are determined by the state of bit MODE[0]. The data compression is applied if the audio block is configured as a transmitter. The data expansion is automatically applied when the audio block is configured as a receiver. Refer to Section: Companding mode for more details. Note: Companding mode is applicable only when TDM is selected.
    inline uint32_t SAI4_SAI_BCR2_COMP (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BFRCR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI4_SAI_BFRCR (* ((volatile uint32_t *) (0x58005400 + 44)))

  // Field FRL: Frame length. These bits are set and cleared by software. They define the audio frame length expressed in number of SCK clock cycles: the number of bits in the frame is equal to FRL[7:0] + 1. The minimum number of bits to transfer in an audio frame must be equal to 8, otherwise the audio block will behaves in an unexpected way. This is the case when the data size is 8 bits and only one slot 0 is defined in NBSLOT[4:0] of SAI_xSLOTR register (NBSLOT[3:0] = 0000). In master mode, if the master clock (available on MCLK_x pin) is used, the frame length should be aligned with a number equal to a power of 2, ranging from 8 to 256. When the master clock is not used (NODIV = 1), it is recommended to program the frame length to an value ranging from 8 to 256. These bits are meaningless and are not used in AC97 or SPDIF audio block configuration.
    inline uint32_t SAI4_SAI_BFRCR_FRL (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field FSALL: Frame synchronization active level length. These bits are set and cleared by software. They specify the length in number of bit clock (SCK) + 1 (FSALL[6:0] + 1) of the active level of the FS signal in the audio frame These bits are meaningless and are not used in AC97 or SPDIF audio block configuration. They must be configured when the audio block is disabled.
    inline uint32_t SAI4_SAI_BFRCR_FSALL (const uint32_t inValue) {return (inValue & 0x7FU) << 8 ; }

  // Field FSDEF: Frame synchronization definition. This bit is set and cleared by software. When the bit is set, the number of slots defined in the SAI_xSLOTR register has to be even. It means that half of this number of slots will be dedicated to the left channel and the other slots for the right channel (e.g: this bit has to be set for I2S or MSB/LSB-justified protocols...). This bit is meaningless and is not used in AC97 or SPDIF audio block configuration. It must be configured when the audio block is disabled.
    const uint32_t SAI4_SAI_BFRCR_FSDEF = 1U << 16 ;

  // Field FSPOL: Frame synchronization polarity. This bit is set and cleared by software. It is used to configure the level of the start of frame on the FS signal. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI4_SAI_BFRCR_FSPOL = 1U << 17 ;

  // Field FSOFF: Frame synchronization offset. This bit is set and cleared by software. It is meaningless and is not used in AC97 or SPDIF audio block configuration. This bit must be configured when the audio block is disabled.
    const uint32_t SAI4_SAI_BFRCR_FSOFF = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSLOTR: This register has no meaning in AC97 and SPDIF audio protocol
  #define SAI4_SAI_BSLOTR (* ((volatile uint32_t *) (0x58005400 + 48)))

  // Field FBOFF: First bit offset These bits are set and cleared by software. The value set in this bitfield defines the position of the first data transfer bit in the slot. It represents an offset value. In transmission mode, the bits outside the data field are forced to 0. In reception mode, the extra received bits are discarded. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_BSLOTR_FBOFF (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

  // Field SLOTSZ: Slot size This bits is set and cleared by software. The slot size must be higher or equal to the data size. If this condition is not respected, the behavior of the SAI will be undetermined. Refer to Section: Output data line management on an inactive slot for information on how to drive SD line. These bits must be set when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_BSLOTR_SLOTSZ (const uint32_t inValue) {return (inValue & 0x3U) << 6 ; }

  // Field NBSLOT: Number of slots in an audio frame. These bits are set and cleared by software. The value set in this bitfield represents the number of slots + 1 in the audio frame (including the number of inactive slots). The maximum number of slots is 16. The number of slots should be even if FSDEF bit in the SAI_xFRCR register is set. The number of slots must be configured when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_BSLOTR_NBSLOT (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field SLOTEN: Slot enable. These bits are set and cleared by software. Each SLOTEN bit corresponds to a slot position from 0 to 15 (maximum 16 slots). The slot must be enabled when the audio block is disabled. They are ignored in AC97 or SPDIF mode.
    inline uint32_t SAI4_SAI_BSLOTR_SLOTEN (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BIM: Interrupt mask register 2
  #define SAI4_SAI_BIM (* ((volatile uint32_t *) (0x58005400 + 52)))

  // Field OVRUDRIE: Overrun/underrun interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the OVRUDR bit in the SAI_xSR register is set.
    const uint32_t SAI4_SAI_BIM_OVRUDRIE = 1U << 0 ;

  // Field MUTEDETIE: Mute detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the MUTEDET bit in the SAI_xSR register is set. This bit has a meaning only if the audio block is configured in receiver mode.
    const uint32_t SAI4_SAI_BIM_MUTEDETIE = 1U << 1 ;

  // Field WCKCFGIE: Wrong clock configuration interrupt enable. This bit is set and cleared by software. This bit is taken into account only if the audio block is configured as a master (MODE[1] = 0) and NODIV = 0. It generates an interrupt if the WCKCFG flag in the SAI_xSR register is set. Note: This bit is used only in TDM mode and is meaningless in other modes.
    const uint32_t SAI4_SAI_BIM_WCKCFGIE = 1U << 2 ;

  // Field FREQIE: FIFO request interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt is generated if the FREQ bit in the SAI_xSR register is set. Since the audio block defaults to operate as a transmitter after reset, the MODE bit must be configured before setting FREQIE to avoid a parasitic interruption in receiver mode,
    const uint32_t SAI4_SAI_BIM_FREQIE = 1U << 3 ;

  // Field CNRDYIE: Codec not ready interrupt enable (AC97). This bit is set and cleared by software. When the interrupt is enabled, the audio block detects in the slot 0 (tag0) of the AC97 frame if the Codec connected to this line is ready or not. If it is not ready, the CNRDY flag in the SAI_xSR register is set and an interruption i generated. This bit has a meaning only if the AC97 mode is selected through PRTCFG[1:0] bits and the audio block is operates as a receiver.
    const uint32_t SAI4_SAI_BIM_CNRDYIE = 1U << 4 ;

  // Field AFSDETIE: Anticipated frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the AFSDET bit in the SAI_xSR register is set. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI4_SAI_BIM_AFSDETIE = 1U << 5 ;

  // Field LFSDETIE: Late frame synchronization detection interrupt enable. This bit is set and cleared by software. When this bit is set, an interrupt will be generated if the LFSDET bit is set in the SAI_xSR register. This bit is meaningless in AC97, SPDIF mode or when the audio block operates as a master.
    const uint32_t SAI4_SAI_BIM_LFSDETIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BSR: Status register
  #define SAI4_SAI_BSR (* ((const volatile uint32_t *) (0x58005400 + 56)))

  // Field OVRUDR: Overrun / underrun. This bit is read only. The overrun and underrun conditions can occur only when the audio block is configured as a receiver and a transmitter, respectively. It can generate an interrupt if OVRUDRIE bit is set in SAI_xIM register. This flag is cleared when the software sets COVRUDR bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_BSR_OVRUDR = 1U << 0 ;

  // Field MUTEDET: Mute detection. This bit is read only. This flag is set if consecutive 0 values are received in each slot of a given audio frame and for a consecutive number of audio frames (set in the MUTECNT bit in the SAI_xCR2 register). It can generate an interrupt if MUTEDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets bit CMUTEDET in the SAI_xCLRFR register.
    const uint32_t SAI4_SAI_BSR_MUTEDET = 1U << 1 ;

  // Field WCKCFG: Wrong clock configuration flag. This bit is read only. This bit is used only when the audio block operates in master mode (MODE[1] = 0) and NODIV = 0. It can generate an interrupt if WCKCFGIE bit is set in SAI_xIM register. This flag is cleared when the software sets CWCKCFG bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_BSR_WCKCFG = 1U << 2 ;

  // Field FREQ: FIFO request. This bit is read only. The request depends on the audio block configuration: If the block is configured in transmission mode, the FIFO request is related to a write request operation in the SAI_xDR. If the block configured in reception, the FIFO request related to a read request operation from the SAI_xDR. This flag can generate an interrupt if FREQIE bit is set in SAI_xIM register.
    const uint32_t SAI4_SAI_BSR_FREQ = 1U << 3 ;

  // Field CNRDY: Codec not ready. This bit is read only. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register and configured in receiver mode. It can generate an interrupt if CNRDYIE bit is set in SAI_xIM register. This flag is cleared when the software sets CCNRDY bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_BSR_CNRDY = 1U << 4 ;

  // Field AFSDET: Anticipated frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97or SPDIF mode. It can generate an interrupt if AFSDETIE bit is set in SAI_xIM register. This flag is cleared when the software sets CAFSDET bit in SAI_xCLRFR register.
    const uint32_t SAI4_SAI_BSR_AFSDET = 1U << 5 ;

  // Field LFSDET: Late frame synchronization detection. This bit is read only. This flag can be set only if the audio block is configured in slave mode. It is not used in AC97 or SPDIF mode. It can generate an interrupt if LFSDETIE bit is set in the SAI_xIM register. This flag is cleared when the software sets bit CLFSDET in SAI_xCLRFR register
    const uint32_t SAI4_SAI_BSR_LFSDET = 1U << 6 ;

  // Field FLVL: FIFO level threshold. This bit is read only. The FIFO level threshold flag is managed only by hardware and its setting depends on SAI block configuration (transmitter or receiver mode). If the SAI block is configured as transmitter: If SAI block is configured as receiver:
    inline uint32_t SAI4_SAI_BSR_FLVL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SAI_BCLRFR: Clear flag register
  #define SAI4_SAI_BCLRFR (* ((volatile uint32_t *) (0x58005400 + 60)))

  // Field COVRUDR: Clear overrun / underrun. This bit is write only. Programming this bit to 1 clears the OVRUDR flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_BCLRFR_COVRUDR = 1U << 0 ;

  // Field CMUTEDET: Mute detection flag. This bit is write only. Programming this bit to 1 clears the MUTEDET flag in the SAI_xSR register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_BCLRFR_CMUTEDET = 1U << 1 ;

  // Field CWCKCFG: Clear wrong clock configuration flag. This bit is write only. Programming this bit to 1 clears the WCKCFG flag in the SAI_xSR register. This bit is used only when the audio block is set as master (MODE[1] = 0) and NODIV = 0 in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_BCLRFR_CWCKCFG = 1U << 2 ;

  // Field CCNRDY: Clear Codec not ready flag. This bit is write only. Programming this bit to 1 clears the CNRDY flag in the SAI_xSR register. This bit is used only when the AC97 audio protocol is selected in the SAI_xCR1 register. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_BCLRFR_CCNRDY = 1U << 4 ;

  // Field CAFSDET: Clear anticipated frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the AFSDET flag in the SAI_xSR register. It is not used in AC97or SPDIF mode. Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_BCLRFR_CAFSDET = 1U << 5 ;

  // Field CLFSDET: Clear late frame synchronization detection flag. This bit is write only. Programming this bit to 1 clears the LFSDET flag in the SAI_xSR register. This bit is not used in AC97or SPDIF mode Reading this bit always returns the value 0.
    const uint32_t SAI4_SAI_BCLRFR_CLFSDET = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SAI_BDR: Data register
  #define SAI4_SAI_BDR (* ((volatile uint32_t *) (0x58005400 + 64)))

  // Field DATA: Data A write to this register loads the FIFO provided the FIFO is not full. A read from this register empties the FIFO if the FIFO is not empty.
    inline uint32_t SAI4_SAI_BDR_DATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SAI_PDMCR: PDM control register
  #define SAI4_SAI_PDMCR (* ((volatile uint32_t *) (0x58005400 + 68)))

  // Field PDMEN: PDM enable
    const uint32_t SAI4_SAI_PDMCR_PDMEN = 1U << 0 ;

  // Field MICNBR: Number of microphones
    inline uint32_t SAI4_SAI_PDMCR_MICNBR (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field CKEN1: Clock enable of bitstream clock number 1
    const uint32_t SAI4_SAI_PDMCR_CKEN1 = 1U << 8 ;

  // Field CKEN2: Clock enable of bitstream clock number 2
    const uint32_t SAI4_SAI_PDMCR_CKEN2 = 1U << 9 ;

  // Field CKEN3: Clock enable of bitstream clock number 3
    const uint32_t SAI4_SAI_PDMCR_CKEN3 = 1U << 10 ;

  // Field CKEN4: Clock enable of bitstream clock number 4
    const uint32_t SAI4_SAI_PDMCR_CKEN4 = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register SAI_PDMDLY: PDM delay register
  #define SAI4_SAI_PDMDLY (* ((volatile uint32_t *) (0x58005400 + 72)))

  // Field DLYM1L: Delay line adjust for first microphone of pair 1
    inline uint32_t SAI4_SAI_PDMDLY_DLYM1L (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field DLYM1R: Delay line adjust for second microphone of pair 1
    inline uint32_t SAI4_SAI_PDMDLY_DLYM1R (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field DLYM2L: Delay line for first microphone of pair 2
    inline uint32_t SAI4_SAI_PDMDLY_DLYM2L (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field DLYM2R: Delay line for second microphone of pair 2
    inline uint32_t SAI4_SAI_PDMDLY_DLYM2R (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field DLYM3L: Delay line for first microphone of pair 3
    inline uint32_t SAI4_SAI_PDMDLY_DLYM3L (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field DLYM3R: Delay line for second microphone of pair 3
    inline uint32_t SAI4_SAI_PDMDLY_DLYM3R (const uint32_t inValue) {return (inValue & 0x7U) << 20 ; }

  // Field DLYM4L: Delay line for first microphone of pair 4
    inline uint32_t SAI4_SAI_PDMDLY_DLYM4L (const uint32_t inValue) {return (inValue & 0x7U) << 24 ; }

  // Field DLYM4R: Delay line for second microphone of pair 4
    inline uint32_t SAI4_SAI_PDMDLY_DLYM4R (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

//------------------------------------------------------------------------------
// Peripheral SCB: System control block
//------------------------------------------------------------------------------

//---  Register CPUID: CPUID base register
  #define SCB_CPUID (* ((const volatile uint32_t *) (0xE000ED00 + 0)))

  // Field Revision: Revision number
    inline uint32_t SCB_CPUID_Revision (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field PartNo: Part number of the processor
    inline uint32_t SCB_CPUID_PartNo (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field Constant: Reads as 0xF
    inline uint32_t SCB_CPUID_Constant (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field Variant: Variant number
    inline uint32_t SCB_CPUID_Variant (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field Implementer: Implementer code
    inline uint32_t SCB_CPUID_Implementer (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register ICSR: Interrupt control and state register
  #define SCB_ICSR (* ((volatile uint32_t *) (0xE000ED00 + 4)))

  // Field VECTACTIVE: Active vector
    inline uint32_t SCB_ICSR_VECTACTIVE (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

  // Field RETTOBASE: Return to base level
    const uint32_t SCB_ICSR_RETTOBASE = 1U << 11 ;

  // Field VECTPENDING: Pending vector
    inline uint32_t SCB_ICSR_VECTPENDING (const uint32_t inValue) {return (inValue & 0x7FU) << 12 ; }

  // Field ISRPENDING: Interrupt pending flag
    const uint32_t SCB_ICSR_ISRPENDING = 1U << 22 ;

  // Field PENDSTCLR: SysTick exception clear-pending bit
    const uint32_t SCB_ICSR_PENDSTCLR = 1U << 25 ;

  // Field PENDSTSET: SysTick exception set-pending bit
    const uint32_t SCB_ICSR_PENDSTSET = 1U << 26 ;

  // Field PENDSVCLR: PendSV clear-pending bit
    const uint32_t SCB_ICSR_PENDSVCLR = 1U << 27 ;

  // Field PENDSVSET: PendSV set-pending bit
    const uint32_t SCB_ICSR_PENDSVSET = 1U << 28 ;

  // Field NMIPENDSET: NMI set-pending bit.
    const uint32_t SCB_ICSR_NMIPENDSET = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register VTOR: Vector table offset register
  #define SCB_VTOR (* ((volatile uint32_t *) (0xE000ED00 + 8)))

  // Field TBLOFF: Vector table base offset field
    inline uint32_t SCB_VTOR_TBLOFF (const uint32_t inValue) {return (inValue & 0x1FFFFFU) << 9 ; }

//------------------------------------------------------------------------------

//---  Register AIRCR: Application interrupt and reset control register
  #define SCB_AIRCR (* ((volatile uint32_t *) (0xE000ED00 + 12)))

  // Field VECTRESET: VECTRESET
    const uint32_t SCB_AIRCR_VECTRESET = 1U << 0 ;

  // Field VECTCLRACTIVE: VECTCLRACTIVE
    const uint32_t SCB_AIRCR_VECTCLRACTIVE = 1U << 1 ;

  // Field SYSRESETREQ: SYSRESETREQ
    const uint32_t SCB_AIRCR_SYSRESETREQ = 1U << 2 ;

  // Field PRIGROUP: PRIGROUP
    inline uint32_t SCB_AIRCR_PRIGROUP (const uint32_t inValue) {return (inValue & 0x7U) << 8 ; }

  // Field ENDIANESS: ENDIANESS
    const uint32_t SCB_AIRCR_ENDIANESS = 1U << 15 ;

  // Field VECTKEYSTAT: Register key
    inline uint32_t SCB_AIRCR_VECTKEYSTAT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SCR: System control register
  #define SCB_SCR (* ((volatile uint32_t *) (0xE000ED00 + 16)))

  // Field SLEEPONEXIT: SLEEPONEXIT
    const uint32_t SCB_SCR_SLEEPONEXIT = 1U << 1 ;

  // Field SLEEPDEEP: SLEEPDEEP
    const uint32_t SCB_SCR_SLEEPDEEP = 1U << 2 ;

  // Field SEVEONPEND: Send Event on Pending bit
    const uint32_t SCB_SCR_SEVEONPEND = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CCR: Configuration and control register
  #define SCB_CCR (* ((volatile uint32_t *) (0xE000ED00 + 20)))

  // Field NONBASETHRDENA: Configures how the processor enters Thread mode
    const uint32_t SCB_CCR_NONBASETHRDENA = 1U << 0 ;

  // Field USERSETMPEND: USERSETMPEND
    const uint32_t SCB_CCR_USERSETMPEND = 1U << 1 ;

  // Field UNALIGN__TRP: UNALIGN_ TRP
    const uint32_t SCB_CCR_UNALIGN__TRP = 1U << 3 ;

  // Field DIV_0_TRP: DIV_0_TRP
    const uint32_t SCB_CCR_DIV_0_TRP = 1U << 4 ;

  // Field BFHFNMIGN: BFHFNMIGN
    const uint32_t SCB_CCR_BFHFNMIGN = 1U << 8 ;

  // Field STKALIGN: STKALIGN
    const uint32_t SCB_CCR_STKALIGN = 1U << 9 ;

  // Field DC: DC
    const uint32_t SCB_CCR_DC = 1U << 16 ;

  // Field IC: IC
    const uint32_t SCB_CCR_IC = 1U << 17 ;

  // Field BP: BP
    const uint32_t SCB_CCR_BP = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register SHPR1: System handler priority registers
  #define SCB_SHPR1 (* ((volatile uint32_t *) (0xE000ED00 + 24)))

  // Field PRI_4: Priority of system handler 4
    inline uint32_t SCB_SHPR1_PRI_4 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field PRI_5: Priority of system handler 5
    inline uint32_t SCB_SHPR1_PRI_5 (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PRI_6: Priority of system handler 6
    inline uint32_t SCB_SHPR1_PRI_6 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register SHPR2: System handler priority registers
  #define SCB_SHPR2 (* ((volatile uint32_t *) (0xE000ED00 + 28)))

  // Field PRI_11: Priority of system handler 11
    inline uint32_t SCB_SHPR2_PRI_11 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register SHPR3: System handler priority registers
  #define SCB_SHPR3 (* ((volatile uint32_t *) (0xE000ED00 + 32)))

  // Field PRI_14: Priority of system handler 14
    inline uint32_t SCB_SHPR3_PRI_14 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field PRI_15: Priority of system handler 15
    inline uint32_t SCB_SHPR3_PRI_15 (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

//------------------------------------------------------------------------------

//---  Register SHCSR: System handler control and state register
  #define SCB_SHCSR (* ((volatile uint32_t *) (0xE000ED00 + 36)))

  // Field MEMFAULTACT: Memory management fault exception active bit
    const uint32_t SCB_SHCSR_MEMFAULTACT = 1U << 0 ;

  // Field BUSFAULTACT: Bus fault exception active bit
    const uint32_t SCB_SHCSR_BUSFAULTACT = 1U << 1 ;

  // Field USGFAULTACT: Usage fault exception active bit
    const uint32_t SCB_SHCSR_USGFAULTACT = 1U << 3 ;

  // Field SVCALLACT: SVC call active bit
    const uint32_t SCB_SHCSR_SVCALLACT = 1U << 7 ;

  // Field MONITORACT: Debug monitor active bit
    const uint32_t SCB_SHCSR_MONITORACT = 1U << 8 ;

  // Field PENDSVACT: PendSV exception active bit
    const uint32_t SCB_SHCSR_PENDSVACT = 1U << 10 ;

  // Field SYSTICKACT: SysTick exception active bit
    const uint32_t SCB_SHCSR_SYSTICKACT = 1U << 11 ;

  // Field USGFAULTPENDED: Usage fault exception pending bit
    const uint32_t SCB_SHCSR_USGFAULTPENDED = 1U << 12 ;

  // Field MEMFAULTPENDED: Memory management fault exception pending bit
    const uint32_t SCB_SHCSR_MEMFAULTPENDED = 1U << 13 ;

  // Field BUSFAULTPENDED: Bus fault exception pending bit
    const uint32_t SCB_SHCSR_BUSFAULTPENDED = 1U << 14 ;

  // Field SVCALLPENDED: SVC call pending bit
    const uint32_t SCB_SHCSR_SVCALLPENDED = 1U << 15 ;

  // Field MEMFAULTENA: Memory management fault enable bit
    const uint32_t SCB_SHCSR_MEMFAULTENA = 1U << 16 ;

  // Field BUSFAULTENA: Bus fault enable bit
    const uint32_t SCB_SHCSR_BUSFAULTENA = 1U << 17 ;

  // Field USGFAULTENA: Usage fault enable bit
    const uint32_t SCB_SHCSR_USGFAULTENA = 1U << 18 ;

//------------------------------------------------------------------------------

//---  Register CFSR_UFSR_BFSR_MMFSR: Configurable fault status register
  #define SCB_CFSR_UFSR_BFSR_MMFSR (* ((volatile uint32_t *) (0xE000ED00 + 40)))

  // Field IACCVIOL: IACCVIOL
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IACCVIOL = 1U << 0 ;

  // Field DACCVIOL: DACCVIOL
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DACCVIOL = 1U << 1 ;

  // Field MUNSTKERR: MUNSTKERR
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MUNSTKERR = 1U << 3 ;

  // Field MSTKERR: MSTKERR
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MSTKERR = 1U << 4 ;

  // Field MLSPERR: MLSPERR
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MLSPERR = 1U << 5 ;

  // Field MMARVALID: MMARVALID
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_MMARVALID = 1U << 7 ;

  // Field IBUSERR: Instruction bus error
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IBUSERR = 1U << 8 ;

  // Field PRECISERR: Precise data bus error
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_PRECISERR = 1U << 9 ;

  // Field IMPRECISERR: Imprecise data bus error
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_IMPRECISERR = 1U << 10 ;

  // Field UNSTKERR: Bus fault on unstacking for a return from exception
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNSTKERR = 1U << 11 ;

  // Field STKERR: Bus fault on stacking for exception entry
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_STKERR = 1U << 12 ;

  // Field LSPERR: Bus fault on floating-point lazy state preservation
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_LSPERR = 1U << 13 ;

  // Field BFARVALID: Bus Fault Address Register (BFAR) valid flag
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_BFARVALID = 1U << 15 ;

  // Field UNDEFINSTR: Undefined instruction usage fault
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNDEFINSTR = 1U << 16 ;

  // Field INVSTATE: Invalid state usage fault
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVSTATE = 1U << 17 ;

  // Field INVPC: Invalid PC load usage fault
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_INVPC = 1U << 18 ;

  // Field NOCP: No coprocessor usage fault.
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_NOCP = 1U << 19 ;

  // Field UNALIGNED: Unaligned access usage fault
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_UNALIGNED = 1U << 24 ;

  // Field DIVBYZERO: Divide by zero usage fault
    const uint32_t SCB_CFSR_UFSR_BFSR_MMFSR_DIVBYZERO = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register HFSR: Hard fault status register
  #define SCB_HFSR (* ((volatile uint32_t *) (0xE000ED00 + 44)))

  // Field VECTTBL: Vector table hard fault
    const uint32_t SCB_HFSR_VECTTBL = 1U << 1 ;

  // Field FORCED: Forced hard fault
    const uint32_t SCB_HFSR_FORCED = 1U << 30 ;

  // Field DEBUG_VT: Reserved for Debug use
    const uint32_t SCB_HFSR_DEBUG_VT = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register MMFAR: Memory management fault address register
  #define SCB_MMFAR (* ((volatile uint32_t *) (0xE000ED00 + 52)))

  // Field ADDRESS: Memory management fault address
    inline uint32_t SCB_MMFAR_ADDRESS (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BFAR: Bus fault address register
  #define SCB_BFAR (* ((volatile uint32_t *) (0xE000ED00 + 56)))

  // Field ADDRESS: Bus fault address
    inline uint32_t SCB_BFAR_ADDRESS (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral SCB_ACTRL: System control block ACTLR
//------------------------------------------------------------------------------

//---  Register ACTRL: Auxiliary control register
  #define SCB_ACTRL_ACTRL (* ((volatile uint32_t *) (0xE000E008 + 0)))

  // Field DISFOLD: DISFOLD
    const uint32_t SCB_ACTRL_ACTRL_DISFOLD = 1U << 2 ;

  // Field FPEXCODIS: FPEXCODIS
    const uint32_t SCB_ACTRL_ACTRL_FPEXCODIS = 1U << 10 ;

  // Field DISRAMODE: DISRAMODE
    const uint32_t SCB_ACTRL_ACTRL_DISRAMODE = 1U << 11 ;

  // Field DISITMATBFLUSH: DISITMATBFLUSH
    const uint32_t SCB_ACTRL_ACTRL_DISITMATBFLUSH = 1U << 12 ;

//------------------------------------------------------------------------------
// Peripheral SDMMC1: SDMMC1
//------------------------------------------------------------------------------

//---  Register POWER: SDMMC power control register
  #define SDMMC1_POWER (* ((volatile uint32_t *) (0x52007000 + 0)))

  // Field PWRCTRL: SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
    inline uint32_t SDMMC1_POWER_PWRCTRL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field VSWITCH: Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
    const uint32_t SDMMC1_POWER_VSWITCH = 1U << 2 ;

  // Field VSWITCHEN: Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
    const uint32_t SDMMC1_POWER_VSWITCHEN = 1U << 3 ;

  // Field DIRPOL: Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    const uint32_t SDMMC1_POWER_DIRPOL = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CLKCR: The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
  #define SDMMC1_CLKCR (* ((volatile uint32_t *) (0x52007000 + 4)))

  // Field CLKDIV: Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
    inline uint32_t SDMMC1_CLKCR_CLKDIV (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field PWRSAV: Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
    const uint32_t SDMMC1_CLKCR_PWRSAV = 1U << 12 ;

  // Field WIDBUS: Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    inline uint32_t SDMMC1_CLKCR_WIDBUS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field NEGEDGE: SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
    const uint32_t SDMMC1_CLKCR_NEGEDGE = 1U << 16 ;

  // Field HWFC_EN: Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
    const uint32_t SDMMC1_CLKCR_HWFC_EN = 1U << 17 ;

  // Field DDR: Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
    const uint32_t SDMMC1_CLKCR_DDR = 1U << 18 ;

  // Field BUSSPEED: Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    const uint32_t SDMMC1_CLKCR_BUSSPEED = 1U << 19 ;

  // Field SELCLKRX: Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    inline uint32_t SDMMC1_CLKCR_SELCLKRX (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register ARGR: The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
  #define SDMMC1_ARGR (* ((volatile uint32_t *) (0x52007000 + 8)))

  // Field CMDARG: Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
    inline uint32_t SDMMC1_ARGR_CMDARG (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMDR: The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
  #define SDMMC1_CMDR (* ((volatile uint32_t *) (0x52007000 + 12)))

  // Field CMDINDEX: Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
    inline uint32_t SDMMC1_CMDR_CMDINDEX (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field CMDTRANS: The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
    const uint32_t SDMMC1_CMDR_CMDTRANS = 1U << 6 ;

  // Field CMDSTOP: The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
    const uint32_t SDMMC1_CMDR_CMDSTOP = 1U << 7 ;

  // Field WAITRESP: Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
    inline uint32_t SDMMC1_CMDR_WAITRESP (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field WAITINT: CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
    const uint32_t SDMMC1_CMDR_WAITINT = 1U << 10 ;

  // Field WAITPEND: CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
    const uint32_t SDMMC1_CMDR_WAITPEND = 1U << 11 ;

  // Field CPSMEN: Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
    const uint32_t SDMMC1_CMDR_CPSMEN = 1U << 12 ;

  // Field DTHOLD: Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
    const uint32_t SDMMC1_CMDR_DTHOLD = 1U << 13 ;

  // Field BOOTMODE: Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
    const uint32_t SDMMC1_CMDR_BOOTMODE = 1U << 14 ;

  // Field BOOTEN: Enable boot mode procedure.
    const uint32_t SDMMC1_CMDR_BOOTEN = 1U << 15 ;

  // Field CMDSUSPEND: The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    const uint32_t SDMMC1_CMDR_CMDSUSPEND = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register RESP1R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC1_RESP1R (* ((const volatile uint32_t *) (0x52007000 + 20)))

  // Field CARDSTATUS1: see Table 432
    inline uint32_t SDMMC1_RESP1R_CARDSTATUS1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESP2R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC1_RESP2R (* ((const volatile uint32_t *) (0x52007000 + 24)))

  // Field CARDSTATUS2: see Table404.
    inline uint32_t SDMMC1_RESP2R_CARDSTATUS2 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESP3R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC1_RESP3R (* ((const volatile uint32_t *) (0x52007000 + 28)))

  // Field CARDSTATUS3: see Table404.
    inline uint32_t SDMMC1_RESP3R_CARDSTATUS3 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESP4R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC1_RESP4R (* ((const volatile uint32_t *) (0x52007000 + 32)))

  // Field CARDSTATUS4: see Table404.
    inline uint32_t SDMMC1_RESP4R_CARDSTATUS4 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTIMER: The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
  #define SDMMC1_DTIMER (* ((volatile uint32_t *) (0x52007000 + 36)))

  // Field DATATIME: Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
    inline uint32_t SDMMC1_DTIMER_DATATIME (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DLENR: The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
  #define SDMMC1_DLENR (* ((volatile uint32_t *) (0x52007000 + 40)))

  // Field DATALENGTH: Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
    inline uint32_t SDMMC1_DLENR_DATALENGTH (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCTRL: The SDMMC_DCTRL register control the data path state machine (DPSM).
  #define SDMMC1_DCTRL (* ((volatile uint32_t *) (0x52007000 + 44)))

  // Field DTEN: Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
    const uint32_t SDMMC1_DCTRL_DTEN = 1U << 0 ;

  // Field DTDIR: Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC1_DCTRL_DTDIR = 1U << 1 ;

  // Field DTMODE: Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    inline uint32_t SDMMC1_DCTRL_DTMODE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DBLOCKSIZE: Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
    inline uint32_t SDMMC1_DCTRL_DBLOCKSIZE (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field RWSTART: Read wait start. If this bit is set, read wait operation starts.
    const uint32_t SDMMC1_DCTRL_RWSTART = 1U << 8 ;

  // Field RWSTOP: Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
    const uint32_t SDMMC1_DCTRL_RWSTOP = 1U << 9 ;

  // Field RWMOD: Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC1_DCTRL_RWMOD = 1U << 10 ;

  // Field SDIOEN: SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
    const uint32_t SDMMC1_DCTRL_SDIOEN = 1U << 11 ;

  // Field BOOTACKEN: Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC1_DCTRL_BOOTACKEN = 1U << 12 ;

  // Field FIFORST: FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    const uint32_t SDMMC1_DCTRL_FIFORST = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register DCNTR: The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
  #define SDMMC1_DCNTR (* ((const volatile uint32_t *) (0x52007000 + 48)))

  // Field DATACOUNT: Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
    inline uint32_t SDMMC1_DCNTR_DATACOUNT (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register STAR: The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
  #define SDMMC1_STAR (* ((const volatile uint32_t *) (0x52007000 + 52)))

  // Field CCRCFAIL: Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_CCRCFAIL = 1U << 0 ;

  // Field DCRCFAIL: Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_DCRCFAIL = 1U << 1 ;

  // Field CTIMEOUT: Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
    const uint32_t SDMMC1_STAR_CTIMEOUT = 1U << 2 ;

  // Field DTIMEOUT: Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_DTIMEOUT = 1U << 3 ;

  // Field TXUNDERR: Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_TXUNDERR = 1U << 4 ;

  // Field RXOVERR: Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_RXOVERR = 1U << 5 ;

  // Field CMDREND: Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_CMDREND = 1U << 6 ;

  // Field CMDSENT: Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_CMDSENT = 1U << 7 ;

  // Field DATAEND: Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_DATAEND = 1U << 8 ;

  // Field DHOLD: Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_DHOLD = 1U << 9 ;

  // Field DBCKEND: Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_DBCKEND = 1U << 10 ;

  // Field DABORT: Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_DABORT = 1U << 11 ;

  // Field DPSMACT: Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    const uint32_t SDMMC1_STAR_DPSMACT = 1U << 12 ;

  // Field CPSMACT: Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    const uint32_t SDMMC1_STAR_CPSMACT = 1U << 13 ;

  // Field TXFIFOHE: Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
    const uint32_t SDMMC1_STAR_TXFIFOHE = 1U << 14 ;

  // Field RXFIFOHF: Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
    const uint32_t SDMMC1_STAR_RXFIFOHF = 1U << 15 ;

  // Field TXFIFOF: Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
    const uint32_t SDMMC1_STAR_TXFIFOF = 1U << 16 ;

  // Field RXFIFOF: Receive FIFO full This bit is cleared when one FIFO location becomes empty.
    const uint32_t SDMMC1_STAR_RXFIFOF = 1U << 17 ;

  // Field TXFIFOE: Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
    const uint32_t SDMMC1_STAR_TXFIFOE = 1U << 18 ;

  // Field RXFIFOE: Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
    const uint32_t SDMMC1_STAR_RXFIFOE = 1U << 19 ;

  // Field BUSYD0: Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
    const uint32_t SDMMC1_STAR_BUSYD0 = 1U << 20 ;

  // Field BUSYD0END: end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_BUSYD0END = 1U << 21 ;

  // Field SDIOIT: SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_SDIOIT = 1U << 22 ;

  // Field ACKFAIL: Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_ACKFAIL = 1U << 23 ;

  // Field ACKTIMEOUT: Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_ACKTIMEOUT = 1U << 24 ;

  // Field VSWEND: Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_VSWEND = 1U << 25 ;

  // Field CKSTOP: SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_CKSTOP = 1U << 26 ;

  // Field IDMATE: IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_IDMATE = 1U << 27 ;

  // Field IDMABTC: IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC1_STAR_IDMABTC = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register ICR: The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
  #define SDMMC1_ICR (* ((volatile uint32_t *) (0x52007000 + 56)))

  // Field CCRCFAILC: CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
    const uint32_t SDMMC1_ICR_CCRCFAILC = 1U << 0 ;

  // Field DCRCFAILC: DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
    const uint32_t SDMMC1_ICR_DCRCFAILC = 1U << 1 ;

  // Field CTIMEOUTC: CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
    const uint32_t SDMMC1_ICR_CTIMEOUTC = 1U << 2 ;

  // Field DTIMEOUTC: DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
    const uint32_t SDMMC1_ICR_DTIMEOUTC = 1U << 3 ;

  // Field TXUNDERRC: TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
    const uint32_t SDMMC1_ICR_TXUNDERRC = 1U << 4 ;

  // Field RXOVERRC: RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
    const uint32_t SDMMC1_ICR_RXOVERRC = 1U << 5 ;

  // Field CMDRENDC: CMDREND flag clear bit Set by software to clear the CMDREND flag.
    const uint32_t SDMMC1_ICR_CMDRENDC = 1U << 6 ;

  // Field CMDSENTC: CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
    const uint32_t SDMMC1_ICR_CMDSENTC = 1U << 7 ;

  // Field DATAENDC: DATAEND flag clear bit Set by software to clear the DATAEND flag.
    const uint32_t SDMMC1_ICR_DATAENDC = 1U << 8 ;

  // Field DHOLDC: DHOLD flag clear bit Set by software to clear the DHOLD flag.
    const uint32_t SDMMC1_ICR_DHOLDC = 1U << 9 ;

  // Field DBCKENDC: DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
    const uint32_t SDMMC1_ICR_DBCKENDC = 1U << 10 ;

  // Field DABORTC: DABORT flag clear bit Set by software to clear the DABORT flag.
    const uint32_t SDMMC1_ICR_DABORTC = 1U << 11 ;

  // Field BUSYD0ENDC: BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
    const uint32_t SDMMC1_ICR_BUSYD0ENDC = 1U << 21 ;

  // Field SDIOITC: SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
    const uint32_t SDMMC1_ICR_SDIOITC = 1U << 22 ;

  // Field ACKFAILC: ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
    const uint32_t SDMMC1_ICR_ACKFAILC = 1U << 23 ;

  // Field ACKTIMEOUTC: ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
    const uint32_t SDMMC1_ICR_ACKTIMEOUTC = 1U << 24 ;

  // Field VSWENDC: VSWEND flag clear bit Set by software to clear the VSWEND flag.
    const uint32_t SDMMC1_ICR_VSWENDC = 1U << 25 ;

  // Field CKSTOPC: CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
    const uint32_t SDMMC1_ICR_CKSTOPC = 1U << 26 ;

  // Field IDMATEC: IDMA transfer error clear bit Set by software to clear the IDMATE flag.
    const uint32_t SDMMC1_ICR_IDMATEC = 1U << 27 ;

  // Field IDMABTCC: IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    const uint32_t SDMMC1_ICR_IDMABTCC = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register MASKR: The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
  #define SDMMC1_MASKR (* ((volatile uint32_t *) (0x52007000 + 60)))

  // Field CCRCFAILIE: Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
    const uint32_t SDMMC1_MASKR_CCRCFAILIE = 1U << 0 ;

  // Field DCRCFAILIE: Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
    const uint32_t SDMMC1_MASKR_DCRCFAILIE = 1U << 1 ;

  // Field CTIMEOUTIE: Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
    const uint32_t SDMMC1_MASKR_CTIMEOUTIE = 1U << 2 ;

  // Field DTIMEOUTIE: Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
    const uint32_t SDMMC1_MASKR_DTIMEOUTIE = 1U << 3 ;

  // Field TXUNDERRIE: Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
    const uint32_t SDMMC1_MASKR_TXUNDERRIE = 1U << 4 ;

  // Field RXOVERRIE: Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
    const uint32_t SDMMC1_MASKR_RXOVERRIE = 1U << 5 ;

  // Field CMDRENDIE: Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
    const uint32_t SDMMC1_MASKR_CMDRENDIE = 1U << 6 ;

  // Field CMDSENTIE: Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
    const uint32_t SDMMC1_MASKR_CMDSENTIE = 1U << 7 ;

  // Field DATAENDIE: Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
    const uint32_t SDMMC1_MASKR_DATAENDIE = 1U << 8 ;

  // Field DHOLDIE: Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
    const uint32_t SDMMC1_MASKR_DHOLDIE = 1U << 9 ;

  // Field DBCKENDIE: Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
    const uint32_t SDMMC1_MASKR_DBCKENDIE = 1U << 10 ;

  // Field DABORTIE: Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
    const uint32_t SDMMC1_MASKR_DABORTIE = 1U << 11 ;

  // Field TXFIFOHEIE: Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
    const uint32_t SDMMC1_MASKR_TXFIFOHEIE = 1U << 14 ;

  // Field RXFIFOHFIE: Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
    const uint32_t SDMMC1_MASKR_RXFIFOHFIE = 1U << 15 ;

  // Field RXFIFOFIE: Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
    const uint32_t SDMMC1_MASKR_RXFIFOFIE = 1U << 17 ;

  // Field TXFIFOEIE: Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
    const uint32_t SDMMC1_MASKR_TXFIFOEIE = 1U << 18 ;

  // Field BUSYD0ENDIE: BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
    const uint32_t SDMMC1_MASKR_BUSYD0ENDIE = 1U << 21 ;

  // Field SDIOITIE: SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
    const uint32_t SDMMC1_MASKR_SDIOITIE = 1U << 22 ;

  // Field ACKFAILIE: Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
    const uint32_t SDMMC1_MASKR_ACKFAILIE = 1U << 23 ;

  // Field ACKTIMEOUTIE: Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
    const uint32_t SDMMC1_MASKR_ACKTIMEOUTIE = 1U << 24 ;

  // Field VSWENDIE: Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
    const uint32_t SDMMC1_MASKR_VSWENDIE = 1U << 25 ;

  // Field CKSTOPIE: Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
    const uint32_t SDMMC1_MASKR_CKSTOPIE = 1U << 26 ;

  // Field IDMABTCIE: IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    const uint32_t SDMMC1_MASKR_IDMABTCIE = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register ACKTIMER: The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
  #define SDMMC1_ACKTIMER (* ((volatile uint32_t *) (0x52007000 + 64)))

  // Field ACKTIME: Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
    inline uint32_t SDMMC1_ACKTIMER_ACKTIME (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IDMACTRLR: The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
  #define SDMMC1_IDMACTRLR (* ((volatile uint32_t *) (0x52007000 + 80)))

  // Field IDMAEN: IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC1_IDMACTRLR_IDMAEN = 1U << 0 ;

  // Field IDMABMODE: Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC1_IDMACTRLR_IDMABMODE = 1U << 1 ;

  // Field IDMABACT: Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    const uint32_t SDMMC1_IDMACTRLR_IDMABACT = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register IDMABSIZER: The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
  #define SDMMC1_IDMABSIZER (* ((volatile uint32_t *) (0x52007000 + 84)))

  // Field IDMABNDT: Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    inline uint32_t SDMMC1_IDMABSIZER_IDMABNDT (const uint32_t inValue) {return (inValue & 0xFFU) << 5 ; }

//------------------------------------------------------------------------------

//---  Register IDMABASE0R: The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
  #define SDMMC1_IDMABASE0R (* ((volatile uint32_t *) (0x52007000 + 88)))

  // Field IDMABASE0: Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
    inline uint32_t SDMMC1_IDMABASE0R_IDMABASE0 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IDMABASE1R: The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
  #define SDMMC1_IDMABASE1R (* ((volatile uint32_t *) (0x52007000 + 92)))

  // Field IDMABASE1: Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
    inline uint32_t SDMMC1_IDMABASE1R_IDMABASE1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FIFOR: The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
  #define SDMMC1_FIFOR (* ((volatile uint32_t *) (0x52007000 + 128)))

  // Field FIFODATA: Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
    inline uint32_t SDMMC1_FIFOR_FIFODATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register VER: SDMMC IP version register
  #define SDMMC1_VER (* ((const volatile uint32_t *) (0x52007000 + 1012)))

  // Field MINREV: IP minor revision number.
    inline uint32_t SDMMC1_VER_MINREV (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field MAJREV: IP major revision number.
    inline uint32_t SDMMC1_VER_MAJREV (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register ID: SDMMC IP identification register
  #define SDMMC1_ID (* ((const volatile uint32_t *) (0x52007000 + 1016)))

  // Field IP_ID: SDMMC IP identification.
    inline uint32_t SDMMC1_ID_IP_ID (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESPCMDR: SDMMC command response register
  #define SDMMC1_RESPCMDR (* ((const volatile uint32_t *) (0x52007000 + 16)))

  // Field RESPCMD: Response command index
    inline uint32_t SDMMC1_RESPCMDR_RESPCMD (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral SDMMC2
//------------------------------------------------------------------------------

//---  Register POWER: SDMMC power control register
  #define SDMMC2_POWER (* ((volatile uint32_t *) (0x48022400 + 0)))

  // Field PWRCTRL: SDMMC state control bits. These bits can only be written when the SDMMC is not in the power-on state (PWRCTRL?11). These bits are used to define the functional state of the SDMMC signals: Any further write will be ignored, PWRCTRL value will keep 11.
    inline uint32_t SDMMC2_POWER_PWRCTRL (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field VSWITCH: Voltage switch sequence start. This bit is used to start the timing critical section of the voltage switch sequence:
    const uint32_t SDMMC2_POWER_VSWITCH = 1U << 2 ;

  // Field VSWITCHEN: Voltage switch procedure enable. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). This bit is used to stop the SDMMC_CK after the voltage switch command response:
    const uint32_t SDMMC2_POWER_VSWITCHEN = 1U << 3 ;

  // Field DIRPOL: Data and command direction signals polarity selection. This bit can only be written when the SDMMC is in the power-off state (PWRCTRL = 00).
    const uint32_t SDMMC2_POWER_DIRPOL = 1U << 4 ;

//------------------------------------------------------------------------------

//---  Register CLKCR: The SDMMC_CLKCR register controls the SDMMC_CK output clock, the SDMMC_RX_CLK receive clock, and the bus width.
  #define SDMMC2_CLKCR (* ((volatile uint32_t *) (0x48022400 + 4)))

  // Field CLKDIV: Clock divide factor This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). This field defines the divide factor between the input clock (SDMMCCLK) and the output clock (SDMMC_CK): SDMMC_CK frequency = SDMMCCLK / [2 * CLKDIV]. 0xx: etc.. xxx: etc..
    inline uint32_t SDMMC2_CLKCR_CLKDIV (const uint32_t inValue) {return (inValue & 0x3FFU) << 0 ; }

  // Field PWRSAV: Power saving configuration bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) For power saving, the SDMMC_CK clock output can be disabled when the bus is idle by setting PWRSAV:
    const uint32_t SDMMC2_CLKCR_PWRSAV = 1U << 12 ;

  // Field WIDBUS: Wide bus mode enable bit This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    inline uint32_t SDMMC2_CLKCR_WIDBUS (const uint32_t inValue) {return (inValue & 0x3U) << 14 ; }

  // Field NEGEDGE: SDMMC_CK dephasing selection bit for data and Command. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). When clock division = 1 (CLKDIV = 0), this bit has no effect. Data and Command change on SDMMC_CK falling edge. When clock division &gt;1 (CLKDIV &gt; 0) &amp; DDR = 0: - SDMMC_CK edge occurs on SDMMCCLK rising edge. When clock division >1 (CLKDIV > 0) & DDR = 1: - Data changed on the SDMMCCLK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge. - Data changed on the SDMMC_CK falling edge succeeding a SDMMC_CK edge. - SDMMC_CK edge occurs on SDMMCCLK rising edge.
    const uint32_t SDMMC2_CLKCR_NEGEDGE = 1U << 16 ;

  // Field HWFC_EN: Hardware flow control enable This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) When Hardware flow control is enabled, the meaning of the TXFIFOE and RXFIFOF flags change, please see SDMMC status register definition in Section56.8.11.
    const uint32_t SDMMC2_CLKCR_HWFC_EN = 1U << 17 ;

  // Field DDR: Data rate signaling selection This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0) DDR rate shall only be selected with 4-bit or 8-bit wide bus mode. (WIDBUS &gt; 00). DDR = 1 has no effect when WIDBUS = 00 (1-bit wide bus). DDR rate shall only be selected with clock division &gt;1. (CLKDIV &gt; 0)
    const uint32_t SDMMC2_CLKCR_DDR = 1U << 18 ;

  // Field BUSSPEED: Bus speed mode selection between DS, HS, SDR12, SDR25 and SDR50, DDR50, SDR104. This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    const uint32_t SDMMC2_CLKCR_BUSSPEED = 1U << 19 ;

  // Field SELCLKRX: Receive clock selection. These bits can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0)
    inline uint32_t SDMMC2_CLKCR_SELCLKRX (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register ARGR: The SDMMC_ARGR register contains a 32-bit command argument, which is sent to a card as part of a command message.
  #define SDMMC2_ARGR (* ((volatile uint32_t *) (0x48022400 + 8)))

  // Field CMDARG: Command argument. These bits can only be written by firmware when CPSM is disabled (CPSMEN = 0). Command argument sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing a command to the command register.
    inline uint32_t SDMMC2_ARGR_CMDARG (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CMDR: The SDMMC_CMDR register contains the command index and command type bits. The command index is sent to a card as part of a command message. The command type bits control the command path state machine (CPSM).
  #define SDMMC2_CMDR (* ((volatile uint32_t *) (0x48022400 + 12)))

  // Field CMDINDEX: Command index. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). The command index is sent to the card as part of a command message.
    inline uint32_t SDMMC2_CMDR_CMDINDEX (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

  // Field CMDTRANS: The CPSM treats the command as a data transfer command, stops the interrupt period, and signals DataEnable to the DPSM This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues an end of interrupt period and issues DataEnable signal to the DPSM when the command is sent.
    const uint32_t SDMMC2_CMDR_CMDTRANS = 1U << 6 ;

  // Field CMDSTOP: The CPSM treats the command as a Stop Transmission command and signals Abort to the DPSM. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). If this bit is set, the CPSM issues the Abort signal to the DPSM when the command is sent.
    const uint32_t SDMMC2_CMDR_CMDSTOP = 1U << 7 ;

  // Field WAITRESP: Wait for response bits. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). They are used to configure whether the CPSM is to wait for a response, and if yes, which kind of response.
    inline uint32_t SDMMC2_CMDR_WAITRESP (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field WAITINT: CPSM waits for interrupt request. If this bit is set, the CPSM disables command timeout and waits for an card interrupt request (Response). If this bit is cleared in the CPSM Wait state, will cause the abort of the interrupt mode.
    const uint32_t SDMMC2_CMDR_WAITINT = 1U << 10 ;

  // Field WAITPEND: CPSM Waits for end of data transfer (CmdPend internal signal) from DPSM. This bit when set, the CPSM waits for the end of data transfer trigger before it starts sending a command. WAITPEND is only taken into account when DTMODE = MMC stream data transfer, WIDBUS = 1-bit wide bus mode, DPSMACT = 1 and DTDIR = from host to card.
    const uint32_t SDMMC2_CMDR_WAITPEND = 1U << 11 ;

  // Field CPSMEN: Command path state machine (CPSM) Enable bit This bit is written 1 by firmware, and cleared by hardware when the CPSM enters the Idle state. If this bit is set, the CPSM is enabled. When DTEN = 1, no command will be transfered nor boot procedure will be started. CPSMEN is cleared to 0.
    const uint32_t SDMMC2_CMDR_CPSMEN = 1U << 12 ;

  // Field DTHOLD: Hold new data block transmission and reception in the DPSM. If this bit is set, the DPSM will not move from the Wait_S state to the Send state or from the Wait_R state to the Receive state.
    const uint32_t SDMMC2_CMDR_DTHOLD = 1U << 13 ;

  // Field BOOTMODE: Select the boot mode procedure to be used. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0)
    const uint32_t SDMMC2_CMDR_BOOTMODE = 1U << 14 ;

  // Field BOOTEN: Enable boot mode procedure.
    const uint32_t SDMMC2_CMDR_BOOTEN = 1U << 15 ;

  // Field CMDSUSPEND: The CPSM treats the command as a Suspend or Resume command and signals interrupt period start/end. This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). CMDSUSPEND = 1 and CMDTRANS = 0 Suspend command, start interrupt period when response bit BS=0. CMDSUSPEND = 1 and CMDTRANS = 1 Resume command with data, end interrupt period when response bit DF=1.
    const uint32_t SDMMC2_CMDR_CMDSUSPEND = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register RESP1R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC2_RESP1R (* ((const volatile uint32_t *) (0x48022400 + 20)))

  // Field CARDSTATUS1: see Table 432
    inline uint32_t SDMMC2_RESP1R_CARDSTATUS1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESP2R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC2_RESP2R (* ((const volatile uint32_t *) (0x48022400 + 24)))

  // Field CARDSTATUS2: see Table404.
    inline uint32_t SDMMC2_RESP2R_CARDSTATUS2 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESP3R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC2_RESP3R (* ((const volatile uint32_t *) (0x48022400 + 28)))

  // Field CARDSTATUS3: see Table404.
    inline uint32_t SDMMC2_RESP3R_CARDSTATUS3 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESP4R: The SDMMC_RESP1/2/3/4R registers contain the status of a card, which is part of the received response.
  #define SDMMC2_RESP4R (* ((const volatile uint32_t *) (0x48022400 + 32)))

  // Field CARDSTATUS4: see Table404.
    inline uint32_t SDMMC2_RESP4R_CARDSTATUS4 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DTIMER: The SDMMC_DTIMER register contains the data timeout period, in card bus clock periods. A counter loads the value from the SDMMC_DTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_R or Busy state. If the timer reaches 0 while the DPSM is in either of these states, the timeout status flag is set.
  #define SDMMC2_DTIMER (* ((volatile uint32_t *) (0x48022400 + 36)))

  // Field DATATIME: Data and R1b busy timeout period This bit can only be written when the CPSM and DPSM are not active (CPSMACT = 0 and DPSMACT = 0). Data and R1b busy timeout period expressed in card bus clock periods.
    inline uint32_t SDMMC2_DTIMER_DATATIME (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DLENR: The SDMMC_DLENR register contains the number of data bytes to be transferred. The value is loaded into the data counter when data transfer starts.
  #define SDMMC2_DLENR (* ((volatile uint32_t *) (0x48022400 + 40)))

  // Field DATALENGTH: Data length value This register can only be written by firmware when DPSM is inactive (DPSMACT = 0). Number of data bytes to be transferred. When DDR = 1 DATALENGTH is truncated to a multiple of 2. (The last odd byte is not transfered) When DATALENGTH = 0 no data will be transfered, when requested by a CPSMEN and CMDTRANS = 1 also no command will be transfered. DTEN and CPSMEN are cleared to 0.
    inline uint32_t SDMMC2_DLENR_DATALENGTH (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCTRL: The SDMMC_DCTRL register control the data path state machine (DPSM).
  #define SDMMC2_DCTRL (* ((volatile uint32_t *) (0x48022400 + 44)))

  // Field DTEN: Data transfer enable bit This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). This bit is cleared by Hardware when data transfer completes. This bit shall only be used to transfer data when no associated data transfer command is used, i.e. shall not be used with SD or eMMC cards.
    const uint32_t SDMMC2_DCTRL_DTEN = 1U << 0 ;

  // Field DTDIR: Data transfer direction selection This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC2_DCTRL_DTDIR = 1U << 1 ;

  // Field DTMODE: Data transfer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    inline uint32_t SDMMC2_DCTRL_DTMODE (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field DBLOCKSIZE: Data block size This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). Define the data block length when the block data transfer mode is selected: When DATALENGTH is not a multiple of DBLOCKSIZE, the transfered data is truncated at a multiple of DBLOCKSIZE. (Any remain data will not be transfered.) When DDR = 1, DBLOCKSIZE = 0000 shall not be used. (No data will be transfered)
    inline uint32_t SDMMC2_DCTRL_DBLOCKSIZE (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field RWSTART: Read wait start. If this bit is set, read wait operation starts.
    const uint32_t SDMMC2_DCTRL_RWSTART = 1U << 8 ;

  // Field RWSTOP: Read wait stop This bit is written by firmware and auto cleared by hardware when the DPSM moves from the READ_WAIT state to the WAIT_R or IDLE state.
    const uint32_t SDMMC2_DCTRL_RWSTOP = 1U << 9 ;

  // Field RWMOD: Read wait mode. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC2_DCTRL_RWMOD = 1U << 10 ;

  // Field SDIOEN: SD I/O interrupt enable functions This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). If this bit is set, the DPSM enables the SD I/O card specific interrupt operation.
    const uint32_t SDMMC2_DCTRL_SDIOEN = 1U << 11 ;

  // Field BOOTACKEN: Enable the reception of the boot acknowledgment. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC2_DCTRL_BOOTACKEN = 1U << 12 ;

  // Field FIFORST: FIFO reset, will flush any remaining data. This bit can only be written by firmware when IDMAEN= 0 and DPSM is active (DPSMACT = 1). This bit will only take effect when a transfer error or transfer hold occurs.
    const uint32_t SDMMC2_DCTRL_FIFORST = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register DCNTR: The SDMMC_DCNTR register loads the value from the data length register (see SDMMC_DLENR) when the DPSM moves from the Idle state to the Wait_R or Wait_S state. As data is transferred, the counter decrements the value until it reaches 0. The DPSM then moves to the Idle state and when there has been no error, the data status end flag (DATAEND) is set.
  #define SDMMC2_DCNTR (* ((const volatile uint32_t *) (0x48022400 + 48)))

  // Field DATACOUNT: Data count value When read, the number of remaining data bytes to be transferred is returned. Write has no effect.
    inline uint32_t SDMMC2_DCNTR_DATACOUNT (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register STAR: The SDMMC_STAR register is a read-only register. It contains two types of flag:Static flags (bits [29,21,11:0]): these bits remain asserted until they are cleared by writing to the SDMMC interrupt Clear register (see SDMMC_ICR)Dynamic flags (bits [20:12]): these bits change state depending on the state of the underlying logic (for example, FIFO full and empty flags are asserted and de-asserted as data while written to the FIFO)
  #define SDMMC2_STAR (* ((const volatile uint32_t *) (0x48022400 + 52)))

  // Field CCRCFAIL: Command response received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_CCRCFAIL = 1U << 0 ;

  // Field DCRCFAIL: Data block sent/received (CRC check failed). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_DCRCFAIL = 1U << 1 ;

  // Field CTIMEOUT: Command response timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR. The Command Timeout period has a fixed value of 64 SDMMC_CK clock periods.
    const uint32_t SDMMC2_STAR_CTIMEOUT = 1U << 2 ;

  // Field DTIMEOUT: Data timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_DTIMEOUT = 1U << 3 ;

  // Field TXUNDERR: Transmit FIFO underrun error or IDMA read transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_TXUNDERR = 1U << 4 ;

  // Field RXOVERR: Received FIFO overrun error or IDMA write transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_RXOVERR = 1U << 5 ;

  // Field CMDREND: Command response received (CRC check passed, or no CRC). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_CMDREND = 1U << 6 ;

  // Field CMDSENT: Command sent (no response required). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_CMDSENT = 1U << 7 ;

  // Field DATAEND: Data transfer ended correctly. (data counter, DATACOUNT is zero and no errors occur). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_DATAEND = 1U << 8 ;

  // Field DHOLD: Data transfer Hold. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_DHOLD = 1U << 9 ;

  // Field DBCKEND: Data block sent/received. (CRC check passed) and DPSM moves to the READWAIT state. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_DBCKEND = 1U << 10 ;

  // Field DABORT: Data transfer aborted by CMD12. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_DABORT = 1U << 11 ;

  // Field DPSMACT: Data path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    const uint32_t SDMMC2_STAR_DPSMACT = 1U << 12 ;

  // Field CPSMACT: Command path state machine active, i.e. not in Idle state. This is a hardware status flag only, does not generate an interrupt.
    const uint32_t SDMMC2_STAR_CPSMACT = 1U << 13 ;

  // Field TXFIFOHE: Transmit FIFO half empty At least half the number of words can be written into the FIFO. This bit is cleared when the FIFO becomes half+1 full.
    const uint32_t SDMMC2_STAR_TXFIFOHE = 1U << 14 ;

  // Field RXFIFOHF: Receive FIFO half full There are at least half the number of words in the FIFO. This bit is cleared when the FIFO becomes half+1 empty.
    const uint32_t SDMMC2_STAR_RXFIFOHF = 1U << 15 ;

  // Field TXFIFOF: Transmit FIFO full This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes empty.
    const uint32_t SDMMC2_STAR_TXFIFOF = 1U << 16 ;

  // Field RXFIFOF: Receive FIFO full This bit is cleared when one FIFO location becomes empty.
    const uint32_t SDMMC2_STAR_RXFIFOF = 1U << 17 ;

  // Field TXFIFOE: Transmit FIFO empty This bit is cleared when one FIFO location becomes full.
    const uint32_t SDMMC2_STAR_TXFIFOE = 1U << 18 ;

  // Field RXFIFOE: Receive FIFO empty This is a hardware status flag only, does not generate an interrupt. This bit is cleared when one FIFO location becomes full.
    const uint32_t SDMMC2_STAR_RXFIFOE = 1U << 19 ;

  // Field BUSYD0: Inverted value of SDMMC_D0 line (Busy), sampled at the end of a CMD response and a second time 2 SDMMC_CK cycles after the CMD response. This bit is reset to not busy when the SDMMCD0 line changes from busy to not busy. This bit does not signal busy due to data transfer. This is a hardware status flag only, it does not generate an interrupt.
    const uint32_t SDMMC2_STAR_BUSYD0 = 1U << 20 ;

  // Field BUSYD0END: end of SDMMC_D0 Busy following a CMD response detected. This indicates only end of busy following a CMD response. This bit does not signal busy due to data transfer. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_BUSYD0END = 1U << 21 ;

  // Field SDIOIT: SDIO interrupt received. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_SDIOIT = 1U << 22 ;

  // Field ACKFAIL: Boot acknowledgment received (boot acknowledgment check fail). Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_ACKFAIL = 1U << 23 ;

  // Field ACKTIMEOUT: Boot acknowledgment timeout. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_ACKTIMEOUT = 1U << 24 ;

  // Field VSWEND: Voltage switch critical timing section completion. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_VSWEND = 1U << 25 ;

  // Field CKSTOP: SDMMC_CK stopped in Voltage switch procedure. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_CKSTOP = 1U << 26 ;

  // Field IDMATE: IDMA transfer error. Interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_IDMATE = 1U << 27 ;

  // Field IDMABTC: IDMA buffer transfer complete. interrupt flag is cleared by writing corresponding interrupt clear bit in SDMMC_ICR.
    const uint32_t SDMMC2_STAR_IDMABTC = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register ICR: The SDMMC_ICR register is a write-only register. Writing a bit with 1 clears the corresponding bit in the SDMMC_STAR status register.
  #define SDMMC2_ICR (* ((volatile uint32_t *) (0x48022400 + 56)))

  // Field CCRCFAILC: CCRCFAIL flag clear bit Set by software to clear the CCRCFAIL flag.
    const uint32_t SDMMC2_ICR_CCRCFAILC = 1U << 0 ;

  // Field DCRCFAILC: DCRCFAIL flag clear bit Set by software to clear the DCRCFAIL flag.
    const uint32_t SDMMC2_ICR_DCRCFAILC = 1U << 1 ;

  // Field CTIMEOUTC: CTIMEOUT flag clear bit Set by software to clear the CTIMEOUT flag.
    const uint32_t SDMMC2_ICR_CTIMEOUTC = 1U << 2 ;

  // Field DTIMEOUTC: DTIMEOUT flag clear bit Set by software to clear the DTIMEOUT flag.
    const uint32_t SDMMC2_ICR_DTIMEOUTC = 1U << 3 ;

  // Field TXUNDERRC: TXUNDERR flag clear bit Set by software to clear TXUNDERR flag.
    const uint32_t SDMMC2_ICR_TXUNDERRC = 1U << 4 ;

  // Field RXOVERRC: RXOVERR flag clear bit Set by software to clear the RXOVERR flag.
    const uint32_t SDMMC2_ICR_RXOVERRC = 1U << 5 ;

  // Field CMDRENDC: CMDREND flag clear bit Set by software to clear the CMDREND flag.
    const uint32_t SDMMC2_ICR_CMDRENDC = 1U << 6 ;

  // Field CMDSENTC: CMDSENT flag clear bit Set by software to clear the CMDSENT flag.
    const uint32_t SDMMC2_ICR_CMDSENTC = 1U << 7 ;

  // Field DATAENDC: DATAEND flag clear bit Set by software to clear the DATAEND flag.
    const uint32_t SDMMC2_ICR_DATAENDC = 1U << 8 ;

  // Field DHOLDC: DHOLD flag clear bit Set by software to clear the DHOLD flag.
    const uint32_t SDMMC2_ICR_DHOLDC = 1U << 9 ;

  // Field DBCKENDC: DBCKEND flag clear bit Set by software to clear the DBCKEND flag.
    const uint32_t SDMMC2_ICR_DBCKENDC = 1U << 10 ;

  // Field DABORTC: DABORT flag clear bit Set by software to clear the DABORT flag.
    const uint32_t SDMMC2_ICR_DABORTC = 1U << 11 ;

  // Field BUSYD0ENDC: BUSYD0END flag clear bit Set by software to clear the BUSYD0END flag.
    const uint32_t SDMMC2_ICR_BUSYD0ENDC = 1U << 21 ;

  // Field SDIOITC: SDIOIT flag clear bit Set by software to clear the SDIOIT flag.
    const uint32_t SDMMC2_ICR_SDIOITC = 1U << 22 ;

  // Field ACKFAILC: ACKFAIL flag clear bit Set by software to clear the ACKFAIL flag.
    const uint32_t SDMMC2_ICR_ACKFAILC = 1U << 23 ;

  // Field ACKTIMEOUTC: ACKTIMEOUT flag clear bit Set by software to clear the ACKTIMEOUT flag.
    const uint32_t SDMMC2_ICR_ACKTIMEOUTC = 1U << 24 ;

  // Field VSWENDC: VSWEND flag clear bit Set by software to clear the VSWEND flag.
    const uint32_t SDMMC2_ICR_VSWENDC = 1U << 25 ;

  // Field CKSTOPC: CKSTOP flag clear bit Set by software to clear the CKSTOP flag.
    const uint32_t SDMMC2_ICR_CKSTOPC = 1U << 26 ;

  // Field IDMATEC: IDMA transfer error clear bit Set by software to clear the IDMATE flag.
    const uint32_t SDMMC2_ICR_IDMATEC = 1U << 27 ;

  // Field IDMABTCC: IDMA buffer transfer complete clear bit Set by software to clear the IDMABTC flag.
    const uint32_t SDMMC2_ICR_IDMABTCC = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register MASKR: The interrupt mask register determines which status flags generate an interrupt request by setting the corresponding bit to 1.
  #define SDMMC2_MASKR (* ((volatile uint32_t *) (0x48022400 + 60)))

  // Field CCRCFAILIE: Command CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by command CRC failure.
    const uint32_t SDMMC2_MASKR_CCRCFAILIE = 1U << 0 ;

  // Field DCRCFAILIE: Data CRC fail interrupt enable Set and cleared by software to enable/disable interrupt caused by data CRC failure.
    const uint32_t SDMMC2_MASKR_DCRCFAILIE = 1U << 1 ;

  // Field CTIMEOUTIE: Command timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by command timeout.
    const uint32_t SDMMC2_MASKR_CTIMEOUTIE = 1U << 2 ;

  // Field DTIMEOUTIE: Data timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by data timeout.
    const uint32_t SDMMC2_MASKR_DTIMEOUTIE = 1U << 3 ;

  // Field TXUNDERRIE: Tx FIFO underrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO underrun error.
    const uint32_t SDMMC2_MASKR_TXUNDERRIE = 1U << 4 ;

  // Field RXOVERRIE: Rx FIFO overrun error interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO overrun error.
    const uint32_t SDMMC2_MASKR_RXOVERRIE = 1U << 5 ;

  // Field CMDRENDIE: Command response received interrupt enable Set and cleared by software to enable/disable interrupt caused by receiving command response.
    const uint32_t SDMMC2_MASKR_CMDRENDIE = 1U << 6 ;

  // Field CMDSENTIE: Command sent interrupt enable Set and cleared by software to enable/disable interrupt caused by sending command.
    const uint32_t SDMMC2_MASKR_CMDSENTIE = 1U << 7 ;

  // Field DATAENDIE: Data end interrupt enable Set and cleared by software to enable/disable interrupt caused by data end.
    const uint32_t SDMMC2_MASKR_DATAENDIE = 1U << 8 ;

  // Field DHOLDIE: Data hold interrupt enable Set and cleared by software to enable/disable the interrupt generated when sending new data is hold in the DPSM Wait_S state.
    const uint32_t SDMMC2_MASKR_DHOLDIE = 1U << 9 ;

  // Field DBCKENDIE: Data block end interrupt enable Set and cleared by software to enable/disable interrupt caused by data block end.
    const uint32_t SDMMC2_MASKR_DBCKENDIE = 1U << 10 ;

  // Field DABORTIE: Data transfer aborted interrupt enable Set and cleared by software to enable/disable interrupt caused by a data transfer being aborted.
    const uint32_t SDMMC2_MASKR_DABORTIE = 1U << 11 ;

  // Field TXFIFOHEIE: Tx FIFO half empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO half empty.
    const uint32_t SDMMC2_MASKR_TXFIFOHEIE = 1U << 14 ;

  // Field RXFIFOHFIE: Rx FIFO half full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO half full.
    const uint32_t SDMMC2_MASKR_RXFIFOHFIE = 1U << 15 ;

  // Field RXFIFOFIE: Rx FIFO full interrupt enable Set and cleared by software to enable/disable interrupt caused by Rx FIFO full.
    const uint32_t SDMMC2_MASKR_RXFIFOFIE = 1U << 17 ;

  // Field TXFIFOEIE: Tx FIFO empty interrupt enable Set and cleared by software to enable/disable interrupt caused by Tx FIFO empty.
    const uint32_t SDMMC2_MASKR_TXFIFOEIE = 1U << 18 ;

  // Field BUSYD0ENDIE: BUSYD0END interrupt enable Set and cleared by software to enable/disable the interrupt generated when SDMMC_D0 signal changes from busy to NOT busy following a CMD response.
    const uint32_t SDMMC2_MASKR_BUSYD0ENDIE = 1U << 21 ;

  // Field SDIOITIE: SDIO mode interrupt received interrupt enable Set and cleared by software to enable/disable the interrupt generated when receiving the SDIO mode interrupt.
    const uint32_t SDMMC2_MASKR_SDIOITIE = 1U << 22 ;

  // Field ACKFAILIE: Acknowledgment Fail interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment Fail.
    const uint32_t SDMMC2_MASKR_ACKFAILIE = 1U << 23 ;

  // Field ACKTIMEOUTIE: Acknowledgment timeout interrupt enable Set and cleared by software to enable/disable interrupt caused by acknowledgment timeout.
    const uint32_t SDMMC2_MASKR_ACKTIMEOUTIE = 1U << 24 ;

  // Field VSWENDIE: Voltage switch critical timing section completion interrupt enable Set and cleared by software to enable/disable the interrupt generated when voltage switch critical timing section completion.
    const uint32_t SDMMC2_MASKR_VSWENDIE = 1U << 25 ;

  // Field CKSTOPIE: Voltage Switch clock stopped interrupt enable Set and cleared by software to enable/disable interrupt caused by Voltage Switch clock stopped.
    const uint32_t SDMMC2_MASKR_CKSTOPIE = 1U << 26 ;

  // Field IDMABTCIE: IDMA buffer transfer complete interrupt enable Set and cleared by software to enable/disable the interrupt generated when the IDMA has transferred all data belonging to a memory buffer.
    const uint32_t SDMMC2_MASKR_IDMABTCIE = 1U << 28 ;

//------------------------------------------------------------------------------

//---  Register ACKTIMER: The SDMMC_ACKTIMER register contains the acknowledgment timeout period, in SDMMC_CK bus clock periods. A counter loads the value from the SDMMC_ACKTIMER register, and starts decrementing when the data path state machine (DPSM) enters the Wait_Ack state. If the timer reaches 0 while the DPSM is in this states, the acknowledgment timeout status flag is set.
  #define SDMMC2_ACKTIMER (* ((volatile uint32_t *) (0x48022400 + 64)))

  // Field ACKTIME: Boot acknowledgment timeout period This bit can only be written by firmware when CPSM is disabled (CPSMEN = 0). Boot acknowledgment timeout period expressed in card bus clock periods.
    inline uint32_t SDMMC2_ACKTIMER_ACKTIME (const uint32_t inValue) {return (inValue & 0x1FFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IDMACTRLR: The receive and transmit FIFOs can be read or written as 32-bit wide registers. The FIFOs contain 32 entries on 32 sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.
  #define SDMMC2_IDMACTRLR (* ((volatile uint32_t *) (0x48022400 + 80)))

  // Field IDMAEN: IDMA enable This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC2_IDMACTRLR_IDMAEN = 1U << 0 ;

  // Field IDMABMODE: Buffer mode selection. This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    const uint32_t SDMMC2_IDMACTRLR_IDMABMODE = 1U << 1 ;

  // Field IDMABACT: Double buffer mode active buffer indication This bit can only be written by firmware when DPSM is inactive (DPSMACT = 0). When IDMA is enabled this bit is toggled by hardware.
    const uint32_t SDMMC2_IDMACTRLR_IDMABACT = 1U << 2 ;

//------------------------------------------------------------------------------

//---  Register IDMABSIZER: The SDMMC_IDMABSIZER register contains the buffers size when in double buffer configuration.
  #define SDMMC2_IDMABSIZER (* ((volatile uint32_t *) (0x48022400 + 84)))

  // Field IDMABNDT: Number of transfers per buffer. This 8-bit value shall be multiplied by 8 to get the size of the buffer in 32-bit words and by 32 to get the size of the buffer in bytes. Example: IDMABNDT = 0x01: buffer size = 8 words = 32 bytes. These bits can only be written by firmware when DPSM is inactive (DPSMACT = 0).
    inline uint32_t SDMMC2_IDMABSIZER_IDMABNDT (const uint32_t inValue) {return (inValue & 0xFFU) << 5 ; }

//------------------------------------------------------------------------------

//---  Register IDMABASE0R: The SDMMC_IDMABASE0R register contains the memory buffer base address in single buffer configuration and the buffer 0 base address in double buffer configuration.
  #define SDMMC2_IDMABASE0R (* ((volatile uint32_t *) (0x48022400 + 88)))

  // Field IDMABASE0: Buffer 0 memory base address bits [31:2], shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 0 is inactive (IDMABACT = 1).
    inline uint32_t SDMMC2_IDMABASE0R_IDMABASE0 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IDMABASE1R: The SDMMC_IDMABASE1R register contains the double buffer configuration second buffer memory base address.
  #define SDMMC2_IDMABASE1R (* ((volatile uint32_t *) (0x48022400 + 92)))

  // Field IDMABASE1: Buffer 1 memory base address, shall be word aligned (bit [1:0] are always 0 and read only). This register can be written by firmware when DPSM is inactive (DPSMACT = 0), and can dynamically be written by firmware when DPSM active (DPSMACT = 1) and memory buffer 1 is inactive (IDMABACT = 0).
    inline uint32_t SDMMC2_IDMABASE1R_IDMABASE1 (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register FIFOR: The receive and transmit FIFOs can be only read or written as word (32-bit) wide registers. The FIFOs contain 16 entries on sequential addresses. This allows the CPU to use its load and store multiple operands to read from/write to the FIFO.When accessing SDMMC_FIFOR with half word or byte access an AHB bus fault is generated.
  #define SDMMC2_FIFOR (* ((volatile uint32_t *) (0x48022400 + 128)))

  // Field FIFODATA: Receive and transmit FIFO data This register can only be read or written by firmware when the DPSM is active (DPSMACT=1). The FIFO data occupies 16 entries of 32-bit words.
    inline uint32_t SDMMC2_FIFOR_FIFODATA (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register VER: SDMMC IP version register
  #define SDMMC2_VER (* ((const volatile uint32_t *) (0x48022400 + 1012)))

  // Field MINREV: IP minor revision number.
    inline uint32_t SDMMC2_VER_MINREV (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field MAJREV: IP major revision number.
    inline uint32_t SDMMC2_VER_MAJREV (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register ID: SDMMC IP identification register
  #define SDMMC2_ID (* ((const volatile uint32_t *) (0x48022400 + 1016)))

  // Field IP_ID: SDMMC IP identification.
    inline uint32_t SDMMC2_ID_IP_ID (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RESPCMDR: SDMMC command response register
  #define SDMMC2_RESPCMDR (* ((const volatile uint32_t *) (0x48022400 + 16)))

  // Field RESPCMD: Response command index
    inline uint32_t SDMMC2_RESPCMDR_RESPCMD (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral SPDIFRX: Receiver Interface
//------------------------------------------------------------------------------

//---  Register CR: Control register
  #define SPDIFRX_CR (* ((volatile uint32_t *) (0x40004000 + 0)))

  // Field SPDIFRXEN: Peripheral Block Enable
    inline uint32_t SPDIFRX_CR_SPDIFRXEN (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field RXDMAEN: Receiver DMA ENable for data flow
    const uint32_t SPDIFRX_CR_RXDMAEN = 1U << 2 ;

  // Field RXSTEO: STerEO Mode
    const uint32_t SPDIFRX_CR_RXSTEO = 1U << 3 ;

  // Field DRFMT: RX Data format
    inline uint32_t SPDIFRX_CR_DRFMT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field PMSK: Mask Parity error bit
    const uint32_t SPDIFRX_CR_PMSK = 1U << 6 ;

  // Field VMSK: Mask of Validity bit
    const uint32_t SPDIFRX_CR_VMSK = 1U << 7 ;

  // Field CUMSK: Mask of channel status and user bits
    const uint32_t SPDIFRX_CR_CUMSK = 1U << 8 ;

  // Field PTMSK: Mask of Preamble Type bits
    const uint32_t SPDIFRX_CR_PTMSK = 1U << 9 ;

  // Field CBDMAEN: Control Buffer DMA ENable for control flow
    const uint32_t SPDIFRX_CR_CBDMAEN = 1U << 10 ;

  // Field CHSEL: Channel Selection
    const uint32_t SPDIFRX_CR_CHSEL = 1U << 11 ;

  // Field NBTR: Maximum allowed re-tries during synchronization phase
    inline uint32_t SPDIFRX_CR_NBTR (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field WFA: Wait For Activity
    const uint32_t SPDIFRX_CR_WFA = 1U << 14 ;

  // Field INSEL: input selection
    inline uint32_t SPDIFRX_CR_INSEL (const uint32_t inValue) {return (inValue & 0x7U) << 16 ; }

  // Field CKSEN: Symbol Clock Enable
    const uint32_t SPDIFRX_CR_CKSEN = 1U << 20 ;

  // Field CKSBKPEN: Backup Symbol Clock Enable
    const uint32_t SPDIFRX_CR_CKSBKPEN = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register IMR: Interrupt mask register
  #define SPDIFRX_IMR (* ((volatile uint32_t *) (0x40004000 + 4)))

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t SPDIFRX_IMR_RXNEIE = 1U << 0 ;

  // Field CSRNEIE: Control Buffer Ready Interrupt Enable
    const uint32_t SPDIFRX_IMR_CSRNEIE = 1U << 1 ;

  // Field PERRIE: Parity error interrupt enable
    const uint32_t SPDIFRX_IMR_PERRIE = 1U << 2 ;

  // Field OVRIE: Overrun error Interrupt Enable
    const uint32_t SPDIFRX_IMR_OVRIE = 1U << 3 ;

  // Field SBLKIE: Synchronization Block Detected Interrupt Enable
    const uint32_t SPDIFRX_IMR_SBLKIE = 1U << 4 ;

  // Field SYNCDIE: Synchronization Done
    const uint32_t SPDIFRX_IMR_SYNCDIE = 1U << 5 ;

  // Field IFEIE: Serial Interface Error Interrupt Enable
    const uint32_t SPDIFRX_IMR_IFEIE = 1U << 6 ;

//------------------------------------------------------------------------------

//---  Register SR: Status register
  #define SPDIFRX_SR (* ((const volatile uint32_t *) (0x40004000 + 8)))

  // Field RXNE: Read data register not empty
    const uint32_t SPDIFRX_SR_RXNE = 1U << 0 ;

  // Field CSRNE: Control Buffer register is not empty
    const uint32_t SPDIFRX_SR_CSRNE = 1U << 1 ;

  // Field PERR: Parity error
    const uint32_t SPDIFRX_SR_PERR = 1U << 2 ;

  // Field OVR: Overrun error
    const uint32_t SPDIFRX_SR_OVR = 1U << 3 ;

  // Field SBD: Synchronization Block Detected
    const uint32_t SPDIFRX_SR_SBD = 1U << 4 ;

  // Field SYNCD: Synchronization Done
    const uint32_t SPDIFRX_SR_SYNCD = 1U << 5 ;

  // Field FERR: Framing error
    const uint32_t SPDIFRX_SR_FERR = 1U << 6 ;

  // Field SERR: Synchronization error
    const uint32_t SPDIFRX_SR_SERR = 1U << 7 ;

  // Field TERR: Time-out error
    const uint32_t SPDIFRX_SR_TERR = 1U << 8 ;

  // Field WIDTH5: Duration of 5 symbols counted with SPDIF_CLK
    inline uint32_t SPDIFRX_SR_WIDTH5 (const uint32_t inValue) {return (inValue & 0x7FFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt Flag Clear register
  #define SPDIFRX_IFCR (* ((volatile uint32_t *) (0x40004000 + 12)))

  // Field PERRCF: Clears the Parity error flag
    const uint32_t SPDIFRX_IFCR_PERRCF = 1U << 2 ;

  // Field OVRCF: Clears the Overrun error flag
    const uint32_t SPDIFRX_IFCR_OVRCF = 1U << 3 ;

  // Field SBDCF: Clears the Synchronization Block Detected flag
    const uint32_t SPDIFRX_IFCR_SBDCF = 1U << 4 ;

  // Field SYNCDCF: Clears the Synchronization Done flag
    const uint32_t SPDIFRX_IFCR_SYNCDCF = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register DR_00: Data input register
  #define SPDIFRX_DR_00 (* ((const volatile uint32_t *) (0x40004000 + 16)))

  // Field DR: Parity Error bit
    inline uint32_t SPDIFRX_DR_00_DR (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

  // Field PE: Parity Error bit
    const uint32_t SPDIFRX_DR_00_PE = 1U << 24 ;

  // Field V: Validity bit
    const uint32_t SPDIFRX_DR_00_V = 1U << 25 ;

  // Field U: User bit
    const uint32_t SPDIFRX_DR_00_U = 1U << 26 ;

  // Field C: Channel Status bit
    const uint32_t SPDIFRX_DR_00_C = 1U << 27 ;

  // Field PT: Preamble Type
    inline uint32_t SPDIFRX_DR_00_PT (const uint32_t inValue) {return (inValue & 0x3U) << 28 ; }

//------------------------------------------------------------------------------

//---  Register CSR: Channel Status register
  #define SPDIFRX_CSR (* ((const volatile uint32_t *) (0x40004000 + 20)))

  // Field USR: User data information
    inline uint32_t SPDIFRX_CSR_USR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CS: Channel A status information
    inline uint32_t SPDIFRX_CSR_CS (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field SOB: Start Of Block
    const uint32_t SPDIFRX_CSR_SOB = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register DIR: Debug Information register
  #define SPDIFRX_DIR (* ((const volatile uint32_t *) (0x40004000 + 24)))

  // Field THI: Threshold HIGH
    inline uint32_t SPDIFRX_DIR_THI (const uint32_t inValue) {return (inValue & 0x1FFFU) << 0 ; }

  // Field TLO: Threshold LOW
    inline uint32_t SPDIFRX_DIR_TLO (const uint32_t inValue) {return (inValue & 0x1FFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register VERR: SPDIFRX version register
  #define SPDIFRX_VERR (* ((const volatile uint32_t *) (0x40004000 + 1012)))

  // Field MINREV: Minor revision
    inline uint32_t SPDIFRX_VERR_MINREV (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field MAJREV: Major revision
    inline uint32_t SPDIFRX_VERR_MAJREV (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register IDR: SPDIFRX identification register
  #define SPDIFRX_IDR (* ((const volatile uint32_t *) (0x40004000 + 1016)))

  // Field ID: SPDIFRX identifier
    inline uint32_t SPDIFRX_IDR_ID (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register SIDR: SPDIFRX size identification register
  #define SPDIFRX_SIDR (* ((const volatile uint32_t *) (0x40004000 + 1020)))

  // Field SID: Size identification
    inline uint32_t SPDIFRX_SIDR_SID (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DR_01: Data input register
  #define SPDIFRX_DR_01 (* ((const volatile uint32_t *) (0x40004000 + 16)))

  // Field PE: Parity Error bit
    const uint32_t SPDIFRX_DR_01_PE = 1U << 0 ;

  // Field V: Validity bit
    const uint32_t SPDIFRX_DR_01_V = 1U << 1 ;

  // Field U: User bit
    const uint32_t SPDIFRX_DR_01_U = 1U << 2 ;

  // Field C: Channel Status bit
    const uint32_t SPDIFRX_DR_01_C = 1U << 3 ;

  // Field PT: Preamble Type
    inline uint32_t SPDIFRX_DR_01_PT (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field DR: Data value
    inline uint32_t SPDIFRX_DR_01_DR (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 8 ; }

//------------------------------------------------------------------------------

//---  Register DR_10: Data input register
  #define SPDIFRX_DR_10 (* ((const volatile uint32_t *) (0x40004000 + 16)))

  // Field DRNL1: Data value
    inline uint32_t SPDIFRX_DR_10_DRNL1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field DRNL2: Data value
    inline uint32_t SPDIFRX_DR_10_DRNL2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------
// Peripheral SPI1: Serial peripheral interface
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define SPI1_CR1 (* ((volatile uint32_t *) (0x40013000 + 0)))

  // Field IOLOCK: Locking the AF configuration of associated IOs
    const uint32_t SPI1_CR1_IOLOCK = 1U << 16 ;

  // Field TCRCI: CRC calculation initialization pattern control for transmitter
    const uint32_t SPI1_CR1_TCRCI = 1U << 15 ;

  // Field RCRCI: CRC calculation initialization pattern control for receiver
    const uint32_t SPI1_CR1_RCRCI = 1U << 14 ;

  // Field CRC33_17: 32-bit CRC polynomial configuration
    const uint32_t SPI1_CR1_CRC33_17 = 1U << 13 ;

  // Field SSI: Internal SS signal input level
    const uint32_t SPI1_CR1_SSI = 1U << 12 ;

  // Field HDDIR: Rx/Tx direction at Half-duplex mode
    const uint32_t SPI1_CR1_HDDIR = 1U << 11 ;

  // Field CSUSP: Master SUSPend request
    const uint32_t SPI1_CR1_CSUSP = 1U << 10 ;

  // Field CSTART: Master transfer start
    const uint32_t SPI1_CR1_CSTART = 1U << 9 ;

  // Field MASRX: Master automatic SUSP in Receive mode
    const uint32_t SPI1_CR1_MASRX = 1U << 8 ;

  // Field SPE: Serial Peripheral Enable
    const uint32_t SPI1_CR1_SPE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define SPI1_CR2 (* ((volatile uint32_t *) (0x40013000 + 4)))

  // Field TSER: Number of data transfer extension to be reload into TSIZE just when a previous
    inline uint32_t SPI1_CR2_TSER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field TSIZE: Number of data at current transfer
    inline uint32_t SPI1_CR2_TSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG1: configuration register 1
  #define SPI1_CFG1 (* ((volatile uint32_t *) (0x40013000 + 8)))

  // Field MBR: Master baud rate
    inline uint32_t SPI1_CFG1_MBR (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field CRCEN: Hardware CRC computation enable
    const uint32_t SPI1_CFG1_CRCEN = 1U << 22 ;

  // Field CRCSIZE: Length of CRC frame to be transacted and compared
    inline uint32_t SPI1_CFG1_CRCSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TXDMAEN: Tx DMA stream enable
    const uint32_t SPI1_CFG1_TXDMAEN = 1U << 15 ;

  // Field RXDMAEN: Rx DMA stream enable
    const uint32_t SPI1_CFG1_RXDMAEN = 1U << 14 ;

  // Field UDRDET: Detection of underrun condition at slave transmitter
    inline uint32_t SPI1_CFG1_UDRDET (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field UDRCFG: Behavior of slave transmitter at underrun condition
    inline uint32_t SPI1_CFG1_UDRCFG (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field FTHVL: threshold level
    inline uint32_t SPI1_CFG1_FTHVL (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field DSIZE: Number of bits in at single SPI data frame
    inline uint32_t SPI1_CFG1_DSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG2: configuration register 2
  #define SPI1_CFG2 (* ((volatile uint32_t *) (0x40013000 + 12)))

  // Field AFCNTR: Alternate function GPIOs control
    const uint32_t SPI1_CFG2_AFCNTR = 1U << 31 ;

  // Field SSOM: SS output management in master mode
    const uint32_t SPI1_CFG2_SSOM = 1U << 30 ;

  // Field SSOE: SS output enable
    const uint32_t SPI1_CFG2_SSOE = 1U << 29 ;

  // Field SSIOP: SS input/output polarity
    const uint32_t SPI1_CFG2_SSIOP = 1U << 28 ;

  // Field SSM: Software management of SS signal input
    const uint32_t SPI1_CFG2_SSM = 1U << 26 ;

  // Field CPOL: Clock polarity
    const uint32_t SPI1_CFG2_CPOL = 1U << 25 ;

  // Field CPHA: Clock phase
    const uint32_t SPI1_CFG2_CPHA = 1U << 24 ;

  // Field LSBFRST: Data frame format
    const uint32_t SPI1_CFG2_LSBFRST = 1U << 23 ;

  // Field MASTER: SPI Master
    const uint32_t SPI1_CFG2_MASTER = 1U << 22 ;

  // Field SP: Serial Protocol
    inline uint32_t SPI1_CFG2_SP (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field COMM: SPI Communication Mode
    inline uint32_t SPI1_CFG2_COMM (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field IOSWP: Swap functionality of MISO and MOSI pins
    const uint32_t SPI1_CFG2_IOSWP = 1U << 15 ;

  // Field MIDI: Master Inter-Data Idleness
    inline uint32_t SPI1_CFG2_MIDI (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field MSSI: Master SS Idleness
    inline uint32_t SPI1_CFG2_MSSI (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define SPI1_IER (* ((volatile uint32_t *) (0x40013000 + 16)))

  // Field TSERFIE: Additional number of transactions reload interrupt enable
    const uint32_t SPI1_IER_TSERFIE = 1U << 10 ;

  // Field MODFIE: Mode Fault interrupt enable
    const uint32_t SPI1_IER_MODFIE = 1U << 9 ;

  // Field TIFREIE: TIFRE interrupt enable
    const uint32_t SPI1_IER_TIFREIE = 1U << 8 ;

  // Field CRCEIE: CRC Interrupt enable
    const uint32_t SPI1_IER_CRCEIE = 1U << 7 ;

  // Field OVRIE: OVR interrupt enable
    const uint32_t SPI1_IER_OVRIE = 1U << 6 ;

  // Field UDRIE: UDR interrupt enable
    const uint32_t SPI1_IER_UDRIE = 1U << 5 ;

  // Field TXTFIE: TXTFIE interrupt enable
    const uint32_t SPI1_IER_TXTFIE = 1U << 4 ;

  // Field EOTIE: EOT, SUSP and TXC interrupt enable
    const uint32_t SPI1_IER_EOTIE = 1U << 3 ;

  // Field DPXPIE: DXP interrupt enabled
    const uint32_t SPI1_IER_DPXPIE = 1U << 2 ;

  // Field TXPIE: TXP interrupt enable
    const uint32_t SPI1_IER_TXPIE = 1U << 1 ;

  // Field RXPIE: RXP Interrupt Enable
    const uint32_t SPI1_IER_RXPIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: Status Register
  #define SPI1_SR (* ((const volatile uint32_t *) (0x40013000 + 20)))

  // Field CTSIZE: Number of data frames remaining in current TSIZE session
    inline uint32_t SPI1_SR_CTSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RXWNE: RxFIFO Word Not Empty
    const uint32_t SPI1_SR_RXWNE = 1U << 15 ;

  // Field RXPLVL: RxFIFO Packing LeVeL
    inline uint32_t SPI1_SR_RXPLVL (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TXC: TxFIFO transmission complete
    const uint32_t SPI1_SR_TXC = 1U << 12 ;

  // Field SUSP: SUSPend
    const uint32_t SPI1_SR_SUSP = 1U << 11 ;

  // Field TSERF: Additional number of SPI data to be transacted was reload
    const uint32_t SPI1_SR_TSERF = 1U << 10 ;

  // Field MODF: Mode Fault
    const uint32_t SPI1_SR_MODF = 1U << 9 ;

  // Field TIFRE: TI frame format error
    const uint32_t SPI1_SR_TIFRE = 1U << 8 ;

  // Field CRCE: CRC Error
    const uint32_t SPI1_SR_CRCE = 1U << 7 ;

  // Field OVR: Overrun
    const uint32_t SPI1_SR_OVR = 1U << 6 ;

  // Field UDR: Underrun at slave transmission mode
    const uint32_t SPI1_SR_UDR = 1U << 5 ;

  // Field TXTF: Transmission Transfer Filled
    const uint32_t SPI1_SR_TXTF = 1U << 4 ;

  // Field EOT: End Of Transfer
    const uint32_t SPI1_SR_EOT = 1U << 3 ;

  // Field DXP: Duplex Packet
    const uint32_t SPI1_SR_DXP = 1U << 2 ;

  // Field TXP: Tx-Packet space available
    const uint32_t SPI1_SR_TXP = 1U << 1 ;

  // Field RXP: Rx-Packet available
    const uint32_t SPI1_SR_RXP = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt/Status Flags Clear Register
  #define SPI1_IFCR (* ((volatile uint32_t *) (0x40013000 + 24)))

  // Field SUSPC: SUSPend flag clear
    const uint32_t SPI1_IFCR_SUSPC = 1U << 11 ;

  // Field TSERFC: TSERFC flag clear
    const uint32_t SPI1_IFCR_TSERFC = 1U << 10 ;

  // Field MODFC: Mode Fault flag clear
    const uint32_t SPI1_IFCR_MODFC = 1U << 9 ;

  // Field TIFREC: TI frame format error flag clear
    const uint32_t SPI1_IFCR_TIFREC = 1U << 8 ;

  // Field CRCEC: CRC Error flag clear
    const uint32_t SPI1_IFCR_CRCEC = 1U << 7 ;

  // Field OVRC: Overrun flag clear
    const uint32_t SPI1_IFCR_OVRC = 1U << 6 ;

  // Field UDRC: Underrun flag clear
    const uint32_t SPI1_IFCR_UDRC = 1U << 5 ;

  // Field TXTFC: Transmission Transfer Filled flag clear
    const uint32_t SPI1_IFCR_TXTFC = 1U << 4 ;

  // Field EOTC: End Of Transfer flag clear
    const uint32_t SPI1_IFCR_EOTC = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register TXDR: Transmit Data Register
  #define SPI1_TXDR (* ((volatile uint32_t *) (0x40013000 + 32)))

  // Field TXDR: Transmit data register
    inline uint32_t SPI1_TXDR_TXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Receive Data Register
  #define SPI1_RXDR (* ((const volatile uint32_t *) (0x40013000 + 48)))

  // Field RXDR: Receive data register
    inline uint32_t SPI1_RXDR_RXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCPOLY: Polynomial Register
  #define SPI1_CRCPOLY (* ((volatile uint32_t *) (0x40013000 + 64)))

  // Field CRCPOLY: CRC polynomial register
    inline uint32_t SPI1_CRCPOLY_CRCPOLY (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXCRC: Transmitter CRC Register
  #define SPI1_TXCRC (* ((volatile uint32_t *) (0x40013000 + 68)))

  // Field TXCRC: CRC register for transmitter
    inline uint32_t SPI1_TXCRC_TXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXCRC: Receiver CRC Register
  #define SPI1_RXCRC (* ((volatile uint32_t *) (0x40013000 + 72)))

  // Field RXCRC: CRC register for receiver
    inline uint32_t SPI1_RXCRC_RXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UDRDR: Underrun Data Register
  #define SPI1_UDRDR (* ((volatile uint32_t *) (0x40013000 + 76)))

  // Field UDRDR: Data at slave underrun condition
    inline uint32_t SPI1_UDRDR_UDRDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CGFR: configuration register
  #define SPI1_CGFR (* ((volatile uint32_t *) (0x40013000 + 80)))

  // Field MCKOE: Master clock output enable
    const uint32_t SPI1_CGFR_MCKOE = 1U << 25 ;

  // Field ODD: Odd factor for the prescaler
    const uint32_t SPI1_CGFR_ODD = 1U << 24 ;

  // Field I2SDIV: I2S linear prescaler
    inline uint32_t SPI1_CGFR_I2SDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DATFMT: Data format
    const uint32_t SPI1_CGFR_DATFMT = 1U << 14 ;

  // Field WSINV: Fixed channel length in SLAVE
    const uint32_t SPI1_CGFR_WSINV = 1U << 13 ;

  // Field FIXCH: Word select inversion
    const uint32_t SPI1_CGFR_FIXCH = 1U << 12 ;

  // Field CKPOL: Serial audio clock polarity
    const uint32_t SPI1_CGFR_CKPOL = 1U << 11 ;

  // Field CHLEN: Channel length (number of bits per audio channel)
    const uint32_t SPI1_CGFR_CHLEN = 1U << 10 ;

  // Field DATLEN: Data length to be transferred
    inline uint32_t SPI1_CGFR_DATLEN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCMSYNC: PCM frame synchronization
    const uint32_t SPI1_CGFR_PCMSYNC = 1U << 7 ;

  // Field I2SSTD: I2S standard selection
    inline uint32_t SPI1_CGFR_I2SSTD (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field I2SCFG: I2S configuration mode
    inline uint32_t SPI1_CGFR_I2SCFG (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

  // Field I2SMOD: I2S mode selection
    const uint32_t SPI1_CGFR_I2SMOD = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral SPI2
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define SPI2_CR1 (* ((volatile uint32_t *) (0x40003800 + 0)))

  // Field IOLOCK: Locking the AF configuration of associated IOs
    const uint32_t SPI2_CR1_IOLOCK = 1U << 16 ;

  // Field TCRCI: CRC calculation initialization pattern control for transmitter
    const uint32_t SPI2_CR1_TCRCI = 1U << 15 ;

  // Field RCRCI: CRC calculation initialization pattern control for receiver
    const uint32_t SPI2_CR1_RCRCI = 1U << 14 ;

  // Field CRC33_17: 32-bit CRC polynomial configuration
    const uint32_t SPI2_CR1_CRC33_17 = 1U << 13 ;

  // Field SSI: Internal SS signal input level
    const uint32_t SPI2_CR1_SSI = 1U << 12 ;

  // Field HDDIR: Rx/Tx direction at Half-duplex mode
    const uint32_t SPI2_CR1_HDDIR = 1U << 11 ;

  // Field CSUSP: Master SUSPend request
    const uint32_t SPI2_CR1_CSUSP = 1U << 10 ;

  // Field CSTART: Master transfer start
    const uint32_t SPI2_CR1_CSTART = 1U << 9 ;

  // Field MASRX: Master automatic SUSP in Receive mode
    const uint32_t SPI2_CR1_MASRX = 1U << 8 ;

  // Field SPE: Serial Peripheral Enable
    const uint32_t SPI2_CR1_SPE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define SPI2_CR2 (* ((volatile uint32_t *) (0x40003800 + 4)))

  // Field TSER: Number of data transfer extension to be reload into TSIZE just when a previous
    inline uint32_t SPI2_CR2_TSER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field TSIZE: Number of data at current transfer
    inline uint32_t SPI2_CR2_TSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG1: configuration register 1
  #define SPI2_CFG1 (* ((volatile uint32_t *) (0x40003800 + 8)))

  // Field MBR: Master baud rate
    inline uint32_t SPI2_CFG1_MBR (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field CRCEN: Hardware CRC computation enable
    const uint32_t SPI2_CFG1_CRCEN = 1U << 22 ;

  // Field CRCSIZE: Length of CRC frame to be transacted and compared
    inline uint32_t SPI2_CFG1_CRCSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TXDMAEN: Tx DMA stream enable
    const uint32_t SPI2_CFG1_TXDMAEN = 1U << 15 ;

  // Field RXDMAEN: Rx DMA stream enable
    const uint32_t SPI2_CFG1_RXDMAEN = 1U << 14 ;

  // Field UDRDET: Detection of underrun condition at slave transmitter
    inline uint32_t SPI2_CFG1_UDRDET (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field UDRCFG: Behavior of slave transmitter at underrun condition
    inline uint32_t SPI2_CFG1_UDRCFG (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field FTHVL: threshold level
    inline uint32_t SPI2_CFG1_FTHVL (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field DSIZE: Number of bits in at single SPI data frame
    inline uint32_t SPI2_CFG1_DSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG2: configuration register 2
  #define SPI2_CFG2 (* ((volatile uint32_t *) (0x40003800 + 12)))

  // Field AFCNTR: Alternate function GPIOs control
    const uint32_t SPI2_CFG2_AFCNTR = 1U << 31 ;

  // Field SSOM: SS output management in master mode
    const uint32_t SPI2_CFG2_SSOM = 1U << 30 ;

  // Field SSOE: SS output enable
    const uint32_t SPI2_CFG2_SSOE = 1U << 29 ;

  // Field SSIOP: SS input/output polarity
    const uint32_t SPI2_CFG2_SSIOP = 1U << 28 ;

  // Field SSM: Software management of SS signal input
    const uint32_t SPI2_CFG2_SSM = 1U << 26 ;

  // Field CPOL: Clock polarity
    const uint32_t SPI2_CFG2_CPOL = 1U << 25 ;

  // Field CPHA: Clock phase
    const uint32_t SPI2_CFG2_CPHA = 1U << 24 ;

  // Field LSBFRST: Data frame format
    const uint32_t SPI2_CFG2_LSBFRST = 1U << 23 ;

  // Field MASTER: SPI Master
    const uint32_t SPI2_CFG2_MASTER = 1U << 22 ;

  // Field SP: Serial Protocol
    inline uint32_t SPI2_CFG2_SP (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field COMM: SPI Communication Mode
    inline uint32_t SPI2_CFG2_COMM (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field IOSWP: Swap functionality of MISO and MOSI pins
    const uint32_t SPI2_CFG2_IOSWP = 1U << 15 ;

  // Field MIDI: Master Inter-Data Idleness
    inline uint32_t SPI2_CFG2_MIDI (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field MSSI: Master SS Idleness
    inline uint32_t SPI2_CFG2_MSSI (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define SPI2_IER (* ((volatile uint32_t *) (0x40003800 + 16)))

  // Field TSERFIE: Additional number of transactions reload interrupt enable
    const uint32_t SPI2_IER_TSERFIE = 1U << 10 ;

  // Field MODFIE: Mode Fault interrupt enable
    const uint32_t SPI2_IER_MODFIE = 1U << 9 ;

  // Field TIFREIE: TIFRE interrupt enable
    const uint32_t SPI2_IER_TIFREIE = 1U << 8 ;

  // Field CRCEIE: CRC Interrupt enable
    const uint32_t SPI2_IER_CRCEIE = 1U << 7 ;

  // Field OVRIE: OVR interrupt enable
    const uint32_t SPI2_IER_OVRIE = 1U << 6 ;

  // Field UDRIE: UDR interrupt enable
    const uint32_t SPI2_IER_UDRIE = 1U << 5 ;

  // Field TXTFIE: TXTFIE interrupt enable
    const uint32_t SPI2_IER_TXTFIE = 1U << 4 ;

  // Field EOTIE: EOT, SUSP and TXC interrupt enable
    const uint32_t SPI2_IER_EOTIE = 1U << 3 ;

  // Field DPXPIE: DXP interrupt enabled
    const uint32_t SPI2_IER_DPXPIE = 1U << 2 ;

  // Field TXPIE: TXP interrupt enable
    const uint32_t SPI2_IER_TXPIE = 1U << 1 ;

  // Field RXPIE: RXP Interrupt Enable
    const uint32_t SPI2_IER_RXPIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: Status Register
  #define SPI2_SR (* ((const volatile uint32_t *) (0x40003800 + 20)))

  // Field CTSIZE: Number of data frames remaining in current TSIZE session
    inline uint32_t SPI2_SR_CTSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RXWNE: RxFIFO Word Not Empty
    const uint32_t SPI2_SR_RXWNE = 1U << 15 ;

  // Field RXPLVL: RxFIFO Packing LeVeL
    inline uint32_t SPI2_SR_RXPLVL (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TXC: TxFIFO transmission complete
    const uint32_t SPI2_SR_TXC = 1U << 12 ;

  // Field SUSP: SUSPend
    const uint32_t SPI2_SR_SUSP = 1U << 11 ;

  // Field TSERF: Additional number of SPI data to be transacted was reload
    const uint32_t SPI2_SR_TSERF = 1U << 10 ;

  // Field MODF: Mode Fault
    const uint32_t SPI2_SR_MODF = 1U << 9 ;

  // Field TIFRE: TI frame format error
    const uint32_t SPI2_SR_TIFRE = 1U << 8 ;

  // Field CRCE: CRC Error
    const uint32_t SPI2_SR_CRCE = 1U << 7 ;

  // Field OVR: Overrun
    const uint32_t SPI2_SR_OVR = 1U << 6 ;

  // Field UDR: Underrun at slave transmission mode
    const uint32_t SPI2_SR_UDR = 1U << 5 ;

  // Field TXTF: Transmission Transfer Filled
    const uint32_t SPI2_SR_TXTF = 1U << 4 ;

  // Field EOT: End Of Transfer
    const uint32_t SPI2_SR_EOT = 1U << 3 ;

  // Field DXP: Duplex Packet
    const uint32_t SPI2_SR_DXP = 1U << 2 ;

  // Field TXP: Tx-Packet space available
    const uint32_t SPI2_SR_TXP = 1U << 1 ;

  // Field RXP: Rx-Packet available
    const uint32_t SPI2_SR_RXP = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt/Status Flags Clear Register
  #define SPI2_IFCR (* ((volatile uint32_t *) (0x40003800 + 24)))

  // Field SUSPC: SUSPend flag clear
    const uint32_t SPI2_IFCR_SUSPC = 1U << 11 ;

  // Field TSERFC: TSERFC flag clear
    const uint32_t SPI2_IFCR_TSERFC = 1U << 10 ;

  // Field MODFC: Mode Fault flag clear
    const uint32_t SPI2_IFCR_MODFC = 1U << 9 ;

  // Field TIFREC: TI frame format error flag clear
    const uint32_t SPI2_IFCR_TIFREC = 1U << 8 ;

  // Field CRCEC: CRC Error flag clear
    const uint32_t SPI2_IFCR_CRCEC = 1U << 7 ;

  // Field OVRC: Overrun flag clear
    const uint32_t SPI2_IFCR_OVRC = 1U << 6 ;

  // Field UDRC: Underrun flag clear
    const uint32_t SPI2_IFCR_UDRC = 1U << 5 ;

  // Field TXTFC: Transmission Transfer Filled flag clear
    const uint32_t SPI2_IFCR_TXTFC = 1U << 4 ;

  // Field EOTC: End Of Transfer flag clear
    const uint32_t SPI2_IFCR_EOTC = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register TXDR: Transmit Data Register
  #define SPI2_TXDR (* ((volatile uint32_t *) (0x40003800 + 32)))

  // Field TXDR: Transmit data register
    inline uint32_t SPI2_TXDR_TXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Receive Data Register
  #define SPI2_RXDR (* ((const volatile uint32_t *) (0x40003800 + 48)))

  // Field RXDR: Receive data register
    inline uint32_t SPI2_RXDR_RXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCPOLY: Polynomial Register
  #define SPI2_CRCPOLY (* ((volatile uint32_t *) (0x40003800 + 64)))

  // Field CRCPOLY: CRC polynomial register
    inline uint32_t SPI2_CRCPOLY_CRCPOLY (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXCRC: Transmitter CRC Register
  #define SPI2_TXCRC (* ((volatile uint32_t *) (0x40003800 + 68)))

  // Field TXCRC: CRC register for transmitter
    inline uint32_t SPI2_TXCRC_TXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXCRC: Receiver CRC Register
  #define SPI2_RXCRC (* ((volatile uint32_t *) (0x40003800 + 72)))

  // Field RXCRC: CRC register for receiver
    inline uint32_t SPI2_RXCRC_RXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UDRDR: Underrun Data Register
  #define SPI2_UDRDR (* ((volatile uint32_t *) (0x40003800 + 76)))

  // Field UDRDR: Data at slave underrun condition
    inline uint32_t SPI2_UDRDR_UDRDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CGFR: configuration register
  #define SPI2_CGFR (* ((volatile uint32_t *) (0x40003800 + 80)))

  // Field MCKOE: Master clock output enable
    const uint32_t SPI2_CGFR_MCKOE = 1U << 25 ;

  // Field ODD: Odd factor for the prescaler
    const uint32_t SPI2_CGFR_ODD = 1U << 24 ;

  // Field I2SDIV: I2S linear prescaler
    inline uint32_t SPI2_CGFR_I2SDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DATFMT: Data format
    const uint32_t SPI2_CGFR_DATFMT = 1U << 14 ;

  // Field WSINV: Fixed channel length in SLAVE
    const uint32_t SPI2_CGFR_WSINV = 1U << 13 ;

  // Field FIXCH: Word select inversion
    const uint32_t SPI2_CGFR_FIXCH = 1U << 12 ;

  // Field CKPOL: Serial audio clock polarity
    const uint32_t SPI2_CGFR_CKPOL = 1U << 11 ;

  // Field CHLEN: Channel length (number of bits per audio channel)
    const uint32_t SPI2_CGFR_CHLEN = 1U << 10 ;

  // Field DATLEN: Data length to be transferred
    inline uint32_t SPI2_CGFR_DATLEN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCMSYNC: PCM frame synchronization
    const uint32_t SPI2_CGFR_PCMSYNC = 1U << 7 ;

  // Field I2SSTD: I2S standard selection
    inline uint32_t SPI2_CGFR_I2SSTD (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field I2SCFG: I2S configuration mode
    inline uint32_t SPI2_CGFR_I2SCFG (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

  // Field I2SMOD: I2S mode selection
    const uint32_t SPI2_CGFR_I2SMOD = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral SPI3
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define SPI3_CR1 (* ((volatile uint32_t *) (0x40003C00 + 0)))

  // Field IOLOCK: Locking the AF configuration of associated IOs
    const uint32_t SPI3_CR1_IOLOCK = 1U << 16 ;

  // Field TCRCI: CRC calculation initialization pattern control for transmitter
    const uint32_t SPI3_CR1_TCRCI = 1U << 15 ;

  // Field RCRCI: CRC calculation initialization pattern control for receiver
    const uint32_t SPI3_CR1_RCRCI = 1U << 14 ;

  // Field CRC33_17: 32-bit CRC polynomial configuration
    const uint32_t SPI3_CR1_CRC33_17 = 1U << 13 ;

  // Field SSI: Internal SS signal input level
    const uint32_t SPI3_CR1_SSI = 1U << 12 ;

  // Field HDDIR: Rx/Tx direction at Half-duplex mode
    const uint32_t SPI3_CR1_HDDIR = 1U << 11 ;

  // Field CSUSP: Master SUSPend request
    const uint32_t SPI3_CR1_CSUSP = 1U << 10 ;

  // Field CSTART: Master transfer start
    const uint32_t SPI3_CR1_CSTART = 1U << 9 ;

  // Field MASRX: Master automatic SUSP in Receive mode
    const uint32_t SPI3_CR1_MASRX = 1U << 8 ;

  // Field SPE: Serial Peripheral Enable
    const uint32_t SPI3_CR1_SPE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define SPI3_CR2 (* ((volatile uint32_t *) (0x40003C00 + 4)))

  // Field TSER: Number of data transfer extension to be reload into TSIZE just when a previous
    inline uint32_t SPI3_CR2_TSER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field TSIZE: Number of data at current transfer
    inline uint32_t SPI3_CR2_TSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG1: configuration register 1
  #define SPI3_CFG1 (* ((volatile uint32_t *) (0x40003C00 + 8)))

  // Field MBR: Master baud rate
    inline uint32_t SPI3_CFG1_MBR (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field CRCEN: Hardware CRC computation enable
    const uint32_t SPI3_CFG1_CRCEN = 1U << 22 ;

  // Field CRCSIZE: Length of CRC frame to be transacted and compared
    inline uint32_t SPI3_CFG1_CRCSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TXDMAEN: Tx DMA stream enable
    const uint32_t SPI3_CFG1_TXDMAEN = 1U << 15 ;

  // Field RXDMAEN: Rx DMA stream enable
    const uint32_t SPI3_CFG1_RXDMAEN = 1U << 14 ;

  // Field UDRDET: Detection of underrun condition at slave transmitter
    inline uint32_t SPI3_CFG1_UDRDET (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field UDRCFG: Behavior of slave transmitter at underrun condition
    inline uint32_t SPI3_CFG1_UDRCFG (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field FTHVL: threshold level
    inline uint32_t SPI3_CFG1_FTHVL (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field DSIZE: Number of bits in at single SPI data frame
    inline uint32_t SPI3_CFG1_DSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG2: configuration register 2
  #define SPI3_CFG2 (* ((volatile uint32_t *) (0x40003C00 + 12)))

  // Field AFCNTR: Alternate function GPIOs control
    const uint32_t SPI3_CFG2_AFCNTR = 1U << 31 ;

  // Field SSOM: SS output management in master mode
    const uint32_t SPI3_CFG2_SSOM = 1U << 30 ;

  // Field SSOE: SS output enable
    const uint32_t SPI3_CFG2_SSOE = 1U << 29 ;

  // Field SSIOP: SS input/output polarity
    const uint32_t SPI3_CFG2_SSIOP = 1U << 28 ;

  // Field SSM: Software management of SS signal input
    const uint32_t SPI3_CFG2_SSM = 1U << 26 ;

  // Field CPOL: Clock polarity
    const uint32_t SPI3_CFG2_CPOL = 1U << 25 ;

  // Field CPHA: Clock phase
    const uint32_t SPI3_CFG2_CPHA = 1U << 24 ;

  // Field LSBFRST: Data frame format
    const uint32_t SPI3_CFG2_LSBFRST = 1U << 23 ;

  // Field MASTER: SPI Master
    const uint32_t SPI3_CFG2_MASTER = 1U << 22 ;

  // Field SP: Serial Protocol
    inline uint32_t SPI3_CFG2_SP (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field COMM: SPI Communication Mode
    inline uint32_t SPI3_CFG2_COMM (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field IOSWP: Swap functionality of MISO and MOSI pins
    const uint32_t SPI3_CFG2_IOSWP = 1U << 15 ;

  // Field MIDI: Master Inter-Data Idleness
    inline uint32_t SPI3_CFG2_MIDI (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field MSSI: Master SS Idleness
    inline uint32_t SPI3_CFG2_MSSI (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define SPI3_IER (* ((volatile uint32_t *) (0x40003C00 + 16)))

  // Field TSERFIE: Additional number of transactions reload interrupt enable
    const uint32_t SPI3_IER_TSERFIE = 1U << 10 ;

  // Field MODFIE: Mode Fault interrupt enable
    const uint32_t SPI3_IER_MODFIE = 1U << 9 ;

  // Field TIFREIE: TIFRE interrupt enable
    const uint32_t SPI3_IER_TIFREIE = 1U << 8 ;

  // Field CRCEIE: CRC Interrupt enable
    const uint32_t SPI3_IER_CRCEIE = 1U << 7 ;

  // Field OVRIE: OVR interrupt enable
    const uint32_t SPI3_IER_OVRIE = 1U << 6 ;

  // Field UDRIE: UDR interrupt enable
    const uint32_t SPI3_IER_UDRIE = 1U << 5 ;

  // Field TXTFIE: TXTFIE interrupt enable
    const uint32_t SPI3_IER_TXTFIE = 1U << 4 ;

  // Field EOTIE: EOT, SUSP and TXC interrupt enable
    const uint32_t SPI3_IER_EOTIE = 1U << 3 ;

  // Field DPXPIE: DXP interrupt enabled
    const uint32_t SPI3_IER_DPXPIE = 1U << 2 ;

  // Field TXPIE: TXP interrupt enable
    const uint32_t SPI3_IER_TXPIE = 1U << 1 ;

  // Field RXPIE: RXP Interrupt Enable
    const uint32_t SPI3_IER_RXPIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: Status Register
  #define SPI3_SR (* ((const volatile uint32_t *) (0x40003C00 + 20)))

  // Field CTSIZE: Number of data frames remaining in current TSIZE session
    inline uint32_t SPI3_SR_CTSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RXWNE: RxFIFO Word Not Empty
    const uint32_t SPI3_SR_RXWNE = 1U << 15 ;

  // Field RXPLVL: RxFIFO Packing LeVeL
    inline uint32_t SPI3_SR_RXPLVL (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TXC: TxFIFO transmission complete
    const uint32_t SPI3_SR_TXC = 1U << 12 ;

  // Field SUSP: SUSPend
    const uint32_t SPI3_SR_SUSP = 1U << 11 ;

  // Field TSERF: Additional number of SPI data to be transacted was reload
    const uint32_t SPI3_SR_TSERF = 1U << 10 ;

  // Field MODF: Mode Fault
    const uint32_t SPI3_SR_MODF = 1U << 9 ;

  // Field TIFRE: TI frame format error
    const uint32_t SPI3_SR_TIFRE = 1U << 8 ;

  // Field CRCE: CRC Error
    const uint32_t SPI3_SR_CRCE = 1U << 7 ;

  // Field OVR: Overrun
    const uint32_t SPI3_SR_OVR = 1U << 6 ;

  // Field UDR: Underrun at slave transmission mode
    const uint32_t SPI3_SR_UDR = 1U << 5 ;

  // Field TXTF: Transmission Transfer Filled
    const uint32_t SPI3_SR_TXTF = 1U << 4 ;

  // Field EOT: End Of Transfer
    const uint32_t SPI3_SR_EOT = 1U << 3 ;

  // Field DXP: Duplex Packet
    const uint32_t SPI3_SR_DXP = 1U << 2 ;

  // Field TXP: Tx-Packet space available
    const uint32_t SPI3_SR_TXP = 1U << 1 ;

  // Field RXP: Rx-Packet available
    const uint32_t SPI3_SR_RXP = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt/Status Flags Clear Register
  #define SPI3_IFCR (* ((volatile uint32_t *) (0x40003C00 + 24)))

  // Field SUSPC: SUSPend flag clear
    const uint32_t SPI3_IFCR_SUSPC = 1U << 11 ;

  // Field TSERFC: TSERFC flag clear
    const uint32_t SPI3_IFCR_TSERFC = 1U << 10 ;

  // Field MODFC: Mode Fault flag clear
    const uint32_t SPI3_IFCR_MODFC = 1U << 9 ;

  // Field TIFREC: TI frame format error flag clear
    const uint32_t SPI3_IFCR_TIFREC = 1U << 8 ;

  // Field CRCEC: CRC Error flag clear
    const uint32_t SPI3_IFCR_CRCEC = 1U << 7 ;

  // Field OVRC: Overrun flag clear
    const uint32_t SPI3_IFCR_OVRC = 1U << 6 ;

  // Field UDRC: Underrun flag clear
    const uint32_t SPI3_IFCR_UDRC = 1U << 5 ;

  // Field TXTFC: Transmission Transfer Filled flag clear
    const uint32_t SPI3_IFCR_TXTFC = 1U << 4 ;

  // Field EOTC: End Of Transfer flag clear
    const uint32_t SPI3_IFCR_EOTC = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register TXDR: Transmit Data Register
  #define SPI3_TXDR (* ((volatile uint32_t *) (0x40003C00 + 32)))

  // Field TXDR: Transmit data register
    inline uint32_t SPI3_TXDR_TXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Receive Data Register
  #define SPI3_RXDR (* ((const volatile uint32_t *) (0x40003C00 + 48)))

  // Field RXDR: Receive data register
    inline uint32_t SPI3_RXDR_RXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCPOLY: Polynomial Register
  #define SPI3_CRCPOLY (* ((volatile uint32_t *) (0x40003C00 + 64)))

  // Field CRCPOLY: CRC polynomial register
    inline uint32_t SPI3_CRCPOLY_CRCPOLY (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXCRC: Transmitter CRC Register
  #define SPI3_TXCRC (* ((volatile uint32_t *) (0x40003C00 + 68)))

  // Field TXCRC: CRC register for transmitter
    inline uint32_t SPI3_TXCRC_TXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXCRC: Receiver CRC Register
  #define SPI3_RXCRC (* ((volatile uint32_t *) (0x40003C00 + 72)))

  // Field RXCRC: CRC register for receiver
    inline uint32_t SPI3_RXCRC_RXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UDRDR: Underrun Data Register
  #define SPI3_UDRDR (* ((volatile uint32_t *) (0x40003C00 + 76)))

  // Field UDRDR: Data at slave underrun condition
    inline uint32_t SPI3_UDRDR_UDRDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CGFR: configuration register
  #define SPI3_CGFR (* ((volatile uint32_t *) (0x40003C00 + 80)))

  // Field MCKOE: Master clock output enable
    const uint32_t SPI3_CGFR_MCKOE = 1U << 25 ;

  // Field ODD: Odd factor for the prescaler
    const uint32_t SPI3_CGFR_ODD = 1U << 24 ;

  // Field I2SDIV: I2S linear prescaler
    inline uint32_t SPI3_CGFR_I2SDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DATFMT: Data format
    const uint32_t SPI3_CGFR_DATFMT = 1U << 14 ;

  // Field WSINV: Fixed channel length in SLAVE
    const uint32_t SPI3_CGFR_WSINV = 1U << 13 ;

  // Field FIXCH: Word select inversion
    const uint32_t SPI3_CGFR_FIXCH = 1U << 12 ;

  // Field CKPOL: Serial audio clock polarity
    const uint32_t SPI3_CGFR_CKPOL = 1U << 11 ;

  // Field CHLEN: Channel length (number of bits per audio channel)
    const uint32_t SPI3_CGFR_CHLEN = 1U << 10 ;

  // Field DATLEN: Data length to be transferred
    inline uint32_t SPI3_CGFR_DATLEN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCMSYNC: PCM frame synchronization
    const uint32_t SPI3_CGFR_PCMSYNC = 1U << 7 ;

  // Field I2SSTD: I2S standard selection
    inline uint32_t SPI3_CGFR_I2SSTD (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field I2SCFG: I2S configuration mode
    inline uint32_t SPI3_CGFR_I2SCFG (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

  // Field I2SMOD: I2S mode selection
    const uint32_t SPI3_CGFR_I2SMOD = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral SPI4
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define SPI4_CR1 (* ((volatile uint32_t *) (0x40013400 + 0)))

  // Field IOLOCK: Locking the AF configuration of associated IOs
    const uint32_t SPI4_CR1_IOLOCK = 1U << 16 ;

  // Field TCRCI: CRC calculation initialization pattern control for transmitter
    const uint32_t SPI4_CR1_TCRCI = 1U << 15 ;

  // Field RCRCI: CRC calculation initialization pattern control for receiver
    const uint32_t SPI4_CR1_RCRCI = 1U << 14 ;

  // Field CRC33_17: 32-bit CRC polynomial configuration
    const uint32_t SPI4_CR1_CRC33_17 = 1U << 13 ;

  // Field SSI: Internal SS signal input level
    const uint32_t SPI4_CR1_SSI = 1U << 12 ;

  // Field HDDIR: Rx/Tx direction at Half-duplex mode
    const uint32_t SPI4_CR1_HDDIR = 1U << 11 ;

  // Field CSUSP: Master SUSPend request
    const uint32_t SPI4_CR1_CSUSP = 1U << 10 ;

  // Field CSTART: Master transfer start
    const uint32_t SPI4_CR1_CSTART = 1U << 9 ;

  // Field MASRX: Master automatic SUSP in Receive mode
    const uint32_t SPI4_CR1_MASRX = 1U << 8 ;

  // Field SPE: Serial Peripheral Enable
    const uint32_t SPI4_CR1_SPE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define SPI4_CR2 (* ((volatile uint32_t *) (0x40013400 + 4)))

  // Field TSER: Number of data transfer extension to be reload into TSIZE just when a previous
    inline uint32_t SPI4_CR2_TSER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field TSIZE: Number of data at current transfer
    inline uint32_t SPI4_CR2_TSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG1: configuration register 1
  #define SPI4_CFG1 (* ((volatile uint32_t *) (0x40013400 + 8)))

  // Field MBR: Master baud rate
    inline uint32_t SPI4_CFG1_MBR (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field CRCEN: Hardware CRC computation enable
    const uint32_t SPI4_CFG1_CRCEN = 1U << 22 ;

  // Field CRCSIZE: Length of CRC frame to be transacted and compared
    inline uint32_t SPI4_CFG1_CRCSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TXDMAEN: Tx DMA stream enable
    const uint32_t SPI4_CFG1_TXDMAEN = 1U << 15 ;

  // Field RXDMAEN: Rx DMA stream enable
    const uint32_t SPI4_CFG1_RXDMAEN = 1U << 14 ;

  // Field UDRDET: Detection of underrun condition at slave transmitter
    inline uint32_t SPI4_CFG1_UDRDET (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field UDRCFG: Behavior of slave transmitter at underrun condition
    inline uint32_t SPI4_CFG1_UDRCFG (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field FTHVL: threshold level
    inline uint32_t SPI4_CFG1_FTHVL (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field DSIZE: Number of bits in at single SPI data frame
    inline uint32_t SPI4_CFG1_DSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG2: configuration register 2
  #define SPI4_CFG2 (* ((volatile uint32_t *) (0x40013400 + 12)))

  // Field AFCNTR: Alternate function GPIOs control
    const uint32_t SPI4_CFG2_AFCNTR = 1U << 31 ;

  // Field SSOM: SS output management in master mode
    const uint32_t SPI4_CFG2_SSOM = 1U << 30 ;

  // Field SSOE: SS output enable
    const uint32_t SPI4_CFG2_SSOE = 1U << 29 ;

  // Field SSIOP: SS input/output polarity
    const uint32_t SPI4_CFG2_SSIOP = 1U << 28 ;

  // Field SSM: Software management of SS signal input
    const uint32_t SPI4_CFG2_SSM = 1U << 26 ;

  // Field CPOL: Clock polarity
    const uint32_t SPI4_CFG2_CPOL = 1U << 25 ;

  // Field CPHA: Clock phase
    const uint32_t SPI4_CFG2_CPHA = 1U << 24 ;

  // Field LSBFRST: Data frame format
    const uint32_t SPI4_CFG2_LSBFRST = 1U << 23 ;

  // Field MASTER: SPI Master
    const uint32_t SPI4_CFG2_MASTER = 1U << 22 ;

  // Field SP: Serial Protocol
    inline uint32_t SPI4_CFG2_SP (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field COMM: SPI Communication Mode
    inline uint32_t SPI4_CFG2_COMM (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field IOSWP: Swap functionality of MISO and MOSI pins
    const uint32_t SPI4_CFG2_IOSWP = 1U << 15 ;

  // Field MIDI: Master Inter-Data Idleness
    inline uint32_t SPI4_CFG2_MIDI (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field MSSI: Master SS Idleness
    inline uint32_t SPI4_CFG2_MSSI (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define SPI4_IER (* ((volatile uint32_t *) (0x40013400 + 16)))

  // Field TSERFIE: Additional number of transactions reload interrupt enable
    const uint32_t SPI4_IER_TSERFIE = 1U << 10 ;

  // Field MODFIE: Mode Fault interrupt enable
    const uint32_t SPI4_IER_MODFIE = 1U << 9 ;

  // Field TIFREIE: TIFRE interrupt enable
    const uint32_t SPI4_IER_TIFREIE = 1U << 8 ;

  // Field CRCEIE: CRC Interrupt enable
    const uint32_t SPI4_IER_CRCEIE = 1U << 7 ;

  // Field OVRIE: OVR interrupt enable
    const uint32_t SPI4_IER_OVRIE = 1U << 6 ;

  // Field UDRIE: UDR interrupt enable
    const uint32_t SPI4_IER_UDRIE = 1U << 5 ;

  // Field TXTFIE: TXTFIE interrupt enable
    const uint32_t SPI4_IER_TXTFIE = 1U << 4 ;

  // Field EOTIE: EOT, SUSP and TXC interrupt enable
    const uint32_t SPI4_IER_EOTIE = 1U << 3 ;

  // Field DPXPIE: DXP interrupt enabled
    const uint32_t SPI4_IER_DPXPIE = 1U << 2 ;

  // Field TXPIE: TXP interrupt enable
    const uint32_t SPI4_IER_TXPIE = 1U << 1 ;

  // Field RXPIE: RXP Interrupt Enable
    const uint32_t SPI4_IER_RXPIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: Status Register
  #define SPI4_SR (* ((const volatile uint32_t *) (0x40013400 + 20)))

  // Field CTSIZE: Number of data frames remaining in current TSIZE session
    inline uint32_t SPI4_SR_CTSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RXWNE: RxFIFO Word Not Empty
    const uint32_t SPI4_SR_RXWNE = 1U << 15 ;

  // Field RXPLVL: RxFIFO Packing LeVeL
    inline uint32_t SPI4_SR_RXPLVL (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TXC: TxFIFO transmission complete
    const uint32_t SPI4_SR_TXC = 1U << 12 ;

  // Field SUSP: SUSPend
    const uint32_t SPI4_SR_SUSP = 1U << 11 ;

  // Field TSERF: Additional number of SPI data to be transacted was reload
    const uint32_t SPI4_SR_TSERF = 1U << 10 ;

  // Field MODF: Mode Fault
    const uint32_t SPI4_SR_MODF = 1U << 9 ;

  // Field TIFRE: TI frame format error
    const uint32_t SPI4_SR_TIFRE = 1U << 8 ;

  // Field CRCE: CRC Error
    const uint32_t SPI4_SR_CRCE = 1U << 7 ;

  // Field OVR: Overrun
    const uint32_t SPI4_SR_OVR = 1U << 6 ;

  // Field UDR: Underrun at slave transmission mode
    const uint32_t SPI4_SR_UDR = 1U << 5 ;

  // Field TXTF: Transmission Transfer Filled
    const uint32_t SPI4_SR_TXTF = 1U << 4 ;

  // Field EOT: End Of Transfer
    const uint32_t SPI4_SR_EOT = 1U << 3 ;

  // Field DXP: Duplex Packet
    const uint32_t SPI4_SR_DXP = 1U << 2 ;

  // Field TXP: Tx-Packet space available
    const uint32_t SPI4_SR_TXP = 1U << 1 ;

  // Field RXP: Rx-Packet available
    const uint32_t SPI4_SR_RXP = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt/Status Flags Clear Register
  #define SPI4_IFCR (* ((volatile uint32_t *) (0x40013400 + 24)))

  // Field SUSPC: SUSPend flag clear
    const uint32_t SPI4_IFCR_SUSPC = 1U << 11 ;

  // Field TSERFC: TSERFC flag clear
    const uint32_t SPI4_IFCR_TSERFC = 1U << 10 ;

  // Field MODFC: Mode Fault flag clear
    const uint32_t SPI4_IFCR_MODFC = 1U << 9 ;

  // Field TIFREC: TI frame format error flag clear
    const uint32_t SPI4_IFCR_TIFREC = 1U << 8 ;

  // Field CRCEC: CRC Error flag clear
    const uint32_t SPI4_IFCR_CRCEC = 1U << 7 ;

  // Field OVRC: Overrun flag clear
    const uint32_t SPI4_IFCR_OVRC = 1U << 6 ;

  // Field UDRC: Underrun flag clear
    const uint32_t SPI4_IFCR_UDRC = 1U << 5 ;

  // Field TXTFC: Transmission Transfer Filled flag clear
    const uint32_t SPI4_IFCR_TXTFC = 1U << 4 ;

  // Field EOTC: End Of Transfer flag clear
    const uint32_t SPI4_IFCR_EOTC = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register TXDR: Transmit Data Register
  #define SPI4_TXDR (* ((volatile uint32_t *) (0x40013400 + 32)))

  // Field TXDR: Transmit data register
    inline uint32_t SPI4_TXDR_TXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Receive Data Register
  #define SPI4_RXDR (* ((const volatile uint32_t *) (0x40013400 + 48)))

  // Field RXDR: Receive data register
    inline uint32_t SPI4_RXDR_RXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCPOLY: Polynomial Register
  #define SPI4_CRCPOLY (* ((volatile uint32_t *) (0x40013400 + 64)))

  // Field CRCPOLY: CRC polynomial register
    inline uint32_t SPI4_CRCPOLY_CRCPOLY (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXCRC: Transmitter CRC Register
  #define SPI4_TXCRC (* ((volatile uint32_t *) (0x40013400 + 68)))

  // Field TXCRC: CRC register for transmitter
    inline uint32_t SPI4_TXCRC_TXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXCRC: Receiver CRC Register
  #define SPI4_RXCRC (* ((volatile uint32_t *) (0x40013400 + 72)))

  // Field RXCRC: CRC register for receiver
    inline uint32_t SPI4_RXCRC_RXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UDRDR: Underrun Data Register
  #define SPI4_UDRDR (* ((volatile uint32_t *) (0x40013400 + 76)))

  // Field UDRDR: Data at slave underrun condition
    inline uint32_t SPI4_UDRDR_UDRDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CGFR: configuration register
  #define SPI4_CGFR (* ((volatile uint32_t *) (0x40013400 + 80)))

  // Field MCKOE: Master clock output enable
    const uint32_t SPI4_CGFR_MCKOE = 1U << 25 ;

  // Field ODD: Odd factor for the prescaler
    const uint32_t SPI4_CGFR_ODD = 1U << 24 ;

  // Field I2SDIV: I2S linear prescaler
    inline uint32_t SPI4_CGFR_I2SDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DATFMT: Data format
    const uint32_t SPI4_CGFR_DATFMT = 1U << 14 ;

  // Field WSINV: Fixed channel length in SLAVE
    const uint32_t SPI4_CGFR_WSINV = 1U << 13 ;

  // Field FIXCH: Word select inversion
    const uint32_t SPI4_CGFR_FIXCH = 1U << 12 ;

  // Field CKPOL: Serial audio clock polarity
    const uint32_t SPI4_CGFR_CKPOL = 1U << 11 ;

  // Field CHLEN: Channel length (number of bits per audio channel)
    const uint32_t SPI4_CGFR_CHLEN = 1U << 10 ;

  // Field DATLEN: Data length to be transferred
    inline uint32_t SPI4_CGFR_DATLEN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCMSYNC: PCM frame synchronization
    const uint32_t SPI4_CGFR_PCMSYNC = 1U << 7 ;

  // Field I2SSTD: I2S standard selection
    inline uint32_t SPI4_CGFR_I2SSTD (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field I2SCFG: I2S configuration mode
    inline uint32_t SPI4_CGFR_I2SCFG (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

  // Field I2SMOD: I2S mode selection
    const uint32_t SPI4_CGFR_I2SMOD = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral SPI5
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define SPI5_CR1 (* ((volatile uint32_t *) (0x40015000 + 0)))

  // Field IOLOCK: Locking the AF configuration of associated IOs
    const uint32_t SPI5_CR1_IOLOCK = 1U << 16 ;

  // Field TCRCI: CRC calculation initialization pattern control for transmitter
    const uint32_t SPI5_CR1_TCRCI = 1U << 15 ;

  // Field RCRCI: CRC calculation initialization pattern control for receiver
    const uint32_t SPI5_CR1_RCRCI = 1U << 14 ;

  // Field CRC33_17: 32-bit CRC polynomial configuration
    const uint32_t SPI5_CR1_CRC33_17 = 1U << 13 ;

  // Field SSI: Internal SS signal input level
    const uint32_t SPI5_CR1_SSI = 1U << 12 ;

  // Field HDDIR: Rx/Tx direction at Half-duplex mode
    const uint32_t SPI5_CR1_HDDIR = 1U << 11 ;

  // Field CSUSP: Master SUSPend request
    const uint32_t SPI5_CR1_CSUSP = 1U << 10 ;

  // Field CSTART: Master transfer start
    const uint32_t SPI5_CR1_CSTART = 1U << 9 ;

  // Field MASRX: Master automatic SUSP in Receive mode
    const uint32_t SPI5_CR1_MASRX = 1U << 8 ;

  // Field SPE: Serial Peripheral Enable
    const uint32_t SPI5_CR1_SPE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define SPI5_CR2 (* ((volatile uint32_t *) (0x40015000 + 4)))

  // Field TSER: Number of data transfer extension to be reload into TSIZE just when a previous
    inline uint32_t SPI5_CR2_TSER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field TSIZE: Number of data at current transfer
    inline uint32_t SPI5_CR2_TSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG1: configuration register 1
  #define SPI5_CFG1 (* ((volatile uint32_t *) (0x40015000 + 8)))

  // Field MBR: Master baud rate
    inline uint32_t SPI5_CFG1_MBR (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field CRCEN: Hardware CRC computation enable
    const uint32_t SPI5_CFG1_CRCEN = 1U << 22 ;

  // Field CRCSIZE: Length of CRC frame to be transacted and compared
    inline uint32_t SPI5_CFG1_CRCSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TXDMAEN: Tx DMA stream enable
    const uint32_t SPI5_CFG1_TXDMAEN = 1U << 15 ;

  // Field RXDMAEN: Rx DMA stream enable
    const uint32_t SPI5_CFG1_RXDMAEN = 1U << 14 ;

  // Field UDRDET: Detection of underrun condition at slave transmitter
    inline uint32_t SPI5_CFG1_UDRDET (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field UDRCFG: Behavior of slave transmitter at underrun condition
    inline uint32_t SPI5_CFG1_UDRCFG (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field FTHVL: threshold level
    inline uint32_t SPI5_CFG1_FTHVL (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field DSIZE: Number of bits in at single SPI data frame
    inline uint32_t SPI5_CFG1_DSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG2: configuration register 2
  #define SPI5_CFG2 (* ((volatile uint32_t *) (0x40015000 + 12)))

  // Field AFCNTR: Alternate function GPIOs control
    const uint32_t SPI5_CFG2_AFCNTR = 1U << 31 ;

  // Field SSOM: SS output management in master mode
    const uint32_t SPI5_CFG2_SSOM = 1U << 30 ;

  // Field SSOE: SS output enable
    const uint32_t SPI5_CFG2_SSOE = 1U << 29 ;

  // Field SSIOP: SS input/output polarity
    const uint32_t SPI5_CFG2_SSIOP = 1U << 28 ;

  // Field SSM: Software management of SS signal input
    const uint32_t SPI5_CFG2_SSM = 1U << 26 ;

  // Field CPOL: Clock polarity
    const uint32_t SPI5_CFG2_CPOL = 1U << 25 ;

  // Field CPHA: Clock phase
    const uint32_t SPI5_CFG2_CPHA = 1U << 24 ;

  // Field LSBFRST: Data frame format
    const uint32_t SPI5_CFG2_LSBFRST = 1U << 23 ;

  // Field MASTER: SPI Master
    const uint32_t SPI5_CFG2_MASTER = 1U << 22 ;

  // Field SP: Serial Protocol
    inline uint32_t SPI5_CFG2_SP (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field COMM: SPI Communication Mode
    inline uint32_t SPI5_CFG2_COMM (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field IOSWP: Swap functionality of MISO and MOSI pins
    const uint32_t SPI5_CFG2_IOSWP = 1U << 15 ;

  // Field MIDI: Master Inter-Data Idleness
    inline uint32_t SPI5_CFG2_MIDI (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field MSSI: Master SS Idleness
    inline uint32_t SPI5_CFG2_MSSI (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define SPI5_IER (* ((volatile uint32_t *) (0x40015000 + 16)))

  // Field TSERFIE: Additional number of transactions reload interrupt enable
    const uint32_t SPI5_IER_TSERFIE = 1U << 10 ;

  // Field MODFIE: Mode Fault interrupt enable
    const uint32_t SPI5_IER_MODFIE = 1U << 9 ;

  // Field TIFREIE: TIFRE interrupt enable
    const uint32_t SPI5_IER_TIFREIE = 1U << 8 ;

  // Field CRCEIE: CRC Interrupt enable
    const uint32_t SPI5_IER_CRCEIE = 1U << 7 ;

  // Field OVRIE: OVR interrupt enable
    const uint32_t SPI5_IER_OVRIE = 1U << 6 ;

  // Field UDRIE: UDR interrupt enable
    const uint32_t SPI5_IER_UDRIE = 1U << 5 ;

  // Field TXTFIE: TXTFIE interrupt enable
    const uint32_t SPI5_IER_TXTFIE = 1U << 4 ;

  // Field EOTIE: EOT, SUSP and TXC interrupt enable
    const uint32_t SPI5_IER_EOTIE = 1U << 3 ;

  // Field DPXPIE: DXP interrupt enabled
    const uint32_t SPI5_IER_DPXPIE = 1U << 2 ;

  // Field TXPIE: TXP interrupt enable
    const uint32_t SPI5_IER_TXPIE = 1U << 1 ;

  // Field RXPIE: RXP Interrupt Enable
    const uint32_t SPI5_IER_RXPIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: Status Register
  #define SPI5_SR (* ((const volatile uint32_t *) (0x40015000 + 20)))

  // Field CTSIZE: Number of data frames remaining in current TSIZE session
    inline uint32_t SPI5_SR_CTSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RXWNE: RxFIFO Word Not Empty
    const uint32_t SPI5_SR_RXWNE = 1U << 15 ;

  // Field RXPLVL: RxFIFO Packing LeVeL
    inline uint32_t SPI5_SR_RXPLVL (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TXC: TxFIFO transmission complete
    const uint32_t SPI5_SR_TXC = 1U << 12 ;

  // Field SUSP: SUSPend
    const uint32_t SPI5_SR_SUSP = 1U << 11 ;

  // Field TSERF: Additional number of SPI data to be transacted was reload
    const uint32_t SPI5_SR_TSERF = 1U << 10 ;

  // Field MODF: Mode Fault
    const uint32_t SPI5_SR_MODF = 1U << 9 ;

  // Field TIFRE: TI frame format error
    const uint32_t SPI5_SR_TIFRE = 1U << 8 ;

  // Field CRCE: CRC Error
    const uint32_t SPI5_SR_CRCE = 1U << 7 ;

  // Field OVR: Overrun
    const uint32_t SPI5_SR_OVR = 1U << 6 ;

  // Field UDR: Underrun at slave transmission mode
    const uint32_t SPI5_SR_UDR = 1U << 5 ;

  // Field TXTF: Transmission Transfer Filled
    const uint32_t SPI5_SR_TXTF = 1U << 4 ;

  // Field EOT: End Of Transfer
    const uint32_t SPI5_SR_EOT = 1U << 3 ;

  // Field DXP: Duplex Packet
    const uint32_t SPI5_SR_DXP = 1U << 2 ;

  // Field TXP: Tx-Packet space available
    const uint32_t SPI5_SR_TXP = 1U << 1 ;

  // Field RXP: Rx-Packet available
    const uint32_t SPI5_SR_RXP = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt/Status Flags Clear Register
  #define SPI5_IFCR (* ((volatile uint32_t *) (0x40015000 + 24)))

  // Field SUSPC: SUSPend flag clear
    const uint32_t SPI5_IFCR_SUSPC = 1U << 11 ;

  // Field TSERFC: TSERFC flag clear
    const uint32_t SPI5_IFCR_TSERFC = 1U << 10 ;

  // Field MODFC: Mode Fault flag clear
    const uint32_t SPI5_IFCR_MODFC = 1U << 9 ;

  // Field TIFREC: TI frame format error flag clear
    const uint32_t SPI5_IFCR_TIFREC = 1U << 8 ;

  // Field CRCEC: CRC Error flag clear
    const uint32_t SPI5_IFCR_CRCEC = 1U << 7 ;

  // Field OVRC: Overrun flag clear
    const uint32_t SPI5_IFCR_OVRC = 1U << 6 ;

  // Field UDRC: Underrun flag clear
    const uint32_t SPI5_IFCR_UDRC = 1U << 5 ;

  // Field TXTFC: Transmission Transfer Filled flag clear
    const uint32_t SPI5_IFCR_TXTFC = 1U << 4 ;

  // Field EOTC: End Of Transfer flag clear
    const uint32_t SPI5_IFCR_EOTC = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register TXDR: Transmit Data Register
  #define SPI5_TXDR (* ((volatile uint32_t *) (0x40015000 + 32)))

  // Field TXDR: Transmit data register
    inline uint32_t SPI5_TXDR_TXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Receive Data Register
  #define SPI5_RXDR (* ((const volatile uint32_t *) (0x40015000 + 48)))

  // Field RXDR: Receive data register
    inline uint32_t SPI5_RXDR_RXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCPOLY: Polynomial Register
  #define SPI5_CRCPOLY (* ((volatile uint32_t *) (0x40015000 + 64)))

  // Field CRCPOLY: CRC polynomial register
    inline uint32_t SPI5_CRCPOLY_CRCPOLY (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXCRC: Transmitter CRC Register
  #define SPI5_TXCRC (* ((volatile uint32_t *) (0x40015000 + 68)))

  // Field TXCRC: CRC register for transmitter
    inline uint32_t SPI5_TXCRC_TXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXCRC: Receiver CRC Register
  #define SPI5_RXCRC (* ((volatile uint32_t *) (0x40015000 + 72)))

  // Field RXCRC: CRC register for receiver
    inline uint32_t SPI5_RXCRC_RXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UDRDR: Underrun Data Register
  #define SPI5_UDRDR (* ((volatile uint32_t *) (0x40015000 + 76)))

  // Field UDRDR: Data at slave underrun condition
    inline uint32_t SPI5_UDRDR_UDRDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CGFR: configuration register
  #define SPI5_CGFR (* ((volatile uint32_t *) (0x40015000 + 80)))

  // Field MCKOE: Master clock output enable
    const uint32_t SPI5_CGFR_MCKOE = 1U << 25 ;

  // Field ODD: Odd factor for the prescaler
    const uint32_t SPI5_CGFR_ODD = 1U << 24 ;

  // Field I2SDIV: I2S linear prescaler
    inline uint32_t SPI5_CGFR_I2SDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DATFMT: Data format
    const uint32_t SPI5_CGFR_DATFMT = 1U << 14 ;

  // Field WSINV: Fixed channel length in SLAVE
    const uint32_t SPI5_CGFR_WSINV = 1U << 13 ;

  // Field FIXCH: Word select inversion
    const uint32_t SPI5_CGFR_FIXCH = 1U << 12 ;

  // Field CKPOL: Serial audio clock polarity
    const uint32_t SPI5_CGFR_CKPOL = 1U << 11 ;

  // Field CHLEN: Channel length (number of bits per audio channel)
    const uint32_t SPI5_CGFR_CHLEN = 1U << 10 ;

  // Field DATLEN: Data length to be transferred
    inline uint32_t SPI5_CGFR_DATLEN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCMSYNC: PCM frame synchronization
    const uint32_t SPI5_CGFR_PCMSYNC = 1U << 7 ;

  // Field I2SSTD: I2S standard selection
    inline uint32_t SPI5_CGFR_I2SSTD (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field I2SCFG: I2S configuration mode
    inline uint32_t SPI5_CGFR_I2SCFG (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

  // Field I2SMOD: I2S mode selection
    const uint32_t SPI5_CGFR_I2SMOD = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral SPI6
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define SPI6_CR1 (* ((volatile uint32_t *) (0x58001400 + 0)))

  // Field IOLOCK: Locking the AF configuration of associated IOs
    const uint32_t SPI6_CR1_IOLOCK = 1U << 16 ;

  // Field TCRCI: CRC calculation initialization pattern control for transmitter
    const uint32_t SPI6_CR1_TCRCI = 1U << 15 ;

  // Field RCRCI: CRC calculation initialization pattern control for receiver
    const uint32_t SPI6_CR1_RCRCI = 1U << 14 ;

  // Field CRC33_17: 32-bit CRC polynomial configuration
    const uint32_t SPI6_CR1_CRC33_17 = 1U << 13 ;

  // Field SSI: Internal SS signal input level
    const uint32_t SPI6_CR1_SSI = 1U << 12 ;

  // Field HDDIR: Rx/Tx direction at Half-duplex mode
    const uint32_t SPI6_CR1_HDDIR = 1U << 11 ;

  // Field CSUSP: Master SUSPend request
    const uint32_t SPI6_CR1_CSUSP = 1U << 10 ;

  // Field CSTART: Master transfer start
    const uint32_t SPI6_CR1_CSTART = 1U << 9 ;

  // Field MASRX: Master automatic SUSP in Receive mode
    const uint32_t SPI6_CR1_MASRX = 1U << 8 ;

  // Field SPE: Serial Peripheral Enable
    const uint32_t SPI6_CR1_SPE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define SPI6_CR2 (* ((volatile uint32_t *) (0x58001400 + 4)))

  // Field TSER: Number of data transfer extension to be reload into TSIZE just when a previous
    inline uint32_t SPI6_CR2_TSER (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field TSIZE: Number of data at current transfer
    inline uint32_t SPI6_CR2_TSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG1: configuration register 1
  #define SPI6_CFG1 (* ((volatile uint32_t *) (0x58001400 + 8)))

  // Field MBR: Master baud rate
    inline uint32_t SPI6_CFG1_MBR (const uint32_t inValue) {return (inValue & 0x7U) << 28 ; }

  // Field CRCEN: Hardware CRC computation enable
    const uint32_t SPI6_CFG1_CRCEN = 1U << 22 ;

  // Field CRCSIZE: Length of CRC frame to be transacted and compared
    inline uint32_t SPI6_CFG1_CRCSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 16 ; }

  // Field TXDMAEN: Tx DMA stream enable
    const uint32_t SPI6_CFG1_TXDMAEN = 1U << 15 ;

  // Field RXDMAEN: Rx DMA stream enable
    const uint32_t SPI6_CFG1_RXDMAEN = 1U << 14 ;

  // Field UDRDET: Detection of underrun condition at slave transmitter
    inline uint32_t SPI6_CFG1_UDRDET (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field UDRCFG: Behavior of slave transmitter at underrun condition
    inline uint32_t SPI6_CFG1_UDRCFG (const uint32_t inValue) {return (inValue & 0x3U) << 9 ; }

  // Field FTHVL: threshold level
    inline uint32_t SPI6_CFG1_FTHVL (const uint32_t inValue) {return (inValue & 0xFU) << 5 ; }

  // Field DSIZE: Number of bits in at single SPI data frame
    inline uint32_t SPI6_CFG1_DSIZE (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CFG2: configuration register 2
  #define SPI6_CFG2 (* ((volatile uint32_t *) (0x58001400 + 12)))

  // Field AFCNTR: Alternate function GPIOs control
    const uint32_t SPI6_CFG2_AFCNTR = 1U << 31 ;

  // Field SSOM: SS output management in master mode
    const uint32_t SPI6_CFG2_SSOM = 1U << 30 ;

  // Field SSOE: SS output enable
    const uint32_t SPI6_CFG2_SSOE = 1U << 29 ;

  // Field SSIOP: SS input/output polarity
    const uint32_t SPI6_CFG2_SSIOP = 1U << 28 ;

  // Field SSM: Software management of SS signal input
    const uint32_t SPI6_CFG2_SSM = 1U << 26 ;

  // Field CPOL: Clock polarity
    const uint32_t SPI6_CFG2_CPOL = 1U << 25 ;

  // Field CPHA: Clock phase
    const uint32_t SPI6_CFG2_CPHA = 1U << 24 ;

  // Field LSBFRST: Data frame format
    const uint32_t SPI6_CFG2_LSBFRST = 1U << 23 ;

  // Field MASTER: SPI Master
    const uint32_t SPI6_CFG2_MASTER = 1U << 22 ;

  // Field SP: Serial Protocol
    inline uint32_t SPI6_CFG2_SP (const uint32_t inValue) {return (inValue & 0x7U) << 19 ; }

  // Field COMM: SPI Communication Mode
    inline uint32_t SPI6_CFG2_COMM (const uint32_t inValue) {return (inValue & 0x3U) << 17 ; }

  // Field IOSWP: Swap functionality of MISO and MOSI pins
    const uint32_t SPI6_CFG2_IOSWP = 1U << 15 ;

  // Field MIDI: Master Inter-Data Idleness
    inline uint32_t SPI6_CFG2_MIDI (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field MSSI: Master SS Idleness
    inline uint32_t SPI6_CFG2_MSSI (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register IER: Interrupt Enable Register
  #define SPI6_IER (* ((volatile uint32_t *) (0x58001400 + 16)))

  // Field TSERFIE: Additional number of transactions reload interrupt enable
    const uint32_t SPI6_IER_TSERFIE = 1U << 10 ;

  // Field MODFIE: Mode Fault interrupt enable
    const uint32_t SPI6_IER_MODFIE = 1U << 9 ;

  // Field TIFREIE: TIFRE interrupt enable
    const uint32_t SPI6_IER_TIFREIE = 1U << 8 ;

  // Field CRCEIE: CRC Interrupt enable
    const uint32_t SPI6_IER_CRCEIE = 1U << 7 ;

  // Field OVRIE: OVR interrupt enable
    const uint32_t SPI6_IER_OVRIE = 1U << 6 ;

  // Field UDRIE: UDR interrupt enable
    const uint32_t SPI6_IER_UDRIE = 1U << 5 ;

  // Field TXTFIE: TXTFIE interrupt enable
    const uint32_t SPI6_IER_TXTFIE = 1U << 4 ;

  // Field EOTIE: EOT, SUSP and TXC interrupt enable
    const uint32_t SPI6_IER_EOTIE = 1U << 3 ;

  // Field DPXPIE: DXP interrupt enabled
    const uint32_t SPI6_IER_DPXPIE = 1U << 2 ;

  // Field TXPIE: TXP interrupt enable
    const uint32_t SPI6_IER_TXPIE = 1U << 1 ;

  // Field RXPIE: RXP Interrupt Enable
    const uint32_t SPI6_IER_RXPIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: Status Register
  #define SPI6_SR (* ((const volatile uint32_t *) (0x58001400 + 20)))

  // Field CTSIZE: Number of data frames remaining in current TSIZE session
    inline uint32_t SPI6_SR_CTSIZE (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field RXWNE: RxFIFO Word Not Empty
    const uint32_t SPI6_SR_RXWNE = 1U << 15 ;

  // Field RXPLVL: RxFIFO Packing LeVeL
    inline uint32_t SPI6_SR_RXPLVL (const uint32_t inValue) {return (inValue & 0x3U) << 13 ; }

  // Field TXC: TxFIFO transmission complete
    const uint32_t SPI6_SR_TXC = 1U << 12 ;

  // Field SUSP: SUSPend
    const uint32_t SPI6_SR_SUSP = 1U << 11 ;

  // Field TSERF: Additional number of SPI data to be transacted was reload
    const uint32_t SPI6_SR_TSERF = 1U << 10 ;

  // Field MODF: Mode Fault
    const uint32_t SPI6_SR_MODF = 1U << 9 ;

  // Field TIFRE: TI frame format error
    const uint32_t SPI6_SR_TIFRE = 1U << 8 ;

  // Field CRCE: CRC Error
    const uint32_t SPI6_SR_CRCE = 1U << 7 ;

  // Field OVR: Overrun
    const uint32_t SPI6_SR_OVR = 1U << 6 ;

  // Field UDR: Underrun at slave transmission mode
    const uint32_t SPI6_SR_UDR = 1U << 5 ;

  // Field TXTF: Transmission Transfer Filled
    const uint32_t SPI6_SR_TXTF = 1U << 4 ;

  // Field EOT: End Of Transfer
    const uint32_t SPI6_SR_EOT = 1U << 3 ;

  // Field DXP: Duplex Packet
    const uint32_t SPI6_SR_DXP = 1U << 2 ;

  // Field TXP: Tx-Packet space available
    const uint32_t SPI6_SR_TXP = 1U << 1 ;

  // Field RXP: Rx-Packet available
    const uint32_t SPI6_SR_RXP = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register IFCR: Interrupt/Status Flags Clear Register
  #define SPI6_IFCR (* ((volatile uint32_t *) (0x58001400 + 24)))

  // Field SUSPC: SUSPend flag clear
    const uint32_t SPI6_IFCR_SUSPC = 1U << 11 ;

  // Field TSERFC: TSERFC flag clear
    const uint32_t SPI6_IFCR_TSERFC = 1U << 10 ;

  // Field MODFC: Mode Fault flag clear
    const uint32_t SPI6_IFCR_MODFC = 1U << 9 ;

  // Field TIFREC: TI frame format error flag clear
    const uint32_t SPI6_IFCR_TIFREC = 1U << 8 ;

  // Field CRCEC: CRC Error flag clear
    const uint32_t SPI6_IFCR_CRCEC = 1U << 7 ;

  // Field OVRC: Overrun flag clear
    const uint32_t SPI6_IFCR_OVRC = 1U << 6 ;

  // Field UDRC: Underrun flag clear
    const uint32_t SPI6_IFCR_UDRC = 1U << 5 ;

  // Field TXTFC: Transmission Transfer Filled flag clear
    const uint32_t SPI6_IFCR_TXTFC = 1U << 4 ;

  // Field EOTC: End Of Transfer flag clear
    const uint32_t SPI6_IFCR_EOTC = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register TXDR: Transmit Data Register
  #define SPI6_TXDR (* ((volatile uint32_t *) (0x58001400 + 32)))

  // Field TXDR: Transmit data register
    inline uint32_t SPI6_TXDR_TXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXDR: Receive Data Register
  #define SPI6_RXDR (* ((const volatile uint32_t *) (0x58001400 + 48)))

  // Field RXDR: Receive data register
    inline uint32_t SPI6_RXDR_RXDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CRCPOLY: Polynomial Register
  #define SPI6_CRCPOLY (* ((volatile uint32_t *) (0x58001400 + 64)))

  // Field CRCPOLY: CRC polynomial register
    inline uint32_t SPI6_CRCPOLY_CRCPOLY (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TXCRC: Transmitter CRC Register
  #define SPI6_TXCRC (* ((volatile uint32_t *) (0x58001400 + 68)))

  // Field TXCRC: CRC register for transmitter
    inline uint32_t SPI6_TXCRC_TXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RXCRC: Receiver CRC Register
  #define SPI6_RXCRC (* ((volatile uint32_t *) (0x58001400 + 72)))

  // Field RXCRC: CRC register for receiver
    inline uint32_t SPI6_RXCRC_RXCRC (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UDRDR: Underrun Data Register
  #define SPI6_UDRDR (* ((volatile uint32_t *) (0x58001400 + 76)))

  // Field UDRDR: Data at slave underrun condition
    inline uint32_t SPI6_UDRDR_UDRDR (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CGFR: configuration register
  #define SPI6_CGFR (* ((volatile uint32_t *) (0x58001400 + 80)))

  // Field MCKOE: Master clock output enable
    const uint32_t SPI6_CGFR_MCKOE = 1U << 25 ;

  // Field ODD: Odd factor for the prescaler
    const uint32_t SPI6_CGFR_ODD = 1U << 24 ;

  // Field I2SDIV: I2S linear prescaler
    inline uint32_t SPI6_CGFR_I2SDIV (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

  // Field DATFMT: Data format
    const uint32_t SPI6_CGFR_DATFMT = 1U << 14 ;

  // Field WSINV: Fixed channel length in SLAVE
    const uint32_t SPI6_CGFR_WSINV = 1U << 13 ;

  // Field FIXCH: Word select inversion
    const uint32_t SPI6_CGFR_FIXCH = 1U << 12 ;

  // Field CKPOL: Serial audio clock polarity
    const uint32_t SPI6_CGFR_CKPOL = 1U << 11 ;

  // Field CHLEN: Channel length (number of bits per audio channel)
    const uint32_t SPI6_CGFR_CHLEN = 1U << 10 ;

  // Field DATLEN: Data length to be transferred
    inline uint32_t SPI6_CGFR_DATLEN (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field PCMSYNC: PCM frame synchronization
    const uint32_t SPI6_CGFR_PCMSYNC = 1U << 7 ;

  // Field I2SSTD: I2S standard selection
    inline uint32_t SPI6_CGFR_I2SSTD (const uint32_t inValue) {return (inValue & 0x3U) << 4 ; }

  // Field I2SCFG: I2S configuration mode
    inline uint32_t SPI6_CGFR_I2SCFG (const uint32_t inValue) {return (inValue & 0x7U) << 1 ; }

  // Field I2SMOD: I2S mode selection
    const uint32_t SPI6_CGFR_I2SMOD = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral STK: SysTick timer
//------------------------------------------------------------------------------

//---  Register CSR: SysTick control and status register
  #define STK_CSR (* ((volatile uint32_t *) (0xE000E010 + 0)))

  // Field ENABLE: Counter enable
    const uint32_t STK_CSR_ENABLE = 1U << 0 ;

  // Field TICKINT: SysTick exception request enable
    const uint32_t STK_CSR_TICKINT = 1U << 1 ;

  // Field CLKSOURCE: Clock source selection
    const uint32_t STK_CSR_CLKSOURCE = 1U << 2 ;

  // Field COUNTFLAG: COUNTFLAG
    const uint32_t STK_CSR_COUNTFLAG = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register RVR: SysTick reload value register
  #define STK_RVR (* ((volatile uint32_t *) (0xE000E010 + 4)))

  // Field RELOAD: RELOAD value
    inline uint32_t STK_RVR_RELOAD (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CVR: SysTick current value register
  #define STK_CVR (* ((volatile uint32_t *) (0xE000E010 + 8)))

  // Field CURRENT: Current counter value
    inline uint32_t STK_CVR_CURRENT (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CALIB: SysTick calibration value register
  #define STK_CALIB (* ((volatile uint32_t *) (0xE000E010 + 12)))

  // Field TENMS: Calibration value
    inline uint32_t STK_CALIB_TENMS (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

  // Field SKEW: SKEW flag: Indicates whether the TENMS value is exact
    const uint32_t STK_CALIB_SKEW = 1U << 30 ;

  // Field NOREF: NOREF flag. Reads as zero
    const uint32_t STK_CALIB_NOREF = 1U << 31 ;

//------------------------------------------------------------------------------
// Peripheral SWPMI: Single Wire Protocol Master       Interface
//------------------------------------------------------------------------------

//---  Register CR: SWPMI Configuration/Control register
  #define SWPMI_CR (* ((volatile uint32_t *) (0x40008800 + 0)))

  // Field RXDMA: Reception DMA enable
    const uint32_t SWPMI_CR_RXDMA = 1U << 0 ;

  // Field TXDMA: Transmission DMA enable
    const uint32_t SWPMI_CR_TXDMA = 1U << 1 ;

  // Field RXMODE: Reception buffering mode
    const uint32_t SWPMI_CR_RXMODE = 1U << 2 ;

  // Field TXMODE: Transmission buffering mode
    const uint32_t SWPMI_CR_TXMODE = 1U << 3 ;

  // Field LPBK: Loopback mode enable
    const uint32_t SWPMI_CR_LPBK = 1U << 4 ;

  // Field SWPACT: Single wire protocol master interface activate
    const uint32_t SWPMI_CR_SWPACT = 1U << 5 ;

  // Field DEACT: Single wire protocol master interface deactivate
    const uint32_t SWPMI_CR_DEACT = 1U << 10 ;

  // Field SWPTEN: Single wire protocol master transceiver enable
    const uint32_t SWPMI_CR_SWPTEN = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register BRR: SWPMI Bitrate register
  #define SWPMI_BRR (* ((volatile uint32_t *) (0x40008800 + 4)))

  // Field BR: Bitrate prescaler
    inline uint32_t SWPMI_BRR_BR (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ISR: SWPMI Interrupt and Status register
  #define SWPMI_ISR (* ((const volatile uint32_t *) (0x40008800 + 12)))

  // Field RXBFF: Receive buffer full flag
    const uint32_t SWPMI_ISR_RXBFF = 1U << 0 ;

  // Field TXBEF: Transmit buffer empty flag
    const uint32_t SWPMI_ISR_TXBEF = 1U << 1 ;

  // Field RXBERF: Receive CRC error flag
    const uint32_t SWPMI_ISR_RXBERF = 1U << 2 ;

  // Field RXOVRF: Receive overrun error flag
    const uint32_t SWPMI_ISR_RXOVRF = 1U << 3 ;

  // Field TXUNRF: Transmit underrun error flag
    const uint32_t SWPMI_ISR_TXUNRF = 1U << 4 ;

  // Field RXNE: Receive data register not empty
    const uint32_t SWPMI_ISR_RXNE = 1U << 5 ;

  // Field TXE: Transmit data register empty
    const uint32_t SWPMI_ISR_TXE = 1U << 6 ;

  // Field TCF: Transfer complete flag
    const uint32_t SWPMI_ISR_TCF = 1U << 7 ;

  // Field SRF: Slave resume flag
    const uint32_t SWPMI_ISR_SRF = 1U << 8 ;

  // Field SUSP: SUSPEND flag
    const uint32_t SWPMI_ISR_SUSP = 1U << 9 ;

  // Field DEACTF: DEACTIVATED flag
    const uint32_t SWPMI_ISR_DEACTF = 1U << 10 ;

  // Field RDYF: transceiver ready flag
    const uint32_t SWPMI_ISR_RDYF = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register ICR: SWPMI Interrupt Flag Clear register
  #define SWPMI_ICR (* ((volatile uint32_t *) (0x40008800 + 16)))

  // Field CRXBFF: Clear receive buffer full flag
    const uint32_t SWPMI_ICR_CRXBFF = 1U << 0 ;

  // Field CTXBEF: Clear transmit buffer empty flag
    const uint32_t SWPMI_ICR_CTXBEF = 1U << 1 ;

  // Field CRXBERF: Clear receive CRC error flag
    const uint32_t SWPMI_ICR_CRXBERF = 1U << 2 ;

  // Field CRXOVRF: Clear receive overrun error flag
    const uint32_t SWPMI_ICR_CRXOVRF = 1U << 3 ;

  // Field CTXUNRF: Clear transmit underrun error flag
    const uint32_t SWPMI_ICR_CTXUNRF = 1U << 4 ;

  // Field CTCF: Clear transfer complete flag
    const uint32_t SWPMI_ICR_CTCF = 1U << 7 ;

  // Field CSRF: Clear slave resume flag
    const uint32_t SWPMI_ICR_CSRF = 1U << 8 ;

  // Field CRDYF: Clear transceiver ready flag
    const uint32_t SWPMI_ICR_CRDYF = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register IER: SWPMI Interrupt Enable register
  #define SWPMI_IER (* ((volatile uint32_t *) (0x40008800 + 20)))

  // Field RXBFIE: Receive buffer full interrupt enable
    const uint32_t SWPMI_IER_RXBFIE = 1U << 0 ;

  // Field TXBEIE: Transmit buffer empty interrupt enable
    const uint32_t SWPMI_IER_TXBEIE = 1U << 1 ;

  // Field RXBERIE: Receive CRC error interrupt enable
    const uint32_t SWPMI_IER_RXBERIE = 1U << 2 ;

  // Field RXOVRIE: Receive overrun error interrupt enable
    const uint32_t SWPMI_IER_RXOVRIE = 1U << 3 ;

  // Field TXUNRIE: Transmit underrun error interrupt enable
    const uint32_t SWPMI_IER_TXUNRIE = 1U << 4 ;

  // Field RIE: Receive interrupt enable
    const uint32_t SWPMI_IER_RIE = 1U << 5 ;

  // Field TIE: Transmit interrupt enable
    const uint32_t SWPMI_IER_TIE = 1U << 6 ;

  // Field TCIE: Transmit complete interrupt enable
    const uint32_t SWPMI_IER_TCIE = 1U << 7 ;

  // Field SRIE: Slave resume interrupt enable
    const uint32_t SWPMI_IER_SRIE = 1U << 8 ;

  // Field RDYIE: Transceiver ready interrupt enable
    const uint32_t SWPMI_IER_RDYIE = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register RFL: SWPMI Receive Frame Length register
  #define SWPMI_RFL (* ((const volatile uint32_t *) (0x40008800 + 24)))

  // Field RFL: Receive frame length
    inline uint32_t SWPMI_RFL_RFL (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: SWPMI Transmit data register
  #define SWPMI_TDR (* ((volatile uint32_t *) (0x40008800 + 28)))

  // Field TD: Transmit data
    inline uint32_t SWPMI_TDR_TD (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RDR: SWPMI Receive data register
  #define SWPMI_RDR (* ((const volatile uint32_t *) (0x40008800 + 32)))

  // Field RD: received data
    inline uint32_t SWPMI_RDR_RD (const uint32_t inValue) {return (inValue & 0xFFFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register OR: SWPMI Option register
  #define SWPMI_OR (* ((volatile uint32_t *) (0x40008800 + 36)))

  // Field SWP_TBYP: SWP transceiver bypass
    const uint32_t SWPMI_OR_SWP_TBYP = 1U << 0 ;

  // Field SWP_CLASS: SWP class selection
    const uint32_t SWPMI_OR_SWP_CLASS = 1U << 1 ;

//------------------------------------------------------------------------------
// Peripheral SYSCFG: System configuration controller
//------------------------------------------------------------------------------

//---  Register PMCR: peripheral mode configuration register
  #define SYSCFG_PMCR (* ((volatile uint32_t *) (0x58000400 + 4)))

  // Field I2C1FMP: I2C1 Fm+
    const uint32_t SYSCFG_PMCR_I2C1FMP = 1U << 0 ;

  // Field I2C2FMP: I2C2 Fm+
    const uint32_t SYSCFG_PMCR_I2C2FMP = 1U << 1 ;

  // Field I2C3FMP: I2C3 Fm+
    const uint32_t SYSCFG_PMCR_I2C3FMP = 1U << 2 ;

  // Field I2C4FMP: I2C4 Fm+
    const uint32_t SYSCFG_PMCR_I2C4FMP = 1U << 3 ;

  // Field PB6FMP: PB(6) Fm+
    const uint32_t SYSCFG_PMCR_PB6FMP = 1U << 4 ;

  // Field PB7FMP: PB(7) Fast Mode Plus
    const uint32_t SYSCFG_PMCR_PB7FMP = 1U << 5 ;

  // Field PB8FMP: PB(8) Fast Mode Plus
    const uint32_t SYSCFG_PMCR_PB8FMP = 1U << 6 ;

  // Field PB9FMP: PB(9) Fm+
    const uint32_t SYSCFG_PMCR_PB9FMP = 1U << 7 ;

  // Field BOOSTE: Booster Enable
    const uint32_t SYSCFG_PMCR_BOOSTE = 1U << 8 ;

  // Field BOOSTVDDSEL: Analog switch supply voltage selection
    const uint32_t SYSCFG_PMCR_BOOSTVDDSEL = 1U << 9 ;

  // Field EPIS: Ethernet PHY Interface Selection
    inline uint32_t SYSCFG_PMCR_EPIS (const uint32_t inValue) {return (inValue & 0x7U) << 21 ; }

  // Field PA0SO: PA0 Switch Open
    const uint32_t SYSCFG_PMCR_PA0SO = 1U << 24 ;

  // Field PA1SO: PA1 Switch Open
    const uint32_t SYSCFG_PMCR_PA1SO = 1U << 25 ;

  // Field PC2SO: PC2 Switch Open
    const uint32_t SYSCFG_PMCR_PC2SO = 1U << 26 ;

  // Field PC3SO: PC3 Switch Open
    const uint32_t SYSCFG_PMCR_PC3SO = 1U << 27 ;

//------------------------------------------------------------------------------

//---  Register EXTICR1: external interrupt configuration register 1
  #define SYSCFG_EXTICR1 (* ((volatile uint32_t *) (0x58000400 + 8)))

  // Field EXTI3: EXTI x configuration (x = 0 to 3)
    inline uint32_t SYSCFG_EXTICR1_EXTI3 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field EXTI2: EXTI x configuration (x = 0 to 3)
    inline uint32_t SYSCFG_EXTICR1_EXTI2 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field EXTI1: EXTI x configuration (x = 0 to 3)
    inline uint32_t SYSCFG_EXTICR1_EXTI1 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field EXTI0: EXTI x configuration (x = 0 to 3)
    inline uint32_t SYSCFG_EXTICR1_EXTI0 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EXTICR2: external interrupt configuration register 2
  #define SYSCFG_EXTICR2 (* ((volatile uint32_t *) (0x58000400 + 12)))

  // Field EXTI7: EXTI x configuration (x = 4 to 7)
    inline uint32_t SYSCFG_EXTICR2_EXTI7 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field EXTI6: EXTI x configuration (x = 4 to 7)
    inline uint32_t SYSCFG_EXTICR2_EXTI6 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field EXTI5: EXTI x configuration (x = 4 to 7)
    inline uint32_t SYSCFG_EXTICR2_EXTI5 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field EXTI4: EXTI x configuration (x = 4 to 7)
    inline uint32_t SYSCFG_EXTICR2_EXTI4 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EXTICR3: external interrupt configuration register 3
  #define SYSCFG_EXTICR3 (* ((volatile uint32_t *) (0x58000400 + 16)))

  // Field EXTI11: EXTI x configuration (x = 8 to 11)
    inline uint32_t SYSCFG_EXTICR3_EXTI11 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field EXTI10: EXTI10
    inline uint32_t SYSCFG_EXTICR3_EXTI10 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field EXTI9: EXTI x configuration (x = 8 to 11)
    inline uint32_t SYSCFG_EXTICR3_EXTI9 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field EXTI8: EXTI x configuration (x = 8 to 11)
    inline uint32_t SYSCFG_EXTICR3_EXTI8 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register EXTICR4: external interrupt configuration register 4
  #define SYSCFG_EXTICR4 (* ((volatile uint32_t *) (0x58000400 + 20)))

  // Field EXTI15: EXTI x configuration (x = 12 to 15)
    inline uint32_t SYSCFG_EXTICR4_EXTI15 (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field EXTI14: EXTI x configuration (x = 12 to 15)
    inline uint32_t SYSCFG_EXTICR4_EXTI14 (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field EXTI13: EXTI x configuration (x = 12 to 15)
    inline uint32_t SYSCFG_EXTICR4_EXTI13 (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field EXTI12: EXTI x configuration (x = 12 to 15)
    inline uint32_t SYSCFG_EXTICR4_EXTI12 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCCSR: compensation cell control/status register
  #define SYSCFG_CCCSR (* ((volatile uint32_t *) (0x58000400 + 32)))

  // Field EN: enable
    const uint32_t SYSCFG_CCCSR_EN = 1U << 0 ;

  // Field CS: Code selection
    const uint32_t SYSCFG_CCCSR_CS = 1U << 1 ;

  // Field READY: Compensation cell ready flag
    const uint32_t SYSCFG_CCCSR_READY = 1U << 8 ;

  // Field HSLV: High-speed at low-voltage
    const uint32_t SYSCFG_CCCSR_HSLV = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register CCVR: SYSCFG compensation cell value register
  #define SYSCFG_CCVR (* ((const volatile uint32_t *) (0x58000400 + 36)))

  // Field NCV: NMOS compensation value
    inline uint32_t SYSCFG_CCVR_NCV (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field PCV: PMOS compensation value
    inline uint32_t SYSCFG_CCVR_PCV (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CCCR: SYSCFG compensation cell code register
  #define SYSCFG_CCCR (* ((volatile uint32_t *) (0x58000400 + 40)))

  // Field NCC: NMOS compensation code
    inline uint32_t SYSCFG_CCCR_NCC (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field PCC: PMOS compensation code
    inline uint32_t SYSCFG_CCCR_PCC (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

//------------------------------------------------------------------------------

//---  Register PWRCR: SYSCFG power control register
  #define SYSCFG_PWRCR (* ((volatile uint32_t *) (0x58000400 + 44)))

  // Field ODEN: Overdrive enable
    inline uint32_t SYSCFG_PWRCR_ODEN (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PKGR: SYSCFG package register
  #define SYSCFG_PKGR (* ((const volatile uint32_t *) (0x58000400 + 292)))

  // Field PKG: Package
    inline uint32_t SYSCFG_PKGR_PKG (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register UR0: SYSCFG user register 0
  #define SYSCFG_UR0 (* ((const volatile uint32_t *) (0x58000400 + 768)))

  // Field BKS: Bank Swap
    const uint32_t SYSCFG_UR0_BKS = 1U << 0 ;

  // Field RDP: Readout protection
    inline uint32_t SYSCFG_UR0_RDP (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR2: SYSCFG user register 2
  #define SYSCFG_UR2 (* ((volatile uint32_t *) (0x58000400 + 776)))

  // Field BORH: BOR_LVL Brownout Reset Threshold Level
    inline uint32_t SYSCFG_UR2_BORH (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field BOOT_ADD0: Boot Address 0
    inline uint32_t SYSCFG_UR2_BOOT_ADD0 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR3: SYSCFG user register 3
  #define SYSCFG_UR3 (* ((volatile uint32_t *) (0x58000400 + 780)))

  // Field BOOT_ADD1: Boot Address 1
    inline uint32_t SYSCFG_UR3_BOOT_ADD1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR4: SYSCFG user register 4
  #define SYSCFG_UR4 (* ((const volatile uint32_t *) (0x58000400 + 784)))

  // Field MEPAD_1: Mass Erase Protected Area Disabled for bank 1
    const uint32_t SYSCFG_UR4_MEPAD_1 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR5: SYSCFG user register 5
  #define SYSCFG_UR5 (* ((const volatile uint32_t *) (0x58000400 + 788)))

  // Field MESAD_1: Mass erase secured area disabled for bank 1
    const uint32_t SYSCFG_UR5_MESAD_1 = 1U << 0 ;

  // Field WRPN_1: Write protection for flash bank 1
    inline uint32_t SYSCFG_UR5_WRPN_1 (const uint32_t inValue) {return (inValue & 0xFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR6: SYSCFG user register 6
  #define SYSCFG_UR6 (* ((const volatile uint32_t *) (0x58000400 + 792)))

  // Field PA_BEG_1: Protected area start address for bank 1
    inline uint32_t SYSCFG_UR6_PA_BEG_1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field PA_END_1: Protected area end address for bank 1
    inline uint32_t SYSCFG_UR6_PA_END_1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR7: SYSCFG user register 7
  #define SYSCFG_UR7 (* ((const volatile uint32_t *) (0x58000400 + 796)))

  // Field SA_BEG_1: Secured area start address for bank 1
    inline uint32_t SYSCFG_UR7_SA_BEG_1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field SA_END_1: Secured area end address for bank 1
    inline uint32_t SYSCFG_UR7_SA_END_1 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR8: SYSCFG user register 8
  #define SYSCFG_UR8 (* ((const volatile uint32_t *) (0x58000400 + 800)))

  // Field MEPAD_2: Mass erase protected area disabled for bank 2
    const uint32_t SYSCFG_UR8_MEPAD_2 = 1U << 0 ;

  // Field MESAD_2: Mass erase secured area disabled for bank 2
    const uint32_t SYSCFG_UR8_MESAD_2 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR9: SYSCFG user register 9
  #define SYSCFG_UR9 (* ((const volatile uint32_t *) (0x58000400 + 804)))

  // Field WRPN_2: Write protection for flash bank 2
    inline uint32_t SYSCFG_UR9_WRPN_2 (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field PA_BEG_2: Protected area start address for bank 2
    inline uint32_t SYSCFG_UR9_PA_BEG_2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR10: SYSCFG user register 10
  #define SYSCFG_UR10 (* ((const volatile uint32_t *) (0x58000400 + 808)))

  // Field PA_END_2: Protected area end address for bank 2
    inline uint32_t SYSCFG_UR10_PA_END_2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field SA_BEG_2: Secured area start address for bank 2
    inline uint32_t SYSCFG_UR10_SA_BEG_2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register UR11: SYSCFG user register 11
  #define SYSCFG_UR11 (* ((const volatile uint32_t *) (0x58000400 + 812)))

  // Field SA_END_2: Secured area end address for bank 2
    inline uint32_t SYSCFG_UR11_SA_END_2 (const uint32_t inValue) {return (inValue & 0xFFFU) << 0 ; }

  // Field IWDG1M: Independent Watchdog 1 mode
    const uint32_t SYSCFG_UR11_IWDG1M = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR12: SYSCFG user register 12
  #define SYSCFG_UR12 (* ((const volatile uint32_t *) (0x58000400 + 816)))

  // Field SECURE: Secure mode
    const uint32_t SYSCFG_UR12_SECURE = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR13: SYSCFG user register 13
  #define SYSCFG_UR13 (* ((const volatile uint32_t *) (0x58000400 + 820)))

  // Field SDRS: Secured DTCM RAM Size
    inline uint32_t SYSCFG_UR13_SDRS (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field D1SBRST: D1 Standby reset
    const uint32_t SYSCFG_UR13_D1SBRST = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR14: SYSCFG user register 14
  #define SYSCFG_UR14 (* ((volatile uint32_t *) (0x58000400 + 824)))

  // Field D1STPRST: D1 Stop Reset
    const uint32_t SYSCFG_UR14_D1STPRST = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register UR15: SYSCFG user register 15
  #define SYSCFG_UR15 (* ((const volatile uint32_t *) (0x58000400 + 828)))

  // Field FZIWDGSTB: Freeze independent watchdog in Standby mode
    const uint32_t SYSCFG_UR15_FZIWDGSTB = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR16: SYSCFG user register 16
  #define SYSCFG_UR16 (* ((const volatile uint32_t *) (0x58000400 + 832)))

  // Field FZIWDGSTP: Freeze independent watchdog in Stop mode
    const uint32_t SYSCFG_UR16_FZIWDGSTP = 1U << 0 ;

  // Field PKP: Private key programmed
    const uint32_t SYSCFG_UR16_PKP = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register UR17: SYSCFG user register 17
  #define SYSCFG_UR17 (* ((const volatile uint32_t *) (0x58000400 + 836)))

  // Field IO_HSLV: I/O high speed / low voltage
    const uint32_t SYSCFG_UR17_IO_HSLV = 1U << 0 ;

//------------------------------------------------------------------------------
// Peripheral TIM1: Advanced-timers
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM1_CR1 (* ((volatile uint32_t *) (0x40010000 + 0)))

  // Field CEN: Counter enable
    const uint32_t TIM1_CR1_CEN = 1U << 0 ;

  // Field UDIS: Update disable
    const uint32_t TIM1_CR1_UDIS = 1U << 1 ;

  // Field URS: Update request source
    const uint32_t TIM1_CR1_URS = 1U << 2 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM1_CR1_OPM = 1U << 3 ;

  // Field DIR: Direction
    const uint32_t TIM1_CR1_DIR = 1U << 4 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM1_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM1_CR1_ARPE = 1U << 7 ;

  // Field CKD: Clock division
    inline uint32_t TIM1_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM1_CR1_UIFREMAP = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM1_CR2 (* ((volatile uint32_t *) (0x40010000 + 4)))

  // Field MMS2: Master mode selection 2
    inline uint32_t TIM1_CR2_MMS2 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OIS6: Output Idle state 6
    const uint32_t TIM1_CR2_OIS6 = 1U << 18 ;

  // Field OIS5: Output Idle state 5
    const uint32_t TIM1_CR2_OIS5 = 1U << 16 ;

  // Field OIS4: Output Idle state 4
    const uint32_t TIM1_CR2_OIS4 = 1U << 14 ;

  // Field OIS3N: Output Idle state 3
    const uint32_t TIM1_CR2_OIS3N = 1U << 13 ;

  // Field OIS3: Output Idle state 3
    const uint32_t TIM1_CR2_OIS3 = 1U << 12 ;

  // Field OIS2N: Output Idle state 2
    const uint32_t TIM1_CR2_OIS2N = 1U << 11 ;

  // Field OIS2: Output Idle state 2
    const uint32_t TIM1_CR2_OIS2 = 1U << 10 ;

  // Field OIS1N: Output Idle state 1
    const uint32_t TIM1_CR2_OIS1N = 1U << 9 ;

  // Field OIS1: Output Idle state 1
    const uint32_t TIM1_CR2_OIS1 = 1U << 8 ;

  // Field TI1S: TI1 selection
    const uint32_t TIM1_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM1_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM1_CR2_CCDS = 1U << 3 ;

  // Field CCUS: Capture/compare control update selection
    const uint32_t TIM1_CR2_CCUS = 1U << 2 ;

  // Field CCPC: Capture/compare preloaded control
    const uint32_t TIM1_CR2_CCPC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM1_SMCR (* ((volatile uint32_t *) (0x40010000 + 8)))

  // Field SMS: Slave mode selection
    inline uint32_t TIM1_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field TS: Trigger selection
    inline uint32_t TIM1_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM1_SMCR_MSM = 1U << 7 ;

  // Field ETF: External trigger filter
    inline uint32_t TIM1_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM1_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ECE: External clock enable
    const uint32_t TIM1_SMCR_ECE = 1U << 14 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM1_SMCR_ETP = 1U << 15 ;

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM1_SMCR_SMS_3 = 1U << 16 ;

  // Field TS_4_3: Trigger selection - bit 4:3
    inline uint32_t TIM1_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM1_DIER (* ((volatile uint32_t *) (0x40010000 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM1_DIER_TDE = 1U << 14 ;

  // Field COMDE: COM DMA request enable
    const uint32_t TIM1_DIER_COMDE = 1U << 13 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM1_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM1_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM1_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM1_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM1_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM1_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM1_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM1_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM1_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM1_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM1_DIER_UIE = 1U << 0 ;

  // Field BIE: Break interrupt enable
    const uint32_t TIM1_DIER_BIE = 1U << 7 ;

  // Field COMIE: COM interrupt enable
    const uint32_t TIM1_DIER_COMIE = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM1_SR (* ((volatile uint32_t *) (0x40010000 + 16)))

  // Field CC6IF: Compare 6 interrupt flag
    const uint32_t TIM1_SR_CC6IF = 1U << 17 ;

  // Field CC5IF: Compare 5 interrupt flag
    const uint32_t TIM1_SR_CC5IF = 1U << 16 ;

  // Field SBIF: System Break interrupt flag
    const uint32_t TIM1_SR_SBIF = 1U << 13 ;

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM1_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM1_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM1_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM1_SR_CC1OF = 1U << 9 ;

  // Field B2IF: Break 2 interrupt flag
    const uint32_t TIM1_SR_B2IF = 1U << 8 ;

  // Field BIF: Break interrupt flag
    const uint32_t TIM1_SR_BIF = 1U << 7 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM1_SR_TIF = 1U << 6 ;

  // Field COMIF: COM interrupt flag
    const uint32_t TIM1_SR_COMIF = 1U << 5 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM1_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM1_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM1_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM1_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM1_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM1_EGR (* ((volatile uint32_t *) (0x40010000 + 20)))

  // Field UG: Update generation
    const uint32_t TIM1_EGR_UG = 1U << 0 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM1_EGR_CC1G = 1U << 1 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM1_EGR_CC2G = 1U << 2 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM1_EGR_CC3G = 1U << 3 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM1_EGR_CC4G = 1U << 4 ;

  // Field COMG: Capture/Compare control update generation
    const uint32_t TIM1_EGR_COMG = 1U << 5 ;

  // Field TG: Trigger generation
    const uint32_t TIM1_EGR_TG = 1U << 6 ;

  // Field BG: Break generation
    const uint32_t TIM1_EGR_BG = 1U << 7 ;

  // Field B2G: Break 2 generation
    const uint32_t TIM1_EGR_B2G = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM1_CCMR1_Output (* ((volatile uint32_t *) (0x40010000 + 24)))

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM1_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: Output Compare 1 fast enable
    const uint32_t TIM1_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: Output Compare 1 preload enable
    const uint32_t TIM1_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: Output Compare 1 mode
    inline uint32_t TIM1_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: Output Compare 1 clear enable
    const uint32_t TIM1_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM1_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: Output Compare 2 fast enable
    const uint32_t TIM1_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: Output Compare 2 preload enable
    const uint32_t TIM1_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: Output Compare 2 mode
    inline uint32_t TIM1_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: Output Compare 2 clear enable
    const uint32_t TIM1_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM1_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM1_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM1_CCMR1_Input (* ((volatile uint32_t *) (0x40010000 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM1_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM1_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM1_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM1_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM1_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM1_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM1_CCMR2_Output (* ((volatile uint32_t *) (0x40010000 + 28)))

  // Field CC3S: Capture/Compare 3 selection
    inline uint32_t TIM1_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC3FE: Output compare 3 fast enable
    const uint32_t TIM1_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field OC3PE: Output compare 3 preload enable
    const uint32_t TIM1_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3M: Output compare 3 mode
    inline uint32_t TIM1_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3CE: Output compare 3 clear enable
    const uint32_t TIM1_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM1_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC4FE: Output compare 4 fast enable
    const uint32_t TIM1_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field OC4PE: Output compare 4 preload enable
    const uint32_t TIM1_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4M: Output compare 4 mode
    inline uint32_t TIM1_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4CE: Output compare 4 clear enable
    const uint32_t TIM1_CCMR2_Output_OC4CE = 1U << 15 ;

  // Field OC3M_3: Output Compare 3 mode - bit 3
    const uint32_t TIM1_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field OC4M_4: Output Compare 4 mode - bit 3
    const uint32_t TIM1_CCMR2_Output_OC4M_4 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM1_CCMR2_Input (* ((volatile uint32_t *) (0x40010000 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM1_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM1_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM1_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM1_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM1_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM1_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM1_CCER (* ((volatile uint32_t *) (0x40010000 + 32)))

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM1_CCER_CC1E = 1U << 0 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM1_CCER_CC1P = 1U << 1 ;

  // Field CC1NE: Capture/Compare 1 complementary output enable
    const uint32_t TIM1_CCER_CC1NE = 1U << 2 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM1_CCER_CC1NP = 1U << 3 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM1_CCER_CC2E = 1U << 4 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM1_CCER_CC2P = 1U << 5 ;

  // Field CC2NE: Capture/Compare 2 complementary output enable
    const uint32_t TIM1_CCER_CC2NE = 1U << 6 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM1_CCER_CC2NP = 1U << 7 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM1_CCER_CC3E = 1U << 8 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM1_CCER_CC3P = 1U << 9 ;

  // Field CC3NE: Capture/Compare 3 complementary output enable
    const uint32_t TIM1_CCER_CC3NE = 1U << 10 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM1_CCER_CC3NP = 1U << 11 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM1_CCER_CC4E = 1U << 12 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM1_CCER_CC4P = 1U << 13 ;

  // Field CC4NP: Capture/Compare 4 complementary output polarity
    const uint32_t TIM1_CCER_CC4NP = 1U << 15 ;

  // Field CC5E: Capture/Compare 5 output enable
    const uint32_t TIM1_CCER_CC5E = 1U << 16 ;

  // Field CC5P: Capture/Compare 5 output polarity
    const uint32_t TIM1_CCER_CC5P = 1U << 17 ;

  // Field CC6E: Capture/Compare 6 output enable
    const uint32_t TIM1_CCER_CC6E = 1U << 20 ;

  // Field CC6P: Capture/Compare 6 output polarity
    const uint32_t TIM1_CCER_CC6P = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM1_CNT (* ((volatile uint32_t *) (0x40010000 + 36)))

  // Field CNT: counter value
    inline uint32_t TIM1_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF copy
    const uint32_t TIM1_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM1_PSC (* ((volatile uint32_t *) (0x40010000 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM1_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM1_ARR (* ((volatile uint32_t *) (0x40010000 + 44)))

  // Field ARR: Auto-reload value
    inline uint32_t TIM1_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM1_CCR1 (* ((volatile uint32_t *) (0x40010000 + 52)))

  // Field CCR1: Capture/Compare 1 value
    inline uint32_t TIM1_CCR1_CCR1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM1_CCR2 (* ((volatile uint32_t *) (0x40010000 + 56)))

  // Field CCR2: Capture/Compare 2 value
    inline uint32_t TIM1_CCR2_CCR2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM1_CCR3 (* ((volatile uint32_t *) (0x40010000 + 60)))

  // Field CCR3: Capture/Compare value
    inline uint32_t TIM1_CCR3_CCR3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM1_CCR4 (* ((volatile uint32_t *) (0x40010000 + 64)))

  // Field CCR4: Capture/Compare value
    inline uint32_t TIM1_CCR4_CCR4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM1_DCR (* ((volatile uint32_t *) (0x40010000 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM1_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM1_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM1_DMAR (* ((volatile uint32_t *) (0x40010000 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM1_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RCR: repetition counter register
  #define TIM1_RCR (* ((volatile uint32_t *) (0x40010000 + 48)))

  // Field REP: Repetition counter value
    inline uint32_t TIM1_RCR_REP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BDTR: break and dead-time register
  #define TIM1_BDTR (* ((volatile uint32_t *) (0x40010000 + 68)))

  // Field DTG: Dead-time generator setup
    inline uint32_t TIM1_BDTR_DTG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field LOCK: Lock configuration
    inline uint32_t TIM1_BDTR_LOCK (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSSI: Off-state selection for Idle mode
    const uint32_t TIM1_BDTR_OSSI = 1U << 10 ;

  // Field OSSR: Off-state selection for Run mode
    const uint32_t TIM1_BDTR_OSSR = 1U << 11 ;

  // Field BKE: Break enable
    const uint32_t TIM1_BDTR_BKE = 1U << 12 ;

  // Field BKP: Break polarity
    const uint32_t TIM1_BDTR_BKP = 1U << 13 ;

  // Field AOE: Automatic output enable
    const uint32_t TIM1_BDTR_AOE = 1U << 14 ;

  // Field MOE: Main output enable
    const uint32_t TIM1_BDTR_MOE = 1U << 15 ;

  // Field BKF: Break filter
    inline uint32_t TIM1_BDTR_BKF (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field BK2F: Break 2 filter
    inline uint32_t TIM1_BDTR_BK2F (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field BK2E: Break 2 enable
    const uint32_t TIM1_BDTR_BK2E = 1U << 24 ;

  // Field BK2P: Break 2 polarity
    const uint32_t TIM1_BDTR_BK2P = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register CCMR3_Output: capture/compare mode register 3 (output mode)
  #define TIM1_CCMR3_Output (* ((volatile uint32_t *) (0x40010000 + 84)))

  // Field OC5FE: Output compare 5 fast enable
    const uint32_t TIM1_CCMR3_Output_OC5FE = 1U << 2 ;

  // Field OC5PE: Output compare 5 preload enable
    const uint32_t TIM1_CCMR3_Output_OC5PE = 1U << 3 ;

  // Field OC5M: Output compare 5 mode
    inline uint32_t TIM1_CCMR3_Output_OC5M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC5CE: Output compare 5 clear enable
    const uint32_t TIM1_CCMR3_Output_OC5CE = 1U << 7 ;

  // Field OC6FE: Output compare 6 fast enable
    const uint32_t TIM1_CCMR3_Output_OC6FE = 1U << 10 ;

  // Field OC6PE: Output compare 6 preload enable
    const uint32_t TIM1_CCMR3_Output_OC6PE = 1U << 11 ;

  // Field OC6M: Output compare 6 mode
    inline uint32_t TIM1_CCMR3_Output_OC6M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC6CE: Output compare 6 clear enable
    const uint32_t TIM1_CCMR3_Output_OC6CE = 1U << 15 ;

  // Field OC5M3: Output Compare 5 mode
    const uint32_t TIM1_CCMR3_Output_OC5M3 = 1U << 16 ;

  // Field OC6M3: Output Compare 6 mode
    const uint32_t TIM1_CCMR3_Output_OC6M3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCR5: capture/compare register 5
  #define TIM1_CCR5 (* ((volatile uint32_t *) (0x40010000 + 88)))

  // Field CCR5: Capture/Compare 5 value
    inline uint32_t TIM1_CCR5_CCR5 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field GC5C1: Group Channel 5 and Channel 1
    const uint32_t TIM1_CCR5_GC5C1 = 1U << 29 ;

  // Field GC5C2: Group Channel 5 and Channel 2
    const uint32_t TIM1_CCR5_GC5C2 = 1U << 30 ;

  // Field GC5C3: Group Channel 5 and Channel 3
    const uint32_t TIM1_CCR5_GC5C3 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CRR6: capture/compare register 6
  #define TIM1_CRR6 (* ((volatile uint32_t *) (0x40010000 + 92)))

  // Field CCR6: Capture/Compare 6 value
    inline uint32_t TIM1_CRR6_CCR6 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM1 alternate function option register 1
  #define TIM1_AF1 (* ((volatile uint32_t *) (0x40010000 + 96)))

  // Field BKINE: BRK BKIN input enable
    const uint32_t TIM1_AF1_BKINE = 1U << 0 ;

  // Field BKCMP1E: BRK COMP1 enable
    const uint32_t TIM1_AF1_BKCMP1E = 1U << 1 ;

  // Field BKCMP2E: BRK COMP2 enable
    const uint32_t TIM1_AF1_BKCMP2E = 1U << 2 ;

  // Field BKDF1BK0E: BRK dfsdm1_break[0] enable
    const uint32_t TIM1_AF1_BKDF1BK0E = 1U << 8 ;

  // Field BKINP: BRK BKIN input polarity
    const uint32_t TIM1_AF1_BKINP = 1U << 9 ;

  // Field BKCMP1P: BRK COMP1 input polarity
    const uint32_t TIM1_AF1_BKCMP1P = 1U << 10 ;

  // Field BKCMP2P: BRK COMP2 input polarity
    const uint32_t TIM1_AF1_BKCMP2P = 1U << 11 ;

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM1_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register AF2: TIM1 Alternate function odfsdm1_breakster 2
  #define TIM1_AF2 (* ((volatile uint32_t *) (0x40010000 + 100)))

  // Field BK2INE: BRK2 BKIN input enable
    const uint32_t TIM1_AF2_BK2INE = 1U << 0 ;

  // Field BK2CMP1E: BRK2 COMP1 enable
    const uint32_t TIM1_AF2_BK2CMP1E = 1U << 1 ;

  // Field BK2CMP2E: BRK2 COMP2 enable
    const uint32_t TIM1_AF2_BK2CMP2E = 1U << 2 ;

  // Field BK2DF1BK1E: BRK2 dfsdm1_break[1] enable
    const uint32_t TIM1_AF2_BK2DF1BK1E = 1U << 8 ;

  // Field BK2INP: BRK2 BKIN2 input polarity
    const uint32_t TIM1_AF2_BK2INP = 1U << 9 ;

  // Field BK2CMP1P: BRK2 COMP1 input polarit
    const uint32_t TIM1_AF2_BK2CMP1P = 1U << 10 ;

  // Field BK2CMP2P: BRK2 COMP2 input polarity
    const uint32_t TIM1_AF2_BK2CMP2P = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register TISEL: TIM1 timer input selection register
  #define TIM1_TISEL (* ((volatile uint32_t *) (0x40010000 + 104)))

  // Field TI1SEL: selects TI1[0] to TI1[15] input
    inline uint32_t TIM1_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: selects TI2[0] to TI2[15] input
    inline uint32_t TIM1_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: selects TI3[0] to TI3[15] input
    inline uint32_t TIM1_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: selects TI4[0] to TI4[15] input
    inline uint32_t TIM1_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM12
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM12_CR1 (* ((volatile uint32_t *) (0x40001800 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM12_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM12_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM12_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM12_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM12_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM12_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM12_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM12_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM12_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM12_CR2 (* ((volatile uint32_t *) (0x40001800 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM12_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM12_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM12_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM12_SMCR (* ((volatile uint32_t *) (0x40001800 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM12_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM12_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM12_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM12_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM12_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM12_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM12_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM12_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM12_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM12_DIER (* ((volatile uint32_t *) (0x40001800 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM12_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM12_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM12_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM12_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM12_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM12_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM12_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM12_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM12_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM12_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM12_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM12_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM12_SR (* ((volatile uint32_t *) (0x40001800 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM12_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM12_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM12_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM12_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM12_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM12_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM12_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM12_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM12_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM12_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM12_EGR (* ((volatile uint32_t *) (0x40001800 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM12_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM12_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM12_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM12_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM12_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM12_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM12_CCMR1_Output (* ((volatile uint32_t *) (0x40001800 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM12_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM12_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM12_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM12_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM12_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM12_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM12_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM12_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM12_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM12_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM12_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM12_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM12_CCMR1_Input (* ((volatile uint32_t *) (0x40001800 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM12_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM12_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM12_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM12_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM12_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM12_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM12_CCMR2_Output (* ((volatile uint32_t *) (0x40001800 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM12_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM12_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM12_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM12_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM12_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM12_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM12_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM12_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM12_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM12_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM12_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM12_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM12_CCMR2_Input (* ((volatile uint32_t *) (0x40001800 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM12_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM12_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM12_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM12_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM12_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM12_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM12_CCER (* ((volatile uint32_t *) (0x40001800 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM12_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM12_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM12_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM12_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM12_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM12_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM12_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM12_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM12_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM12_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM12_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM12_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM12_CNT (* ((volatile uint32_t *) (0x40001800 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM12_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM12_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM12_PSC (* ((volatile uint32_t *) (0x40001800 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM12_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM12_ARR (* ((volatile uint32_t *) (0x40001800 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM12_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM12_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM12_CCR1 (* ((volatile uint32_t *) (0x40001800 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM12_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM12_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM12_CCR2 (* ((volatile uint32_t *) (0x40001800 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM12_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM12_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM12_CCR3 (* ((volatile uint32_t *) (0x40001800 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM12_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM12_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM12_CCR4 (* ((volatile uint32_t *) (0x40001800 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM12_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM12_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM12_DCR (* ((volatile uint32_t *) (0x40001800 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM12_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM12_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM12_DMAR (* ((volatile uint32_t *) (0x40001800 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM12_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM12_AF1 (* ((volatile uint32_t *) (0x40001800 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM12_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM12_TISEL (* ((volatile uint32_t *) (0x40001800 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM12_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM12_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM12_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM12_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM13
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM13_CR1 (* ((volatile uint32_t *) (0x40001C00 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM13_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM13_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM13_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM13_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM13_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM13_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM13_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM13_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM13_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM13_CR2 (* ((volatile uint32_t *) (0x40001C00 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM13_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM13_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM13_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM13_SMCR (* ((volatile uint32_t *) (0x40001C00 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM13_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM13_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM13_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM13_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM13_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM13_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM13_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM13_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM13_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM13_DIER (* ((volatile uint32_t *) (0x40001C00 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM13_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM13_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM13_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM13_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM13_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM13_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM13_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM13_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM13_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM13_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM13_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM13_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM13_SR (* ((volatile uint32_t *) (0x40001C00 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM13_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM13_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM13_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM13_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM13_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM13_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM13_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM13_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM13_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM13_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM13_EGR (* ((volatile uint32_t *) (0x40001C00 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM13_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM13_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM13_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM13_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM13_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM13_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM13_CCMR1_Output (* ((volatile uint32_t *) (0x40001C00 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM13_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM13_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM13_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM13_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM13_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM13_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM13_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM13_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM13_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM13_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM13_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM13_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM13_CCMR1_Input (* ((volatile uint32_t *) (0x40001C00 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM13_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM13_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM13_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM13_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM13_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM13_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM13_CCMR2_Output (* ((volatile uint32_t *) (0x40001C00 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM13_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM13_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM13_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM13_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM13_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM13_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM13_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM13_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM13_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM13_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM13_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM13_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM13_CCMR2_Input (* ((volatile uint32_t *) (0x40001C00 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM13_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM13_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM13_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM13_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM13_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM13_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM13_CCER (* ((volatile uint32_t *) (0x40001C00 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM13_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM13_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM13_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM13_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM13_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM13_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM13_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM13_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM13_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM13_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM13_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM13_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM13_CNT (* ((volatile uint32_t *) (0x40001C00 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM13_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM13_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM13_PSC (* ((volatile uint32_t *) (0x40001C00 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM13_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM13_ARR (* ((volatile uint32_t *) (0x40001C00 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM13_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM13_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM13_CCR1 (* ((volatile uint32_t *) (0x40001C00 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM13_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM13_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM13_CCR2 (* ((volatile uint32_t *) (0x40001C00 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM13_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM13_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM13_CCR3 (* ((volatile uint32_t *) (0x40001C00 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM13_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM13_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM13_CCR4 (* ((volatile uint32_t *) (0x40001C00 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM13_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM13_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM13_DCR (* ((volatile uint32_t *) (0x40001C00 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM13_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM13_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM13_DMAR (* ((volatile uint32_t *) (0x40001C00 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM13_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM13_AF1 (* ((volatile uint32_t *) (0x40001C00 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM13_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM13_TISEL (* ((volatile uint32_t *) (0x40001C00 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM13_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM13_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM13_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM13_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM14
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM14_CR1 (* ((volatile uint32_t *) (0x40002000 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM14_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM14_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM14_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM14_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM14_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM14_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM14_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM14_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM14_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM14_CR2 (* ((volatile uint32_t *) (0x40002000 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM14_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM14_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM14_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM14_SMCR (* ((volatile uint32_t *) (0x40002000 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM14_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM14_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM14_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM14_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM14_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM14_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM14_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM14_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM14_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM14_DIER (* ((volatile uint32_t *) (0x40002000 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM14_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM14_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM14_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM14_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM14_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM14_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM14_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM14_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM14_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM14_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM14_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM14_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM14_SR (* ((volatile uint32_t *) (0x40002000 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM14_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM14_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM14_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM14_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM14_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM14_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM14_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM14_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM14_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM14_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM14_EGR (* ((volatile uint32_t *) (0x40002000 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM14_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM14_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM14_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM14_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM14_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM14_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM14_CCMR1_Output (* ((volatile uint32_t *) (0x40002000 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM14_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM14_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM14_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM14_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM14_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM14_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM14_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM14_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM14_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM14_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM14_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM14_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM14_CCMR1_Input (* ((volatile uint32_t *) (0x40002000 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM14_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM14_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM14_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM14_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM14_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM14_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM14_CCMR2_Output (* ((volatile uint32_t *) (0x40002000 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM14_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM14_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM14_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM14_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM14_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM14_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM14_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM14_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM14_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM14_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM14_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM14_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM14_CCMR2_Input (* ((volatile uint32_t *) (0x40002000 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM14_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM14_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM14_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM14_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM14_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM14_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM14_CCER (* ((volatile uint32_t *) (0x40002000 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM14_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM14_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM14_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM14_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM14_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM14_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM14_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM14_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM14_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM14_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM14_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM14_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM14_CNT (* ((volatile uint32_t *) (0x40002000 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM14_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM14_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM14_PSC (* ((volatile uint32_t *) (0x40002000 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM14_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM14_ARR (* ((volatile uint32_t *) (0x40002000 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM14_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM14_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM14_CCR1 (* ((volatile uint32_t *) (0x40002000 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM14_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM14_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM14_CCR2 (* ((volatile uint32_t *) (0x40002000 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM14_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM14_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM14_CCR3 (* ((volatile uint32_t *) (0x40002000 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM14_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM14_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM14_CCR4 (* ((volatile uint32_t *) (0x40002000 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM14_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM14_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM14_DCR (* ((volatile uint32_t *) (0x40002000 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM14_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM14_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM14_DMAR (* ((volatile uint32_t *) (0x40002000 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM14_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM14_AF1 (* ((volatile uint32_t *) (0x40002000 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM14_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM14_TISEL (* ((volatile uint32_t *) (0x40002000 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM14_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM14_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM14_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM14_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM15: General purpose timers
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM15_CR1 (* ((volatile uint32_t *) (0x40014000 + 0)))

  // Field CEN: Counter enable
    const uint32_t TIM15_CR1_CEN = 1U << 0 ;

  // Field UDIS: Update disable
    const uint32_t TIM15_CR1_UDIS = 1U << 1 ;

  // Field URS: Update request source
    const uint32_t TIM15_CR1_URS = 1U << 2 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM15_CR1_OPM = 1U << 3 ;

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM15_CR1_ARPE = 1U << 7 ;

  // Field CKD: Clock division
    inline uint32_t TIM15_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM15_CR1_UIFREMAP = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM15_CR2 (* ((volatile uint32_t *) (0x40014000 + 4)))

  // Field CCPC: Capture/compare preloaded control
    const uint32_t TIM15_CR2_CCPC = 1U << 0 ;

  // Field CCUS: Capture/compare control update selection
    const uint32_t TIM15_CR2_CCUS = 1U << 2 ;

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM15_CR2_CCDS = 1U << 3 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM15_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field TI1S: TI1 selection
    const uint32_t TIM15_CR2_TI1S = 1U << 7 ;

  // Field OIS1: Output Idle state 1
    const uint32_t TIM15_CR2_OIS1 = 1U << 8 ;

  // Field OIS1N: Output Idle state 1
    const uint32_t TIM15_CR2_OIS1N = 1U << 9 ;

  // Field OIS2: Output Idle state 2
    const uint32_t TIM15_CR2_OIS2 = 1U << 10 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM15_SMCR (* ((volatile uint32_t *) (0x40014000 + 8)))

  // Field SMS: Slave mode selection
    inline uint32_t TIM15_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field TS_2_0: Trigger selection
    inline uint32_t TIM15_SMCR_TS_2_0 (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM15_SMCR_MSM = 1U << 7 ;

  // Field SMS_3: Slave mode selection bit 3
    const uint32_t TIM15_SMCR_SMS_3 = 1U << 16 ;

  // Field TS_4_3: Trigger selection - bit 4:3
    inline uint32_t TIM15_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM15_DIER (* ((volatile uint32_t *) (0x40014000 + 12)))

  // Field UIE: Update interrupt enable
    const uint32_t TIM15_DIER_UIE = 1U << 0 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM15_DIER_CC1IE = 1U << 1 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM15_DIER_CC2IE = 1U << 2 ;

  // Field COMIE: COM interrupt enable
    const uint32_t TIM15_DIER_COMIE = 1U << 5 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM15_DIER_TIE = 1U << 6 ;

  // Field BIE: Break interrupt enable
    const uint32_t TIM15_DIER_BIE = 1U << 7 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM15_DIER_UDE = 1U << 8 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM15_DIER_CC1DE = 1U << 9 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM15_DIER_CC2DE = 1U << 10 ;

  // Field COMDE: COM DMA request enable
    const uint32_t TIM15_DIER_COMDE = 1U << 13 ;

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM15_DIER_TDE = 1U << 14 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM15_SR (* ((volatile uint32_t *) (0x40014000 + 16)))

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM15_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM15_SR_CC1OF = 1U << 9 ;

  // Field BIF: Break interrupt flag
    const uint32_t TIM15_SR_BIF = 1U << 7 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM15_SR_TIF = 1U << 6 ;

  // Field COMIF: COM interrupt flag
    const uint32_t TIM15_SR_COMIF = 1U << 5 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM15_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM15_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM15_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM15_EGR (* ((volatile uint32_t *) (0x40014000 + 20)))

  // Field BG: Break generation
    const uint32_t TIM15_EGR_BG = 1U << 7 ;

  // Field TG: Trigger generation
    const uint32_t TIM15_EGR_TG = 1U << 6 ;

  // Field COMG: Capture/Compare control update generation
    const uint32_t TIM15_EGR_COMG = 1U << 5 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM15_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM15_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM15_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register (output mode)
  #define TIM15_CCMR1_Output (* ((volatile uint32_t *) (0x40014000 + 24)))

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM15_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: Output Compare 1 fast enable
    const uint32_t TIM15_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: Output Compare 1 preload enable
    const uint32_t TIM15_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: Output Compare 1 mode
    inline uint32_t TIM15_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM15_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: Output Compare 2 fast enable
    const uint32_t TIM15_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: Output Compare 2 preload enable
    const uint32_t TIM15_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: Output Compare 2 mode
    inline uint32_t TIM15_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC1M_3: Output Compare 1 mode bit 3
    const uint32_t TIM15_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode bit 3
    const uint32_t TIM15_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM15_CCMR1_Input (* ((volatile uint32_t *) (0x40014000 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM15_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PSC: Input capture 2 prescaler
    inline uint32_t TIM15_CCMR1_Input_IC2PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM15_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM15_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC1PSC: Input capture 1 prescaler
    inline uint32_t TIM15_CCMR1_Input_IC1PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM15_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM15_CCER (* ((volatile uint32_t *) (0x40014000 + 32)))

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM15_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM15_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM15_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM15_CCER_CC1NP = 1U << 3 ;

  // Field CC1NE: Capture/Compare 1 complementary output enable
    const uint32_t TIM15_CCER_CC1NE = 1U << 2 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM15_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM15_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM15_CNT (* ((volatile uint32_t *) (0x40014000 + 36)))

  // Field CNT: counter value
    inline uint32_t TIM15_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF copy
    const uint32_t TIM15_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM15_PSC (* ((volatile uint32_t *) (0x40014000 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM15_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM15_ARR (* ((volatile uint32_t *) (0x40014000 + 44)))

  // Field ARR: Auto-reload value
    inline uint32_t TIM15_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RCR: repetition counter register
  #define TIM15_RCR (* ((volatile uint32_t *) (0x40014000 + 48)))

  // Field REP: Repetition counter value
    inline uint32_t TIM15_RCR_REP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM15_CCR1 (* ((volatile uint32_t *) (0x40014000 + 52)))

  // Field CCR1: Capture/Compare 1 value
    inline uint32_t TIM15_CCR1_CCR1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM15_CCR2 (* ((volatile uint32_t *) (0x40014000 + 56)))

  // Field CCR2: Capture/Compare 2 value
    inline uint32_t TIM15_CCR2_CCR2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BDTR: break and dead-time register
  #define TIM15_BDTR (* ((volatile uint32_t *) (0x40014000 + 68)))

  // Field MOE: Main output enable
    const uint32_t TIM15_BDTR_MOE = 1U << 15 ;

  // Field AOE: Automatic output enable
    const uint32_t TIM15_BDTR_AOE = 1U << 14 ;

  // Field BKP: Break polarity
    const uint32_t TIM15_BDTR_BKP = 1U << 13 ;

  // Field BKE: Break enable
    const uint32_t TIM15_BDTR_BKE = 1U << 12 ;

  // Field OSSR: Off-state selection for Run mode
    const uint32_t TIM15_BDTR_OSSR = 1U << 11 ;

  // Field OSSI: Off-state selection for Idle mode
    const uint32_t TIM15_BDTR_OSSI = 1U << 10 ;

  // Field LOCK: Lock configuration
    inline uint32_t TIM15_BDTR_LOCK (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field DTG: Dead-time generator setup
    inline uint32_t TIM15_BDTR_DTG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field BKF: Break filter
    inline uint32_t TIM15_BDTR_BKF (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM15_DCR (* ((volatile uint32_t *) (0x40014000 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM15_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM15_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM15_DMAR (* ((volatile uint32_t *) (0x40014000 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM15_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM15 alternate fdfsdm1_breakon register 1
  #define TIM15_AF1 (* ((volatile uint32_t *) (0x40014000 + 96)))

  // Field BKINE: BRK BKIN input enable
    const uint32_t TIM15_AF1_BKINE = 1U << 0 ;

  // Field BKCMP1E: BRK COMP1 enable
    const uint32_t TIM15_AF1_BKCMP1E = 1U << 1 ;

  // Field BKCMP2E: BRK COMP2 enable
    const uint32_t TIM15_AF1_BKCMP2E = 1U << 2 ;

  // Field BKDF1BK0E: BRK dfsdm1_break[0] enable
    const uint32_t TIM15_AF1_BKDF1BK0E = 1U << 8 ;

  // Field BKINP: BRK BKIN input polarity
    const uint32_t TIM15_AF1_BKINP = 1U << 9 ;

  // Field BKCMP1P: BRK COMP1 input polarity
    const uint32_t TIM15_AF1_BKCMP1P = 1U << 10 ;

  // Field BKCMP2P: BRK COMP2 input polarity
    const uint32_t TIM15_AF1_BKCMP2P = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register TISEL: TIM15 input selection register
  #define TIM15_TISEL (* ((volatile uint32_t *) (0x40014000 + 104)))

  // Field TI1SEL: selects TI1[0] to TI1[15] input
    inline uint32_t TIM15_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: selects TI2[0] to TI2[15] input
    inline uint32_t TIM15_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

//------------------------------------------------------------------------------
// Peripheral TIM16: General-purpose-timers
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM16_CR1 (* ((volatile uint32_t *) (0x40014400 + 0)))

  // Field CEN: Counter enable
    const uint32_t TIM16_CR1_CEN = 1U << 0 ;

  // Field UDIS: Update disable
    const uint32_t TIM16_CR1_UDIS = 1U << 1 ;

  // Field URS: Update request source
    const uint32_t TIM16_CR1_URS = 1U << 2 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM16_CR1_OPM = 1U << 3 ;

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM16_CR1_ARPE = 1U << 7 ;

  // Field CKD: Clock division
    inline uint32_t TIM16_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM16_CR1_UIFREMAP = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM16_CR2 (* ((volatile uint32_t *) (0x40014400 + 4)))

  // Field OIS1N: Output Idle state 1
    const uint32_t TIM16_CR2_OIS1N = 1U << 9 ;

  // Field OIS1: Output Idle state 1
    const uint32_t TIM16_CR2_OIS1 = 1U << 8 ;

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM16_CR2_CCDS = 1U << 3 ;

  // Field CCUS: Capture/compare control update selection
    const uint32_t TIM16_CR2_CCUS = 1U << 2 ;

  // Field CCPC: Capture/compare preloaded control
    const uint32_t TIM16_CR2_CCPC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM16_DIER (* ((volatile uint32_t *) (0x40014400 + 12)))

  // Field UIE: Update interrupt enable
    const uint32_t TIM16_DIER_UIE = 1U << 0 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM16_DIER_CC1IE = 1U << 1 ;

  // Field COMIE: COM interrupt enable
    const uint32_t TIM16_DIER_COMIE = 1U << 5 ;

  // Field BIE: Break interrupt enable
    const uint32_t TIM16_DIER_BIE = 1U << 7 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM16_DIER_UDE = 1U << 8 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM16_DIER_CC1DE = 1U << 9 ;

  // Field COMDE: COM DMA request enable
    const uint32_t TIM16_DIER_COMDE = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM16_SR (* ((volatile uint32_t *) (0x40014400 + 16)))

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM16_SR_CC1OF = 1U << 9 ;

  // Field BIF: Break interrupt flag
    const uint32_t TIM16_SR_BIF = 1U << 7 ;

  // Field COMIF: COM interrupt flag
    const uint32_t TIM16_SR_COMIF = 1U << 5 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM16_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM16_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM16_EGR (* ((volatile uint32_t *) (0x40014400 + 20)))

  // Field BG: Break generation
    const uint32_t TIM16_EGR_BG = 1U << 7 ;

  // Field COMG: Capture/Compare control update generation
    const uint32_t TIM16_EGR_COMG = 1U << 5 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM16_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM16_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register (output mode)
  #define TIM16_CCMR1_Output (* ((volatile uint32_t *) (0x40014400 + 24)))

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM16_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: Output Compare 1 fast enable
    const uint32_t TIM16_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: Output Compare 1 preload enable
    const uint32_t TIM16_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: Output Compare 1 mode
    inline uint32_t TIM16_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1M_3: Output Compare 1 mode
    const uint32_t TIM16_CCMR1_Output_OC1M_3 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM16_CCMR1_Input (* ((volatile uint32_t *) (0x40014400 + 24)))

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM16_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC1PSC: Input capture 1 prescaler
    inline uint32_t TIM16_CCMR1_Input_IC1PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM16_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM16_CCER (* ((volatile uint32_t *) (0x40014400 + 32)))

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM16_CCER_CC1NP = 1U << 3 ;

  // Field CC1NE: Capture/Compare 1 complementary output enable
    const uint32_t TIM16_CCER_CC1NE = 1U << 2 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM16_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM16_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM16_CNT (* ((volatile uint32_t *) (0x40014400 + 36)))

  // Field CNT: counter value
    inline uint32_t TIM16_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF Copy
    const uint32_t TIM16_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM16_PSC (* ((volatile uint32_t *) (0x40014400 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM16_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM16_ARR (* ((volatile uint32_t *) (0x40014400 + 44)))

  // Field ARR: Auto-reload value
    inline uint32_t TIM16_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RCR: repetition counter register
  #define TIM16_RCR (* ((volatile uint32_t *) (0x40014400 + 48)))

  // Field REP: Repetition counter value
    inline uint32_t TIM16_RCR_REP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM16_CCR1 (* ((volatile uint32_t *) (0x40014400 + 52)))

  // Field CCR1: Capture/Compare 1 value
    inline uint32_t TIM16_CCR1_CCR1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BDTR: break and dead-time register
  #define TIM16_BDTR (* ((volatile uint32_t *) (0x40014400 + 68)))

  // Field DTG: Dead-time generator setup
    inline uint32_t TIM16_BDTR_DTG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field LOCK: Lock configuration
    inline uint32_t TIM16_BDTR_LOCK (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSSI: Off-state selection for Idle mode
    const uint32_t TIM16_BDTR_OSSI = 1U << 10 ;

  // Field OSSR: Off-state selection for Run mode
    const uint32_t TIM16_BDTR_OSSR = 1U << 11 ;

  // Field BKE: Break enable
    const uint32_t TIM16_BDTR_BKE = 1U << 12 ;

  // Field BKP: Break polarity
    const uint32_t TIM16_BDTR_BKP = 1U << 13 ;

  // Field AOE: Automatic output enable
    const uint32_t TIM16_BDTR_AOE = 1U << 14 ;

  // Field MOE: Main output enable
    const uint32_t TIM16_BDTR_MOE = 1U << 15 ;

  // Field BKF: Break filter
    inline uint32_t TIM16_BDTR_BKF (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM16_DCR (* ((volatile uint32_t *) (0x40014400 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM16_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM16_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM16_DMAR (* ((volatile uint32_t *) (0x40014400 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM16_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIM16_AF1: TIM16 alternate function register 1
  #define TIM16_TIM16_AF1 (* ((volatile uint32_t *) (0x40014400 + 96)))

  // Field BKINE: BRK BKIN input enable
    const uint32_t TIM16_TIM16_AF1_BKINE = 1U << 0 ;

  // Field BKCMP1E: BRK COMP1 enable
    const uint32_t TIM16_TIM16_AF1_BKCMP1E = 1U << 1 ;

  // Field BKCMP2E: BRK COMP2 enable
    const uint32_t TIM16_TIM16_AF1_BKCMP2E = 1U << 2 ;

  // Field BKDFBK1E: BRK dfsdm1_break[1] enable
    const uint32_t TIM16_TIM16_AF1_BKDFBK1E = 1U << 8 ;

  // Field BKINP: BRK BKIN input polarity
    const uint32_t TIM16_TIM16_AF1_BKINP = 1U << 9 ;

  // Field BKCMP1P: BRK COMP1 input polarity
    const uint32_t TIM16_TIM16_AF1_BKCMP1P = 1U << 10 ;

  // Field BKCMP2P: BRK COMP2 input polarity
    const uint32_t TIM16_TIM16_AF1_BKCMP2P = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register TIM16_TISEL: TIM16 input selection register
  #define TIM16_TIM16_TISEL (* ((volatile uint32_t *) (0x40014400 + 104)))

  // Field TI1SEL: selects TI1[0] to TI1[15] input
    inline uint32_t TIM16_TIM16_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral TIM17: General-purpose-timers
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM17_CR1 (* ((volatile uint32_t *) (0x40014800 + 0)))

  // Field CEN: Counter enable
    const uint32_t TIM17_CR1_CEN = 1U << 0 ;

  // Field UDIS: Update disable
    const uint32_t TIM17_CR1_UDIS = 1U << 1 ;

  // Field URS: Update request source
    const uint32_t TIM17_CR1_URS = 1U << 2 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM17_CR1_OPM = 1U << 3 ;

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM17_CR1_ARPE = 1U << 7 ;

  // Field CKD: Clock division
    inline uint32_t TIM17_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM17_CR1_UIFREMAP = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM17_CR2 (* ((volatile uint32_t *) (0x40014800 + 4)))

  // Field OIS1N: Output Idle state 1
    const uint32_t TIM17_CR2_OIS1N = 1U << 9 ;

  // Field OIS1: Output Idle state 1
    const uint32_t TIM17_CR2_OIS1 = 1U << 8 ;

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM17_CR2_CCDS = 1U << 3 ;

  // Field CCUS: Capture/compare control update selection
    const uint32_t TIM17_CR2_CCUS = 1U << 2 ;

  // Field CCPC: Capture/compare preloaded control
    const uint32_t TIM17_CR2_CCPC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM17_DIER (* ((volatile uint32_t *) (0x40014800 + 12)))

  // Field UIE: Update interrupt enable
    const uint32_t TIM17_DIER_UIE = 1U << 0 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM17_DIER_CC1IE = 1U << 1 ;

  // Field COMIE: COM interrupt enable
    const uint32_t TIM17_DIER_COMIE = 1U << 5 ;

  // Field BIE: Break interrupt enable
    const uint32_t TIM17_DIER_BIE = 1U << 7 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM17_DIER_UDE = 1U << 8 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM17_DIER_CC1DE = 1U << 9 ;

  // Field COMDE: COM DMA request enable
    const uint32_t TIM17_DIER_COMDE = 1U << 13 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM17_SR (* ((volatile uint32_t *) (0x40014800 + 16)))

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM17_SR_CC1OF = 1U << 9 ;

  // Field BIF: Break interrupt flag
    const uint32_t TIM17_SR_BIF = 1U << 7 ;

  // Field COMIF: COM interrupt flag
    const uint32_t TIM17_SR_COMIF = 1U << 5 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM17_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM17_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM17_EGR (* ((volatile uint32_t *) (0x40014800 + 20)))

  // Field BG: Break generation
    const uint32_t TIM17_EGR_BG = 1U << 7 ;

  // Field COMG: Capture/Compare control update generation
    const uint32_t TIM17_EGR_COMG = 1U << 5 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM17_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM17_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register (output mode)
  #define TIM17_CCMR1_Output (* ((volatile uint32_t *) (0x40014800 + 24)))

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM17_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: Output Compare 1 fast enable
    const uint32_t TIM17_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: Output Compare 1 preload enable
    const uint32_t TIM17_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: Output Compare 1 mode
    inline uint32_t TIM17_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1M_3: Output Compare 1 mode
    const uint32_t TIM17_CCMR1_Output_OC1M_3 = 1U << 16 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM17_CCMR1_Input (* ((volatile uint32_t *) (0x40014800 + 24)))

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM17_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC1PSC: Input capture 1 prescaler
    inline uint32_t TIM17_CCMR1_Input_IC1PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM17_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM17_CCER (* ((volatile uint32_t *) (0x40014800 + 32)))

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM17_CCER_CC1NP = 1U << 3 ;

  // Field CC1NE: Capture/Compare 1 complementary output enable
    const uint32_t TIM17_CCER_CC1NE = 1U << 2 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM17_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM17_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM17_CNT (* ((volatile uint32_t *) (0x40014800 + 36)))

  // Field CNT: counter value
    inline uint32_t TIM17_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF Copy
    const uint32_t TIM17_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM17_PSC (* ((volatile uint32_t *) (0x40014800 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM17_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM17_ARR (* ((volatile uint32_t *) (0x40014800 + 44)))

  // Field ARR: Auto-reload value
    inline uint32_t TIM17_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RCR: repetition counter register
  #define TIM17_RCR (* ((volatile uint32_t *) (0x40014800 + 48)))

  // Field REP: Repetition counter value
    inline uint32_t TIM17_RCR_REP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM17_CCR1 (* ((volatile uint32_t *) (0x40014800 + 52)))

  // Field CCR1: Capture/Compare 1 value
    inline uint32_t TIM17_CCR1_CCR1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BDTR: break and dead-time register
  #define TIM17_BDTR (* ((volatile uint32_t *) (0x40014800 + 68)))

  // Field DTG: Dead-time generator setup
    inline uint32_t TIM17_BDTR_DTG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field LOCK: Lock configuration
    inline uint32_t TIM17_BDTR_LOCK (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSSI: Off-state selection for Idle mode
    const uint32_t TIM17_BDTR_OSSI = 1U << 10 ;

  // Field OSSR: Off-state selection for Run mode
    const uint32_t TIM17_BDTR_OSSR = 1U << 11 ;

  // Field BKE: Break enable
    const uint32_t TIM17_BDTR_BKE = 1U << 12 ;

  // Field BKP: Break polarity
    const uint32_t TIM17_BDTR_BKP = 1U << 13 ;

  // Field AOE: Automatic output enable
    const uint32_t TIM17_BDTR_AOE = 1U << 14 ;

  // Field MOE: Main output enable
    const uint32_t TIM17_BDTR_MOE = 1U << 15 ;

  // Field BKF: Break filter
    inline uint32_t TIM17_BDTR_BKF (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM17_DCR (* ((volatile uint32_t *) (0x40014800 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM17_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM17_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM17_DMAR (* ((volatile uint32_t *) (0x40014800 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM17_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TIM17_AF1: TIM17 alternate function register 1
  #define TIM17_TIM17_AF1 (* ((volatile uint32_t *) (0x40014800 + 96)))

  // Field BKINE: BRK BKIN input enable
    const uint32_t TIM17_TIM17_AF1_BKINE = 1U << 0 ;

  // Field BKCMP1E: BRK COMP1 enable
    const uint32_t TIM17_TIM17_AF1_BKCMP1E = 1U << 1 ;

  // Field BKCMP2E: BRK COMP2 enable
    const uint32_t TIM17_TIM17_AF1_BKCMP2E = 1U << 2 ;

  // Field BKDFBK1E: BRK dfsdm1_break[1] enable
    const uint32_t TIM17_TIM17_AF1_BKDFBK1E = 1U << 8 ;

  // Field BKINP: BRK BKIN input polarity
    const uint32_t TIM17_TIM17_AF1_BKINP = 1U << 9 ;

  // Field BKCMP1P: BRK COMP1 input polarity
    const uint32_t TIM17_TIM17_AF1_BKCMP1P = 1U << 10 ;

  // Field BKCMP2P: BRK COMP2 input polarity
    const uint32_t TIM17_TIM17_AF1_BKCMP2P = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register TIM17_TISEL: TIM17 input selection register
  #define TIM17_TIM17_TISEL (* ((volatile uint32_t *) (0x40014800 + 104)))

  // Field TI1SEL: selects TI1[0] to TI1[15] input
    inline uint32_t TIM17_TIM17_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral TIM2: General purpose timers
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM2_CR1 (* ((volatile uint32_t *) (0x40000000 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM2_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM2_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM2_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM2_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM2_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM2_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM2_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM2_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM2_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM2_CR2 (* ((volatile uint32_t *) (0x40000000 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM2_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM2_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM2_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM2_SMCR (* ((volatile uint32_t *) (0x40000000 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM2_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM2_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM2_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM2_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM2_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM2_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM2_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM2_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM2_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM2_DIER (* ((volatile uint32_t *) (0x40000000 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM2_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM2_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM2_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM2_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM2_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM2_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM2_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM2_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM2_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM2_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM2_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM2_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM2_SR (* ((volatile uint32_t *) (0x40000000 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM2_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM2_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM2_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM2_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM2_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM2_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM2_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM2_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM2_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM2_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM2_EGR (* ((volatile uint32_t *) (0x40000000 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM2_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM2_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM2_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM2_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM2_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM2_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM2_CCMR1_Output (* ((volatile uint32_t *) (0x40000000 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM2_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM2_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM2_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM2_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM2_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM2_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM2_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM2_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM2_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM2_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM2_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM2_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM2_CCMR1_Input (* ((volatile uint32_t *) (0x40000000 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM2_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM2_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM2_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM2_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM2_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM2_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM2_CCMR2_Output (* ((volatile uint32_t *) (0x40000000 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM2_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM2_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM2_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM2_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM2_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM2_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM2_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM2_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM2_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM2_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM2_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM2_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM2_CCMR2_Input (* ((volatile uint32_t *) (0x40000000 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM2_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM2_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM2_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM2_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM2_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM2_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM2_CCER (* ((volatile uint32_t *) (0x40000000 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM2_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM2_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM2_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM2_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM2_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM2_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM2_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM2_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM2_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM2_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM2_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM2_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM2_CNT (* ((volatile uint32_t *) (0x40000000 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM2_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM2_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM2_PSC (* ((volatile uint32_t *) (0x40000000 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM2_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM2_ARR (* ((volatile uint32_t *) (0x40000000 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM2_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM2_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM2_CCR1 (* ((volatile uint32_t *) (0x40000000 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM2_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM2_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM2_CCR2 (* ((volatile uint32_t *) (0x40000000 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM2_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM2_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM2_CCR3 (* ((volatile uint32_t *) (0x40000000 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM2_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM2_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM2_CCR4 (* ((volatile uint32_t *) (0x40000000 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM2_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM2_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM2_DCR (* ((volatile uint32_t *) (0x40000000 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM2_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM2_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM2_DMAR (* ((volatile uint32_t *) (0x40000000 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM2_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM2_AF1 (* ((volatile uint32_t *) (0x40000000 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM2_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM2_TISEL (* ((volatile uint32_t *) (0x40000000 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM2_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM2_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM2_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM2_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM3
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM3_CR1 (* ((volatile uint32_t *) (0x40000400 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM3_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM3_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM3_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM3_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM3_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM3_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM3_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM3_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM3_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM3_CR2 (* ((volatile uint32_t *) (0x40000400 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM3_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM3_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM3_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM3_SMCR (* ((volatile uint32_t *) (0x40000400 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM3_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM3_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM3_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM3_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM3_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM3_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM3_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM3_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM3_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM3_DIER (* ((volatile uint32_t *) (0x40000400 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM3_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM3_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM3_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM3_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM3_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM3_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM3_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM3_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM3_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM3_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM3_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM3_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM3_SR (* ((volatile uint32_t *) (0x40000400 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM3_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM3_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM3_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM3_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM3_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM3_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM3_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM3_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM3_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM3_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM3_EGR (* ((volatile uint32_t *) (0x40000400 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM3_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM3_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM3_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM3_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM3_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM3_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM3_CCMR1_Output (* ((volatile uint32_t *) (0x40000400 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM3_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM3_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM3_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM3_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM3_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM3_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM3_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM3_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM3_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM3_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM3_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM3_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM3_CCMR1_Input (* ((volatile uint32_t *) (0x40000400 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM3_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM3_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM3_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM3_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM3_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM3_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM3_CCMR2_Output (* ((volatile uint32_t *) (0x40000400 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM3_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM3_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM3_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM3_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM3_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM3_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM3_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM3_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM3_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM3_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM3_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM3_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM3_CCMR2_Input (* ((volatile uint32_t *) (0x40000400 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM3_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM3_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM3_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM3_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM3_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM3_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM3_CCER (* ((volatile uint32_t *) (0x40000400 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM3_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM3_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM3_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM3_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM3_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM3_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM3_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM3_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM3_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM3_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM3_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM3_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM3_CNT (* ((volatile uint32_t *) (0x40000400 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM3_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM3_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM3_PSC (* ((volatile uint32_t *) (0x40000400 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM3_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM3_ARR (* ((volatile uint32_t *) (0x40000400 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM3_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM3_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM3_CCR1 (* ((volatile uint32_t *) (0x40000400 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM3_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM3_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM3_CCR2 (* ((volatile uint32_t *) (0x40000400 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM3_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM3_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM3_CCR3 (* ((volatile uint32_t *) (0x40000400 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM3_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM3_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM3_CCR4 (* ((volatile uint32_t *) (0x40000400 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM3_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM3_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM3_DCR (* ((volatile uint32_t *) (0x40000400 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM3_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM3_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM3_DMAR (* ((volatile uint32_t *) (0x40000400 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM3_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM3_AF1 (* ((volatile uint32_t *) (0x40000400 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM3_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM3_TISEL (* ((volatile uint32_t *) (0x40000400 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM3_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM3_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM3_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM3_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM4
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM4_CR1 (* ((volatile uint32_t *) (0x40000800 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM4_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM4_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM4_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM4_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM4_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM4_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM4_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM4_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM4_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM4_CR2 (* ((volatile uint32_t *) (0x40000800 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM4_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM4_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM4_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM4_SMCR (* ((volatile uint32_t *) (0x40000800 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM4_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM4_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM4_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM4_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM4_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM4_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM4_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM4_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM4_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM4_DIER (* ((volatile uint32_t *) (0x40000800 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM4_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM4_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM4_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM4_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM4_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM4_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM4_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM4_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM4_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM4_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM4_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM4_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM4_SR (* ((volatile uint32_t *) (0x40000800 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM4_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM4_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM4_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM4_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM4_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM4_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM4_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM4_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM4_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM4_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM4_EGR (* ((volatile uint32_t *) (0x40000800 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM4_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM4_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM4_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM4_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM4_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM4_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM4_CCMR1_Output (* ((volatile uint32_t *) (0x40000800 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM4_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM4_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM4_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM4_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM4_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM4_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM4_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM4_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM4_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM4_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM4_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM4_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM4_CCMR1_Input (* ((volatile uint32_t *) (0x40000800 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM4_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM4_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM4_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM4_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM4_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM4_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM4_CCMR2_Output (* ((volatile uint32_t *) (0x40000800 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM4_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM4_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM4_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM4_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM4_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM4_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM4_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM4_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM4_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM4_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM4_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM4_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM4_CCMR2_Input (* ((volatile uint32_t *) (0x40000800 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM4_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM4_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM4_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM4_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM4_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM4_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM4_CCER (* ((volatile uint32_t *) (0x40000800 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM4_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM4_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM4_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM4_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM4_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM4_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM4_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM4_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM4_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM4_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM4_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM4_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM4_CNT (* ((volatile uint32_t *) (0x40000800 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM4_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM4_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM4_PSC (* ((volatile uint32_t *) (0x40000800 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM4_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM4_ARR (* ((volatile uint32_t *) (0x40000800 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM4_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM4_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM4_CCR1 (* ((volatile uint32_t *) (0x40000800 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM4_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM4_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM4_CCR2 (* ((volatile uint32_t *) (0x40000800 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM4_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM4_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM4_CCR3 (* ((volatile uint32_t *) (0x40000800 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM4_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM4_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM4_CCR4 (* ((volatile uint32_t *) (0x40000800 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM4_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM4_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM4_DCR (* ((volatile uint32_t *) (0x40000800 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM4_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM4_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM4_DMAR (* ((volatile uint32_t *) (0x40000800 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM4_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM4_AF1 (* ((volatile uint32_t *) (0x40000800 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM4_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM4_TISEL (* ((volatile uint32_t *) (0x40000800 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM4_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM4_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM4_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM4_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM5
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM5_CR1 (* ((volatile uint32_t *) (0x40000C00 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM5_CR1_UIFREMAP = 1U << 11 ;

  // Field CKD: Clock division
    inline uint32_t TIM5_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM5_CR1_ARPE = 1U << 7 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM5_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field DIR: Direction
    const uint32_t TIM5_CR1_DIR = 1U << 4 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM5_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM5_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM5_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM5_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM5_CR2 (* ((volatile uint32_t *) (0x40000C00 + 4)))

  // Field TI1S: TI1 selection
    const uint32_t TIM5_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM5_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM5_CR2_CCDS = 1U << 3 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM5_SMCR (* ((volatile uint32_t *) (0x40000C00 + 8)))

  // Field TS_4_3: Trigger selection
    inline uint32_t TIM5_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM5_SMCR_SMS_3 = 1U << 16 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM5_SMCR_ETP = 1U << 15 ;

  // Field ECE: External clock enable
    const uint32_t TIM5_SMCR_ECE = 1U << 14 ;

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM5_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ETF: External trigger filter
    inline uint32_t TIM5_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM5_SMCR_MSM = 1U << 7 ;

  // Field TS: Trigger selection
    inline uint32_t TIM5_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field SMS: Slave mode selection
    inline uint32_t TIM5_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM5_DIER (* ((volatile uint32_t *) (0x40000C00 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM5_DIER_TDE = 1U << 14 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM5_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM5_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM5_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM5_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM5_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM5_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM5_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM5_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM5_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM5_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM5_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM5_SR (* ((volatile uint32_t *) (0x40000C00 + 16)))

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM5_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM5_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM5_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM5_SR_CC1OF = 1U << 9 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM5_SR_TIF = 1U << 6 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM5_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM5_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM5_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM5_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM5_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM5_EGR (* ((volatile uint32_t *) (0x40000C00 + 20)))

  // Field TG: Trigger generation
    const uint32_t TIM5_EGR_TG = 1U << 6 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM5_EGR_CC4G = 1U << 4 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM5_EGR_CC3G = 1U << 3 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM5_EGR_CC2G = 1U << 2 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM5_EGR_CC1G = 1U << 1 ;

  // Field UG: Update generation
    const uint32_t TIM5_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM5_CCMR1_Output (* ((volatile uint32_t *) (0x40000C00 + 24)))

  // Field CC1S: CC1S
    inline uint32_t TIM5_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: OC1FE
    const uint32_t TIM5_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: OC1PE
    const uint32_t TIM5_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: OC1M
    inline uint32_t TIM5_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: OC1CE
    const uint32_t TIM5_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: CC2S
    inline uint32_t TIM5_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: OC2FE
    const uint32_t TIM5_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: OC2PE
    const uint32_t TIM5_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: OC2M
    inline uint32_t TIM5_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: OC2CE
    const uint32_t TIM5_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM5_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM5_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM5_CCMR1_Input (* ((volatile uint32_t *) (0x40000C00 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM5_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM5_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM5_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM5_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM5_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM5_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM5_CCMR2_Output (* ((volatile uint32_t *) (0x40000C00 + 28)))

  // Field OC4M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM5_CCMR2_Output_OC4M_3 = 1U << 24 ;

  // Field OC3M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM5_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field O24CE: O24CE
    const uint32_t TIM5_CCMR2_Output_O24CE = 1U << 15 ;

  // Field OC4M: OC4M
    inline uint32_t TIM5_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4PE: OC4PE
    const uint32_t TIM5_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4FE: OC4FE
    const uint32_t TIM5_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field CC4S: CC4S
    inline uint32_t TIM5_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC3CE: OC3CE
    const uint32_t TIM5_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field OC3M: OC3M
    inline uint32_t TIM5_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3PE: OC3PE
    const uint32_t TIM5_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3FE: OC3FE
    const uint32_t TIM5_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field CC3S: CC3S
    inline uint32_t TIM5_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM5_CCMR2_Input (* ((volatile uint32_t *) (0x40000C00 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM5_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM5_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM5_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM5_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM5_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM5_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM5_CCER (* ((volatile uint32_t *) (0x40000C00 + 32)))

  // Field CC4NP: Capture/Compare 4 output Polarity
    const uint32_t TIM5_CCER_CC4NP = 1U << 15 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM5_CCER_CC4P = 1U << 13 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM5_CCER_CC4E = 1U << 12 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM5_CCER_CC3NP = 1U << 11 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM5_CCER_CC3P = 1U << 9 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM5_CCER_CC3E = 1U << 8 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM5_CCER_CC2NP = 1U << 7 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM5_CCER_CC2P = 1U << 5 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM5_CCER_CC2E = 1U << 4 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM5_CCER_CC1NP = 1U << 3 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM5_CCER_CC1P = 1U << 1 ;

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM5_CCER_CC1E = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM5_CNT (* ((volatile uint32_t *) (0x40000C00 + 36)))

  // Field CNT_L: low counter value
    inline uint32_t TIM5_CNT_CNT_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field CNT_H: High counter value
    inline uint32_t TIM5_CNT_CNT_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM5_PSC (* ((volatile uint32_t *) (0x40000C00 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM5_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM5_ARR (* ((volatile uint32_t *) (0x40000C00 + 44)))

  // Field ARR_H: High Auto-reload value
    inline uint32_t TIM5_ARR_ARR_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field ARR_L: Low Auto-reload value
    inline uint32_t TIM5_ARR_ARR_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM5_CCR1 (* ((volatile uint32_t *) (0x40000C00 + 52)))

  // Field CCR1_H: High Capture/Compare 1 value
    inline uint32_t TIM5_CCR1_CCR1_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR1_L: Low Capture/Compare 1 value
    inline uint32_t TIM5_CCR1_CCR1_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM5_CCR2 (* ((volatile uint32_t *) (0x40000C00 + 56)))

  // Field CCR2_H: High Capture/Compare 2 value
    inline uint32_t TIM5_CCR2_CCR2_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR2_L: Low Capture/Compare 2 value
    inline uint32_t TIM5_CCR2_CCR2_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM5_CCR3 (* ((volatile uint32_t *) (0x40000C00 + 60)))

  // Field CCR3_H: High Capture/Compare value
    inline uint32_t TIM5_CCR3_CCR3_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR3_L: Low Capture/Compare value
    inline uint32_t TIM5_CCR3_CCR3_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM5_CCR4 (* ((volatile uint32_t *) (0x40000C00 + 64)))

  // Field CCR4_H: High Capture/Compare value
    inline uint32_t TIM5_CCR4_CCR4_H (const uint32_t inValue) {return (inValue & 0xFFFFU) << 16 ; }

  // Field CCR4_L: Low Capture/Compare value
    inline uint32_t TIM5_CCR4_CCR4_L (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM5_DCR (* ((volatile uint32_t *) (0x40000C00 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM5_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM5_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM5_DMAR (* ((volatile uint32_t *) (0x40000C00 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM5_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM alternate function option register 1
  #define TIM5_AF1 (* ((volatile uint32_t *) (0x40000C00 + 96)))

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM5_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register TISEL: TIM timer input selection register
  #define TIM5_TISEL (* ((volatile uint32_t *) (0x40000C00 + 104)))

  // Field TI1SEL: TI1[0] to TI1[15] input selection
    inline uint32_t TIM5_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: TI2[0] to TI2[15] input selection
    inline uint32_t TIM5_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: TI3[0] to TI3[15] input selection
    inline uint32_t TIM5_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: TI4[0] to TI4[15] input selection
    inline uint32_t TIM5_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral TIM6: Basic timers
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM6_CR1 (* ((volatile uint32_t *) (0x40001000 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM6_CR1_UIFREMAP = 1U << 11 ;

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM6_CR1_ARPE = 1U << 7 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM6_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM6_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM6_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM6_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM6_CR2 (* ((volatile uint32_t *) (0x40001000 + 4)))

  // Field MMS: Master mode selection
    inline uint32_t TIM6_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM6_DIER (* ((volatile uint32_t *) (0x40001000 + 12)))

  // Field UDE: Update DMA request enable
    const uint32_t TIM6_DIER_UDE = 1U << 8 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM6_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM6_SR (* ((volatile uint32_t *) (0x40001000 + 16)))

  // Field UIF: Update interrupt flag
    const uint32_t TIM6_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM6_EGR (* ((volatile uint32_t *) (0x40001000 + 20)))

  // Field UG: Update generation
    const uint32_t TIM6_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM6_CNT (* ((volatile uint32_t *) (0x40001000 + 36)))

  // Field CNT: Low counter value
    inline uint32_t TIM6_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF Copy
    const uint32_t TIM6_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM6_PSC (* ((volatile uint32_t *) (0x40001000 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM6_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM6_ARR (* ((volatile uint32_t *) (0x40001000 + 44)))

  // Field ARR: Low Auto-reload value
    inline uint32_t TIM6_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral TIM7
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM7_CR1 (* ((volatile uint32_t *) (0x40001400 + 0)))

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM7_CR1_UIFREMAP = 1U << 11 ;

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM7_CR1_ARPE = 1U << 7 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM7_CR1_OPM = 1U << 3 ;

  // Field URS: Update request source
    const uint32_t TIM7_CR1_URS = 1U << 2 ;

  // Field UDIS: Update disable
    const uint32_t TIM7_CR1_UDIS = 1U << 1 ;

  // Field CEN: Counter enable
    const uint32_t TIM7_CR1_CEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM7_CR2 (* ((volatile uint32_t *) (0x40001400 + 4)))

  // Field MMS: Master mode selection
    inline uint32_t TIM7_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM7_DIER (* ((volatile uint32_t *) (0x40001400 + 12)))

  // Field UDE: Update DMA request enable
    const uint32_t TIM7_DIER_UDE = 1U << 8 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM7_DIER_UIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM7_SR (* ((volatile uint32_t *) (0x40001400 + 16)))

  // Field UIF: Update interrupt flag
    const uint32_t TIM7_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM7_EGR (* ((volatile uint32_t *) (0x40001400 + 20)))

  // Field UG: Update generation
    const uint32_t TIM7_EGR_UG = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM7_CNT (* ((volatile uint32_t *) (0x40001400 + 36)))

  // Field CNT: Low counter value
    inline uint32_t TIM7_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF Copy
    const uint32_t TIM7_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM7_PSC (* ((volatile uint32_t *) (0x40001400 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM7_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM7_ARR (* ((volatile uint32_t *) (0x40001400 + 44)))

  // Field ARR: Low Auto-reload value
    inline uint32_t TIM7_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral TIM8
//------------------------------------------------------------------------------

//---  Register CR1: control register 1
  #define TIM8_CR1 (* ((volatile uint32_t *) (0x40010400 + 0)))

  // Field CEN: Counter enable
    const uint32_t TIM8_CR1_CEN = 1U << 0 ;

  // Field UDIS: Update disable
    const uint32_t TIM8_CR1_UDIS = 1U << 1 ;

  // Field URS: Update request source
    const uint32_t TIM8_CR1_URS = 1U << 2 ;

  // Field OPM: One-pulse mode
    const uint32_t TIM8_CR1_OPM = 1U << 3 ;

  // Field DIR: Direction
    const uint32_t TIM8_CR1_DIR = 1U << 4 ;

  // Field CMS: Center-aligned mode selection
    inline uint32_t TIM8_CR1_CMS (const uint32_t inValue) {return (inValue & 0x3U) << 5 ; }

  // Field ARPE: Auto-reload preload enable
    const uint32_t TIM8_CR1_ARPE = 1U << 7 ;

  // Field CKD: Clock division
    inline uint32_t TIM8_CR1_CKD (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field UIFREMAP: UIF status bit remapping
    const uint32_t TIM8_CR1_UIFREMAP = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register CR2: control register 2
  #define TIM8_CR2 (* ((volatile uint32_t *) (0x40010400 + 4)))

  // Field MMS2: Master mode selection 2
    inline uint32_t TIM8_CR2_MMS2 (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field OIS6: Output Idle state 6
    const uint32_t TIM8_CR2_OIS6 = 1U << 18 ;

  // Field OIS5: Output Idle state 5
    const uint32_t TIM8_CR2_OIS5 = 1U << 16 ;

  // Field OIS4: Output Idle state 4
    const uint32_t TIM8_CR2_OIS4 = 1U << 14 ;

  // Field OIS3N: Output Idle state 3
    const uint32_t TIM8_CR2_OIS3N = 1U << 13 ;

  // Field OIS3: Output Idle state 3
    const uint32_t TIM8_CR2_OIS3 = 1U << 12 ;

  // Field OIS2N: Output Idle state 2
    const uint32_t TIM8_CR2_OIS2N = 1U << 11 ;

  // Field OIS2: Output Idle state 2
    const uint32_t TIM8_CR2_OIS2 = 1U << 10 ;

  // Field OIS1N: Output Idle state 1
    const uint32_t TIM8_CR2_OIS1N = 1U << 9 ;

  // Field OIS1: Output Idle state 1
    const uint32_t TIM8_CR2_OIS1 = 1U << 8 ;

  // Field TI1S: TI1 selection
    const uint32_t TIM8_CR2_TI1S = 1U << 7 ;

  // Field MMS: Master mode selection
    inline uint32_t TIM8_CR2_MMS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field CCDS: Capture/compare DMA selection
    const uint32_t TIM8_CR2_CCDS = 1U << 3 ;

  // Field CCUS: Capture/compare control update selection
    const uint32_t TIM8_CR2_CCUS = 1U << 2 ;

  // Field CCPC: Capture/compare preloaded control
    const uint32_t TIM8_CR2_CCPC = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register SMCR: slave mode control register
  #define TIM8_SMCR (* ((volatile uint32_t *) (0x40010400 + 8)))

  // Field SMS: Slave mode selection
    inline uint32_t TIM8_SMCR_SMS (const uint32_t inValue) {return (inValue & 0x7U) << 0 ; }

  // Field TS: Trigger selection
    inline uint32_t TIM8_SMCR_TS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field MSM: Master/Slave mode
    const uint32_t TIM8_SMCR_MSM = 1U << 7 ;

  // Field ETF: External trigger filter
    inline uint32_t TIM8_SMCR_ETF (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field ETPS: External trigger prescaler
    inline uint32_t TIM8_SMCR_ETPS (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field ECE: External clock enable
    const uint32_t TIM8_SMCR_ECE = 1U << 14 ;

  // Field ETP: External trigger polarity
    const uint32_t TIM8_SMCR_ETP = 1U << 15 ;

  // Field SMS_3: Slave mode selection - bit 3
    const uint32_t TIM8_SMCR_SMS_3 = 1U << 16 ;

  // Field TS_4_3: Trigger selection - bit 4:3
    inline uint32_t TIM8_SMCR_TS_4_3 (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

//------------------------------------------------------------------------------

//---  Register DIER: DMA/Interrupt enable register
  #define TIM8_DIER (* ((volatile uint32_t *) (0x40010400 + 12)))

  // Field TDE: Trigger DMA request enable
    const uint32_t TIM8_DIER_TDE = 1U << 14 ;

  // Field COMDE: COM DMA request enable
    const uint32_t TIM8_DIER_COMDE = 1U << 13 ;

  // Field CC4DE: Capture/Compare 4 DMA request enable
    const uint32_t TIM8_DIER_CC4DE = 1U << 12 ;

  // Field CC3DE: Capture/Compare 3 DMA request enable
    const uint32_t TIM8_DIER_CC3DE = 1U << 11 ;

  // Field CC2DE: Capture/Compare 2 DMA request enable
    const uint32_t TIM8_DIER_CC2DE = 1U << 10 ;

  // Field CC1DE: Capture/Compare 1 DMA request enable
    const uint32_t TIM8_DIER_CC1DE = 1U << 9 ;

  // Field UDE: Update DMA request enable
    const uint32_t TIM8_DIER_UDE = 1U << 8 ;

  // Field TIE: Trigger interrupt enable
    const uint32_t TIM8_DIER_TIE = 1U << 6 ;

  // Field CC4IE: Capture/Compare 4 interrupt enable
    const uint32_t TIM8_DIER_CC4IE = 1U << 4 ;

  // Field CC3IE: Capture/Compare 3 interrupt enable
    const uint32_t TIM8_DIER_CC3IE = 1U << 3 ;

  // Field CC2IE: Capture/Compare 2 interrupt enable
    const uint32_t TIM8_DIER_CC2IE = 1U << 2 ;

  // Field CC1IE: Capture/Compare 1 interrupt enable
    const uint32_t TIM8_DIER_CC1IE = 1U << 1 ;

  // Field UIE: Update interrupt enable
    const uint32_t TIM8_DIER_UIE = 1U << 0 ;

  // Field BIE: Break interrupt enable
    const uint32_t TIM8_DIER_BIE = 1U << 7 ;

  // Field COMIE: COM interrupt enable
    const uint32_t TIM8_DIER_COMIE = 1U << 5 ;

//------------------------------------------------------------------------------

//---  Register SR: status register
  #define TIM8_SR (* ((volatile uint32_t *) (0x40010400 + 16)))

  // Field CC6IF: Compare 6 interrupt flag
    const uint32_t TIM8_SR_CC6IF = 1U << 17 ;

  // Field CC5IF: Compare 5 interrupt flag
    const uint32_t TIM8_SR_CC5IF = 1U << 16 ;

  // Field SBIF: System Break interrupt flag
    const uint32_t TIM8_SR_SBIF = 1U << 13 ;

  // Field CC4OF: Capture/Compare 4 overcapture flag
    const uint32_t TIM8_SR_CC4OF = 1U << 12 ;

  // Field CC3OF: Capture/Compare 3 overcapture flag
    const uint32_t TIM8_SR_CC3OF = 1U << 11 ;

  // Field CC2OF: Capture/compare 2 overcapture flag
    const uint32_t TIM8_SR_CC2OF = 1U << 10 ;

  // Field CC1OF: Capture/Compare 1 overcapture flag
    const uint32_t TIM8_SR_CC1OF = 1U << 9 ;

  // Field B2IF: Break 2 interrupt flag
    const uint32_t TIM8_SR_B2IF = 1U << 8 ;

  // Field BIF: Break interrupt flag
    const uint32_t TIM8_SR_BIF = 1U << 7 ;

  // Field TIF: Trigger interrupt flag
    const uint32_t TIM8_SR_TIF = 1U << 6 ;

  // Field COMIF: COM interrupt flag
    const uint32_t TIM8_SR_COMIF = 1U << 5 ;

  // Field CC4IF: Capture/Compare 4 interrupt flag
    const uint32_t TIM8_SR_CC4IF = 1U << 4 ;

  // Field CC3IF: Capture/Compare 3 interrupt flag
    const uint32_t TIM8_SR_CC3IF = 1U << 3 ;

  // Field CC2IF: Capture/Compare 2 interrupt flag
    const uint32_t TIM8_SR_CC2IF = 1U << 2 ;

  // Field CC1IF: Capture/compare 1 interrupt flag
    const uint32_t TIM8_SR_CC1IF = 1U << 1 ;

  // Field UIF: Update interrupt flag
    const uint32_t TIM8_SR_UIF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register EGR: event generation register
  #define TIM8_EGR (* ((volatile uint32_t *) (0x40010400 + 20)))

  // Field UG: Update generation
    const uint32_t TIM8_EGR_UG = 1U << 0 ;

  // Field CC1G: Capture/compare 1 generation
    const uint32_t TIM8_EGR_CC1G = 1U << 1 ;

  // Field CC2G: Capture/compare 2 generation
    const uint32_t TIM8_EGR_CC2G = 1U << 2 ;

  // Field CC3G: Capture/compare 3 generation
    const uint32_t TIM8_EGR_CC3G = 1U << 3 ;

  // Field CC4G: Capture/compare 4 generation
    const uint32_t TIM8_EGR_CC4G = 1U << 4 ;

  // Field COMG: Capture/Compare control update generation
    const uint32_t TIM8_EGR_COMG = 1U << 5 ;

  // Field TG: Trigger generation
    const uint32_t TIM8_EGR_TG = 1U << 6 ;

  // Field BG: Break generation
    const uint32_t TIM8_EGR_BG = 1U << 7 ;

  // Field B2G: Break 2 generation
    const uint32_t TIM8_EGR_B2G = 1U << 8 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Output: capture/compare mode register 1 (output mode)
  #define TIM8_CCMR1_Output (* ((volatile uint32_t *) (0x40010400 + 24)))

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM8_CCMR1_Output_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC1FE: Output Compare 1 fast enable
    const uint32_t TIM8_CCMR1_Output_OC1FE = 1U << 2 ;

  // Field OC1PE: Output Compare 1 preload enable
    const uint32_t TIM8_CCMR1_Output_OC1PE = 1U << 3 ;

  // Field OC1M: Output Compare 1 mode
    inline uint32_t TIM8_CCMR1_Output_OC1M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC1CE: Output Compare 1 clear enable
    const uint32_t TIM8_CCMR1_Output_OC1CE = 1U << 7 ;

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM8_CCMR1_Output_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC2FE: Output Compare 2 fast enable
    const uint32_t TIM8_CCMR1_Output_OC2FE = 1U << 10 ;

  // Field OC2PE: Output Compare 2 preload enable
    const uint32_t TIM8_CCMR1_Output_OC2PE = 1U << 11 ;

  // Field OC2M: Output Compare 2 mode
    inline uint32_t TIM8_CCMR1_Output_OC2M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC2CE: Output Compare 2 clear enable
    const uint32_t TIM8_CCMR1_Output_OC2CE = 1U << 15 ;

  // Field OC1M_3: Output Compare 1 mode - bit 3
    const uint32_t TIM8_CCMR1_Output_OC1M_3 = 1U << 16 ;

  // Field OC2M_3: Output Compare 2 mode - bit 3
    const uint32_t TIM8_CCMR1_Output_OC2M_3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR1_Input: capture/compare mode register 1 (input mode)
  #define TIM8_CCMR1_Input (* ((volatile uint32_t *) (0x40010400 + 24)))

  // Field IC2F: Input capture 2 filter
    inline uint32_t TIM8_CCMR1_Input_IC2F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC2PCS: Input capture 2 prescaler
    inline uint32_t TIM8_CCMR1_Input_IC2PCS (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC2S: Capture/Compare 2 selection
    inline uint32_t TIM8_CCMR1_Input_CC2S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC1F: Input capture 1 filter
    inline uint32_t TIM8_CCMR1_Input_IC1F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field ICPCS: Input capture 1 prescaler
    inline uint32_t TIM8_CCMR1_Input_ICPCS (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC1S: Capture/Compare 1 selection
    inline uint32_t TIM8_CCMR1_Input_CC1S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCMR2_Output: capture/compare mode register 2 (output mode)
  #define TIM8_CCMR2_Output (* ((volatile uint32_t *) (0x40010400 + 28)))

  // Field CC3S: Capture/Compare 3 selection
    inline uint32_t TIM8_CCMR2_Output_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

  // Field OC3FE: Output compare 3 fast enable
    const uint32_t TIM8_CCMR2_Output_OC3FE = 1U << 2 ;

  // Field OC3PE: Output compare 3 preload enable
    const uint32_t TIM8_CCMR2_Output_OC3PE = 1U << 3 ;

  // Field OC3M: Output compare 3 mode
    inline uint32_t TIM8_CCMR2_Output_OC3M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC3CE: Output compare 3 clear enable
    const uint32_t TIM8_CCMR2_Output_OC3CE = 1U << 7 ;

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM8_CCMR2_Output_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OC4FE: Output compare 4 fast enable
    const uint32_t TIM8_CCMR2_Output_OC4FE = 1U << 10 ;

  // Field OC4PE: Output compare 4 preload enable
    const uint32_t TIM8_CCMR2_Output_OC4PE = 1U << 11 ;

  // Field OC4M: Output compare 4 mode
    inline uint32_t TIM8_CCMR2_Output_OC4M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC4CE: Output compare 4 clear enable
    const uint32_t TIM8_CCMR2_Output_OC4CE = 1U << 15 ;

  // Field OC3M_3: Output Compare 3 mode - bit 3
    const uint32_t TIM8_CCMR2_Output_OC3M_3 = 1U << 16 ;

  // Field OC4M_4: Output Compare 4 mode - bit 3
    const uint32_t TIM8_CCMR2_Output_OC4M_4 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCMR2_Input: capture/compare mode register 2 (input mode)
  #define TIM8_CCMR2_Input (* ((volatile uint32_t *) (0x40010400 + 28)))

  // Field IC4F: Input capture 4 filter
    inline uint32_t TIM8_CCMR2_Input_IC4F (const uint32_t inValue) {return (inValue & 0xFU) << 12 ; }

  // Field IC4PSC: Input capture 4 prescaler
    inline uint32_t TIM8_CCMR2_Input_IC4PSC (const uint32_t inValue) {return (inValue & 0x3U) << 10 ; }

  // Field CC4S: Capture/Compare 4 selection
    inline uint32_t TIM8_CCMR2_Input_CC4S (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field IC3F: Input capture 3 filter
    inline uint32_t TIM8_CCMR2_Input_IC3F (const uint32_t inValue) {return (inValue & 0xFU) << 4 ; }

  // Field IC3PSC: Input capture 3 prescaler
    inline uint32_t TIM8_CCMR2_Input_IC3PSC (const uint32_t inValue) {return (inValue & 0x3U) << 2 ; }

  // Field CC3S: Capture/compare 3 selection
    inline uint32_t TIM8_CCMR2_Input_CC3S (const uint32_t inValue) {return (inValue & 0x3U) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCER: capture/compare enable register
  #define TIM8_CCER (* ((volatile uint32_t *) (0x40010400 + 32)))

  // Field CC1E: Capture/Compare 1 output enable
    const uint32_t TIM8_CCER_CC1E = 1U << 0 ;

  // Field CC1P: Capture/Compare 1 output Polarity
    const uint32_t TIM8_CCER_CC1P = 1U << 1 ;

  // Field CC1NE: Capture/Compare 1 complementary output enable
    const uint32_t TIM8_CCER_CC1NE = 1U << 2 ;

  // Field CC1NP: Capture/Compare 1 output Polarity
    const uint32_t TIM8_CCER_CC1NP = 1U << 3 ;

  // Field CC2E: Capture/Compare 2 output enable
    const uint32_t TIM8_CCER_CC2E = 1U << 4 ;

  // Field CC2P: Capture/Compare 2 output Polarity
    const uint32_t TIM8_CCER_CC2P = 1U << 5 ;

  // Field CC2NE: Capture/Compare 2 complementary output enable
    const uint32_t TIM8_CCER_CC2NE = 1U << 6 ;

  // Field CC2NP: Capture/Compare 2 output Polarity
    const uint32_t TIM8_CCER_CC2NP = 1U << 7 ;

  // Field CC3E: Capture/Compare 3 output enable
    const uint32_t TIM8_CCER_CC3E = 1U << 8 ;

  // Field CC3P: Capture/Compare 3 output Polarity
    const uint32_t TIM8_CCER_CC3P = 1U << 9 ;

  // Field CC3NE: Capture/Compare 3 complementary output enable
    const uint32_t TIM8_CCER_CC3NE = 1U << 10 ;

  // Field CC3NP: Capture/Compare 3 output Polarity
    const uint32_t TIM8_CCER_CC3NP = 1U << 11 ;

  // Field CC4E: Capture/Compare 4 output enable
    const uint32_t TIM8_CCER_CC4E = 1U << 12 ;

  // Field CC4P: Capture/Compare 3 output Polarity
    const uint32_t TIM8_CCER_CC4P = 1U << 13 ;

  // Field CC4NP: Capture/Compare 4 complementary output polarity
    const uint32_t TIM8_CCER_CC4NP = 1U << 15 ;

  // Field CC5E: Capture/Compare 5 output enable
    const uint32_t TIM8_CCER_CC5E = 1U << 16 ;

  // Field CC5P: Capture/Compare 5 output polarity
    const uint32_t TIM8_CCER_CC5P = 1U << 17 ;

  // Field CC6E: Capture/Compare 6 output enable
    const uint32_t TIM8_CCER_CC6E = 1U << 20 ;

  // Field CC6P: Capture/Compare 6 output polarity
    const uint32_t TIM8_CCER_CC6P = 1U << 21 ;

//------------------------------------------------------------------------------

//---  Register CNT: counter
  #define TIM8_CNT (* ((volatile uint32_t *) (0x40010400 + 36)))

  // Field CNT: counter value
    inline uint32_t TIM8_CNT_CNT (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field UIFCPY: UIF copy
    const uint32_t TIM8_CNT_UIFCPY = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register PSC: prescaler
  #define TIM8_PSC (* ((volatile uint32_t *) (0x40010400 + 40)))

  // Field PSC: Prescaler value
    inline uint32_t TIM8_PSC_PSC (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register ARR: auto-reload register
  #define TIM8_ARR (* ((volatile uint32_t *) (0x40010400 + 44)))

  // Field ARR: Auto-reload value
    inline uint32_t TIM8_ARR_ARR (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR1: capture/compare register 1
  #define TIM8_CCR1 (* ((volatile uint32_t *) (0x40010400 + 52)))

  // Field CCR1: Capture/Compare 1 value
    inline uint32_t TIM8_CCR1_CCR1 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR2: capture/compare register 2
  #define TIM8_CCR2 (* ((volatile uint32_t *) (0x40010400 + 56)))

  // Field CCR2: Capture/Compare 2 value
    inline uint32_t TIM8_CCR2_CCR2 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR3: capture/compare register 3
  #define TIM8_CCR3 (* ((volatile uint32_t *) (0x40010400 + 60)))

  // Field CCR3: Capture/Compare value
    inline uint32_t TIM8_CCR3_CCR3 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register CCR4: capture/compare register 4
  #define TIM8_CCR4 (* ((volatile uint32_t *) (0x40010400 + 64)))

  // Field CCR4: Capture/Compare value
    inline uint32_t TIM8_CCR4_CCR4 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DCR: DMA control register
  #define TIM8_DCR (* ((volatile uint32_t *) (0x40010400 + 72)))

  // Field DBL: DMA burst length
    inline uint32_t TIM8_DCR_DBL (const uint32_t inValue) {return (inValue & 0x1FU) << 8 ; }

  // Field DBA: DMA base address
    inline uint32_t TIM8_DCR_DBA (const uint32_t inValue) {return (inValue & 0x1FU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register DMAR: DMA address for full transfer
  #define TIM8_DMAR (* ((volatile uint32_t *) (0x40010400 + 76)))

  // Field DMAB: DMA register for burst accesses
    inline uint32_t TIM8_DMAR_DMAB (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RCR: repetition counter register
  #define TIM8_RCR (* ((volatile uint32_t *) (0x40010400 + 48)))

  // Field REP: Repetition counter value
    inline uint32_t TIM8_RCR_REP (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register BDTR: break and dead-time register
  #define TIM8_BDTR (* ((volatile uint32_t *) (0x40010400 + 68)))

  // Field DTG: Dead-time generator setup
    inline uint32_t TIM8_BDTR_DTG (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

  // Field LOCK: Lock configuration
    inline uint32_t TIM8_BDTR_LOCK (const uint32_t inValue) {return (inValue & 0x3U) << 8 ; }

  // Field OSSI: Off-state selection for Idle mode
    const uint32_t TIM8_BDTR_OSSI = 1U << 10 ;

  // Field OSSR: Off-state selection for Run mode
    const uint32_t TIM8_BDTR_OSSR = 1U << 11 ;

  // Field BKE: Break enable
    const uint32_t TIM8_BDTR_BKE = 1U << 12 ;

  // Field BKP: Break polarity
    const uint32_t TIM8_BDTR_BKP = 1U << 13 ;

  // Field AOE: Automatic output enable
    const uint32_t TIM8_BDTR_AOE = 1U << 14 ;

  // Field MOE: Main output enable
    const uint32_t TIM8_BDTR_MOE = 1U << 15 ;

  // Field BKF: Break filter
    inline uint32_t TIM8_BDTR_BKF (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field BK2F: Break 2 filter
    inline uint32_t TIM8_BDTR_BK2F (const uint32_t inValue) {return (inValue & 0xFU) << 20 ; }

  // Field BK2E: Break 2 enable
    const uint32_t TIM8_BDTR_BK2E = 1U << 24 ;

  // Field BK2P: Break 2 polarity
    const uint32_t TIM8_BDTR_BK2P = 1U << 25 ;

//------------------------------------------------------------------------------

//---  Register CCMR3_Output: capture/compare mode register 3 (output mode)
  #define TIM8_CCMR3_Output (* ((volatile uint32_t *) (0x40010400 + 84)))

  // Field OC5FE: Output compare 5 fast enable
    const uint32_t TIM8_CCMR3_Output_OC5FE = 1U << 2 ;

  // Field OC5PE: Output compare 5 preload enable
    const uint32_t TIM8_CCMR3_Output_OC5PE = 1U << 3 ;

  // Field OC5M: Output compare 5 mode
    inline uint32_t TIM8_CCMR3_Output_OC5M (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

  // Field OC5CE: Output compare 5 clear enable
    const uint32_t TIM8_CCMR3_Output_OC5CE = 1U << 7 ;

  // Field OC6FE: Output compare 6 fast enable
    const uint32_t TIM8_CCMR3_Output_OC6FE = 1U << 10 ;

  // Field OC6PE: Output compare 6 preload enable
    const uint32_t TIM8_CCMR3_Output_OC6PE = 1U << 11 ;

  // Field OC6M: Output compare 6 mode
    inline uint32_t TIM8_CCMR3_Output_OC6M (const uint32_t inValue) {return (inValue & 0x7U) << 12 ; }

  // Field OC6CE: Output compare 6 clear enable
    const uint32_t TIM8_CCMR3_Output_OC6CE = 1U << 15 ;

  // Field OC5M3: Output Compare 5 mode
    const uint32_t TIM8_CCMR3_Output_OC5M3 = 1U << 16 ;

  // Field OC6M3: Output Compare 6 mode
    const uint32_t TIM8_CCMR3_Output_OC6M3 = 1U << 24 ;

//------------------------------------------------------------------------------

//---  Register CCR5: capture/compare register 5
  #define TIM8_CCR5 (* ((volatile uint32_t *) (0x40010400 + 88)))

  // Field CCR5: Capture/Compare 5 value
    inline uint32_t TIM8_CCR5_CCR5 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

  // Field GC5C1: Group Channel 5 and Channel 1
    const uint32_t TIM8_CCR5_GC5C1 = 1U << 29 ;

  // Field GC5C2: Group Channel 5 and Channel 2
    const uint32_t TIM8_CCR5_GC5C2 = 1U << 30 ;

  // Field GC5C3: Group Channel 5 and Channel 3
    const uint32_t TIM8_CCR5_GC5C3 = 1U << 31 ;

//------------------------------------------------------------------------------

//---  Register CRR6: capture/compare register 6
  #define TIM8_CRR6 (* ((volatile uint32_t *) (0x40010400 + 92)))

  // Field CCR6: Capture/Compare 6 value
    inline uint32_t TIM8_CRR6_CCR6 (const uint32_t inValue) {return (inValue & 0xFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register AF1: TIM1 alternate function option register 1
  #define TIM8_AF1 (* ((volatile uint32_t *) (0x40010400 + 96)))

  // Field BKINE: BRK BKIN input enable
    const uint32_t TIM8_AF1_BKINE = 1U << 0 ;

  // Field BKCMP1E: BRK COMP1 enable
    const uint32_t TIM8_AF1_BKCMP1E = 1U << 1 ;

  // Field BKCMP2E: BRK COMP2 enable
    const uint32_t TIM8_AF1_BKCMP2E = 1U << 2 ;

  // Field BKDF1BK0E: BRK dfsdm1_break[0] enable
    const uint32_t TIM8_AF1_BKDF1BK0E = 1U << 8 ;

  // Field BKINP: BRK BKIN input polarity
    const uint32_t TIM8_AF1_BKINP = 1U << 9 ;

  // Field BKCMP1P: BRK COMP1 input polarity
    const uint32_t TIM8_AF1_BKCMP1P = 1U << 10 ;

  // Field BKCMP2P: BRK COMP2 input polarity
    const uint32_t TIM8_AF1_BKCMP2P = 1U << 11 ;

  // Field ETRSEL: ETR source selection
    inline uint32_t TIM8_AF1_ETRSEL (const uint32_t inValue) {return (inValue & 0xFU) << 14 ; }

//------------------------------------------------------------------------------

//---  Register AF2: TIM1 Alternate function odfsdm1_breakster 2
  #define TIM8_AF2 (* ((volatile uint32_t *) (0x40010400 + 100)))

  // Field BK2INE: BRK2 BKIN input enable
    const uint32_t TIM8_AF2_BK2INE = 1U << 0 ;

  // Field BK2CMP1E: BRK2 COMP1 enable
    const uint32_t TIM8_AF2_BK2CMP1E = 1U << 1 ;

  // Field BK2CMP2E: BRK2 COMP2 enable
    const uint32_t TIM8_AF2_BK2CMP2E = 1U << 2 ;

  // Field BK2DF1BK1E: BRK2 dfsdm1_break[1] enable
    const uint32_t TIM8_AF2_BK2DF1BK1E = 1U << 8 ;

  // Field BK2INP: BRK2 BKIN2 input polarity
    const uint32_t TIM8_AF2_BK2INP = 1U << 9 ;

  // Field BK2CMP1P: BRK2 COMP1 input polarit
    const uint32_t TIM8_AF2_BK2CMP1P = 1U << 10 ;

  // Field BK2CMP2P: BRK2 COMP2 input polarity
    const uint32_t TIM8_AF2_BK2CMP2P = 1U << 11 ;

//------------------------------------------------------------------------------

//---  Register TISEL: TIM1 timer input selection register
  #define TIM8_TISEL (* ((volatile uint32_t *) (0x40010400 + 104)))

  // Field TI1SEL: selects TI1[0] to TI1[15] input
    inline uint32_t TIM8_TISEL_TI1SEL (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

  // Field TI2SEL: selects TI2[0] to TI2[15] input
    inline uint32_t TIM8_TISEL_TI2SEL (const uint32_t inValue) {return (inValue & 0xFU) << 8 ; }

  // Field TI3SEL: selects TI3[0] to TI3[15] input
    inline uint32_t TIM8_TISEL_TI3SEL (const uint32_t inValue) {return (inValue & 0xFU) << 16 ; }

  // Field TI4SEL: selects TI4[0] to TI4[15] input
    inline uint32_t TIM8_TISEL_TI4SEL (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

//------------------------------------------------------------------------------
// Peripheral UART4
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define UART4_CR1 (* ((volatile uint32_t *) (0x40004C00 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t UART4_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t UART4_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t UART4_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t UART4_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t UART4_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t UART4_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t UART4_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t UART4_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t UART4_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t UART4_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t UART4_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t UART4_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t UART4_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t UART4_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t UART4_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t UART4_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t UART4_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t UART4_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t UART4_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t UART4_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t UART4_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t UART4_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t UART4_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t UART4_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t UART4_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t UART4_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t UART4_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t UART4_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t UART4_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t UART4_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t UART4_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t UART4_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define UART4_CR2 (* ((volatile uint32_t *) (0x40004C00 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t UART4_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t UART4_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t UART4_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t UART4_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t UART4_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t UART4_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t UART4_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t UART4_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t UART4_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t UART4_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t UART4_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t UART4_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t UART4_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t UART4_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t UART4_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t UART4_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t UART4_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t UART4_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t UART4_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t UART4_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t UART4_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t UART4_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define UART4_CR3 (* ((volatile uint32_t *) (0x40004C00 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t UART4_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t UART4_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t UART4_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t UART4_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t UART4_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t UART4_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t UART4_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t UART4_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t UART4_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t UART4_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t UART4_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t UART4_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t UART4_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t UART4_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t UART4_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t UART4_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t UART4_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t UART4_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t UART4_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t UART4_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t UART4_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t UART4_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t UART4_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t UART4_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define UART4_BRR (* ((volatile uint32_t *) (0x40004C00 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t UART4_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t UART4_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define UART4_GTPR (* ((volatile uint32_t *) (0x40004C00 + 16)))

  // Field GT: Guard time value
    inline uint32_t UART4_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t UART4_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define UART4_RTOR (* ((volatile uint32_t *) (0x40004C00 + 20)))

  // Field BLEN: Block Length
    inline uint32_t UART4_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t UART4_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define UART4_RQR (* ((volatile uint32_t *) (0x40004C00 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t UART4_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t UART4_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t UART4_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t UART4_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t UART4_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define UART4_ISR (* ((const volatile uint32_t *) (0x40004C00 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t UART4_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t UART4_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t UART4_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t UART4_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t UART4_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t UART4_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t UART4_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t UART4_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t UART4_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t UART4_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t UART4_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t UART4_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t UART4_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t UART4_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t UART4_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t UART4_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t UART4_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t UART4_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t UART4_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t UART4_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t UART4_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t UART4_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t UART4_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t UART4_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t UART4_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t UART4_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t UART4_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t UART4_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define UART4_ICR (* ((volatile uint32_t *) (0x40004C00 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t UART4_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t UART4_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t UART4_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t UART4_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t UART4_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t UART4_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t UART4_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t UART4_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t UART4_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t UART4_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t UART4_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t UART4_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t UART4_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t UART4_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t UART4_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define UART4_RDR (* ((const volatile uint32_t *) (0x40004C00 + 36)))

  // Field RDR: Receive data value
    inline uint32_t UART4_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define UART4_TDR (* ((volatile uint32_t *) (0x40004C00 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t UART4_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define UART4_PRESC (* ((volatile uint32_t *) (0x40004C00 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t UART4_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral UART5
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define UART5_CR1 (* ((volatile uint32_t *) (0x40005000 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t UART5_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t UART5_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t UART5_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t UART5_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t UART5_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t UART5_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t UART5_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t UART5_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t UART5_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t UART5_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t UART5_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t UART5_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t UART5_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t UART5_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t UART5_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t UART5_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t UART5_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t UART5_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t UART5_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t UART5_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t UART5_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t UART5_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t UART5_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t UART5_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t UART5_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t UART5_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t UART5_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t UART5_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t UART5_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t UART5_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t UART5_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t UART5_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define UART5_CR2 (* ((volatile uint32_t *) (0x40005000 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t UART5_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t UART5_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t UART5_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t UART5_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t UART5_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t UART5_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t UART5_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t UART5_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t UART5_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t UART5_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t UART5_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t UART5_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t UART5_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t UART5_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t UART5_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t UART5_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t UART5_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t UART5_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t UART5_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t UART5_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t UART5_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t UART5_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define UART5_CR3 (* ((volatile uint32_t *) (0x40005000 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t UART5_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t UART5_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t UART5_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t UART5_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t UART5_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t UART5_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t UART5_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t UART5_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t UART5_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t UART5_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t UART5_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t UART5_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t UART5_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t UART5_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t UART5_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t UART5_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t UART5_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t UART5_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t UART5_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t UART5_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t UART5_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t UART5_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t UART5_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t UART5_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define UART5_BRR (* ((volatile uint32_t *) (0x40005000 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t UART5_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t UART5_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define UART5_GTPR (* ((volatile uint32_t *) (0x40005000 + 16)))

  // Field GT: Guard time value
    inline uint32_t UART5_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t UART5_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define UART5_RTOR (* ((volatile uint32_t *) (0x40005000 + 20)))

  // Field BLEN: Block Length
    inline uint32_t UART5_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t UART5_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define UART5_RQR (* ((volatile uint32_t *) (0x40005000 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t UART5_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t UART5_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t UART5_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t UART5_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t UART5_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define UART5_ISR (* ((const volatile uint32_t *) (0x40005000 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t UART5_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t UART5_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t UART5_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t UART5_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t UART5_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t UART5_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t UART5_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t UART5_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t UART5_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t UART5_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t UART5_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t UART5_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t UART5_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t UART5_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t UART5_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t UART5_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t UART5_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t UART5_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t UART5_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t UART5_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t UART5_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t UART5_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t UART5_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t UART5_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t UART5_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t UART5_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t UART5_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t UART5_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define UART5_ICR (* ((volatile uint32_t *) (0x40005000 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t UART5_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t UART5_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t UART5_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t UART5_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t UART5_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t UART5_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t UART5_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t UART5_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t UART5_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t UART5_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t UART5_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t UART5_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t UART5_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t UART5_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t UART5_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define UART5_RDR (* ((const volatile uint32_t *) (0x40005000 + 36)))

  // Field RDR: Receive data value
    inline uint32_t UART5_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define UART5_TDR (* ((volatile uint32_t *) (0x40005000 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t UART5_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define UART5_PRESC (* ((volatile uint32_t *) (0x40005000 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t UART5_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral UART7
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define UART7_CR1 (* ((volatile uint32_t *) (0x40007800 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t UART7_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t UART7_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t UART7_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t UART7_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t UART7_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t UART7_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t UART7_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t UART7_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t UART7_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t UART7_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t UART7_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t UART7_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t UART7_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t UART7_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t UART7_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t UART7_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t UART7_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t UART7_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t UART7_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t UART7_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t UART7_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t UART7_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t UART7_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t UART7_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t UART7_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t UART7_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t UART7_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t UART7_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t UART7_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t UART7_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t UART7_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t UART7_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define UART7_CR2 (* ((volatile uint32_t *) (0x40007800 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t UART7_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t UART7_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t UART7_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t UART7_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t UART7_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t UART7_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t UART7_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t UART7_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t UART7_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t UART7_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t UART7_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t UART7_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t UART7_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t UART7_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t UART7_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t UART7_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t UART7_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t UART7_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t UART7_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t UART7_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t UART7_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t UART7_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define UART7_CR3 (* ((volatile uint32_t *) (0x40007800 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t UART7_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t UART7_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t UART7_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t UART7_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t UART7_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t UART7_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t UART7_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t UART7_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t UART7_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t UART7_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t UART7_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t UART7_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t UART7_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t UART7_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t UART7_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t UART7_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t UART7_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t UART7_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t UART7_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t UART7_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t UART7_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t UART7_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t UART7_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t UART7_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define UART7_BRR (* ((volatile uint32_t *) (0x40007800 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t UART7_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t UART7_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define UART7_GTPR (* ((volatile uint32_t *) (0x40007800 + 16)))

  // Field GT: Guard time value
    inline uint32_t UART7_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t UART7_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define UART7_RTOR (* ((volatile uint32_t *) (0x40007800 + 20)))

  // Field BLEN: Block Length
    inline uint32_t UART7_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t UART7_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define UART7_RQR (* ((volatile uint32_t *) (0x40007800 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t UART7_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t UART7_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t UART7_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t UART7_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t UART7_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define UART7_ISR (* ((const volatile uint32_t *) (0x40007800 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t UART7_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t UART7_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t UART7_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t UART7_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t UART7_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t UART7_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t UART7_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t UART7_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t UART7_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t UART7_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t UART7_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t UART7_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t UART7_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t UART7_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t UART7_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t UART7_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t UART7_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t UART7_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t UART7_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t UART7_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t UART7_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t UART7_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t UART7_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t UART7_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t UART7_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t UART7_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t UART7_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t UART7_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define UART7_ICR (* ((volatile uint32_t *) (0x40007800 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t UART7_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t UART7_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t UART7_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t UART7_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t UART7_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t UART7_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t UART7_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t UART7_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t UART7_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t UART7_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t UART7_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t UART7_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t UART7_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t UART7_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t UART7_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define UART7_RDR (* ((const volatile uint32_t *) (0x40007800 + 36)))

  // Field RDR: Receive data value
    inline uint32_t UART7_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define UART7_TDR (* ((volatile uint32_t *) (0x40007800 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t UART7_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define UART7_PRESC (* ((volatile uint32_t *) (0x40007800 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t UART7_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral UART8
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define UART8_CR1 (* ((volatile uint32_t *) (0x40007C00 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t UART8_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t UART8_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t UART8_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t UART8_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t UART8_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t UART8_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t UART8_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t UART8_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t UART8_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t UART8_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t UART8_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t UART8_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t UART8_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t UART8_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t UART8_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t UART8_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t UART8_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t UART8_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t UART8_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t UART8_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t UART8_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t UART8_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t UART8_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t UART8_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t UART8_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t UART8_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t UART8_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t UART8_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t UART8_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t UART8_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t UART8_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t UART8_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define UART8_CR2 (* ((volatile uint32_t *) (0x40007C00 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t UART8_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t UART8_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t UART8_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t UART8_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t UART8_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t UART8_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t UART8_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t UART8_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t UART8_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t UART8_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t UART8_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t UART8_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t UART8_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t UART8_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t UART8_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t UART8_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t UART8_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t UART8_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t UART8_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t UART8_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t UART8_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t UART8_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define UART8_CR3 (* ((volatile uint32_t *) (0x40007C00 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t UART8_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t UART8_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t UART8_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t UART8_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t UART8_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t UART8_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t UART8_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t UART8_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t UART8_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t UART8_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t UART8_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t UART8_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t UART8_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t UART8_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t UART8_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t UART8_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t UART8_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t UART8_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t UART8_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t UART8_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t UART8_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t UART8_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t UART8_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t UART8_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define UART8_BRR (* ((volatile uint32_t *) (0x40007C00 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t UART8_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t UART8_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define UART8_GTPR (* ((volatile uint32_t *) (0x40007C00 + 16)))

  // Field GT: Guard time value
    inline uint32_t UART8_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t UART8_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define UART8_RTOR (* ((volatile uint32_t *) (0x40007C00 + 20)))

  // Field BLEN: Block Length
    inline uint32_t UART8_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t UART8_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define UART8_RQR (* ((volatile uint32_t *) (0x40007C00 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t UART8_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t UART8_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t UART8_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t UART8_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t UART8_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define UART8_ISR (* ((const volatile uint32_t *) (0x40007C00 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t UART8_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t UART8_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t UART8_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t UART8_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t UART8_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t UART8_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t UART8_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t UART8_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t UART8_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t UART8_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t UART8_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t UART8_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t UART8_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t UART8_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t UART8_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t UART8_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t UART8_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t UART8_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t UART8_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t UART8_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t UART8_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t UART8_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t UART8_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t UART8_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t UART8_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t UART8_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t UART8_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t UART8_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define UART8_ICR (* ((volatile uint32_t *) (0x40007C00 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t UART8_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t UART8_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t UART8_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t UART8_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t UART8_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t UART8_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t UART8_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t UART8_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t UART8_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t UART8_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t UART8_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t UART8_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t UART8_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t UART8_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t UART8_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define UART8_RDR (* ((const volatile uint32_t *) (0x40007C00 + 36)))

  // Field RDR: Receive data value
    inline uint32_t UART8_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define UART8_TDR (* ((volatile uint32_t *) (0x40007C00 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t UART8_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define UART8_PRESC (* ((volatile uint32_t *) (0x40007C00 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t UART8_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral USART1: Universal synchronous asynchronous receiver       transmitter
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define USART1_CR1 (* ((volatile uint32_t *) (0x40011000 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t USART1_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t USART1_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t USART1_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t USART1_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t USART1_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t USART1_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t USART1_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t USART1_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t USART1_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t USART1_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t USART1_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t USART1_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t USART1_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t USART1_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t USART1_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t USART1_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t USART1_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t USART1_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t USART1_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t USART1_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t USART1_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t USART1_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t USART1_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t USART1_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t USART1_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t USART1_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t USART1_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t USART1_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t USART1_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t USART1_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t USART1_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t USART1_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define USART1_CR2 (* ((volatile uint32_t *) (0x40011000 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t USART1_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t USART1_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t USART1_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t USART1_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t USART1_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t USART1_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t USART1_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t USART1_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t USART1_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t USART1_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t USART1_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t USART1_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t USART1_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t USART1_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t USART1_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t USART1_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t USART1_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t USART1_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t USART1_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t USART1_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t USART1_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t USART1_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define USART1_CR3 (* ((volatile uint32_t *) (0x40011000 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t USART1_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t USART1_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t USART1_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t USART1_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t USART1_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t USART1_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t USART1_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t USART1_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t USART1_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t USART1_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t USART1_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t USART1_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t USART1_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t USART1_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t USART1_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t USART1_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t USART1_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t USART1_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t USART1_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t USART1_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t USART1_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t USART1_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t USART1_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t USART1_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define USART1_BRR (* ((volatile uint32_t *) (0x40011000 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t USART1_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t USART1_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define USART1_GTPR (* ((volatile uint32_t *) (0x40011000 + 16)))

  // Field GT: Guard time value
    inline uint32_t USART1_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t USART1_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define USART1_RTOR (* ((volatile uint32_t *) (0x40011000 + 20)))

  // Field BLEN: Block Length
    inline uint32_t USART1_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t USART1_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define USART1_RQR (* ((volatile uint32_t *) (0x40011000 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t USART1_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t USART1_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t USART1_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t USART1_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t USART1_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define USART1_ISR (* ((const volatile uint32_t *) (0x40011000 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t USART1_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t USART1_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t USART1_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t USART1_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t USART1_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t USART1_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t USART1_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t USART1_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t USART1_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t USART1_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t USART1_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t USART1_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t USART1_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t USART1_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t USART1_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t USART1_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t USART1_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t USART1_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t USART1_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t USART1_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t USART1_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t USART1_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t USART1_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t USART1_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t USART1_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t USART1_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t USART1_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t USART1_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define USART1_ICR (* ((volatile uint32_t *) (0x40011000 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t USART1_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t USART1_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t USART1_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t USART1_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t USART1_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t USART1_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t USART1_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t USART1_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t USART1_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t USART1_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t USART1_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t USART1_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t USART1_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t USART1_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t USART1_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define USART1_RDR (* ((const volatile uint32_t *) (0x40011000 + 36)))

  // Field RDR: Receive data value
    inline uint32_t USART1_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define USART1_TDR (* ((volatile uint32_t *) (0x40011000 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t USART1_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define USART1_PRESC (* ((volatile uint32_t *) (0x40011000 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t USART1_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral USART2
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define USART2_CR1 (* ((volatile uint32_t *) (0x40004400 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t USART2_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t USART2_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t USART2_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t USART2_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t USART2_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t USART2_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t USART2_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t USART2_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t USART2_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t USART2_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t USART2_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t USART2_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t USART2_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t USART2_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t USART2_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t USART2_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t USART2_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t USART2_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t USART2_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t USART2_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t USART2_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t USART2_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t USART2_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t USART2_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t USART2_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t USART2_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t USART2_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t USART2_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t USART2_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t USART2_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t USART2_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t USART2_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define USART2_CR2 (* ((volatile uint32_t *) (0x40004400 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t USART2_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t USART2_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t USART2_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t USART2_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t USART2_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t USART2_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t USART2_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t USART2_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t USART2_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t USART2_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t USART2_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t USART2_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t USART2_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t USART2_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t USART2_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t USART2_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t USART2_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t USART2_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t USART2_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t USART2_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t USART2_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t USART2_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define USART2_CR3 (* ((volatile uint32_t *) (0x40004400 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t USART2_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t USART2_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t USART2_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t USART2_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t USART2_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t USART2_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t USART2_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t USART2_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t USART2_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t USART2_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t USART2_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t USART2_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t USART2_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t USART2_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t USART2_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t USART2_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t USART2_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t USART2_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t USART2_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t USART2_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t USART2_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t USART2_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t USART2_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t USART2_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define USART2_BRR (* ((volatile uint32_t *) (0x40004400 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t USART2_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t USART2_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define USART2_GTPR (* ((volatile uint32_t *) (0x40004400 + 16)))

  // Field GT: Guard time value
    inline uint32_t USART2_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t USART2_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define USART2_RTOR (* ((volatile uint32_t *) (0x40004400 + 20)))

  // Field BLEN: Block Length
    inline uint32_t USART2_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t USART2_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define USART2_RQR (* ((volatile uint32_t *) (0x40004400 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t USART2_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t USART2_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t USART2_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t USART2_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t USART2_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define USART2_ISR (* ((const volatile uint32_t *) (0x40004400 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t USART2_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t USART2_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t USART2_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t USART2_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t USART2_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t USART2_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t USART2_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t USART2_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t USART2_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t USART2_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t USART2_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t USART2_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t USART2_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t USART2_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t USART2_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t USART2_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t USART2_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t USART2_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t USART2_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t USART2_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t USART2_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t USART2_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t USART2_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t USART2_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t USART2_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t USART2_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t USART2_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t USART2_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define USART2_ICR (* ((volatile uint32_t *) (0x40004400 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t USART2_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t USART2_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t USART2_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t USART2_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t USART2_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t USART2_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t USART2_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t USART2_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t USART2_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t USART2_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t USART2_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t USART2_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t USART2_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t USART2_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t USART2_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define USART2_RDR (* ((const volatile uint32_t *) (0x40004400 + 36)))

  // Field RDR: Receive data value
    inline uint32_t USART2_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define USART2_TDR (* ((volatile uint32_t *) (0x40004400 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t USART2_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define USART2_PRESC (* ((volatile uint32_t *) (0x40004400 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t USART2_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral USART3
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define USART3_CR1 (* ((volatile uint32_t *) (0x40004800 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t USART3_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t USART3_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t USART3_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t USART3_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t USART3_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t USART3_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t USART3_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t USART3_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t USART3_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t USART3_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t USART3_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t USART3_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t USART3_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t USART3_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t USART3_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t USART3_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t USART3_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t USART3_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t USART3_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t USART3_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t USART3_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t USART3_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t USART3_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t USART3_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t USART3_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t USART3_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t USART3_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t USART3_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t USART3_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t USART3_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t USART3_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t USART3_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define USART3_CR2 (* ((volatile uint32_t *) (0x40004800 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t USART3_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t USART3_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t USART3_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t USART3_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t USART3_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t USART3_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t USART3_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t USART3_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t USART3_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t USART3_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t USART3_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t USART3_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t USART3_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t USART3_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t USART3_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t USART3_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t USART3_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t USART3_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t USART3_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t USART3_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t USART3_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t USART3_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define USART3_CR3 (* ((volatile uint32_t *) (0x40004800 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t USART3_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t USART3_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t USART3_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t USART3_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t USART3_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t USART3_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t USART3_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t USART3_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t USART3_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t USART3_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t USART3_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t USART3_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t USART3_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t USART3_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t USART3_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t USART3_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t USART3_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t USART3_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t USART3_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t USART3_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t USART3_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t USART3_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t USART3_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t USART3_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define USART3_BRR (* ((volatile uint32_t *) (0x40004800 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t USART3_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t USART3_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define USART3_GTPR (* ((volatile uint32_t *) (0x40004800 + 16)))

  // Field GT: Guard time value
    inline uint32_t USART3_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t USART3_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define USART3_RTOR (* ((volatile uint32_t *) (0x40004800 + 20)))

  // Field BLEN: Block Length
    inline uint32_t USART3_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t USART3_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define USART3_RQR (* ((volatile uint32_t *) (0x40004800 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t USART3_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t USART3_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t USART3_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t USART3_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t USART3_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define USART3_ISR (* ((const volatile uint32_t *) (0x40004800 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t USART3_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t USART3_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t USART3_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t USART3_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t USART3_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t USART3_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t USART3_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t USART3_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t USART3_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t USART3_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t USART3_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t USART3_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t USART3_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t USART3_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t USART3_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t USART3_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t USART3_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t USART3_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t USART3_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t USART3_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t USART3_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t USART3_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t USART3_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t USART3_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t USART3_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t USART3_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t USART3_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t USART3_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define USART3_ICR (* ((volatile uint32_t *) (0x40004800 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t USART3_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t USART3_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t USART3_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t USART3_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t USART3_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t USART3_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t USART3_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t USART3_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t USART3_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t USART3_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t USART3_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t USART3_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t USART3_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t USART3_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t USART3_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define USART3_RDR (* ((const volatile uint32_t *) (0x40004800 + 36)))

  // Field RDR: Receive data value
    inline uint32_t USART3_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define USART3_TDR (* ((volatile uint32_t *) (0x40004800 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t USART3_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define USART3_PRESC (* ((volatile uint32_t *) (0x40004800 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t USART3_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral USART6
//------------------------------------------------------------------------------

//---  Register CR1: Control register 1
  #define USART6_CR1 (* ((volatile uint32_t *) (0x40011400 + 0)))

  // Field RXFFIE: RXFIFO Full interrupt enable
    const uint32_t USART6_CR1_RXFFIE = 1U << 31 ;

  // Field TXFEIE: TXFIFO empty interrupt enable
    const uint32_t USART6_CR1_TXFEIE = 1U << 30 ;

  // Field FIFOEN: FIFO mode enable
    const uint32_t USART6_CR1_FIFOEN = 1U << 29 ;

  // Field M1: Word length
    const uint32_t USART6_CR1_M1 = 1U << 28 ;

  // Field EOBIE: End of Block interrupt enable
    const uint32_t USART6_CR1_EOBIE = 1U << 27 ;

  // Field RTOIE: Receiver timeout interrupt enable
    const uint32_t USART6_CR1_RTOIE = 1U << 26 ;

  // Field DEAT4: Driver Enable assertion time
    const uint32_t USART6_CR1_DEAT4 = 1U << 25 ;

  // Field DEAT3: DEAT3
    const uint32_t USART6_CR1_DEAT3 = 1U << 24 ;

  // Field DEAT2: DEAT2
    const uint32_t USART6_CR1_DEAT2 = 1U << 23 ;

  // Field DEAT1: DEAT1
    const uint32_t USART6_CR1_DEAT1 = 1U << 22 ;

  // Field DEAT0: DEAT0
    const uint32_t USART6_CR1_DEAT0 = 1U << 21 ;

  // Field DEDT4: Driver Enable de-assertion time
    const uint32_t USART6_CR1_DEDT4 = 1U << 20 ;

  // Field DEDT3: DEDT3
    const uint32_t USART6_CR1_DEDT3 = 1U << 19 ;

  // Field DEDT2: DEDT2
    const uint32_t USART6_CR1_DEDT2 = 1U << 18 ;

  // Field DEDT1: DEDT1
    const uint32_t USART6_CR1_DEDT1 = 1U << 17 ;

  // Field DEDT0: DEDT0
    const uint32_t USART6_CR1_DEDT0 = 1U << 16 ;

  // Field OVER8: Oversampling mode
    const uint32_t USART6_CR1_OVER8 = 1U << 15 ;

  // Field CMIE: Character match interrupt enable
    const uint32_t USART6_CR1_CMIE = 1U << 14 ;

  // Field MME: Mute mode enable
    const uint32_t USART6_CR1_MME = 1U << 13 ;

  // Field M0: Word length
    const uint32_t USART6_CR1_M0 = 1U << 12 ;

  // Field WAKE: Receiver wakeup method
    const uint32_t USART6_CR1_WAKE = 1U << 11 ;

  // Field PCE: Parity control enable
    const uint32_t USART6_CR1_PCE = 1U << 10 ;

  // Field PS: Parity selection
    const uint32_t USART6_CR1_PS = 1U << 9 ;

  // Field PEIE: PE interrupt enable
    const uint32_t USART6_CR1_PEIE = 1U << 8 ;

  // Field TXEIE: interrupt enable
    const uint32_t USART6_CR1_TXEIE = 1U << 7 ;

  // Field TCIE: Transmission complete interrupt enable
    const uint32_t USART6_CR1_TCIE = 1U << 6 ;

  // Field RXNEIE: RXNE interrupt enable
    const uint32_t USART6_CR1_RXNEIE = 1U << 5 ;

  // Field IDLEIE: IDLE interrupt enable
    const uint32_t USART6_CR1_IDLEIE = 1U << 4 ;

  // Field TE: Transmitter enable
    const uint32_t USART6_CR1_TE = 1U << 3 ;

  // Field RE: Receiver enable
    const uint32_t USART6_CR1_RE = 1U << 2 ;

  // Field UESM: USART enable in Stop mode
    const uint32_t USART6_CR1_UESM = 1U << 1 ;

  // Field UE: USART enable
    const uint32_t USART6_CR1_UE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR2: Control register 2
  #define USART6_CR2 (* ((volatile uint32_t *) (0x40011400 + 4)))

  // Field ADD4_7: Address of the USART node
    inline uint32_t USART6_CR2_ADD4_7 (const uint32_t inValue) {return (inValue & 0xFU) << 28 ; }

  // Field ADD0_3: Address of the USART node
    inline uint32_t USART6_CR2_ADD0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 24 ; }

  // Field RTOEN: Receiver timeout enable
    const uint32_t USART6_CR2_RTOEN = 1U << 23 ;

  // Field ABRMOD1: Auto baud rate mode
    const uint32_t USART6_CR2_ABRMOD1 = 1U << 22 ;

  // Field ABRMOD0: ABRMOD0
    const uint32_t USART6_CR2_ABRMOD0 = 1U << 21 ;

  // Field ABREN: Auto baud rate enable
    const uint32_t USART6_CR2_ABREN = 1U << 20 ;

  // Field MSBFIRST: Most significant bit first
    const uint32_t USART6_CR2_MSBFIRST = 1U << 19 ;

  // Field TAINV: Binary data inversion
    const uint32_t USART6_CR2_TAINV = 1U << 18 ;

  // Field TXINV: TX pin active level inversion
    const uint32_t USART6_CR2_TXINV = 1U << 17 ;

  // Field RXINV: RX pin active level inversion
    const uint32_t USART6_CR2_RXINV = 1U << 16 ;

  // Field SWAP: Swap TX/RX pins
    const uint32_t USART6_CR2_SWAP = 1U << 15 ;

  // Field LINEN: LIN mode enable
    const uint32_t USART6_CR2_LINEN = 1U << 14 ;

  // Field STOP: STOP bits
    inline uint32_t USART6_CR2_STOP (const uint32_t inValue) {return (inValue & 0x3U) << 12 ; }

  // Field CLKEN: Clock enable
    const uint32_t USART6_CR2_CLKEN = 1U << 11 ;

  // Field CPOL: Clock polarity
    const uint32_t USART6_CR2_CPOL = 1U << 10 ;

  // Field CPHA: Clock phase
    const uint32_t USART6_CR2_CPHA = 1U << 9 ;

  // Field LBCL: Last bit clock pulse
    const uint32_t USART6_CR2_LBCL = 1U << 8 ;

  // Field LBDIE: LIN break detection interrupt enable
    const uint32_t USART6_CR2_LBDIE = 1U << 6 ;

  // Field LBDL: LIN break detection length
    const uint32_t USART6_CR2_LBDL = 1U << 5 ;

  // Field ADDM7: 7-bit Address Detection/4-bit Address Detection
    const uint32_t USART6_CR2_ADDM7 = 1U << 4 ;

  // Field DIS_NSS: When the DSI_NSS bit is set, the NSS pin input is ignored
    const uint32_t USART6_CR2_DIS_NSS = 1U << 3 ;

  // Field SLVEN: Synchronous Slave mode enable
    const uint32_t USART6_CR2_SLVEN = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register CR3: Control register 3
  #define USART6_CR3 (* ((volatile uint32_t *) (0x40011400 + 8)))

  // Field TXFTCFG: TXFIFO threshold configuration
    inline uint32_t USART6_CR3_TXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 29 ; }

  // Field RXFTIE: RXFIFO threshold interrupt enable
    const uint32_t USART6_CR3_RXFTIE = 1U << 28 ;

  // Field RXFTCFG: Receive FIFO threshold configuration
    inline uint32_t USART6_CR3_RXFTCFG (const uint32_t inValue) {return (inValue & 0x7U) << 25 ; }

  // Field TCBGTIE: Transmission Complete before guard time, interrupt enable
    const uint32_t USART6_CR3_TCBGTIE = 1U << 24 ;

  // Field TXFTIE: TXFIFO threshold interrupt enable
    const uint32_t USART6_CR3_TXFTIE = 1U << 23 ;

  // Field WUFIE: Wakeup from Stop mode interrupt enable
    const uint32_t USART6_CR3_WUFIE = 1U << 22 ;

  // Field WUS: Wakeup from Stop mode interrupt flag selection
    inline uint32_t USART6_CR3_WUS (const uint32_t inValue) {return (inValue & 0x3U) << 20 ; }

  // Field SCARCNT: Smartcard auto-retry count
    inline uint32_t USART6_CR3_SCARCNT (const uint32_t inValue) {return (inValue & 0x7U) << 17 ; }

  // Field DEP: Driver enable polarity selection
    const uint32_t USART6_CR3_DEP = 1U << 15 ;

  // Field DEM: Driver enable mode
    const uint32_t USART6_CR3_DEM = 1U << 14 ;

  // Field DDRE: DMA Disable on Reception Error
    const uint32_t USART6_CR3_DDRE = 1U << 13 ;

  // Field OVRDIS: Overrun Disable
    const uint32_t USART6_CR3_OVRDIS = 1U << 12 ;

  // Field ONEBIT: One sample bit method enable
    const uint32_t USART6_CR3_ONEBIT = 1U << 11 ;

  // Field CTSIE: CTS interrupt enable
    const uint32_t USART6_CR3_CTSIE = 1U << 10 ;

  // Field CTSE: CTS enable
    const uint32_t USART6_CR3_CTSE = 1U << 9 ;

  // Field RTSE: RTS enable
    const uint32_t USART6_CR3_RTSE = 1U << 8 ;

  // Field DMAT: DMA enable transmitter
    const uint32_t USART6_CR3_DMAT = 1U << 7 ;

  // Field DMAR: DMA enable receiver
    const uint32_t USART6_CR3_DMAR = 1U << 6 ;

  // Field SCEN: Smartcard mode enable
    const uint32_t USART6_CR3_SCEN = 1U << 5 ;

  // Field NACK: Smartcard NACK enable
    const uint32_t USART6_CR3_NACK = 1U << 4 ;

  // Field HDSEL: Half-duplex selection
    const uint32_t USART6_CR3_HDSEL = 1U << 3 ;

  // Field IRLP: Ir low-power
    const uint32_t USART6_CR3_IRLP = 1U << 2 ;

  // Field IREN: Ir mode enable
    const uint32_t USART6_CR3_IREN = 1U << 1 ;

  // Field EIE: Error interrupt enable
    const uint32_t USART6_CR3_EIE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register BRR: Baud rate register
  #define USART6_BRR (* ((volatile uint32_t *) (0x40011400 + 12)))

  // Field BRR_4_15: DIV_Mantissa
    inline uint32_t USART6_BRR_BRR_4_15 (const uint32_t inValue) {return (inValue & 0xFFFU) << 4 ; }

  // Field BRR_0_3: DIV_Fraction
    inline uint32_t USART6_BRR_BRR_0_3 (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register GTPR: Guard time and prescaler register
  #define USART6_GTPR (* ((volatile uint32_t *) (0x40011400 + 16)))

  // Field GT: Guard time value
    inline uint32_t USART6_GTPR_GT (const uint32_t inValue) {return (inValue & 0xFFU) << 8 ; }

  // Field PSC: Prescaler value
    inline uint32_t USART6_GTPR_PSC (const uint32_t inValue) {return (inValue & 0xFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RTOR: Receiver timeout register
  #define USART6_RTOR (* ((volatile uint32_t *) (0x40011400 + 20)))

  // Field BLEN: Block Length
    inline uint32_t USART6_RTOR_BLEN (const uint32_t inValue) {return (inValue & 0xFFU) << 24 ; }

  // Field RTO: Receiver timeout value
    inline uint32_t USART6_RTOR_RTO (const uint32_t inValue) {return (inValue & 0xFFFFFFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register RQR: Request register
  #define USART6_RQR (* ((volatile uint32_t *) (0x40011400 + 24)))

  // Field TXFRQ: Transmit data flush request
    const uint32_t USART6_RQR_TXFRQ = 1U << 4 ;

  // Field RXFRQ: Receive data flush request
    const uint32_t USART6_RQR_RXFRQ = 1U << 3 ;

  // Field MMRQ: Mute mode request
    const uint32_t USART6_RQR_MMRQ = 1U << 2 ;

  // Field SBKRQ: Send break request
    const uint32_t USART6_RQR_SBKRQ = 1U << 1 ;

  // Field ABRRQ: Auto baud rate request
    const uint32_t USART6_RQR_ABRRQ = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ISR: Interrupt & status register
  #define USART6_ISR (* ((const volatile uint32_t *) (0x40011400 + 28)))

  // Field TXFT: TXFIFO threshold flag
    const uint32_t USART6_ISR_TXFT = 1U << 27 ;

  // Field RXFT: RXFIFO threshold flag
    const uint32_t USART6_ISR_RXFT = 1U << 26 ;

  // Field TCBGT: Transmission complete before guard time flag
    const uint32_t USART6_ISR_TCBGT = 1U << 25 ;

  // Field RXFF: RXFIFO Full
    const uint32_t USART6_ISR_RXFF = 1U << 24 ;

  // Field TXFE: TXFIFO Empty
    const uint32_t USART6_ISR_TXFE = 1U << 23 ;

  // Field REACK: REACK
    const uint32_t USART6_ISR_REACK = 1U << 22 ;

  // Field TEACK: TEACK
    const uint32_t USART6_ISR_TEACK = 1U << 21 ;

  // Field WUF: WUF
    const uint32_t USART6_ISR_WUF = 1U << 20 ;

  // Field RWU: RWU
    const uint32_t USART6_ISR_RWU = 1U << 19 ;

  // Field SBKF: SBKF
    const uint32_t USART6_ISR_SBKF = 1U << 18 ;

  // Field CMF: CMF
    const uint32_t USART6_ISR_CMF = 1U << 17 ;

  // Field BUSY: BUSY
    const uint32_t USART6_ISR_BUSY = 1U << 16 ;

  // Field ABRF: ABRF
    const uint32_t USART6_ISR_ABRF = 1U << 15 ;

  // Field ABRE: ABRE
    const uint32_t USART6_ISR_ABRE = 1U << 14 ;

  // Field UDR: SPI slave underrun error flag
    const uint32_t USART6_ISR_UDR = 1U << 13 ;

  // Field EOBF: EOBF
    const uint32_t USART6_ISR_EOBF = 1U << 12 ;

  // Field RTOF: RTOF
    const uint32_t USART6_ISR_RTOF = 1U << 11 ;

  // Field CTS: CTS
    const uint32_t USART6_ISR_CTS = 1U << 10 ;

  // Field CTSIF: CTSIF
    const uint32_t USART6_ISR_CTSIF = 1U << 9 ;

  // Field LBDF: LBDF
    const uint32_t USART6_ISR_LBDF = 1U << 8 ;

  // Field TXE: TXE
    const uint32_t USART6_ISR_TXE = 1U << 7 ;

  // Field TC: TC
    const uint32_t USART6_ISR_TC = 1U << 6 ;

  // Field RXNE: RXNE
    const uint32_t USART6_ISR_RXNE = 1U << 5 ;

  // Field IDLE: IDLE
    const uint32_t USART6_ISR_IDLE = 1U << 4 ;

  // Field ORE: ORE
    const uint32_t USART6_ISR_ORE = 1U << 3 ;

  // Field NF: NF
    const uint32_t USART6_ISR_NF = 1U << 2 ;

  // Field FE: FE
    const uint32_t USART6_ISR_FE = 1U << 1 ;

  // Field PE: PE
    const uint32_t USART6_ISR_PE = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register ICR: Interrupt flag clear register
  #define USART6_ICR (* ((volatile uint32_t *) (0x40011400 + 32)))

  // Field WUCF: Wakeup from Stop mode clear flag
    const uint32_t USART6_ICR_WUCF = 1U << 20 ;

  // Field CMCF: Character match clear flag
    const uint32_t USART6_ICR_CMCF = 1U << 17 ;

  // Field UDRCF: SPI slave underrun clear flag
    const uint32_t USART6_ICR_UDRCF = 1U << 13 ;

  // Field EOBCF: End of block clear flag
    const uint32_t USART6_ICR_EOBCF = 1U << 12 ;

  // Field RTOCF: Receiver timeout clear flag
    const uint32_t USART6_ICR_RTOCF = 1U << 11 ;

  // Field CTSCF: CTS clear flag
    const uint32_t USART6_ICR_CTSCF = 1U << 9 ;

  // Field LBDCF: LIN break detection clear flag
    const uint32_t USART6_ICR_LBDCF = 1U << 8 ;

  // Field TCBGTC: Transmission complete before Guard time clear flag
    const uint32_t USART6_ICR_TCBGTC = 1U << 7 ;

  // Field TCCF: Transmission complete clear flag
    const uint32_t USART6_ICR_TCCF = 1U << 6 ;

  // Field TXFECF: TXFIFO empty clear flag
    const uint32_t USART6_ICR_TXFECF = 1U << 5 ;

  // Field IDLECF: Idle line detected clear flag
    const uint32_t USART6_ICR_IDLECF = 1U << 4 ;

  // Field ORECF: Overrun error clear flag
    const uint32_t USART6_ICR_ORECF = 1U << 3 ;

  // Field NCF: Noise detected clear flag
    const uint32_t USART6_ICR_NCF = 1U << 2 ;

  // Field FECF: Framing error clear flag
    const uint32_t USART6_ICR_FECF = 1U << 1 ;

  // Field PECF: Parity error clear flag
    const uint32_t USART6_ICR_PECF = 1U << 0 ;

//------------------------------------------------------------------------------

//---  Register RDR: Receive data register
  #define USART6_RDR (* ((const volatile uint32_t *) (0x40011400 + 36)))

  // Field RDR: Receive data value
    inline uint32_t USART6_RDR_RDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register TDR: Transmit data register
  #define USART6_TDR (* ((volatile uint32_t *) (0x40011400 + 40)))

  // Field TDR: Transmit data value
    inline uint32_t USART6_TDR_TDR (const uint32_t inValue) {return (inValue & 0x1FFU) << 0 ; }

//------------------------------------------------------------------------------

//---  Register PRESC: USART prescaler register
  #define USART6_PRESC (* ((volatile uint32_t *) (0x40011400 + 44)))

  // Field PRESCALER: Clock prescaler
    inline uint32_t USART6_PRESC_PRESCALER (const uint32_t inValue) {return (inValue & 0xFU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral VREFBUF: VREFBUF
//------------------------------------------------------------------------------

//---  Register CSR: VREFBUF control and status register
  #define VREFBUF_CSR (* ((volatile uint32_t *) (0x58003C00 + 0)))

  // Field ENVR: Voltage reference buffer mode enable This bit is used to enable the voltage reference buffer mode.
    const uint32_t VREFBUF_CSR_ENVR = 1U << 0 ;

  // Field HIZ: High impedance mode This bit controls the analog switch to connect or not the VREF+ pin. Refer to Table196: VREF buffer modes for the mode descriptions depending on ENVR bit configuration.
    const uint32_t VREFBUF_CSR_HIZ = 1U << 1 ;

  // Field VRR: Voltage reference buffer ready
    const uint32_t VREFBUF_CSR_VRR = 1U << 3 ;

  // Field VRS: Voltage reference scale These bits select the value generated by the voltage reference buffer. Other: Reserved
    inline uint32_t VREFBUF_CSR_VRS (const uint32_t inValue) {return (inValue & 0x7U) << 4 ; }

//------------------------------------------------------------------------------

//---  Register CCR: VREFBUF calibration control register
  #define VREFBUF_CCR (* ((volatile uint32_t *) (0x58003C00 + 4)))

  // Field TRIM: Trimming code These bits are automatically initialized after reset with the trimming value stored in the Flash memory during the production test. Writing into these bits allows to tune the internal reference buffer voltage.
    inline uint32_t VREFBUF_CCR_TRIM (const uint32_t inValue) {return (inValue & 0x3FU) << 0 ; }

//------------------------------------------------------------------------------
// Peripheral WWDG: WWDG
//------------------------------------------------------------------------------

//---  Register CR: Control register
  #define WWDG_CR (* ((volatile uint32_t *) (0x50003000 + 0)))

  // Field T: 7-bit counter (MSB to LSB) These bits contain the value of the watchdog counter. It is decremented every (4096 x 2WDGTB[1:0]) PCLK cycles. A reset is produced when it is decremented from 0x40 to 0x3F (T6 becomes cleared).
    inline uint32_t WWDG_CR_T (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field WDGA: Activation bit This bit is set by software and only cleared by hardware after a reset. When WDGA=1, the watchdog can generate a reset.
    const uint32_t WWDG_CR_WDGA = 1U << 7 ;

//------------------------------------------------------------------------------

//---  Register CFR: Configuration register
  #define WWDG_CFR (* ((volatile uint32_t *) (0x50003000 + 4)))

  // Field W: 7-bit window value These bits contain the window value to be compared to the downcounter.
    inline uint32_t WWDG_CFR_W (const uint32_t inValue) {return (inValue & 0x7FU) << 0 ; }

  // Field WDGTB: Timer base The time base of the prescaler can be modified as follows:
    inline uint32_t WWDG_CFR_WDGTB (const uint32_t inValue) {return (inValue & 0x3U) << 11 ; }

  // Field EWI: Early wakeup interrupt When set, an interrupt occurs whenever the counter reaches the value 0x40. This interrupt is only cleared by hardware after a reset.
    const uint32_t WWDG_CFR_EWI = 1U << 9 ;

//------------------------------------------------------------------------------

//---  Register SR: Status register
  #define WWDG_SR (* ((volatile uint32_t *) (0x50003000 + 8)))

  // Field EWIF: Early wakeup interrupt flag This bit is set by hardware when the counter has reached the value 0x40. It must be cleared by software by writing 0. A write of 1 has no effect. This bit is also set if the interrupt is not enabled.
    const uint32_t WWDG_SR_EWIF = 1U << 0 ;

//------------------------------------------------------------------------------
// INTERRUPTS
//------------------------------------------------------------------------------

enum class ISRSlot : uint8_t {
  WWDG1 = 0,
  PVD_PVM = 1,
  RTC_TAMP_STAMP_CSS_LSE = 2,
  RTC_WKUP = 3,
  FLASH = 4,
  RCC = 5,
  EXTI0 = 6,
  EXTI1 = 7,
  EXTI2 = 8,
  EXTI3 = 9,
  EXTI4 = 10,
  DMA_STR0 = 11,
  DMA_STR1 = 12,
  DMA_STR2 = 13,
  DMA_STR3 = 14,
  DMA_STR4 = 15,
  DMA_STR5 = 16,
  DMA_STR6 = 17,
  ADC1_2 = 18,
  FDCAN1_IT0 = 19,
  FDCAN2_IT0 = 20,
  FDCAN1_IT1 = 21,
  FDCAN2_IT1 = 22,
  EXTI9_5 = 23,
  TIM1_BRK = 24,
  TIM1_UP = 25,
  TIM1_TRG_COM = 26,
  TIM_CC = 27,
  TIM2 = 28,
  TIM3 = 29,
  TIM4 = 30,
  I2C1_EV = 31,
  I2C1_ER = 32,
  I2C2_EV = 33,
  I2C2_ER = 34,
  SPI1 = 35,
  SPI2 = 36,
  USART1 = 37,
  USART2 = 38,
  USART3 = 39,
  EXTI15_10 = 40,
  RTC_ALARM = 41,
  TIM8_BRK_TIM12 = 43,
  TIM8_UP_TIM13 = 44,
  TIM8_TRG_COM_TIM14 = 45,
  TIM8_CC = 46,
  DMA1_STR7 = 47,
  FMC = 48,
  SDMMC1 = 49,
  TIM5 = 50,
  SPI3 = 51,
  UART4 = 52,
  UART5 = 53,
  TIM6_DAC = 54,
  TIM7 = 55,
  DMA2_STR0 = 56,
  DMA2_STR1 = 57,
  DMA2_STR2 = 58,
  DMA2_STR3 = 59,
  DMA2_STR4 = 60,
  ETH = 61,
  ETH_WKUP = 62,
  FDCAN_CAL = 63,
  DMA2_STR5 = 68,
  DMA2_STR6 = 69,
  DMA2_STR7 = 70,
  USART6 = 71,
  I2C3_EV = 72,
  I2C3_ER = 73,
  OTG_HS_EP1_OUT = 74,
  OTG_HS_EP1_IN = 75,
  OTG_HS_WKUP = 76,
  OTG_HS = 77,
  DCMI = 78,
  FPU = 81,
  UART7 = 82,
  UART8 = 83,
  SPI4 = 84,
  SPI5 = 85,
  SPI6 = 86,
  SAI1 = 87,
  LTDC = 88,
  LTDC_ER = 89,
  DMA2D = 90,
  SAI2 = 91,
  QUADSPI = 92,
  LPTIM1 = 93,
  CEC = 94,
  I2C4_EV = 95,
  I2C4_ER = 96,
  SPDIF = 97,
  OTG_FS_EP1_OUT = 98,
  OTG_FS_EP1_IN = 99,
  OTG_FS_WKUP = 100,
  OTG_FS = 101,
  DMAMUX1_OV = 102,
  HRTIM1_MST = 103,
  HRTIM1_TIMA = 104,
  HRTIM_TIMB = 105,
  HRTIM1_TIMC = 106,
  HRTIM1_TIMD = 107,
  HRTIM_TIME = 108,
  HRTIM1_FLT = 109,
  DFSDM1_FLT0 = 110,
  DFSDM1_FLT1 = 111,
  DFSDM1_FLT2 = 112,
  DFSDM1_FLT3 = 113,
  SAI3 = 114,
  SWPMI1 = 115,
  TIM15 = 116,
  TIM16 = 117,
  TIM17 = 118,
  MDIOS_WKUP = 119,
  MDIOS = 120,
  JPEG = 121,
  MDMA = 122,
  SDMMC = 124,
  HSEM0 = 125,
  ADC3 = 127,
  DMAMUX2_OVR = 128,
  BDMA_CH1 = 129,
  BDMA_CH2 = 130,
  BDMA_CH3 = 131,
  BDMA_CH4 = 132,
  BDMA_CH5 = 133,
  BDMA_CH6 = 134,
  BDMA_CH7 = 135,
  BDMA_CH8 = 136,
  COMP = 137,
  LPTIM2 = 138,
  LPTIM3 = 139,
  LPTIM4 = 140,
  LPTIM5 = 141,
  LPUART = 142,
  WWDG1_RST = 143,
  CRS = 144,
  SAI4 = 146,
  WKUP = 149,
} ;

//------------------------------------------------------------------------------

inline void NVIC_ENABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E100 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------

inline void NVIC_DISABLE_IRQ (const ISRSlot inInterrupt) {
  const uint32_t it = static_cast <uint32_t> (inInterrupt) ;
  *((volatile uint32_t *) (0xE000E180 + 4 * (it >> 5))) = 1U << (it & 31) ;
}

//------------------------------------------------------------------------------
// BITBAND
//------------------------------------------------------------------------------

inline void bitband32 (const volatile uint32_t & inRegister, const uint8_t inBit, const bool inValue) {
  const uint32_t address = ((uint32_t) &inRegister - 0x40000000) * 32 + ((uint32_t) inBit) * 4 + 0x42000000 ;
  volatile uint32_t * ptr = (volatile uint32_t *) address ;
  *ptr = (uint32_t) inValue ;
}

//------------------------------------------------------------------------------
